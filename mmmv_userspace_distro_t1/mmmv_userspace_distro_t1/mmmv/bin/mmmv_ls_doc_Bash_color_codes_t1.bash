#!/usr/bin/env bash
#==========================================================================
# Initial author of this file: Martin.Vahi@softf1.com
# This file is in public domain.
# The following line is a spdx.org license label line:
# SPDX-License-Identifier: 0BSD
#--------------------------------------------------------------------------
S_FP_DIR="$( cd "$( dirname "${BASH_SOURCE[0]}" )" && pwd )"
MMMV_USERSPACE_DISTRO_T1_HOME="`cd $S_FP_DIR/../../ ; pwd `"
#--------------------------------------------------------------------------
echo ""
echo "In computers characters like \"a\", \"?\", etc. are "
echo "positive whole numbers. Which positive whole number "
echo "corresponds to a specific character is a "
echo "matter of agreement and those agreements are called "
echo -e "\"\e[33mcharacter encoding standards\e[39m\". "
echo "Historically there have been many character encoding standards, but "
echo "as of year 2023 the most widely used character encoding standard "
echo "is the Unicode. Before the creation of the Unicode probably "
echo "the most widely adopted character encoding standard in the "
echo "United Kingom and in the U.S. was the ASCII, which is a "
echo "subset of the Unicode. Whole numbers that correspond to "
echo -e "a character are called \"\e[33mcharacter codes\e[39m\", \"\e[33mcode points\e[39m\"."
echo -e "A table of character codes is called a \"\e[33mcharacter code chart\e[39m\" or "
echo -e "a \"\e[33mcode chart\e[39m\" for short. "
echo ""
echo "The ASCII character encoding standard uses positive whole numbers, "
echo "including zero, that fit into 1 byte (1B = \"8 bits\" = 8b) of "
echo "memory/RAM. As the 2^8 = 256 and one value is used for the zero,"
echo "the range of ASCII character codes in base 10 is [0..(256-1=255)]."
echo "There are more than 256 hieroglyphs, but the English "
echo "alphabet fits into those 256 values just fine, which was "
echo "sufficient for British and American computer systems "
echo "of the 1970s era. 2. World War era telegraph machines, teletypes, "
echo "used even less bits than the 8 bits/1B, because they did not "
echo "distinguish between upper case letters/characters and "
echo "lower case letters/characters."
#----------------------------------------
S_TMP_0="$MMMV_USERSPACE_DISTRO_T1_HOME/attic/documentation/videos/teletypes"
SB_AT_LEAST_ONE_FILE_PRESENT="f" # like "false"
S_FP_0="$S_TMP_0/2018_12_10_YouTube_jxkygWI-Wfs_CuriousMarc_Principles_of_Teletype_operation_and_Teletype_Model_19_and_Model_15_Demonstration_t1.webm"
if [ -e "$S_FP_0" ]; then
    if [ ! -d "$S_FP_0" ]; then
        SB_AT_LEAST_ONE_FILE_PRESENT="t" # like "true"
    fi
fi
S_FP_0="$S_TMP_0/2019_06_19_YouTube_oKrzmofE6L0_Peter_Peterson_and_Matt_Singer_PDP12_How_an_ASR33_Teletype_Sends_and_Receives_Characters_t1.webm"
if [ -e "$S_FP_0" ]; then
    if [ ! -d "$S_FP_0" ]; then
        SB_AT_LEAST_ONE_FILE_PRESENT="t" # like "true"
    fi
fi
if [ "$SB_AT_LEAST_ONE_FILE_PRESENT" == "t" ]; then
    echo "At least one introductory video about teletypes"
    echo "can be fround from the folder "
    echo ""
    echo "    $S_TMP_0"
fi
echo ""
#----------------------------------------
echo "In addition to letters the ASCII character encoding standard assigns "
echo "some of the values within the [0..255] to keyboard key presses that "
echo "at the time of the introduction of the ASCII did not have "
echo "a visual representation associated with them. A character/letter "
echo -e "analogue of a key press is called \"\e[33mcontrol character\e[39m\", "
echo -e "\"\e[33mnon-printing character\e[39m\", and the corresponding "
echo -e "positive whole number is called a \"\e[33mcontrol code\e[39m\"."
echo -e "Examples of control codes are \e[33m27, which corresponds to an ESC key press\e[39m,"
echo -e "and \e[33m13, which corresponds to an ENTER key press\e[39m."
echo ""
echo "Text in computers is a series of positive whole numbers."
echo "There are different ways, how positive whole numbers can be "
echo "encoded. Some further information about that might be found by "
echo -e "searching for phrases \"\e[33mbit endianness\e[39m\" and \"\e[33mbyte endianness\e[39m\". "
echo "There are different ways, how to encode a series of whole numbers, "
echo "speicially, if there is a motive to write the series "
echo -e "in a succinct (\"\e[33mcompressed\e[39m\") manner. An example: "
echo ""
echo "    An uncompressed way of writing a number series:"
echo "    1 42 42 42 42 42 42 42 42 42 42 42 42 772 147 147 147 147 147 147"
echo ""
echo "    The above number series written in a succinct, compressed, manner:"
echo "    1 42{12 times} 772 147{6 times}"
echo ""
echo "The different ways, how to write a number series in a "
echo -e "succinct, compressed, manner are called \"\e[33mcompression schemes\e[39m\". "
echo "In the case of text, one of the relevant phrases to search for is "
echo -e "\"\e[33mlossless compression\e[39m\". For comparison, as of year 2023 images, "
echo -e "sounds, videos tend to be written by using \"\e[33mlossy compression\e[39m\", where "
echo "some of the initial data is thrown away so that the initial "
echo "image, video, sound can not be fully restored, unless "
echo "\"lossless compression\" is used at writing the image, sound, movie."
echo ""
echo "As of year 2023 one of the most widely used, if not the most widely used, "
echo "\"lossless compression schemes\" for writing a "
echo "Unicode character encoding standard based series of whole numbers "
echo -e "is the \"\e[33mUTF-8\e[39m\" standard. As the set of \e[33mUnicode code charts "
echo -e "has the ASCII code charts as its subset\e[39m, the Unicode, and "
echo "therefore the UTF-8, includes control characters. "
echo "A relevant Unicode code chart:"
echo ""
echo "    https://unicode.org/charts/PDF/U0000.pdf"
echo "    archival copy: https://archive.vn/uSV0x"
#----------------------------------------
SB_AT_LEAST_ONE_FILE_PRESENT="f" # like "false"
S_TMP_0="$MMMV_USERSPACE_DISTRO_T1_HOME/attic/documentation/third_party_documentation/text_files/Unicode/2019_06_10_wget_copy_of_Unicode_chart_PDFs/PDF/U0000.pdf"
if [ -e "$S_FP_0" ]; then
    if [ ! -d "$S_FP_0" ]; then
        SB_AT_LEAST_ONE_FILE_PRESENT="t" # like "true"
    fi
fi
if [ "$SB_AT_LEAST_ONE_FILE_PRESENT" == "t" ]; then
    echo "    local copy: $S_TMP_0"
fi
echo ""
#----------------------------------------
echo -e "A\e[33m colour label\e[39m is an ASCII/Unicode_subset character sequence that "
echo "has a format of: "
echo ""
echo -e "\e[33m  <the ESC key press code, id est 27 in base 10><colour code>m \e[39m"
echo ""
echo "As a text file is a series of whole numbers (character codes), "
echo "a text file can be seen as an array of characters. "
echo "In such an array of characters the colour labels "
echo "are ordered according to the array index of their first character, "
echo "the ESC key press control character (27 in base 10). "
echo "Each colour label overrides the effect/colour_setting of all "
echo "colour labels that reside at lower indices than they self are. "
echo "The overall idea: "
echo ""
echo -e "    Some text with default colour<rolor label red>\e[31m this text "
echo -e "    is red<colour label green>\e[32m this text is green<colour label blue>\e[34m this "
echo -e "    text is blue<colour label default colour>\e[39m and this text has the default colour."
echo ""
echo "An example Bash line for copy-pasting:"
echo -e "\e[36m"
echo "    echo -e \"Some text with default colour\\e[31m this text is red\\e[32m this text is green\\e[34m this text is blue\\e[39m and this text has the default colour. \" "
echo -e "\e[39m"
echo ""
echo "People, who know, how to use the GNU sed, might find "
echo "the following Bash code samples useful:"
echo -e "\e[36m"
echo "    echo -e \"text_\\e[31mtext_red_\\e[32mtext_green_\\e[34mtext_blue_\\e[39mtext_default_color\"  | sed -e 's/text/Foo/g' | sed -e 's/green_Foo/colorlabel_lost/g'"
echo "    # The 2. sed call won't replace anything, because "
echo "    # the regex does not match the color label between the "
echo "    # \"green_\" and \"Foo\" like it does at the version without color labels:"
echo "    echo -e \"text_text_red_text_green_text_blue_text_default_color\"  | sed -e 's/text/Foo/g' | sed -e 's/green_Foo/colorlabel_lost/g'"
echo ""
echo "    # The next line uses the GNU sed to color all \"b\" characters green."
echo "    echo \"aaabbbcccc\" | sed -e 's/b/\x1b[32mb\x1b[39m/g' "
echo ""
echo -e "\e[39m"
echo "Color labels do get saved to file, if the stdout is redirected to a file."
echo "A modified version of a code sample from "
echo ""
echo "    https://stackoverflow.com/questions/27397865/how-to-write-stdout-to-file-with-colours"
echo "    archival copy: https://archive.ph/p6jQg "
echo ""
echo -e "\e[36m    echo \"UFO\" | grep --colour=always UF > ./text_with_colours.txt \e[39m"
echo -e "\e[36m    wait \e[39m"
echo -e "\e[36m    cat ./text_with_colours.txt \e[39m"
echo ""
echo "Anohter code example:"
echo -e "\e[36m"
#
# Unescaped version of the Bash-line for testing:
#
#     echo -e "\e[32ma\e[39m"  | xargs ruby -e 's_0="a\\" ; ar_0=s_0.codepoints ; s_in=ARGV[0].to_s ; ar_i=s_in.codepoints ; puts("\nCodepoint of \""+s_0[0..0]+"\" is: "+ar_0[0].to_s+"\nCodepoint of \""+s_0[1..1]+"\" is: "+ar_0[1].to_s+"\nThe ASCII codepoint for the ESC key is 27 \n\nar_i and respective chars:") ; s="" ; ar_i.size.times{|ix| s<<(s_in[ix..ix]+" code is "+ar_i[ix].to_s+"\n")} ; puts(s+"\n") ;'
# 
# Testline for understanding, how to escape for the printf:
#
#     # The 
#     printf " \\\n ff ' \" \\ G \\\\ M \\\\\\ W \\\\\" X \` Y "
#     # outputs:{ \n ff ' " \ G \ M \\ W \" X ` Y }
#
printf "    echo -e \"\\\e[32ma\\\e[39m\"  | xargs ruby -e 's_0=\"a\\\\\\\\\" ; ar_0=s_0.codepoints ; s_in=ARGV[0].to_s ; ar_i=s_in.codepoints ; puts(\"\\\nCodepoint of \\\\\"\"+s_0[0..0]+\"\\\\\" is: \"+ar_0[0].to_s+\"\\\nCodepoint of \\\\\"\"+s_0[1..1]+\"\\\\\" is: \"+ar_0[1].to_s+\"\\\nThe ASCII codepoint for the ESC key is 27 \\\n\\\nar_i and respective chars:\") ; s=\"\" ; ar_i.size.times{|ix| s<<(s_in[ix..ix]+\" code is \"+ar_i[ix].to_s+\"\\\n\")} ; puts(s+\"\\\n\") ;' "
echo "" # to compensate the lack of "\n" at the end of the printf
echo -e "\e[39m"
echo "and its console output:"
echo ""
echo "    Codepoint of \"a\" is: 97 "
echo "    Codepoint of \"\\\" is: 92 "
echo "    The ASCII codepoint for the ESC key is 27  "
echo "    "
echo "    ar_i and respective chars: "
echo "     code is 27 "
echo "    [ code is 91 "
echo "    3 code is 51 "
echo "    2 code is 50 "
echo "    m code is 109 "
echo "    a code is 97 "
echo "     code is 27 "
echo "    [ code is 91 "
echo "    3 code is 51 "
echo "    9 code is 57 "
echo "    m code is 109 "
echo ""
echo "A code example, where the code fragments originates from:"
echo ""
echo "    # https://www.redhat.com/sysadmin/linux-script-command"
echo "    # archival copy: https://archive.ph/lID9V"
echo ""
echo "    # https://www.redhat.com/sysadmin/playback-scriptreplay"
echo "    # archival copy: https://archive.ph/U2EJS"
echo -e "\e[36m"
echo "    script --timing=./timing_measurements.txt -q ./subsession_stdout_with_ASCII_colourtags.txt"
echo "    ls --colour=always -l"
echo "    # Exiting subsession with Ctrl-d"
echo "    wait "
echo "    cat ./subsession_stdout_with_ASCII_colourtags.txt # displays coloured text"
echo "    # The "
echo "    scriptreplay --timing=./timing_measurements.txt ./subsession_stdout_with_ASCII_colourtags.txt"
echo "    # is the same as the above "cat-line", except that"
echo "    # the content of the file is printed to console according "
echo "    # to the timing_measurements.txt ."
echo -e "\e[39m"
echo -e "The following colour code and formatting table is copy-pasted from"
echo -e "    https://misc.flogisoft.com/bash/tip_colours_and_formatting"
echo -e "    archival copy: https://archive.ph/2pzTs"
echo -e "and edited after copy-pasting.\e[33m Ruby and Bash have exactly the"
echo -e "same text colour switchon/switchoff strings\e[39m."
echo -e ""
echo -e "Formatting:"
echo -e "    Switch-on string \"<backslash>e[1m\" \e[1m Bold       \e[21m Switch-off string \"<backslash>e[21m\""
echo -e "    Switch-on string \"<backslash>e[2m\" \e[2m Dim        \e[22m Switch-off string \"<backslash>e[22m\""
echo -e "    Switch-on string \"<backslash>e[4m\" \e[4m Underlined \e[24m Switch-off string \"<backslash>e[24m\""
echo -e "    Switch-on string \"<backslash>e[5m\" \e[5m Blink      \e[25m Switch-off string \"<backslash>e[25m\""
echo -e "    Switch-on string \"<backslash>e[7m\" \e[7m inverted   \e[27m Switch-off string \"<backslash>e[27m\""
echo -e "    Switch-on string \"<backslash>e[8m\" \e[8m Hidden     \e[28m Switch-off string \"<backslash>e[28m\""
echo -e ""
echo -e ""
echo -e "Text colour:"
echo -e "    Switch-on string \"<backslash>e[30m\" \e[30m Black          \e[39m Switch-off string \"<backslash>e[39m\""
echo -e "    Switch-on string \"<backslash>e[\e[31m31\e[39mm\" \e[31m Red            \e[39m Switch-off string \"<backslash>e[39m\""
echo -e "    Switch-on string \"<backslash>e[\e[32m32\e[39mm\" \e[32m Green          \e[39m Switch-off string \"<backslash>e[39m\""
echo -e "    Switch-on string \"<backslash>e[\e[33m33\e[39mm\" \e[33m Yellow         \e[39m Switch-off string \"<backslash>e[39m\""
echo -e "    Switch-on string \"<backslash>e[\e[34m34\e[39mm\" \e[34m Blue           \e[39m Switch-off string \"<backslash>e[39m\""
echo -e "    Switch-on string \"<backslash>e[\e[35m35\e[39mm\" \e[35m Magenta        \e[39m Switch-off string \"<backslash>e[39m\""
echo -e "    Switch-on string \"<backslash>e[\e[36m36\e[39mm\" \e[36m Cyan           \e[39m Switch-off string \"<backslash>e[39m\""
echo -e "    Switch-on string \"<backslash>e[\e[37m37\e[39mm\" \e[37m Light gray     \e[39m Switch-off string \"<backslash>e[39m\""
echo -e "    Switch-on string \"<backslash>e[\e[90m90\e[39mm\" \e[90m Dark gray      \e[39m Switch-off string \"<backslash>e[39m\""
echo -e "    Switch-on string \"<backslash>e[\e[91m91\e[39mm\" \e[91m Light red      \e[39m Switch-off string \"<backslash>e[39m\""
echo -e "    Switch-on string \"<backslash>e[\e[92m92\e[39mm\" \e[92m Light green    \e[39m Switch-off string \"<backslash>e[39m\""
echo -e "    Switch-on string \"<backslash>e[\e[93m93\e[39mm\" \e[93m Light yellow   \e[39m Switch-off string \"<backslash>e[39m\""
echo -e "    Switch-on string \"<backslash>e[\e[94m94\e[39mm\" \e[94m Light blue     \e[39m Switch-off string \"<backslash>e[39m\""
echo -e "    Switch-on string \"<backslash>e[\e[95m95\e[39mm\" \e[95m Light magenta  \e[39m Switch-off string \"<backslash>e[39m\""
echo -e "    Switch-on string \"<backslash>e[\e[96m96\e[39mm\" \e[96m Light cyan     \e[39m Switch-off string \"<backslash>e[39m\""
echo -e "    Switch-on string \"<backslash>e[\e[97m97\e[39mm\" \e[97m White          \e[39m Switch-off string \"<backslash>e[39m\""
echo -e ""
echo -e "Text background colour:"
echo -e "    Switch-on string \"<backslash>e[40m\"  \e[40m Black         \e[49m Switch-off string \"<backslash>e[49m\""
echo -e "    Switch-on string \"<backslash>e[\e[41;30m41\e[0mm\"  \e[41;30m Red           \e[0m Switch-off string \"<backslash>e[49m\""
echo -e "    Switch-on string \"<backslash>e[\e[42;30m42\e[0mm\"  \e[42;30m Green         \e[0m Switch-off string \"<backslash>e[49m\""
echo -e "    Switch-on string \"<backslash>e[\e[43;30m43\e[0mm\"  \e[43;30m Yellow        \e[0m Switch-off string \"<backslash>e[49m\""
echo -e "    Switch-on string \"<backslash>e[\e[44;30m44\e[0mm\"  \e[44;30m Blue          \e[0m Switch-off string \"<backslash>e[49m\""
echo -e "    Switch-on string \"<backslash>e[\e[45;30m45\e[0mm\"  \e[45;30m Magenta       \e[0m Switch-off string \"<backslash>e[49m\""
echo -e "    Switch-on string \"<backslash>e[\e[46;30m46\e[0mm\"  \e[46;30m Cyan          \e[0m Switch-off string \"<backslash>e[49m\""
echo -e "    Switch-on string \"<backslash>e[\e[47;30m47\e[0mm\"  \e[47;30m Light gray    \e[0m Switch-off string \"<backslash>e[49m\""
echo -e "    Switch-on string \"<backslash>e[\e[100;30m100\e[0mm\" \e[100;30m Dark gray     \e[0m Switch-off string \"<backslash>e[49m\""
echo -e "    Switch-on string \"<backslash>e[\e[101;30m101\e[0mm\" \e[101;30m Light red     \e[0m Switch-off string \"<backslash>e[49m\""
echo -e "    Switch-on string \"<backslash>e[\e[102;30m102\e[0mm\" \e[102;30m Light green   \e[0m Switch-off string \"<backslash>e[49m\""
echo -e "    Switch-on string \"<backslash>e[\e[103;30m103\e[0mm\" \e[103;30m Light yellow  \e[0m Switch-off string \"<backslash>e[49m\""
echo -e "    Switch-on string \"<backslash>e[\e[104;30m104\e[0mm\" \e[104;30m Light blue    \e[0m Switch-off string \"<backslash>e[49m\""
echo -e "    Switch-on string \"<backslash>e[\e[105;30m105\e[0mm\" \e[105;30m Light magenta \e[0m Switch-off string \"<backslash>e[49m\""
echo -e "    Switch-on string \"<backslash>e[\e[106;30m106\e[0mm\" \e[106;30m Light cyan    \e[0m Switch-off string \"<backslash>e[49m\""
echo -e "    Switch-on string \"<backslash>e[\e[107;30m107\e[0mm\" \e[107;30m White         \e[0m Switch-off string \"<backslash>e[49m\""
echo -e ""
echo -e "Combining multiple attributes:"
echo -e "    Switch-on string \"<backslash>e[1;4;36m\"\e[1;4;94m Bold and Underlined\e[0m Switch-off string \"<backslash>e[0m\""
echo ""
#--------------------------------------------------------------------------
S_FN_0="mmmv_ls_doc_Bash_color_table_t1.bash" 
if [ "`which $S_FN_0 2> /dev/null`" != "" ]; then
    echo "A table with color combination samples can be viewed by executing "
    echo -e "\e[36m"
    echo "    $S_FN_0"
    echo -e "\e[39m"
fi
#--------------------------------------------------------------------------
exit 0 
#--------------------------------------------------------------------------
# S_VERSION_OF_THIS_FILE="01e37a27-223a-4605-b37e-d082b0e167e7"
#==========================================================================
