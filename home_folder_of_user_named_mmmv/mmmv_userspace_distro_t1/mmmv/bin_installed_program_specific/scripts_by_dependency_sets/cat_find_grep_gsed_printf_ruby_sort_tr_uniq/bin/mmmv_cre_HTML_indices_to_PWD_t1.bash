#!/usr/bin/env bash
#==========================================================================
# Initial author of this file: Martin.Vahi@softf1.com
# Initial author of the template file: Martin.Vahi@softf1.com
# This file is in public domain.
# The following line is a spdx.org license label line:
# SPDX-License-Identifier: 0BSD
#
# The main control flow entry in this script is the func_main(),
# which resides near the end of this file.
#
func_generate_or_overwrite_file_list_HTML_files(){
    #----------------------------------------------------------------------
    local S_FP_PREFIX="$S_FP_ORIG"
    local S_FP_FOLDER="$S_FP_PREFIX"
    cd "$S_FP_FOLDER" # a superficial access test
    func_mmmv_assert_error_code_zero_t1 "$?" \
        "6a957e1c-883d-4f75-b396-03622141a9e7"
    local S_FP=""
    #----------------------------------------------------------------------
    S_FP="$S_FP_FOLDER"
    func_t5_recursive_list_of_folders "$S_FP_FOLDER"
    func_t8_PDF_and_alike "$S_FP_FOLDER"
    func_t10_PDF_xls_txt_src_mp4_mp3_JPEG_zip "$S_FP_FOLDER"
    func_t11_AVFS_specific_links_to_ZIP "$S_FP_FOLDER"
    func_mmmv_wait_and_sync_t1
    func_t4_recursive_list_of_all_files "$S_FP_FOLDER" # last gen.func call here to include generated files to the list
    #----------------------------------------------------------------------
    nice -n 15 chmod -f -R 0755 "$S_FP_FOLDER"
    func_mmmv_assert_error_code_zero_t1 "$?" \
        "4494a5c2-db5a-424f-8f96-03622141a9e7"
    func_mmmv_wait_and_sync_t1
    #----------------------------------------------------------------------
} # func_generate_or_overwrite_file_list_HTML_files
#==========================================================================
#:Everything:::below::this::line::is::implementation::and::does::not::need::to::be::modified:::
#--------------------------------------------------------------------------
S_FP_DIR="$( cd "$( dirname "${BASH_SOURCE[0]}" )" && pwd )"
S_FP_ORIG="`pwd`"
#--------------------------------------------------------------------------

MMMV_BASH_BOILERPLATE_VERSION="subject_to_initialisation"
func_mmmv_bash_boilerplate_version(){
    local S_GUID="e26ad425-a1f0-4c68-a496-03622141a9e7"
    local S_TIMESTAMP="_subject_to_initialisation_"
# RENESSAATOR_BLOCK_START
# RENESSAATOR_BLOCK_ID=block_566c89e2-c6f0-12ed-9d8a-1c6f6552f9e6_city
# RENESSAATOR_SOURCE_LANGUAGE=Ruby
# RENESSAATOR_SOURCE_START
# ob_t=Time.now
# s_t="_⏳_"
# s_t<<("y"+ob_t.year.to_s)
# s_t<<"_"
# s_t<<("m"+ob_t.month.to_s)
# s_t<<"_"
# s_t<<("d"+ob_t.day.to_s)
# s_t<<"_"
# s_t<<("h"+ob_t.hour.to_s)
# s_t<<"_"
# s_t<<("m"+ob_t.min.to_s)
# s_t<<"_"
# s_t<<("s"+ob_t.sec.to_s)
# s_t<<"_"
# s_t<<("μ"+ob_t.usec.to_s)
# s_t<<"_☺_"
# puts("    S_TIMESTAMP=\""+s_t+"\"")
# RENESSAATOR_SOURCE_END
#
# RENESSAATOR_AUTOGENERATED_TEXT_START
    S_TIMESTAMP="_⏳_y2023_m12_d24_h8_m12_s18_μ309806_☺_"

# RENESSAATOR_AUTOGENERATED_TEXT_END
# RENESSAATOR_BLOCK_END
    MMMV_BASH_BOILERPLATE_VERSION="mmmv_bash_boilerplate_t4_$S_TIMESTAMP$S_GUID"
} # func_mmmv_bash_boilerplate_version
func_mmmv_bash_boilerplate_version

#--------------------------------------------------------------------------

func_mmmv_wait_and_sync_t1(){
    wait # for background processes started by this Bash script to exit/finish
    sync # network drives, USB-sticks, etc.
    wait # for sync
} # func_mmmv_wait_and_sync_t1

#--------------------------------------------------------------------------
func_mmmv_init_s_timestamp_if_not_inited_t1(){
    if [ "$S_TIMESTAMP" == "" ]; then
        if [ "`which date 2> /dev/null`" != "" ]; then
            S_TIMESTAMP="`date +%Y`_`date +%m`_`date +%d`_T_`date +%H`h_`date +%M`min_`date +%S`s"
        else
            S_TIMESTAMP="0000_00_00_T_00h_00min_00s"
            echo ""
            echo -e "The console program \"\e[31mdate\e[39m\" is missing from the PATH."
            echo "Using a constant value, "
            echo ""
            echo "    S_TIMESTAMP=\"$S_TIMESTAMP\""
            echo ""
            echo "GUID=='2c0d0390-c8bd-4173-9296-03622141a9e7'"
            echo ""
        fi
    fi
} # func_mmmv_init_s_timestamp_if_not_inited_t1

#--------------------------------------------------------------------------

func_mmmv_verify_S_FP_ORIG_but_do_not_exit_t1(){
    SB_S_FP_ORIG_VERIFICATION_FAILED="f"
    if [ "$S_FP_ORIG" == "" ]; then
        SB_S_FP_ORIG_VERIFICATION_FAILED="t"
        echo ""
        echo -e "\e[31mThe code of this script has the flaw\e[39m that"
        echo "the variable S_FP_ORIG has not been set."
        echo "GUID=='5fa8275a-e79b-442a-b496-03622141a9e7'"
        echo ""
    else
        if [ ! -e "$S_FP_ORIG" ]; then
            SB_S_FP_ORIG_VERIFICATION_FAILED="t"
            echo ""
            echo -e "\e[31mThe code of this script has the flaw\e[39m that "
            echo "the variable S_FP_ORIG has been declared, but "
            echo "its value is some string that is not a file or folder path."
            echo "It is expected to be a folder path."
            echo ""
            echo "    S_FP_ORIG==\"$S_FP_ORIG\""
            echo ""
            echo "GUID=='cdbcde5c-0c11-4036-8196-03622141a9e7'"
            echo ""
        else
            if [ ! -d "$S_FP_ORIG" ]; then
                SB_S_FP_ORIG_VERIFICATION_FAILED="t"
                echo ""
                echo -e "\e[31mThe code of this script has the flaw\e[39m that "
                echo "the variable S_FP_ORIG references a file, but "
                echo "it is expected to reference a folder."
                echo ""
                echo "    S_FP_ORIG==$S_FP_ORIG"
                echo ""
                echo "GUID=='50ac2404-855c-4593-8496-03622141a9e7'"
                echo ""
            fi
        fi
    fi
    #----------------------------------------------------------------------
    # exit 1 # must NOT be called in ~/.bashrc, because
             # exiting from the ~/.bashrc exits the session.
    #----------------------------------------------------------------------
    # Usage example:
    #    func_mmmv_verify_S_FP_ORIG_but_do_not_exit_t1
    #    if [ "$SB_S_FP_ORIG_VERIFICATION_FAILED" == "f" ]; then
    #        cd "$S_FP_ORIG"
    #    else
    #        echo ""
    #        echo "The code of this script is flawed."
    #        echo "GUID=='1604f731-b0f2-427f-9496-03622141a9e7'"
    #        echo ""
    #    fi
} # func_mmmv_verify_S_FP_ORIG_but_do_not_exit_t1

#--------------------------------------------------------------------------

SB_FUNC_MMMV_VERIFY_S_FP_ORIG_BUT_DO_NOT_EXIT_T2_S_FB_ORIG_ALREADY_VERIFIED="f"
func_mmmv_verify_S_FP_ORIG_but_do_not_exit_t2(){
    if [ "$SB_FUNC_MMMV_VERIFY_S_FP_ORIG_BUT_DO_NOT_EXIT_T2_S_FB_ORIG_ALREADY_VERIFIED" != "t" ]; then
        if [ "$SB_FUNC_MMMV_VERIFY_S_FP_ORIG_BUT_DO_NOT_EXIT_T2_S_FB_ORIG_ALREADY_VERIFIED" != "f" ]; then
            echo ""
            echo -e "\e[31mThe code that calls this function is flawed. \e[39m"
            echo "The global variable "
            echo ""
            echo "    SB_FUNC_MMMV_VERIFY_S_FP_ORIG_BUT_DO_NOT_EXIT_T2_S_FB_ORIG_ALREADY_VERIFIED==\"$SB_FUNC_MMMV_VERIFY_S_FP_ORIG_BUT_DO_NOT_EXIT_T2_S_FB_ORIG_ALREADY_VERIFIED\""
            echo ""
            echo "has a domain of {\"f\", \"t\"}."
            echo "GUID=='42371147-71ef-4eef-a596-03622141a9e7'"
            echo ""
        else
            func_mmmv_verify_S_FP_ORIG_but_do_not_exit_t1
            SB_FUNC_MMMV_VERIFY_S_FP_ORIG_BUT_DO_NOT_EXIT_T2_S_FB_ORIG_ALREADY_VERIFIED="t"
        fi
    fi
} # func_mmmv_verify_S_FP_ORIG_but_do_not_exit_t2

#--------------------------------------------------------------------------

SB_NO_ERRORS_YET="t" # domain=={"t","f"}
func_mmmv_assert_nonempty_string_but_do_not_exit_t1(){
    local S_IN="$1"
    local S_VARIABLE_NAME_IN_CALLING_CODE="$2"
    local S_GUID_CANDIDATE="$3"
    #----------------------------------------------------------------------
    local SB_NO_ERRORS_YET_1="t"
    if [ "$S_GUID_CANDIDATE" == "" ]; then
        echo ""
        echo -e "\e[31mThe code that calls this function is flawed.\e[39m The"
        echo ""
        echo "    S_GUID_CANDIDATE==\"\""
        echo ""
        echo "but it is expected to be a GUID."
        echo "GUID=='38362214-20d5-4423-8296-03622141a9e7'"
        echo ""
        SB_NO_ERRORS_YET_1="f"
    fi
    #--------------------
    if [ "$SB_NO_ERRORS_YET" != "t" ]; then
        echo ""
        echo -e "\e[31mThe code that calls this function is flawed. \e[39m"
        echo "The global variable "
        echo ""
        echo "    SB_NO_ERRORS_YET==\"$SB_NO_ERRORS_YET\""
        echo ""
        if [ "$SB_NO_ERRORS_YET" == "f" ]; then
            echo "is expected to be initialized to \"t\" before calling this function."
            echo "GUID=='1297bfd9-8451-432d-b396-03622141a9e7'"
        else
            echo "is expected to be initialized to \"t\" before calling this function"
            echo "and its domain is {\"f\", \"t\"}."
            echo "GUID=='fc501f71-0206-40e6-a286-03622141a9e7'"
        fi
        if [ "$SB_NO_ERRORS_YET_1" == "t" ]; then
            echo "GUID_CANDIDATE=='$S_GUID_CANDIDATE'"
        fi
        echo ""
        SB_NO_ERRORS_YET="f"
    fi
    #--------------------
    if [ "$SB_NO_ERRORS_YET_1" == "f" ]; then
        SB_NO_ERRORS_YET="f"
    fi
    #----------------------------------------------------------------------
    if [ "$SB_NO_ERRORS_YET" == "t" ]; then
        if [ "$S_VARIABLE_NAME_IN_CALLING_CODE" == "" ]; then
            echo ""
            echo -e "\e[31mThe code that calls this function is flawed.\e[39m The"
            echo ""
            echo "    S_VARIABLE_NAME_IN_CALLING_CODE==\"\""
            echo ""
            echo "GUID=='01409a33-34f5-47fa-b686-03622141a9e7'"
            if [ "$SB_NO_ERRORS_YET_1" == "t" ]; then  # should be always true at this line
                echo "GUID_CANDIDATE=='$S_GUID_CANDIDATE'"
            fi
            echo ""
            SB_NO_ERRORS_YET="f"
        fi
    fi
    #----------------------------------------------------------------------
    if [ "$SB_NO_ERRORS_YET" == "t" ]; then
        if [ "$S_IN" == "" ]; then
            echo ""
            echo -e "\e[31mThere is a flaw somewhere in the code\e[39m that"
            echo "uses a variable named \"$S_VARIABLE_NAME_IN_CALLING_CODE\"."
            echo ""
            echo "    $S_VARIABLE_NAME_IN_CALLING_CODE==\"$S_IN\""
            echo ""
            echo "but it is expected to be something other than an empty string."
            echo "GUID=='21003562-43c2-4864-a186-03622141a9e7'"
            if [ "$SB_NO_ERRORS_YET_1" == "t" ]; then  # should be always true at this line
                echo "GUID_CANDIDATE=='$S_GUID_CANDIDATE'"
            fi
            echo ""
            SB_NO_ERRORS_YET="f"
        fi
    fi
    #----------------------------------------------------------------------
} # func_mmmv_assert_nonempty_string_but_do_not_exit_t1

#--------------------------------------------------------------------------

# SB_NO_ERRORS_YET="t" # domain=={"t","f"}, initial declaration resides upwards from this line
func_mmmv_assert_sbvar_domain_t_f_but_do_not_exit_t1(){
    local SB_VARIABLE_VALUE="$1"
    local S_VARIABLE_NAME_IN_CALLING_CODE="$2"
    local S_GUID_CANDIDATE="$3"
    #----------------------------------------------------------------------
    local SB_NO_ERRORS_YET_1="t"
    if [ "$S_GUID_CANDIDATE" == "" ]; then
        echo ""
        echo -e "\e[31mThe code that calls this function is flawed.\e[39m The"
        echo ""
        echo "    S_GUID_CANDIDATE==\"\""
        echo ""
        echo "but it is expected to be a GUID."
        echo "GUID=='b313475e-cd62-43e9-9286-03622141a9e7'"
        echo ""
        SB_NO_ERRORS_YET_1="f"
    fi
    #--------------------
    if [ "$SB_NO_ERRORS_YET" != "t" ]; then
        echo ""
        echo -e "\e[31mThe code that calls this function is flawed. \e[39m"
        echo "The global variable "
        echo ""
        echo "    SB_NO_ERRORS_YET==\"$SB_NO_ERRORS_YET\""
        echo ""
        if [ "$SB_NO_ERRORS_YET" == "f" ]; then
            echo "is expected to be initialized to \"t\" before calling this function."
            echo "GUID=='2a3117c4-535c-44e9-a286-03622141a9e7'"
        else
            echo "is expected to be initialized to \"t\" before calling this function"
            echo "and its domain is {\"f\", \"t\"}."
            echo "GUID=='a9b8bc12-b077-475e-b186-03622141a9e7'"
        fi
        if [ "$SB_NO_ERRORS_YET_1" == "t" ]; then
            echo "GUID_CANDIDATE=='$S_GUID_CANDIDATE'"
        fi
        echo ""
        SB_NO_ERRORS_YET="f"
    fi
    #--------------------
    if [ "$SB_NO_ERRORS_YET_1" == "f" ]; then
        SB_NO_ERRORS_YET="f"
    fi
    #----------------------------------------------------------------------
    if [ "$SB_NO_ERRORS_YET" == "t" ]; then
        if [ "$S_VARIABLE_NAME_IN_CALLING_CODE" == "" ]; then
            echo ""
            echo -e "\e[31mThe code that calls this function is flawed.\e[39m The"
            echo ""
            echo "    S_VARIABLE_NAME_IN_CALLING_CODE==\"\""
            echo ""
            echo "GUID=='3ee09454-54a2-4fb5-b386-03622141a9e7'"
            if [ "$SB_NO_ERRORS_YET_1" == "t" ]; then  # should be always true at this line
                echo "GUID_CANDIDATE=='$S_GUID_CANDIDATE'"
            fi
            echo ""
            SB_NO_ERRORS_YET="f"
        fi
    fi
    #----------------------------------------------------------------------
    if [ "$SB_NO_ERRORS_YET" == "t" ]; then
        if [ "$SB_VARIABLE_VALUE" != "t" ]; then
            if [ "$SB_VARIABLE_VALUE" != "f" ]; then
                echo ""
                echo -e "\e[31mThere is a flaw somewhere in the code\e[39m that"
                echo "uses a variable named \"$S_VARIABLE_NAME_IN_CALLING_CODE\". The "
                echo ""
                echo "    $S_VARIABLE_NAME_IN_CALLING_CODE==\"$SB_VARIABLE_VALUE\""
                echo ""
                echo "but it is expected to be either \"t\" or \"f\"."
                echo "GUID=='41b6d834-0eee-4122-b486-03622141a9e7'"
                if [ "$SB_NO_ERRORS_YET_1" == "t" ]; then  # should be always true at this line
                    echo "GUID_CANDIDATE=='$S_GUID_CANDIDATE'"
                fi
                echo ""
                SB_NO_ERRORS_YET="f"
            fi
        fi
    fi
    #----------------------------------------------------------------------
} # func_mmmv_assert_sbvar_domain_t_f_but_do_not_exit_t1

#--------------------------------------------------------------------------

func_mmmv_report_an_error_but_do_not_exit_t1(){
    local S_GUID_CANDIDATE="$1" # first  function argument
    local S_ERR_MSG="$2"        # second function argument
    #----------------------------------------------------------------------
    if [ "$S_GUID_CANDIDATE" == "" ]; then
        echo ""
        echo -e "\e[31mThe code of this script is flawed.\e[39m"
        if [ "$S_ERR_MSG" != "" ]; then
            echo "$S_ERR_MSG"
        fi
        echo "GUID=='9bc56652-0de7-4770-9586-03622141a9e7'"
        echo ""
    else
        echo ""
        echo -e "\e[31mThe code of this script is flawed.\e[39m"
        if [ "$S_ERR_MSG" != "" ]; then
            echo "$S_ERR_MSG"
        fi
        echo "GUID_CANDIDATE=='$S_GUID_CANDIDATE'"
        echo "GUID=='364ff2c2-a8aa-488f-ae86-03622141a9e7'"
        echo ""
    fi
    #----------------------------------------------------------------------
    # exit 1 # must NOT be called in ~/.bashrc, because
             # exiting from the ~/.bashrc exits the session.
} # func_mmmv_report_an_error_but_do_not_exit_t1

#--------------------------------------------------------------------------

func_mmmv_report_missing_from_path_and_do_NOT_exit_t1() {
    local S_NAME_OF_THE_EXECUTABLE=$1 # first function argument
    #----------------------------------------------------------------------
    local S_TMP_0="\`which $S_NAME_OF_THE_EXECUTABLE 2> /dev/null\`"
    local S_TMP_1=""
    local S_TMP_2="S_TMP_1=$S_TMP_0"
    eval ${S_TMP_2}
    if [ "$S_TMP_1" == "" ] ; then
        echo ""
        echo "This bash script wished to use the "
        echo "\"$S_NAME_OF_THE_EXECUTABLE\" from the PATH, but "
        echo "it was missing from the PATH."
        echo "GUID=='5ba8ed1f-b93f-4147-b286-03622141a9e7'"
        echo ""
    fi
    #----------------------------------------------------------------------
    # exit 1 # must NOT be called in ~/.bashrc, because
             # exiting from the ~/.bashrc exits the session.
} # func_mmmv_report_missing_from_path_and_do_NOT_exit_t1

#func_mmmv_report_missing_from_path_and_do_NOT_exit_t1 "ln"
#func_mmmv_report_missing_from_path_and_do_NOT_exit_t1 "date"
func_mmmv_report_missing_from_path_and_do_NOT_exit_t1 "printf"
func_mmmv_report_missing_from_path_and_do_NOT_exit_t1 "grep"
#func_mmmv_report_missing_from_path_and_do_NOT_exit_t1 "git"

#--------------------------------------------------------------------------

func_mmmv_verify_that_the_file_exists_but_do_not_exit_t1() {  # S_FP, S_GUID_CANDIDATE
    local S_FP="$1"
    local S_GUID_CANDIDATE="$2"
    local SB_DISPLAY_VERIFICATION_FAILURE_MESSAGE="$3" # domain: {"t","f",""}
                                                       # ""==="t", default "t"
    #----------------------------------------------------------------------
    # A global variable for storing function output.
    SB_VERIFICATION_FAILED="f" # domain: "t", "f" .
    #------------------------------
    if [ "$S_GUID_CANDIDATE" == "" ]; then
        echo ""
        echo -e "\e[31mThe code that calls this function is flawed.\e[39m"
        echo "This function requires 2 parameters: S_FP, S_GUID_CANDIDATE"
        echo "and has an optional 3. parameter: SB_DISPLAY_VERIFICATION_FAILURE_MESSAGE"
        echo "GUID=='2440d673-dbc9-48ab-a586-03622141a9e7'"
        echo ""
        #--------
        SB_VERIFICATION_FAILED="t"
    fi
    #------------------------------
    local SB_DISPLAY_VERIF_FAILURE_MSG="t" # the default
    if [ "$SB_VERIFICATION_FAILED" == "f" ]; then
        if [ "$SB_DISPLAY_VERIFICATION_FAILURE_MESSAGE" != "" ]; then
            if [ "$SB_DISPLAY_VERIFICATION_FAILURE_MESSAGE" == "f" ]; then
                SB_DISPLAY_VERIF_FAILURE_MSG="f"
            else
                if [ "$SB_DISPLAY_VERIFICATION_FAILURE_MESSAGE" != "t" ]; then
                    echo ""
                    echo -e "\e[31mThe code that calls this function is flawed.\e[39m"
                    echo ""
                    echo "  SB_DISPLAY_VERIFICATION_FAILURE_MESSAGE==\"$SB_DISPLAY_VERIFICATION_FAILURE_MESSAGE\""
                    echo ""
                    echo "Valid values are: \"t\", \"f\", \"\" ."
                    echo "\"\" defaults to \"t\"."
                    echo "GUID=='3681e611-3203-4c4e-9476-03622141a9e7'"
                    echo ""
                    #--------
                    SB_VERIFICATION_FAILED="t"
                fi
            fi
        fi
    fi
    #------------------------------
    if [ "$SB_VERIFICATION_FAILED" == "f" ]; then
        if [ ! -e "$S_FP" ]; then
            if [ -h "$S_FP" ]; then
                if [ "$SB_DISPLAY_VERIF_FAILURE_MSG" == "t" ]; then
                    echo ""
                    echo "The path "
                    echo ""
                    echo "    $S_FP "
                    echo ""
                    echo -e "points to a\e[31m broken symlink\e[39m, but a file or"
                    echo "a symlink to a file is expected."
                    echo "GUID==\"$S_GUID_CANDIDATE\""
                    echo "GUID=='99ce8616-ed49-43d5-b176-03622141a9e7'"
                    echo ""
                fi
                #--------
                SB_VERIFICATION_FAILED="t"
            else
                if [ "$SB_DISPLAY_VERIF_FAILURE_MSG" == "t" ]; then
                    echo ""
                    echo "The file "
                    echo ""
                    echo "    $S_FP "
                    echo ""
                    echo -e "\e[31mdoes not exist\e[39m."
                    echo "GUID==\"$S_GUID_CANDIDATE\""
                    echo "GUID=='9e4bc622-5c69-4e68-9476-03622141a9e7'"
                    echo ""
                fi
                #--------
                SB_VERIFICATION_FAILED="t"
            fi
        else
            if [ -d "$S_FP" ]; then
                if [ "$SB_DISPLAY_VERIF_FAILURE_MSG" == "t" ]; then
                    echo ""
                    if [ -h "$S_FP" ]; then
                        echo "The symlink to the folder "
                    else
                        echo "The folder "
                    fi
                    echo ""
                    echo "    $S_FP "
                    echo ""
                    echo -e "exists, but a\e[31m file or a symlink to a file is expected\e[39m."
                    echo "GUID==\"$S_GUID_CANDIDATE\""
                    echo "GUID=='493e4bf2-87c3-48ed-a176-03622141a9e7'"
                    echo ""
                fi
                #--------
                SB_VERIFICATION_FAILED="t"
            fi
        fi
    fi #  "$SB_VERIFICATION_FAILED" == "f"
    #------------------------------
    if [ "$SB_VERIFICATION_FAILED" != "t" ]; then
        if [ "$SB_VERIFICATION_FAILED" != "f" ]; then
            echo ""
            echo -e "\e[31mThe code of this Bash function is flawed.\e[39m"
            echo "GUID=='267c5958-6a9a-4f93-b476-03622141a9e7'"
            echo ""
        fi
    fi
    #------------------------------
} # func_mmmv_verify_that_the_file_exists_but_do_not_exit_t1

#--------------------------------------------------------------------------

func_mmmv_verify_that_the_folder_exists_but_do_not_exit_t1() {  # S_FP, S_GUID_CANDIDATE
    local S_FP="$1"
    local S_GUID_CANDIDATE="$2"
    local SB_DISPLAY_VERIFICATION_FAILURE_MESSAGE="$3" # domain: {"t","f",""}
                                                       # ""==="t", default "t"
    #----------------------------------------------------------------------
    # A global variable for storing function output.
    SB_VERIFICATION_FAILED="f" # domain: "t", "f" .
    #------------------------------
    if [ "$S_GUID_CANDIDATE" == "" ]; then
        echo ""
        echo -e "\e[31mThe code that calls this function is flawed.\e[39m"
        echo "This function requires 2 parameters: S_FP, S_GUID_CANDIDATE"
        echo "and has an optional 3. parameter: SB_DISPLAY_VERIFICATION_FAILURE_MESSAGE"
        echo "GUID=='4ded5057-1682-493f-a176-03622141a9e7'"
        echo ""
        #--------
        SB_VERIFICATION_FAILED="t"
    fi
    #------------------------------
    local SB_DISPLAY_VERIF_FAILURE_MSG="t" # the default
    if [ "$SB_VERIFICATION_FAILED" == "f" ]; then
        if [ "$SB_DISPLAY_VERIFICATION_FAILURE_MESSAGE" != "" ]; then
            if [ "$SB_DISPLAY_VERIFICATION_FAILURE_MESSAGE" == "f" ]; then
                SB_DISPLAY_VERIF_FAILURE_MSG="f"
            else
                if [ "$SB_DISPLAY_VERIFICATION_FAILURE_MESSAGE" != "t" ]; then
                    echo ""
                    echo -e "\e[31mThe code that calls this function is flawed.\e[39m"
                    echo ""
                    echo "  SB_DISPLAY_VERIFICATION_FAILURE_MESSAGE==\"$SB_DISPLAY_VERIFICATION_FAILURE_MESSAGE\""
                    echo ""
                    echo "Valid values are: \"t\", \"f\", \"\" ."
                    echo "\"\" defaults to \"t\"."
                    echo "GUID=='8b819a10-c5bc-46a1-8376-03622141a9e7'"
                    echo ""
                    #--------
                    SB_VERIFICATION_FAILED="t"
                fi
            fi
        fi
    fi
    #------------------------------
    if [ "$SB_VERIFICATION_FAILED" == "f" ]; then
        if [ ! -e "$S_FP" ]; then
            if [ -h "$S_FP" ]; then
                if [ "$SB_DISPLAY_VERIF_FAILURE_MSG" == "t" ]; then
                    echo ""
                    echo "The path "
                    echo ""
                    echo "    $S_FP "
                    echo ""
                    echo -e "points to a\e[31m broken symlink\e[39m, but a folder "
                    echo "or a symlink to a folder is expected."
                    echo "GUID==\"$S_GUID_CANDIDATE\""
                    echo "GUID=='356e8f64-8dad-4aac-9e76-03622141a9e7'"
                    echo ""
                fi
                #--------
                SB_VERIFICATION_FAILED="t"
            else
                if [ "$SB_DISPLAY_VERIF_FAILURE_MSG" == "t" ]; then
                    echo ""
                    echo "The folder "
                    echo ""
                    echo "    $S_FP "
                    echo ""
                    echo -e "\e[31mdoes not exist\e[39m."
                    echo "GUID==\"$S_GUID_CANDIDATE\""
                    echo "GUID=='167e1e48-9654-4f12-9176-03622141a9e7'"
                    echo ""
                fi
                #--------
                SB_VERIFICATION_FAILED="t"
            fi
        else
            if [ ! -d "$S_FP" ]; then
                if [ "$SB_DISPLAY_VERIF_FAILURE_MSG" == "t" ]; then
                    echo ""
                    if [ -h "$S_FP" ]; then
                        echo "The symlink to an existing file "
                    else
                        echo "The file "
                    fi
                    echo ""
                    echo "    $S_FP "
                    echo ""
                    echo -e "exists, but a\e[31m folder is expected\e[39m."
                    echo "GUID==\"$S_GUID_CANDIDATE\""
                    echo "GUID=='6ab86850-da8c-4f90-a276-03622141a9e7'"
                    echo ""
                fi
                #--------
                SB_VERIFICATION_FAILED="t"
            fi
        fi
    fi #  "$SB_VERIFICATION_FAILED" == "f"
    #------------------------------
    if [ "$SB_VERIFICATION_FAILED" != "t" ]; then
        if [ "$SB_VERIFICATION_FAILED" != "f" ]; then
            echo ""
            echo -e "\e[31mThe code of this Bash function is flawed.\e[39m"
            echo "GUID=='45aef4a3-bcfb-4204-9476-03622141a9e7'"
            echo ""
        fi
    fi
    #------------------------------
} # func_mmmv_verify_that_the_folder_exists_but_do_not_exit_t1

#--------------------------------------------------------------------------

func_mmmv_add_bin_2_Z_PATH_and_optionally_share_man_2_MANPATH_t1(){
    local S_FP_INSTALLATION_FOLDER="$1" # is
                      # the folder with the $S_FP_INSTALLATION_FOLDER/bin
                      # and optionally  the $S_FP_INSTALLATION_FOLDER/share/man
    local S_GUID_CANDIDATE="$2"
    local SB_MAN_FOLDER_EXISTENCE_IS_MANDATORY="$3" # domain: {"t","f"} Default: "f"
    #----------------------------------------------------------------------
    # A global variable for storing function output.
    SB_VERIFICATION_FAILED="f" # domain: "t", "f" .
    #------------------------------
    if [ "$SB_VERIFICATION_FAILED" == "f" ]; then
        if [ "$S_GUID_CANDIDATE" == "" ]; then
            echo ""
            echo -e "\e[31mThe code that calls this function is flawed.\e[39m"
            echo ""
            echo "    S_GUID_CANDIDATE==\"\""
            echo ""
            echo "GUID=='4de3015e-0312-4dfc-9376-03622141a9e7'"
            echo ""
            #--------
            SB_VERIFICATION_FAILED="t"
        fi
    fi
    #------------------------------
    if [ "$SB_VERIFICATION_FAILED" == "f" ]; then
        if [ "$S_FP_INSTALLATION_FOLDER" == "" ]; then
            echo ""
            echo -e "\e[31mThe code that calls this function is flawed.\e[39m"
            echo ""
            echo "    S_FP_INSTALLATION_FOLDER==\"\""
            echo ""
            echo "S_GUID_CANDIDATE=='$S_GUID_CANDIDATE'"
            echo "GUID=='539dbe36-ff5d-46a9-b166-03622141a9e7'"
            echo ""
            #--------
            SB_VERIFICATION_FAILED="t"
        fi
    fi
    #------------------------------
    if [ "$SB_VERIFICATION_FAILED" == "f" ]; then
        if [ "$SB_MAN_FOLDER_EXISTENCE_IS_MANDATORY" == "" ]; then
            SB_MAN_FOLDER_EXISTENCE_IS_MANDATORY="f" # the default value
        else
            if [ "$SB_MAN_FOLDER_EXISTENCE_IS_MANDATORY" != "t" ]; then
                if [ "$SB_MAN_FOLDER_EXISTENCE_IS_MANDATORY" != "f" ]; then
                    echo ""
                    echo -e "\e[31mThe code that calls this function is flawed.\e[39m"
                    echo ""
                    echo "    SB_MAN_FOLDER_EXISTENCE_IS_MANDATORY==\"$SB_MAN_FOLDER_EXISTENCE_IS_MANDATORY\""
                    echo ""
                    echo "but its valid values are \"t\" and \"f\" and "
                    echo "\"\", which is automatically converted to the "
                    echo "default value of \"f\"."
                    echo "S_GUID_CANDIDATE=='$S_GUID_CANDIDATE'"
                    echo "GUID=='36d0dd13-a1fa-4de0-b266-03622141a9e7'"
                    echo ""
                    #--------
                    SB_VERIFICATION_FAILED="t"
                fi
            fi
        fi
    fi
    #------------------------------
    local SB_MAN_FOLDER_OR_NONBROKEN_SYMLINK_TO_IT_EXISTS="f"
    if [ "$SB_VERIFICATION_FAILED" == "f" ]; then
        func_mmmv_verify_that_the_folder_exists_but_do_not_exit_t1 \
            "$S_FP_INSTALLATION_FOLDER" "fb197450-951e-4496-8196-03622141a9e7"
        if [ "$SB_VERIFICATION_FAILED" == "f" ]; then
            #--------------
            func_mmmv_verify_that_the_folder_exists_but_do_not_exit_t1 \
                "$S_FP_INSTALLATION_FOLDER/bin" "5351ef51-5064-44b3-b196-03622141a9e7"
            if [ "$SB_VERIFICATION_FAILED" == "f" ]; then
                Z_PATH="$S_FP_INSTALLATION_FOLDER/bin:$Z_PATH"
            fi
            #--------------
            if [ -e "$S_FP_INSTALLATION_FOLDER/share/man" ]; then
                if [ -d "$S_FP_INSTALLATION_FOLDER/share/man" ]; then
                    SB_MAN_FOLDER_OR_NONBROKEN_SYMLINK_TO_IT_EXISTS="t"
                fi
            fi
            if [ "$SB_MAN_FOLDER_OR_NONBROKEN_SYMLINK_TO_IT_EXISTS" == "f" ]; then
                if [ "$SB_MAN_FOLDER_EXISTENCE_IS_MANDATORY" == "t" ]; then
                    # The next 2 lines are for displaying an error message.
                    func_mmmv_verify_that_the_folder_exists_but_do_not_exit_t1 \
                        "$S_FP_INSTALLATION_FOLDER/share/man" "8af6f74a-9841-4aaf-9496-03622141a9e7"
                fi
            else
                MANPATH="$S_FP_INSTALLATION_FOLDER/share/man:$MANPATH"
            fi
            #--------------
        fi
    fi
    #------------------------------
    if [ "$SB_VERIFICATION_FAILED" != "t" ]; then
        if [ "$SB_VERIFICATION_FAILED" != "f" ]; then
            echo ""
            echo -e "\e[31mThe code of this Bash function is flawed.\e[39m"
            echo "GUID=='509e6cd5-1e49-4477-9c66-03622141a9e7'"
            echo ""
        fi
    fi
    #------------------------------
} # func_mmmv_add_bin_2_Z_PATH_and_optionally_share_man_2_MANPATH_t1

#--------------------------------------------------------------------------

func_mmmv_assert_error_code_zero_t1(){
    local S_ERR_CODE="$1" # the "$?"
    local S_GUID_CANDIDATE="$2"
    #----------------------------------------------------------------------
    if [ "$S_GUID_CANDIDATE" == "" ]; then
        echo ""
        echo -e "\e[31mThe Bash code that calls this function is flawed. \e[39m"
        echo ""
        echo "    S_GUID_CANDIDATE==\"\""
        echo ""
        echo "but it is expected to be a GUID."
        echo "Aborting script."
        echo "GUID=='d1db6a0e-9bde-424b-8b66-03622141a9e7'"
        echo "S_GUID_CANDIDATE=='$S_GUID_CANDIDATE'"
        echo ""
        #--------
        cd "$S_FP_ORIG"
        exit 1
    fi
    #------------------------------
    # If the "$?" were evaluated in this function,
    # then it would be "0" even, if it is
    # something else at the calling code.
    if [ "$S_ERR_CODE" != "0" ];then
        echo ""
        echo "Something went wrong. Error code: $S_ERR_CODE"
        echo -e "\e[31mAborting script. \e[39m"
        echo "GUID=='1ccc77c3-adec-4b95-9966-03622141a9e7'"
        echo "S_GUID_CANDIDATE=='$S_GUID_CANDIDATE'"
        echo ""
        #--------
        cd "$S_FP_ORIG"
        exit 1
    fi
    #------------------------------
} # func_mmmv_assert_error_code_zero_t1

#--------------------------------------------------------------------------

# It differs form the
# func_mmmv_assert_error_code_zero_t1
# by the fact that it does not include the
#
#     cd "$S_FP_ORIG"
#
func_mmmv_assert_error_code_zero_t2(){
    local S_ERR_CODE="$1" # the "$?"
    local S_GUID_CANDIDATE="$2"
    #----------------------------------------------------------------------
    if [ "$S_GUID_CANDIDATE" == "" ]; then
        echo ""
        echo -e "\e[31mThe Bash code that calls this function is flawed. \e[39m"
        echo ""
        echo "    S_GUID_CANDIDATE==\"\""
        echo ""
        echo "but it is expected to be a GUID."
        echo "Aborting script."
        echo "GUID=='3381e891-69bb-45c2-8766-03622141a9e7'"
        echo "S_GUID_CANDIDATE=='$S_GUID_CANDIDATE'"
        echo ""
        #--------
        exit 1
    fi
    #------------------------------
    # If the "$?" were evaluated in this function,
    # then it would be "0" even, if it is
    # something else at the calling code.
    if [ "$S_ERR_CODE" != "0" ];then
        echo ""
        echo "Something went wrong. Error code: $S_ERR_CODE"
        echo -e "\e[31mAborting script. \e[39m"
        echo "GUID=='73873256-554a-424c-a466-03622141a9e7'"
        echo "S_GUID_CANDIDATE=='$S_GUID_CANDIDATE'"
        echo ""
        #--------
        exit 1
    fi
    #------------------------------
} # func_mmmv_assert_error_code_zero_t2

#--------------------------------------------------------------------------

func_mmmv_assert_error_code_zero_t3(){
    local S_ERR_CODE="$1" # the "$?"
    local S_GUID_CANDIDATE="$2"
    #----------------------------------------------------------------------
    func_mmmv_assert_error_code_zero_t1 "$S_ERR_CODE" "$S_GUID_CANDIDATE"
    func_mmmv_wait_and_sync_t1
    #------------------------------
} # func_mmmv_assert_error_code_zero_t3

func_mmmv_assert_error_code_zero_t4(){
    local S_ERR_CODE="$1" # the "$?"
    local S_GUID_CANDIDATE="$2"
    #----------------------------------------------------------------------
    func_mmmv_assert_error_code_zero_t2 "$S_ERR_CODE" "$S_GUID_CANDIDATE"
    func_mmmv_wait_and_sync_t1
    #------------------------------
} # func_mmmv_assert_error_code_zero_t4

#--------------------------------------------------------------------------

func_mmmv_exc_verify_S_FP_ORIG_t1() {
    if [ "$S_FP_ORIG" == "" ]; then
        echo ""
        echo -e "\e[31mThe code of this script is flawed. \e[39m"
        echo "The environment variable S_FP_ORIG is expected "
        echo "to be initialized at the start of the script by "
        echo ""
        echo "    S_FP_ORIG=\"\`pwd\`\""
        echo ""
        echo "Aborting script."
        echo "GUID=='2df2f2e5-5c81-4a44-a266-03622141a9e7'"
        echo ""
        exit 1 # exit with an error
    fi
    #------------------------
    local SB_IS_SYMLINK="f"      # possible values: "t", "f"
    if [ -h "$S_FP_ORIG" ]; then # Returns "false" for paths that
                                 # do not refer to anything.
        SB_IS_SYMLINK="t"
    fi
    #--------
    if [ ! -e "$S_FP_ORIG" ]; then
        if [ "$SB_IS_SYMLINK" == "t" ]; then
            echo "The "
        else
            echo "The file or folder "
        fi
        echo ""
        echo "    S_FP_ORIG==$S_FP_ORIG "
        echo ""
        if [ "$SB_IS_SYMLINK" == "t" ]; then
            echo -e "is a\e[31m broken symlink\e[39m. It is expected to be a folder that "
        else
            echo -e "\e[31mdoes not exist\e[39m. It is expected to be a folder that "
        fi
        echo "contains the script that prints this error message."
        echo -e "\e[31mAborting script. \e[39m"
        echo "GUID=='98dbe739-424e-4e61-9166-03622141a9e7'"
        echo ""
        exit 1 # exit with an error
    fi
    #------------------------
    if [ ! -d "$S_FP_ORIG" ]; then
        echo "The "
        echo ""
        echo "    S_FP_ORIG==$S_FP_ORIG "
        echo ""
        echo -e "is\e[31m not a folder\e[39m. It is expected to be a folder that "
        echo "contains the script that prints this error message."
        echo -e "\e[31mAborting script. \e[39m"
        echo "GUID=='f9ffdc43-95d2-4f2d-a366-03622141a9e7'"
        echo ""
        exit 1 # exit with an error
    fi
} # func_mmmv_exc_verify_S_FP_ORIG_t1

#--------------------------------------------------------------------------

FUNC_MMMV_EXC_VERIFY_S_FP_ORIG_T2_S_FB_ORIG_ALREADY_VERIFIED="f"
func_mmmv_exc_verify_S_FP_ORIG_t2(){
    if [ "$FUNC_MMMV_EXC_VERIFY_S_FP_ORIG_T2_S_FB_ORIG_ALREADY_VERIFIED" != "t" ]; then
        if [ "$FUNC_MMMV_EXC_VERIFY_S_FP_ORIG_T2_S_FB_ORIG_ALREADY_VERIFIED" != "f" ]; then
            echo ""
            echo -e "\e[31mThe code that calls this function is flawed. \e[39m"
            echo "The global variable "
            echo ""
            echo "    FUNC_MMMV_EXC_VERIFY_S_FP_ORIG_T2_S_FB_ORIG_ALREADY_VERIFIED==\"$FUNC_MMMV_EXC_VERIFY_S_FP_ORIG_T2_S_FB_ORIG_ALREADY_VERIFIED\""
            echo ""
            echo "has a domain of {\"f\", \"t\"}."
            echo "GUID=='fd0fb543-9007-45aa-a166-03622141a9e7'"
            echo ""
        else
            func_mmmv_exc_verify_S_FP_ORIG_t1
            FUNC_MMMV_EXC_VERIFY_S_FP_ORIG_T2_S_FB_ORIG_ALREADY_VERIFIED="t"
        fi
    fi
} # func_mmmv_exc_verify_S_FP_ORIG_t2

#--------------------------------------------------------------------------

func_mmmv_cd_S_FP_ORIG_and_exit_t1(){
    func_mmmv_exc_verify_S_FP_ORIG_t1
    cd "$S_FP_ORIG"
    func_mmmv_assert_error_code_zero_t2 "$?" \
        "93f28c26-5515-46a0-9596-03622141a9e7"
    exit 0
} # func_mmmv_cd_S_FP_ORIG_and_exit_t1

#--------------------------------------------------------------------------

func_mmmv_assert_nonempty_string_t1(){
    local S_IN="$1"
    local S_VARIABLE_NAME_IN_CALLING_CODE="$2"
    local S_GUID_CANDIDATE="$3"
    #----------------------------------------------------------------------
    func_mmmv_exc_verify_S_FP_ORIG_t2
    if [ "$S_GUID_CANDIDATE" == "" ]; then
        echo ""
        echo -e "\e[31mThe code that calls this function is flawed.\e[39m The"
        echo ""
        echo "    S_GUID_CANDIDATE==\"\""
        echo ""
        echo "but it is expected to be a GUID."
        echo "GUID=='e1a8ba2f-2eed-4b50-b266-03622141a9e7'"
        echo ""
        #--------
        cd "$S_FP_ORIG"
        exit 1 # exiting with an error
    fi
    #----------------------------------------------------------------------
    if [ "$S_VARIABLE_NAME_IN_CALLING_CODE" == "" ]; then
        echo ""
        echo -e "\e[31mThe code that calls this function is flawed.\e[39m The"
        echo ""
        echo "    S_VARIABLE_NAME_IN_CALLING_CODE==\"\""
        echo ""
        echo "GUID=='4126f8f1-6cad-44a8-a156-03622141a9e7'"
        echo "S_GUID_CANDIDATE=='$S_GUID_CANDIDATE'"
        echo ""
        #--------
        cd "$S_FP_ORIG"
        exit 1 # exiting with an error
    fi
    #----------------------------------------------------------------------
    if [ "$S_IN" == "" ]; then
        echo ""
        echo -e "\e[31mThere is a flaw somewhere in the code\e[39m that"
        echo "uses a variable named \"$S_VARIABLE_NAME_IN_CALLING_CODE\"."
        echo ""
        echo "    $S_VARIABLE_NAME_IN_CALLING_CODE==\"$S_IN\""
        echo ""
        echo "but it is expected to be something other than an empty string."
        echo "GUID=='6309ed13-aa27-43c9-8556-03622141a9e7'"
        echo "S_GUID_CANDIDATE=='$S_GUID_CANDIDATE'"
        echo ""
        #--------
        cd "$S_FP_ORIG"
        exit 1 # exiting with an error
    fi
    #----------------------------------------------------------------------
} # func_mmmv_assert_nonempty_string_t1

#--------------------------------------------------------------------------

func_mmmv_assert_sbvar_domain_t_f_t1(){
    local SB_VARIABLE_VALUE="$1"
    local S_VARIABLE_NAME_IN_CALLING_CODE="$2"
    local S_GUID_CANDIDATE="$3"
    #----------------------------------------------------------------------
    func_mmmv_exc_verify_S_FP_ORIG_t2
    if [ "$S_GUID_CANDIDATE" == "" ]; then
        echo ""
        echo -e "\e[31mThe code that calls this function is flawed.\e[39m The"
        echo ""
        echo "    S_GUID_CANDIDATE==\"\""
        echo ""
        echo "but it is expected to be a GUID."
        echo "GUID=='455be02a-300e-4bc8-a556-03622141a9e7'"
        echo ""
        #--------
        cd "$S_FP_ORIG"
        exit 1 # exiting with an error
    fi
    #----------------------------------------------------------------------
    if [ "$S_VARIABLE_NAME_IN_CALLING_CODE" == "" ]; then
        echo ""
        echo -e "\e[31mThe code that calls this function is flawed.\e[39m The"
        echo ""
        echo "    S_VARIABLE_NAME_IN_CALLING_CODE==\"\""
        echo ""
        echo "GUID=='0c5dfe3f-ece3-482e-9156-03622141a9e7'"
        echo "S_GUID_CANDIDATE=='$S_GUID_CANDIDATE'"
        echo ""
        #--------
        cd "$S_FP_ORIG"
        exit 1 # exiting with an error
    fi
    #----------------------------------------------------------------------
    if [ "$SB_VARIABLE_VALUE" != "t" ]; then
        if [ "$SB_VARIABLE_VALUE" != "f" ]; then
            echo ""
            echo -e "\e[31mThere is a flaw somewhere in the code\e[39m that"
            echo "uses a variable named \"$S_VARIABLE_NAME_IN_CALLING_CODE\". The "
            echo ""
            echo "    $S_VARIABLE_NAME_IN_CALLING_CODE==\"$SB_VARIABLE_VALUE\""
            echo ""
            echo "but it is expected to be either \"t\" or \"f\"."
            echo "GUID=='530c7e04-f657-41e1-b356-03622141a9e7'"
            echo "GUID_CANDIDATE=='$S_GUID_CANDIDATE'"
            echo ""
            #--------
            cd "$S_FP_ORIG"
            exit 1 # exiting with an error
        fi
    fi
    #----------------------------------------------------------------------
} # func_mmmv_assert_sbvar_domain_t_f_t1

#--------------------------------------------------------------------------

func_mmmv_assert_file_exists_t1() {
    local S_FP="$1"
    local S_GUID_CANDIDATE="$2"
    local SB_OPTIONAL_BAN_SYMLINKS="$3" # domain: {"t", "f", ""} default: "f"
                                        # is the last formal parameter
                                        # in stead of the S_GUID_CANDIDATE,
                                        # because that way this function is
                                        # backwards compatible with
                                        # an earlier version of this
                                        # function.
    #----------------------------------------------------------------------
    func_mmmv_exc_verify_S_FP_ORIG_t2
    local SB_LACK_OF_PARAMETERS="f"
    if [ "$S_FP" == "" ]; then
        SB_LACK_OF_PARAMETERS="t"
    fi
    if [ "$S_GUID_CANDIDATE" == "" ]; then
        SB_LACK_OF_PARAMETERS="t"
    fi
    if [ "$SB_LACK_OF_PARAMETERS" == "t" ]; then
        echo ""
        echo -e "\e[31mThe code that calls this function is flawed. \e[39m"
        echo "This function requires 2 parameters, which are "
        echo "S_FP, S_GUID_CANDIDATE, and it has an optional 3. parameter, "
        echo "which is SB_OPTIONAL_BAN_SYMLINKS."
        if [ "$S_GUID_CANDIDATE" != "" ]; then
            echo "S_GUID_CANDIDATE=='$S_GUID_CANDIDATE'"
        fi
        echo "GUID=='89496b39-5046-4deb-9456-03622141a9e7'"
        echo ""
        #--------
        cd "$S_FP_ORIG"
        exit 1 # exiting with an error
    else
        if [ "$SB_LACK_OF_PARAMETERS" != "f" ]; then
            echo -e "\e[31mThis code is flawed. \e[39m"
            echo "GUID=='af25cc2e-57ae-4980-a156-03622141a9e7'"
            #--------
            cd "$S_FP_ORIG"
            exit 1 # exiting with an error
        fi
    fi
    #------------------------------
    if [ "$SB_OPTIONAL_BAN_SYMLINKS" == "" ]; then
        # The default value of the
        SB_OPTIONAL_BAN_SYMLINKS="f"
        # must be backwards compatible with the
        # version of this function, where
        # symlinks to files were treated as actual files.
    else
        if [ "$SB_OPTIONAL_BAN_SYMLINKS" != "t" ]; then
            if [ "$SB_OPTIONAL_BAN_SYMLINKS" != "f" ]; then
                echo ""
                echo "The "
                echo ""
                echo "    SB_OPTIONAL_BAN_SYMLINKS==\"$SB_OPTIONAL_BAN_SYMLINKS\""
                echo ""
                echo "but the valid values for the SB_OPTIONAL_BAN_SYMLINKS"
                echo "are: \"t\", \"f\", \"\"."
                echo "S_GUID_CANDIDATE=='$S_GUID_CANDIDATE'"
                echo "GUID=='8f27262c-3e24-4f8a-b556-03622141a9e7'"
                echo ""
                #--------
                cd "$S_FP_ORIG"
                exit 1 # exiting with an error
            fi
        fi
    fi
    #------------------------------
    if [ ! -e "$S_FP" ]; then
        if [ -h "$S_FP" ]; then
            echo ""
            echo "The path "
            echo ""
            echo "    $S_FP "
            echo ""
            echo -e "points to a\e[31m broken symlink\e[39m, but "
            if [ "$SB_OPTIONAL_BAN_SYMLINKS" == "t" ]; then
                echo "a file is expected."
            else
                echo "a file or a symlink to a file is expected."
            fi
            echo "S_GUID_CANDIDATE==\"$S_GUID_CANDIDATE\""
            echo "GUID=='2eb2bbc4-e40d-4be4-8e56-03622141a9e7'"
            echo ""
            #--------
            cd "$S_FP_ORIG"
            exit 1 # exiting with an error
        else
            echo ""
            if [ "$SB_OPTIONAL_BAN_SYMLINKS" == "t" ]; then
                echo "The file "
            else
                echo "The file or a symlink to a file "
            fi
            echo ""
            echo "    $S_FP "
            echo ""
            echo -e "\e[31mdoes not exist\e[39m."
            echo "S_GUID_CANDIDATE==\"$S_GUID_CANDIDATE\""
            echo "GUID=='270ab333-13db-45ae-8b46-03622141a9e7'"
            echo ""
            #--------
            cd "$S_FP_ORIG"
            exit 1 # exiting with an error
        fi
    else
        if [ -d "$S_FP" ]; then
            echo ""
            if [ -h "$S_FP" ]; then
                echo "The symlink to an existing folder "
            else
                echo "The folder "
            fi
            echo ""
            echo "    $S_FP "
            echo ""
            printf "exists, but "
            if [ "$SB_OPTIONAL_BAN_SYMLINKS" == "t" ]; then
                echo -e "a\e[31m file is expected\e[39m."
            else
                echo -e "a\e[31m file or a symlink to a file is expected\e[39m."
            fi
            echo "S_GUID_CANDIDATE==\"$S_GUID_CANDIDATE\""
            echo "GUID=='8ac1f334-bad6-47e7-9546-03622141a9e7'"
            echo ""
            #--------
            cd "$S_FP_ORIG"
            exit 1 # exiting with an error
        else
            if [ "$SB_OPTIONAL_BAN_SYMLINKS" == "t" ]; then
                if [ -h "$S_FP" ]; then
                    echo ""
                    echo "The "
                    echo ""
                    echo "    $S_FP"
                    echo ""
                    echo -e "is a symlink to a file, but a\e[31m file is expected\e[39m."
                    echo "S_GUID_CANDIDATE==\"$S_GUID_CANDIDATE\""
                    echo "GUID=='beddf105-983e-4025-8346-03622141a9e7'"
                    echo ""
                    #--------
                    cd "$S_FP_ORIG"
                    exit 1 # exiting with an error
                fi
            fi
        fi
    fi
} # func_mmmv_assert_file_exists_t1

#--------------------------------------------------------------------------

func_mmmv_assert_folder_exists_t1() {
    local S_FP="$1"
    local S_GUID_CANDIDATE="$2"
    local SB_OPTIONAL_BAN_SYMLINKS="$3" # domain: {"t", "f", ""} default: "f"
                                        # is the last formal parameter
                                        # in stead of the S_GUID_CANDIDATE,
                                        # because that way this function is
                                        # backwards compatible with
                                        # an earlier version of this
                                        # function.
    #----------------------------------------------------------------------
    func_mmmv_exc_verify_S_FP_ORIG_t2
    local SB_LACK_OF_PARAMETERS="f"
    if [ "$S_FP" == "" ]; then
        SB_LACK_OF_PARAMETERS="t"
    fi
    if [ "$S_GUID_CANDIDATE" == "" ]; then
        SB_LACK_OF_PARAMETERS="t"
    fi
    if [ "$SB_LACK_OF_PARAMETERS" == "t" ]; then
        echo ""
        echo -e "\e[31mThe code that calls this function is flawed. \e[39m"
        echo "This function requires 2 parameters, which are "
        echo "S_FP, S_GUID_CANDIDATE, and it has an optional 3. parameter, "
        echo "which is SB_OPTIONAL_BAN_SYMLINKS."
        if [ "$S_GUID_CANDIDATE" != "" ]; then
            echo "S_GUID_CANDIDATE=='$S_GUID_CANDIDATE'"
        fi
        echo "GUID=='0b55f032-a007-4692-b546-03622141a9e7'"
        echo ""
        #--------
        cd "$S_FP_ORIG"
        exit 1 # exiting with an error
    else
        if [ "$SB_LACK_OF_PARAMETERS" != "f" ]; then
            echo -e "\e[31mThis code is flawed. \e[39m"
            echo "GUID=='6da6ff27-5cd0-41f0-a446-03622141a9e7'"
            #--------
            cd "$S_FP_ORIG"
            exit 1 # exiting with an error
        fi
    fi
    #------------------------------
    if [ "$SB_OPTIONAL_BAN_SYMLINKS" == "" ]; then
        # The default value of the
        SB_OPTIONAL_BAN_SYMLINKS="f"
        # must be backwards compatible with the
        # version of this function, where
        # symlinks to folders were treated as actual folders.
    else
        if [ "$SB_OPTIONAL_BAN_SYMLINKS" != "t" ]; then
            if [ "$SB_OPTIONAL_BAN_SYMLINKS" != "f" ]; then
                echo ""
                echo "The "
                echo ""
                echo "    SB_OPTIONAL_BAN_SYMLINKS==\"$SB_OPTIONAL_BAN_SYMLINKS\""
                echo ""
                echo "but the valid values for the SB_OPTIONAL_BAN_SYMLINKS"
                echo "are: \"t\", \"f\", \"\"."
                echo "S_GUID_CANDIDATE=='$S_GUID_CANDIDATE'"
                echo "GUID=='07378ddc-17ec-4528-a646-03622141a9e7'"
                echo ""
                #--------
                cd "$S_FP_ORIG"
                exit 1 # exiting with an error
            fi
        fi
    fi
    #------------------------------
    if [ ! -e "$S_FP" ]; then
        if [ -h "$S_FP" ]; then
            echo ""
            echo "The path "
            echo ""
            echo "    $S_FP "
            echo ""
            echo -e "points to a\e[31m broken symlink\e[39m, but "
            if [ "$SB_OPTIONAL_BAN_SYMLINKS" == "t" ]; then
                echo -e "a\e[31m folder is expected\e[39m."
            else
                echo -e "a\e[31m folder or a symlink to a folder is expected\e[39m."
            fi
            echo "S_GUID_CANDIDATE==\"$S_GUID_CANDIDATE\""
            echo "GUID=='0e3d9c48-4ad3-4032-b246-03622141a9e7'"
            echo ""
            #--------
            cd "$S_FP_ORIG"
            exit 1 # exiting with an error
        else
            echo ""
            if [ "$SB_OPTIONAL_BAN_SYMLINKS" == "t" ]; then
                echo "The folder "
            else
                echo "The folder or a symlink to a folder "
            fi
            echo ""
            echo "    $S_FP "
            echo ""
            echo -e "\e[31mdoes not exist\e[39m."
            echo "S_GUID_CANDIDATE==\"$S_GUID_CANDIDATE\""
            echo "GUID=='2f3acb1e-3403-4770-9246-03622141a9e7'"
            echo ""
            #--------
            cd "$S_FP_ORIG"
            exit 1 # exiting with an error
        fi
    else
        if [ ! -d "$S_FP" ]; then
            echo ""
            if [ -h "$S_FP" ]; then
                echo "The symlink to an existing file "
            else
                echo "The file "
            fi
            echo ""
            echo "    $S_FP "
            echo ""
            printf "exists, but "
            if [ "$SB_OPTIONAL_BAN_SYMLINKS" == "t" ]; then
                echo -e "a\e[31m folder is expected\e[39m."
            else
                echo -e "a\e[31m folder or a symlink to a folder is expected\e[39m."
            fi
            echo "S_GUID_CANDIDATE==\"$S_GUID_CANDIDATE\""
            echo "GUID=='46ba9333-0753-49e3-9346-03622141a9e7'"
            echo ""
            #--------
            cd "$S_FP_ORIG"
            exit 1 # exiting with an error
        else
            if [ "$SB_OPTIONAL_BAN_SYMLINKS" == "t" ]; then
                if [ -h "$S_FP" ]; then
                    echo ""
                    echo "The "
                    echo ""
                    echo "    $S_FP"
                    echo ""
                    echo -e "is a symlink to a folder, but a\e[31m folder is expected\e[39m."
                    echo "S_GUID_CANDIDATE==\"$S_GUID_CANDIDATE\""
                    echo "GUID=='7c85d839-5c12-4a3d-a346-03622141a9e7'"
                    echo ""
                    #--------
                    cd "$S_FP_ORIG"
                    exit 1 # exiting with an error
                fi
            fi
        fi
    fi
} # func_mmmv_assert_folder_exists_t1

#--------------------------------------------------------------------------

func_mmmv_exit_if_not_on_path_t2() { # S_COMMAND_NAME
    local S_COMMAND_NAME="$1"
    #----------------------------------------------------------------------
    func_mmmv_exc_verify_S_FP_ORIG_t2
    local S_LOCAL_VARIABLE="`which $S_COMMAND_NAME 2> /dev/null`"
    if [ "$S_LOCAL_VARIABLE" == "" ]; then
        echo ""
        echo -e "\e[31mCommand \"$S_COMMAND_NAME\" could not be found from the PATH. \e[39m"
        echo "The execution of this Bash script is aborted."
        echo "GUID=='a3dce28f-eede-4adf-8236-03622141a9e7'"
        echo ""
        cd "$S_FP_ORIG"
        exit 1;
    fi
} # func_mmmv_exit_if_not_on_path_t2

#--------------------------------------------------------------------------

func_mmmv_exit_t1(){
    local S_GUID_CANDIDATE="$1" # first function argument
    #----------------------------------------------------------------------
    echo ""
    echo -e "\e[32m\e[7m#======================================================="
    echo -e "\e[0m\e[32mIf You want to run this Bash script, the "
    echo "#--------------"
    echo "$S_FP_DIR/$S_FN_SCRIPTFILE_NAME"
    echo "#--------------"
    echo "then please edit it by outcommenting the line with the "
    echo "\"$S_GUID_CANDIDATE\"."
    echo "Thank You."
    echo -e "\e[32m\e[7m#======================================================="
    echo -e "\e[0m" # resets the text terminal style
    cd "$S_FP_ORIG"
    exit 1
} # func_mmmv_exit_t1

#--------------------------------------------------------------------------

func_mmmv_exc_exit_with_an_error_t1(){
    local S_GUID_CANDIDATE="$1" # first function argument
    #----------------------------------------------------------------------
    func_mmmv_exc_verify_S_FP_ORIG_t1
    echo ""
    echo -e "\e[31mThe code of this script is flawed. \e[39m"
    echo "Aborting script."
    if [ "$S_GUID_CANDIDATE" != "" ]; then
        echo "GUID_CANDIDATE=='$S_GUID_CANDIDATE'"
    fi
    echo "GUID=='544de636-fccd-40e3-8136-03622141a9e7'"
    echo ""
    cd "$S_FP_ORIG"
    exit 1 # exit with an error
} # func_mmmv_exc_exit_with_an_error_t1

#--------------------------------------------------------------------------

func_mmmv_exc_exit_with_an_error_t2(){
    local S_GUID_CANDIDATE="$1"   # first function argument
    local S_OPTIONAL_ERR_MSG="$2" # second function argument
    #----------------------------------------------------------------------
    func_mmmv_exc_verify_S_FP_ORIG_t1
    if [ "$S_GUID_CANDIDATE" == "" ]; then
        echo ""
        echo -e "\e[31mThe code of this script is flawed. \e[39m"
        if [ "$S_OPTIONAL_ERR_MSG" != "" ]; then
            echo -e "$S_OPTIONAL_ERR_MSG"
        fi
        echo "Aborting script."
        echo "GUID=='30e07532-afe7-451c-a436-03622141a9e7'"
        echo ""
        cd "$S_FP_ORIG"
        exit 1 # exit with an error
    else
        echo ""
        echo -e "\e[31mSomething went wrong. \e[39m"
        if [ "$S_OPTIONAL_ERR_MSG" != "" ]; then
            echo "$S_OPTIONAL_ERR_MSG"
        fi
        echo "Aborting script."
        echo "GUID_CANDIDATE=='$S_GUID_CANDIDATE'"
        echo "GUID=='5b4f5212-725d-43b4-9536-03622141a9e7'"
        echo ""
        cd "$S_FP_ORIG"
        exit 1 # exit with an error
    fi
} # func_mmmv_exc_exit_with_an_error_t2

#--------------------------------------------------------------------------

S_AWK_CMD="exit 1;"
func_mmmv_exc_determine_Awk_command_t1() { # prefers the GNU Awk to the BSD Awk
    local SB_AVOID_REINITIALISATION_IF_ALREADY_INITIALIZED="$1" # domain: {"","t","f"}
                                                                # default: "t"
                                                                # "" -> "t"
    #----------------------------------------------------------------------
    local SB_AVOID_REINIT="t" # the default
    if [ "$SB_AVOID_REINITIALISATION_IF_ALREADY_INITIALIZED" != "" ]; then
        func_mmmv_assert_sbvar_domain_t_f_t1 \
            "$SB_AVOID_REINITIALISATION_IF_ALREADY_INITIALIZED" \
            "SB_AVOID_REINITIALISATION_IF_ALREADY_INITIALIZED" \
            "7ddc0231-809d-4cb6-9296-03622141a9e7"
        SB_AVOID_REINIT="$SB_AVOID_REINITIALISATION_IF_ALREADY_INITIALIZED"
    fi
    #----------------------------------------------------------------------
    local SB_REINIT="t"
    if [ "$SB_AVOID_REINIT" == "t" ]; then
        if [ "$S_AWK_CMD" != "exit 1;" ]; then
            SB_REINIT="f"
        fi
    fi
    #----------------------------------------------------------------------
    if [ "$SB_REINIT" == "t" ]; then
        #------------------------------------------------------------------
        func_mmmv_exc_verify_S_FP_ORIG_t2
        S_AWK_CMD="exit 1;" # for reliability
        local SB_THROW="f"
        local S_TMP_0="e8166244-9350-4838-9186-03622141a9e7"
        local S_FP_0="/tmp/this/proB9bably/do00es/noTt/eXXXist/ㄫ/$S_TMP_0"
        #------------------------------------------------------------------
        if [ "$SB_GAWK_EXISTS_ON_PATH" == "f" ]; then # empty string, "", is also in domain
            # This if-branch is a speedhack for a case, where
            # the mmmv_userspace_distro_t1 is in use.
            if [ "$SB_AWK_EXISTS_ON_PATH" == "f" ]; then # empty string, "", is also in domain
                SB_THROW="t"
            else
                S_FP_0="`which awk 2> /dev/null`"
                if [ "$S_FP_0" != "" ]; then
                    S_AWK_CMD="$S_FP_0" # assigns a full path
                else
                    SB_THROW="t"
                fi
            fi
        else
            S_FP_0="`which gawk 2> /dev/null`"
            if [ "$S_FP_0" != "" ]; then
                S_AWK_CMD="$S_FP_0" # assigns a full path
            else
                S_FP_0="`which awk 2> /dev/null`"
                if [ "$S_FP_0" != "" ]; then
                    S_AWK_CMD="$S_FP_0" # assigns a full path
                else
                    SB_THROW="t"
                fi
            fi
        fi
        #------------------------------------------------------------------
        if [ "$SB_THROW" == "t" ]; then
            echo ""
            echo -e "\e[31mNeither 'gawk', nor 'awk' was available on PATH. \e[39m"
            echo "The execution of this Bash script is aborted."
            echo "GUID=='4c3fd905-1597-4310-a236-03622141a9e7'"
            echo ""
            cd "$S_FP_ORIG"
            exit 1;
        fi
        #------------------------------------------------------------------
    fi
    #----------------------------------------------------------------------
} # func_mmmv_exc_determine_Awk_command_t1

#--------------------------------------------------------------------------

S_SED_CMD="exit 1;"
func_mmmv_exc_determine_sed_command_t1() { # prefers the GNU sed to the BSD sed
    local SB_AVOID_REINITIALISATION_IF_ALREADY_INITIALIZED="$1" # domain: {"","t","f"}
                                                              # default: "t"
                                                              # "" -> "t"
    #----------------------------------------------------------------------
    local SB_AVOID_REINIT="t" # the default
    if [ "$SB_AVOID_REINITIALISATION_IF_ALREADY_INITIALIZED" != "" ]; then
        func_mmmv_assert_sbvar_domain_t_f_t1 \
            "$SB_AVOID_REINITIALISATION_IF_ALREADY_INITIALIZED" \
            "SB_AVOID_REINITIALISATION_IF_ALREADY_INITIALIZED" \
            "3e3327ce-76b6-4703-8586-03622141a9e7"
        SB_AVOID_REINIT="$SB_AVOID_REINITIALISATION_IF_ALREADY_INITIALIZED"
    fi
    #----------------------------------------------------------------------
    local SB_REINIT="t"
    if [ "$SB_AVOID_REINIT" == "t" ]; then
        if [ "$S_AWK_CMD" != "exit 1;" ]; then
            SB_REINIT="f"
        fi
    fi
    #----------------------------------------------------------------------
    if [ "$SB_REINIT" == "t" ]; then
        #------------------------------------------------------------------
        func_mmmv_exc_verify_S_FP_ORIG_t2
        S_SED_CMD="exit 1;" # for reliability
        local SB_THROW="f"
        local S_TMP_0="e256e42b-ffe7-4ffe-8186-03622141a9e7"
        local S_FP_0="/tmp/this/proB9bably/do00es/noTt/eXXXist/ㄫ/$S_TMP_0"
        #------------------------------------------------------------------
        if [ "$SB_GSED_EXISTS_ON_PATH" == "f" ]; then # empty string, "", is also in domain
            # This if-branch is a speedhack for a case, where
            # the mmmv_userspace_distro_t1 is in use.
            if [ "$SB_SED_EXISTS_ON_PATH" == "f" ]; then # empty string, "", is also in domain
                SB_THROW="t"
            else
                S_FP_0="`which sed 2> /dev/null`"
                if [ "$S_FP_0" != "" ]; then
                    S_SED_CMD="$S_FP_0" # assigns a full path
                else
                    SB_THROW="t"
                fi
            fi
        else
            S_FP_0="`which gsed 2> /dev/null`"
            if [ "$S_FP_0" != "" ]; then
                S_SED_CMD="$S_FP_0" # assigns a full path
            else
                if [ "`which sed`" != "" ]; then
                    S_SED_CMD="sed"
                else
                    SB_THROW="t"
                fi
            fi
        fi
        #------------------------------------------------------------------
        if [ "$SB_THROW" != "f" ]; then
            echo ""
            echo -e "\e[31mNeither 'gsed', nor 'sed' was available on PATH. \e[39m"
            echo "The execution of this Bash script is aborted."
            echo "GUID=='56e79cb1-0609-47b4-b436-03622141a9e7'"
            echo ""
            cd "$S_FP_ORIG"
            exit 1;
        fi
        #------------------------------------------------------------------
    fi
} # func_mmmv_exc_determine_sed_command_t1

#--------------------------------------------------------------------------

func_mmmv_exc_is_file_t1() {
    local S_FP_CANDIDATE="$1" # folder path
    #----------------------------------------------------------------------
    if [ ! -e "$S_FP_CANDIDATE" ]; then
        echo ""
        echo "The file"
        echo ""
        echo "    $S_FP_CANDIDATE "
        echo ""
        echo -e "\e[31mdoes not exist\e[39m."
        echo "GUID=='dd203843-dee9-44c0-b436-03622141a9e7'"
        echo "Aborting without doing anything."
        echo ""
        exit 1 # exit with an error
    fi
    if [ -d "$S_FP_CANDIDATE" ]; then
        echo ""
        echo "The path"
        echo ""
        echo "    $S_FP_CANDIDATE "
        echo ""
        if [ -h "$S_FP_CANDIDATE" ]; then
            echo "references a symbolic link to a folder, "
        else
            echo "references a folder, "
        fi
        echo -e "but it is\e[31m required to reference a file\e[39m."
        echo "GUID=='20189210-69f9-4af6-b436-03622141a9e7'"
        echo "Aborting without doing anything."
        echo ""
        exit 1 # exit with an error
    fi
} # func_mmmv_exc_is_file_t1

#--------------------------------------------------------------------------

func_mmmv_exc_is_folder_t1() {
    local S_FP_CANDIDATE="$1" # folder path
    #----------------------------------------------------------------------
    if [ ! -e "$S_FP_CANDIDATE" ]; then
        echo ""
        echo "The folder"
        echo ""
        echo "    $S_FP_CANDIDATE "
        echo ""
        echo -e "\e[31mdoes not exist\e[39m."
        echo "GUID=='b1299844-f963-408b-9336-03622141a9e7'"
        echo "Aborting without doing anything."
        echo ""
        exit 1 # exit with an error
    fi
    if [ ! -d "$S_FP_CANDIDATE" ]; then
        echo ""
        echo "The path"
        echo ""
        echo "    $S_FP_CANDIDATE "
        echo ""
        if [ -h "$S_FP_CANDIDATE" ]; then
            echo "references a symbolic link to a file, "
        else
            echo "references a file, "
        fi
        echo -e "but it is\e[31m required to reference a folder\e[39m."
        echo "GUID=='33cda42a-e2e5-447f-8436-03622141a9e7'"
        echo "Aborting without doing anything."
        echo ""
        exit 1 # exit with an error
    fi
} # func_mmmv_exc_is_folder_t1

# S_FP_TMP_0="/tmp/fff_testimine"
# S_FP_TMP_FF1="$S_FP_TMP_0/ff1"
# S_FP_TMP_FILE_1="$S_FP_TMP_0/file1.txt"
# S_FP_TMP_0_SYM_FLDR_OK="$S_FP_TMP_0/sym_folder_exists"
# S_FP_TMP_0_SYM_X_MISSING="$S_FP_TMP_0/sym_x_missing"
# S_FP_TMP_0_SYM_FILE_OK="$S_FP_TMP_0/sym_file_exists"
# rm -fr $S_FP_TMP_0
# mkdir -p $S_FP_TMP_FF1
# echo "Hello World :-)" > $S_FP_TMP_FILE_1
# ln -s $S_FP_TMP_FILE_1  $S_FP_TMP_0_SYM_FILE_OK
# ln -s $S_FP_TMP_FF1  $S_FP_TMP_0_SYM_FLDR_OK
# ln -s $S_FP_TMP_FF1/this_does_not_exist $S_FP_TMP_0_SYM_X_MISSING
#
# # The following assertions must pass:
#     func_mmmv_exc_is_folder_t1 "$S_FP_TMP_FF1"
#     func_mmmv_exc_is_folder_t1 "$S_FP_TMP_0_SYM_FLDR_OK"
#     func_mmmv_exc_is_file_t1 "$S_FP_TMP_FILE_1"
#     func_mmmv_exc_is_file_t1 "$S_FP_TMP_0_SYM_FILE_OK"
#
# # The following assertions must fail:
#     #func_mmmv_exc_is_folder_t1 "$S_FP_TMP_0_SYM_X_MISSING"
#     #func_mmmv_exc_is_file_t1 "$S_FP_TMP_0_SYM_X_MISSING"
#
# rm -fr $S_FP_TMP_0
# exit 0

#--------------------------------------------------------------------------

func_mmmv_create_folder_t1(){
    local S_FP_FOLDER="$1" # first function argument
    #--------
    # The reason, why this function is used instead of the
    #     mkdir -p $S_FP_FOLDER
    # is that there is no guarantee that the
    #     mkdir -p $S_FP_FOLDER
    # succeeds and it would be a waste of
    # development time to write the file system related
    # tests from scratch every time a folder
    # needs to be created.
    #----------------------------------------------------------------------
    func_mmmv_exc_verify_S_FP_ORIG_t2
    if [ "$S_FP_FOLDER" == "" ]; then
        echo ""
        echo "The function formal parameter S_FP_FOLDER "
        echo "is expected to be a full path to a folder that "
        echo "either already exists or that has to be created."
        echo "Aborting script."
        echo "GUID=='6459b919-74cc-45ad-8436-03622141a9e7'"
        echo ""
        cd "$S_FP_ORIG"
        exit 1 # exit with an error
    fi
    #--------
    if [ -e "$S_FP_FOLDER" ]; then
        if [ ! -d "$S_FP_FOLDER" ]; then
            echo ""
            echo "The "
            echo ""
            echo "    $S_FP_FOLDER"
            echo ""
            echo "is a file or a symlink to a file, but it "
            echo "is expected to be a full path to a folder, "
            echo "a symlink to a folder or it should not "
            echo "reference anything that already exists."
            echo "Aborting script."
            echo "GUID=='a5ca0f10-41eb-44fb-9526-03622141a9e7'"
            echo ""
            cd "$S_FP_ORIG"
            exit 1 # exit with an error
        fi
    else
        mkdir -p $S_FP_FOLDER
        local S_TMP_0="$?"
        wait # just in case
        sync # for network drives and USB-sticks
        wait # just in case
        if [ "$S_TMP_0" != "0" ]; then
            func_mmmv_exc_exit_with_an_error_t2 "2f5aeea3-dfbd-4de9-9386-03622141a9e7" \
                "S_FP_FOLDER==$S_FP_FOLDER"
        fi
        if [ ! -e "$S_FP_FOLDER" ]; then
            func_mmmv_exc_exit_with_an_error_t2 "4d56b241-fd70-4865-a386-03622141a9e7" \
                "Folder creation failed. S_FP_FOLDER==$S_FP_FOLDER"
        fi
    fi
    #--------
} # func_mmmv_create_folder_t1

#--------------------------------------------------------------------------

func_mmmv_exc_assure_tmp_folder_existence_t1() {  # S_FP_TMP, S_GUID
    local S_FP_TMP="$1"
    local S_GUID="$2"
    #----------------------------------------------------------------------
    func_mmmv_exc_verify_S_FP_ORIG_t2
    if [ "$S_GUID" == "" ]; then
        echo ""
        echo -e "\e[31mThe code that calls this function is flawed. \e[39m"
        echo "This function requires 2 parameters: S_FP_TMP, S_GUID"
        echo "GUID=='8c5ce642-d30b-4289-a126-03622141a9e7'"
        echo ""
        #--------
        cd "$S_FP_ORIG"
        exit 1 # exiting with an error
    fi
    #------------------------------
    if [ ! -e "$S_FP_TMP" ]; then
        if [ -h "$S_FP_TMP" ]; then
            rm -f "$S_FP_TMP" # deletes a broken symlink
            func_mmmv_assert_error_code_zero_t1 \
                "$?" "25f97851-5519-4300-a586-03622141a9e7"
            func_mmmv_wait_and_sync_t1
            if [ -h "$S_FP_TMP" ]; then
                echo ""
                echo "The path "
                echo ""
                echo "    $S_FP_TMP"
                echo ""
                echo -e "points to a\e[31m broken symlink\e[39m, but a folder "
                echo "or a symlink to a folder is expected."
                echo "An attempt to delete the broken symlink failed."
                echo "GUID==\"$S_GUID\""
                echo "GUID=='3da90bf8-1314-4766-9326-03622141a9e7'"
                echo ""
                #--------
                cd "$S_FP_ORIG"
                exit 1 # exiting with an error
            fi
        fi
        mkdir -p "$S_FP_TMP"
        func_mmmv_assert_error_code_zero_t1 \
            "$?" "d3944a11-bf1c-4a1c-a386-03622141a9e7"
        func_mmmv_wait_and_sync_t1
        func_mmmv_assert_folder_exists_t1 "$S_FP_TMP" \
            '3f82b71c-869e-44f8-8526-03622141a9e7'
    else
        if [ ! -d "$S_FP_TMP" ]; then
            echo ""
            if [ -h "$S_FP_TMP" ]; then
                echo "The symlink to an existing file "
            else
                echo "The file "
            fi
            echo ""
            echo "    $S_FP_TMP"
            echo ""
            echo -e "exists, but a\e[31m folder or a symlink to a folder is expected\e[39m."
            echo "GUID==\"$S_GUID\""
            echo "GUID=='7adaf479-a566-498b-b526-03622141a9e7'"
            echo ""
            #--------
            cd "$S_FP_ORIG"
            exit 1 # exiting with an error
        fi
    fi
} # func_mmmv_exc_assure_tmp_folder_existence_t1

#--------------------------------------------------------------------------

func_mmmv_ln_create_hardlink_t1() { # S_FP_TARGET  S_FP_LINK
    local S_FP_TARGET="$1" # is allowed to be a broken symlink, but
                           # must NOT be a folder and must be
                           # on the same filesystem volume with the S_FP_LINK .

    local S_FP_LINK="$2"   # must not exist during the call of this function .

    local SB_THROW_ON_INVALID_DATA="$3" # Optional.
                                        # Domain: {"t","f","",<unassigned>}.
                                        # default=="t"
    #----------------------------------------------------------------------
    if [ "$SB_THROW_ON_INVALID_DATA" == "" ]; then
        SB_THROW_ON_INVALID_DATA="t"
    else
        if [ "$SB_THROW_ON_INVALID_DATA" != "t" ]; then
            if [ "$SB_THROW_ON_INVALID_DATA" != "f" ]; then
                echo ""
                echo -e "\e[31mThe code that calls this function is flawed. \e[39m"
                echo "Domain(SB_THROW_ON_INVALID_DATA) == "
                echo "    {\"t\",\"f\",\"\",<unassigned>}"
                echo ""
                echo "    SB_THROW_ON_INVALID_DATA==\"$SB_THROW_ON_INVALID_DATA\""
                echo ""
                echo "Aborting script."
                echo "GUID=='9d078d4b-0d87-47de-8526-03622141a9e7'"
                echo ""
                exit 1 # because of a code defect, not just invalid data.
            fi
        fi
    fi
    local SB_DO_NOT_CREATE_THE_HARDLINK="f" #a fallback for not throwing/exiting
    #----------------------------------------------------------------------
    # The original file and the hardlink share the same inode
    # and therefore the original file and the hardlink are
    # distinguishable from each other only by their paths. Hardlinks
    # to folders do not exist, can not be made, because that would
    # change a file system tree into a graph that has true loops,
    # not just symlink based loops. Hardlinks form a relation
    # between a file path and an inode of a file. Hardlinks to
    # symlinks are possible, because symlinks are special purpose files
    # regardless of whether the symlinks reference a folder or a file or another symlink.
    # Revision control systems (Git, Subversion, etc.)
    # can/at_least_sometimes_do break hardlinks by making physical
    # copies of the files that are referenced by hardlinks.
    #
    #     https://superuser.com/questions/12972/how-can-you-see-the-actual-hard-link-by-ls
    #     (archival copy: https://archive.is/8feTw )
    #
    #     http://www.linfo.org/hard_link.html
    #     (archival copy: https://archive.is/HXFYC )
    #
    # Inode numbers can be displayed by executing
    #
    #     ls -l --inode   # short version is: "ls -li "
    #
    # A 2019_06_30 citation of user "ninjalj" 2017_05_02 comment from
    #
    #     https://stackoverflow.com/questions/43733893/when-rm-a-file-but-hard-link-still-there-the-inode-will-be-marked-unused
    #     (archival copy: https://archive.is/5j0cv )
    #     ----citation--start----
    #     i-nodes contain a link count (visible in ls -l output).
    #     Each hard link increments that count. Unlinking
    #     (removing a link, be it the original filename->inode
    #     link, or some hard link added later, which is the only thing
    #     users can request) decrements the count.
    #     ----citation--end------
    #
    #----------------------------------------------------------------------
    if [ -e "$S_FP_LINK" ]; then
        if [ -d "$S_FP_LINK" ]; then # folder or a symlink to a folder
            if [ ! -h "$S_FP_LINK" ]; then # not a symlink, therefore a folder
                echo ""
                echo "The hardlink candidate, the "
                echo ""
                echo "    $S_FP_LINK"
                echo ""
                echo "already exists and it is a folder, not a symlink."
                echo "According to the implementation of this function "
                echo "this is a situation, where there is probably something wrong,"
                echo "because hardlinks can be made only to files and symlinks, "
                echo "regardless of whether the symlinks are broken or not."
                echo "Skipping the creation of the hardlink with the target path of "
                echo ""
                echo "    $S_FP_TARGET"
                echo ""
                echo "GUID=='4c559443-5035-4bba-9e26-03622141a9e7'"
                echo ""
                if [ "$SB_THROW_ON_INVALID_DATA" == "t" ]; then
                    exit 1
                fi
                SB_DO_NOT_CREATE_THE_HARDLINK="t"
            # else # symlink to a folder
            fi
        # else # file or a symlink to a file
        fi
        if [ "$SB_DO_NOT_CREATE_THE_HARDLINK" == "f" ]; then
            echo ""
            echo "According to the specification of this function "
            echo "the hardlink, which in the case of this function call "
            echo "has the path of "
            echo ""
            echo "    $S_FP_LINK"
            echo ""
            echo "must not exist before the call to this function."
            echo "GUID=='5d8704b5-04b3-4a07-8526-03622141a9e7'"
            echo ""
            if [ "$SB_THROW_ON_INVALID_DATA" == "t" ]; then
                exit 1
            fi
            SB_DO_NOT_CREATE_THE_HARDLINK="t"
        fi
    else # missing or a broken symlink
        if [ "$SB_DO_NOT_CREATE_THE_HARDLINK" == "f" ]; then
            if [ -h "$S_FP_LINK" ]; then # a broken symlink, therefore NOT missing
                echo ""
                echo "The hardlink candidate, the "
                echo ""
                echo "    $S_FP_LINK"
                echo ""
                echo "already exists and it is a broken symlink. According to "
                echo "the specification of this function the hardlink "
                echo "must not exist before the call to this function."
                echo "GUID=='f0feee10-c231-46ec-a226-03622141a9e7'"
                echo ""
                if [ "$SB_THROW_ON_INVALID_DATA" == "t" ]; then
                    exit 1
                fi
                SB_DO_NOT_CREATE_THE_HARDLINK="t"
            fi
        fi
    fi
    #----------------------------------------------------------------------
    if [ "$SB_DO_NOT_CREATE_THE_HARDLINK" == "f" ]; then
        if [ -e "$S_FP_TARGET" ]; then
            if [ -d "$S_FP_TARGET" ]; then # a folder or a symlink to a folder
                if [ ! -h "$S_FP_TARGET" ]; then # not a symlink, therefore a folder
                    echo ""
                    echo "The hardlink target candidate, the "
                    echo ""
                    echo "    $S_FP_TARGET"
                    echo ""
                    echo "is a folder, not a symlink to a folder. "
                    echo "Hardlinks can be made only to files and symlinks, "
                    echo "regardless of whether the symlinks are broken or not."
                    echo "Skipping the creation of the hardlink with the path of "
                    echo ""
                    echo "    $S_FP_LINK"
                    echo ""
                    echo "GUID=='44ef3b91-9c35-497c-aa26-03622141a9e7'"
                    echo ""
                    if [ "$SB_THROW_ON_INVALID_DATA" == "t" ]; then
                        exit 1
                    fi
                    SB_DO_NOT_CREATE_THE_HARDLINK="t"
                # else # symlink to a folder
                fi
            # else # file or a symlink to a file
            fi
        else # missing or a broken symlink
            if [ ! -h "$S_FP_TARGET" ]; then # not a symlink, therefore missing
                echo ""
                echo "The hardlink target candidate with the path of  "
                echo ""
                echo "    $S_FP_TARGET"
                echo ""
                echo -e "\e[31mdoes not exist\e[39m. Skipping the creation of a hardlink"
                echo "with the path of "
                echo ""
                echo "    $S_FP_LINK"
                echo ""
                echo "GUID=='129edc31-2beb-4612-b426-03622141a9e7'"
                echo ""
                if [ "$SB_THROW_ON_INVALID_DATA" == "t" ]; then
                    exit 1
                fi
                SB_DO_NOT_CREATE_THE_HARDLINK="t"
            # else # broken symlink
                   # It is possible to create hardlinks to broken symlinks.
            fi
        fi
    fi
    #----------------------------------------------------------------------
    local S_TMP_0="not_set_yet GUID=='f251808b-7753-462b-b116-03622141a9e7'"
    if [ "$SB_DO_NOT_CREATE_THE_HARDLINK" == "f" ]; then
        ln  "$S_FP_TARGET" "$S_FP_LINK"
        S_TMP_0="$?"
        if [ "$S_TMP_0" != "0" ]; then
            echo ""
            echo "The creation of a hardlink with the path of "
            echo ""
            echo "    $S_FP_LINK"
            echo ""
            echo "and the target path of "
            echo ""
            echo "    $S_FP_TARGET"
            echo ""
            echo -e "\e[31mfailed\e[39m. The ln exited with the error code of $S_TMP_0 ."
            echo "GUID=='675e044d-43e7-42a6-a216-03622141a9e7'"
            echo ""
            if [ "$SB_THROW_ON_INVALID_DATA" == "t" ]; then
                exit 1
            fi
            SB_DO_NOT_CREATE_THE_HARDLINK="t" # here to skip some tests later
        fi
        #------------------------------------------------------------------
        #func_mmmv_wait_and_sync_t1 # inlined at the next 2 lines
        wait # for background processes started by this Bash script to exit/finish
        sync # USB-sticks, etc.
        wait # for sync
        #------------------------------------------------------------------
        if [ "$SB_DO_NOT_CREATE_THE_HARDLINK" == "f" ]; then
            #--------------------------------------------------------------
            S_TMP_0="f" # "t" --- potential error condition detected
                        # "f" --- no error detected
            #--------------------------------------------------------------
            if [ -h "$S_FP_TARGET" ]; then
                # A broken symlink, including a hardlink to a broken symlink
                # gives "false" with the Bash "-e".
                if [ ! -h "$S_FP_LINK" ]; then
                    echo ""
                    echo "Problem detection branch marker "
                    echo "GUID=='545c04dd-6107-4ea1-b416-03622141a9e7'"
                    echo ""
                    S_TMP_0="t"
                else
                    if [ -e "$S_FP_TARGET" ]; then # symlink to a folder or a file
                        if [ ! -e "$S_FP_LINK" ]; then
                            echo ""
                            echo "Problem detection branch marker "
                            echo "GUID=='6e6f2f28-2209-4cc9-b216-03622141a9e7'"
                            echo ""
                            S_TMP_0="t"
                        else
                            if [ -d "$S_FP_TARGET" ]; then
                                if [ ! -d "$S_FP_LINK" ]; then
                                    echo ""
                                    echo "Problem detection branch marker "
                                    echo "GUID=='170ab8e5-eb56-4058-9816-03622141a9e7'"
                                    echo ""
                                    S_TMP_0="t"
                                fi
                            else
                                if [ -d "$S_FP_LINK" ]; then
                                    echo ""
                                    echo "Problem detection branch marker "
                                    echo "GUID=='faddca6f-7301-4193-a316-03622141a9e7'"
                                    echo ""
                                    S_TMP_0="t"
                                fi
                            fi
                        fi
                    else # broken symlink
                        if [ -e "$S_FP_LINK" ]; then
                            echo ""
                            echo "Problem detection branch marker "
                            echo "GUID=='22b6f605-1262-4cd5-8816-03622141a9e7'"
                            echo ""
                            S_TMP_0="t"
                        fi
                    fi
                fi
            else # As the S_FP_LINK can never be a hardlink to a folder and
                 # the S_FP_TARGET is not a symlink at this branch, the
                 # S_FP_TARGET is a file. Therefore at this branch
                 # the S_FP_LINK is also a file.
                if [ ! -e "$S_FP_TARGET" ]; then # just an extra test
                    echo ""
                    echo "Problem detection branch marker "
                    echo "GUID=='5295ba16-18f5-4503-b516-03622141a9e7'"
                    echo ""
                    S_TMP_0="t"
                else
                    if [ -d "$S_FP_TARGET" ]; then # just an extra test
                        echo ""
                        echo "Problem detection branch marker "
                        echo "GUID=='55f7af23-a824-4b85-8616-03622141a9e7'"
                        echo ""
                        S_TMP_0="t"
                    else
                        if [ -h "$S_FP_LINK" ]; then
                            echo ""
                            echo "Problem detection branch marker "
                            echo "GUID=='5b5cb74c-1f63-4618-b316-03622141a9e7'"
                            echo ""
                            S_TMP_0="t"
                        else
                            if [ ! -e "$S_FP_LINK" ]; then
                                echo ""
                                echo "Problem detection branch marker "
                                echo "GUID=='9a6e4653-2b16-4f37-8306-03622141a9e7'"
                                echo ""
                                S_TMP_0="t"
                            else
                                if [ -d "$S_FP_LINK" ]; then
                                    echo ""
                                    echo "Problem detection branch marker "
                                    echo "GUID=='baafba23-2727-45f5-a506-03622141a9e7'"
                                    echo ""
                                    S_TMP_0="t"
                                fi
                            fi
                        fi
                    fi
                fi
            fi
            #--------------------------------------------------------------
            if [ "$S_TMP_0" == "t" ]; then
                echo ""
                echo "The creation of a hardlink with the path of "
                echo ""
                echo "    $S_FP_LINK "
                echo ""
                echo "and the target path of "
                echo ""
                echo "    $S_FP_TARGET"
                echo ""
                echo "might have succeeded, but did not go as expected."
                echo "The ln command succeeded, but there might have been "
                echo "some other operating system processes that altered some "
                echo "related files or folders or symlinks on disk before "
                echo "this Bash function could exit. One possible debugging "
                echo "idea is that it is possible to chain symlinks "
                echo "together by making a symlink to symlink that references "
                echo "a symlink that references "
                echo "a symlink that references "
                echo "a symlink that references "
                echo "a symlink that references ..."
                echo "and the operating system processes might have "
                echo "altered any of the symlinks in the chain, including "
                echo "the file or folder at the very end of the symlink chain."
                echo "GUID=='47b4e24f-a73b-4c24-9306-03622141a9e7'"
                echo ""
                if [ "$SB_THROW_ON_INVALID_DATA" == "t" ]; then
                    exit 1
                fi
            else
                if [ "$S_TMP_0" != "f" ]; then
                    echo ""
                    echo -e "\e[31mThe implementation of this function is flawed. \e[39m"
                    echo "Aborting script."
                    echo "GUID=='b1150d7b-bde5-4788-9706-03622141a9e7'"
                    echo ""
                    exit 1
                fi
            fi
            #--------------------------------------------------------------
        fi
        #------------------------------------------------------------------
    else
        if [ "$SB_DO_NOT_CREATE_THE_HARDLINK" != "t" ]; then
            echo ""
            echo -e "\e[31mThe implementation of this function is flawed. \e[39m"
            echo "Aborting script."
            echo "GUID=='e0ff2511-8afc-4c40-9306-03622141a9e7'"
            echo ""
            exit 1
        fi
    fi
} # func_mmmv_ln_create_hardlink_t1

#--------------------------------------------------------------------------

func_mmmv_assert_environment_variable_set_t1() {
    local S_ENVIRONMENT_VARIABLE_NAME="$1"
    local S_GUID_CANDIDATE="$2"
    local S_OPTIONAL_ERR_MSG="$3" # will be appended to failure-message
    #----------------------------------------------------------------------
    local S_ENVIR_VALUE=""
    local S_SCRIPT_0="S_ENVIR_VALUE=\"\`echo \\\"\$$S_ENVIRONMENT_VARIABLE_NAME\\\" \`\""
    eval "$S_SCRIPT_0"
    if [ "$S_ENVIR_VALUE" == "" ]; then
        echo ""
        echo "The environment variable $S_ENVIRONMENT_VARIABLE_NAME is "
        echo -e "\e[31meither not set or it has the value of an empty string\e[39m."
        if [ "$S_OPTIONAL_ERR_MSG" != "" ]; then
            printf "%b" "$S_OPTIONAL_ERR_MSG"
        fi
        if [ "$S_GUID_CANDIDATE" != "" ]; then
            echo "S_GUID_CANDIDATE=='$S_GUID_CANDIDATE'"
        fi
        echo "GUID=='35a087b2-b745-4054-8306-03622141a9e7'"
        echo ""
        exit 1 # exit with an error
    #else
         # echo "S_ENVIR_VALUE==\"$S_ENVIR_VALUE\""
    fi
} # func_mmmv_assert_environment_variable_set_t1

#--------------------------------------------------------------------------

func_mmmv_ar_ls_t1() { # S_ARRAY_VARIABLE_NAME S_FP_LS
    local S_ARRAY_VARIABLE_NAME="$1"
    local S_FP_LS="$2"
    #----------------------------------------------------------------------
    # The "ls -m " works on both, BSD and Linux.
    local AR_0=$( ls -m $S_FP_LS )
    #--------
    local S_SCRIPT_0="$S_ARRAY_VARIABLE_NAME=()"
    eval "$S_SCRIPT_0"
    local S_ITER=""
    S_SCRIPT_0="$S_ARRAY_VARIABLE_NAME+=(\$S_ITER)"
    local S_TMP_IFS="$IFS"
    # The IFS is an internal Bash variable, "Internal Field Separator".
    IFS="," # That should handle file names that contain spaces.
    for ((i = 0; i < ${#AR_0[@]}; i++)) do
        S_ITER="${AR_0[$i]}"
        eval "$S_SCRIPT_0"
    done
    IFS="$S_TMP_IFS"
    if [ -z "$IFS" ]; then  # The "-z" returns true, if the string length is zero.
        unset IFS
    fi
} # func_mmmv_ar_ls_t1

# Test/demo code:
#    func_mmmv_ar_ls_t1 "AR_X" "$HOME"
#
#    AR_2=${AR_X[@]}  # flawed array assignment that tokenizes by space
#    S_TMP=${#AR_X[@]}
#    echo "AR_X length: $S_TMP"
#    echo ""
#    for s_iter in ${AR_X[@]}; do
#         echo "AR_X element:[$s_iter]"
#    done
#
#--------------------------------------------------------------------------

func_mmmv_exec_with_every_ar_element_t1() { # S_CMD_PART_0  S_ARRAY_VARIABLE_NAME_OF_AR_S_CMD_PART_1 S_CMD_PART_2
    local S_CMD_PART_0="$1"
    local S_ARRAY_VARIABLE_NAME_OF_AR_S_CMD_PART_1="$2"
    local S_CMD_PART_2="$3"
    #----------------------------------------------------------------------
    local S_SCRIPT_0=""
    local S_SCRIPT_1=""
    local S_SCRIPT_2=""
    local S_SCRIPT_x0=""
    local S_SCRIPT_x1=""
    local S_SCRIPT_x2=""
    #----------------
    # Wastefully left uncommented to detect flaws and to make life more comfortable :-)
    local S_TMP=""
    S_SCRIPT_0="S_TMP=\${#"
    S_SCRIPT_1="$S_ARRAY_VARIABLE_NAME_OF_AR_S_CMD_PART_1"
    S_SCRIPT_2="[@]}"
    eval "$S_SCRIPT_0$S_SCRIPT_1$S_SCRIPT_2"
    #echo "The length of the $S_ARRAY_VARIABLE_NAME_OF_AR_S_CMD_PART_1 is: $S_TMP"
    #----------------
    # The newline trick
    local S_NEWLINE=$'\n'
    # originates from the answer of Gordon Davisson:
    # https://stackoverflow.com/questions/17821277/how-to-separate-multiple-commands-passed-to-eval-in-bash
    # archival copy: https://archive.fo/7XI3a
    #--------
    local S_ITER=""
    S_SCRIPT_0="for S_ITER in \${$S_ARRAY_VARIABLE_NAME_OF_AR_S_CMD_PART_1[@]}; do "
    S_SCRIPT_x0="echo \"\"; echo \"\$S_ITER\""
    #S_SCRIPT_1="echo \"\$S_ITER\" "
    S_SCRIPT_1="$S_CMD_PART_0 \$S_ITER  $S_CMD_PART_2 ;"
    S_SCRIPT_x1="echo \"\""
    S_SCRIPT_2="done"
    S_SCRIPT_x2=""
    #----
    local S_TMP_0="$S_SCRIPT_0$S_NEWLINE$S_SCRIPT_x0$S_NEWLINE"
    local S_TMP_1="$S_SCRIPT_1$S_NEWLINE$S_SCRIPT_x1$S_NEWLINE"
    local S_TMP_2="$S_SCRIPT_2$S_NEWLINE$S_SCRIPT_x2$S_NEWLINE"
    eval "$S_TMP_0$S_TMP_1$S_TMP_2"
} # func_mmmv_exec_with_every_ar_element_t1

#--------------------------------------------------------------------------

func_mmmv_ar_range_t1() { #S_ARRAY_VARIABLE_NAME I_MINIMUM_INDEX I_MAXIMUM_INDEX
    local S_ARRAY_VARIABLE_NAME="$1"
    local I_MIN=$2
    local I_MAX_PLUS_ONE=`expr $3 + 1`
    #----------------------------------------------------------------------
    local S_SCRIPT_0="$S_ARRAY_VARIABLE_NAME=()"
    eval "$S_SCRIPT_0"
    local i_n=""
    S_SCRIPT_0="$S_ARRAY_VARIABLE_NAME+=(\$i_n)"
    for ((i_n=$I_MIN;i_n<$I_MAX_PLUS_ONE;i_n++))
    do
        eval "$S_SCRIPT_0"
    done
} # func_mmmv_ar_range_t1

# # Test/demo code:
#
#     AR_A_GLOBAL_VARIABLE=()
#     S_TMP="9"
#     func_mmmv_ar_range_t1 "AR_A_GLOBAL_VARIABLE" 4 $S_TMP
#     for ((i = 0; i < ${#AR_A_GLOBAL_VARIABLE[@]}; i++)) do
#         S_ITER="${AR_A_GLOBAL_VARIABLE[$i]}"
#         echo "s_iter==[$S_ITER]"
#     done

#--------------------------------------------------------------------------

func_mmmv_create_array_t1() {
    local ARRR=()
    #-------
    ARRR+=("first value as string")
    ARRR+=("second value as string")
    ARRR+=("third value as string")
    ARRR+=("fourth value as string")
    #-------
    export ARRR_sz=`declare -p ARRR`
} # func_mmmv_create_array_t1

#--------------------------------------------------------------------------

func_mmmv_iterate_over_array_02n_t1() {
    local S_ARRAY_VARIABLE_NAME="$1"
    local S_ARRAY_SERIALIZED="$2" # `declare -p VARIABLENAME` or an empty string
    local S_ITERATION_FUNCTION_NAME="$3" # that accepts "$s_iter" as a parameter
    #----------------------------------------------------------------------
    func_mmmv_exc_verify_S_FP_ORIG_t2
    if [ "$S_ARRAY_VARIABLE_NAME" == "" ]; then
        echo ""
        echo -e "\e[31mS_ARRAY_VARIABLE_NAME\e[39m is not allowed to be an empty string."
        echo "GUID=='2f139453-cadd-4400-a206-03622141a9e7'"
        echo ""
        #--------
        cd "$S_FP_ORIG"
        exit 1
    fi
    #----------------------------------------------------------------------
    if [ "$S_ITERATION_FUNCTION_NAME" == "" ]; then
        echo ""
        echo -e "\e[31mS_ITERATION_FUNCTION_NAME\e[39m is not allowed to be an empty string."
        echo "GUID=='18584134-35a4-4a82-b206-03622141a9e7'"
        echo ""
        #--------
        cd "$S_FP_ORIG"
        exit 1
    fi
    #----------------------------------------------------------------------
    eval ${S_ARRAY_SERIALIZED}
    #-------
    local S_SCRIPT_0="local S_LEN=\${#$S_ARRAY_VARIABLE_NAME[@]}"
    eval ${S_SCRIPT_0}
    #echo "ARRR length: $S_LEN"
    local I_MAX=`expr $S_LEN + 0`
    #-------
    local i_n=42
    local s_iter=""
    local S_SCRIPT_LINE_1="for ((i_n=0;i_n<\$I_MAX;i_n++))"
    local S_SCRIPT_LINE_2="s_iter=\${$S_ARRAY_VARIABLE_NAME[\$i_n]}"
    local S_SCRIPT_LINE_3="$S_ITERATION_FUNCTION_NAME \"\$s_iter\""
    S_SCRIPT_0="$S_SCRIPT_LINE_1 "$'\n'"do"$'\n'"$S_SCRIPT_LINE_2 "$'\n'"$S_SCRIPT_LINE_3 "$'\n'"done"
    #echo "$S_SCRIPT_0"
    eval "$S_SCRIPT_0"
} # func_mmmv_iterate_over_array_02n_t1

# Test/demo code:
#     func_iter() {
#         local S_ITER="$1"
#         echo "Greetings from func_iter: $S_ITER"
#     } # func_iter
#
#     func_mmmv_create_array_t1
#     func_mmmv_iterate_over_array_02n_t1 "ARRR" "$ARRR_sz" "func_iter"
#--------------------------------------------------------------------------

func_mmmv_sb_head_exists_t1() { # S_OUTPUT_VARIABLE_NAME, S_HEAD_REGEX , S_HAYSTACK
    local S_OUTPUT_VARIABLE_NAME="$1"
    local S_HEAD_REGEX="$2"
    local S_HAYSTACK="$3"
    #----------------------------------------------------------------------
    local S_SCRIPT_0="$S_OUTPUT_VARIABLE_NAME=\"f\""
    eval "$S_SCRIPT_0"
    local S_NUMBER_OF_MATCHING_CHARACTERS=`expr match "$S_HAYSTACK" "$S_HEAD_REGEX"`
    if [ "$S_NUMBER_OF_MATCHING_CHARACTERS" != "0" ]; then
        S_SCRIPT_0="$S_OUTPUT_VARIABLE_NAME=\"t\""
        eval "$S_SCRIPT_0"
    fi
} # func_mmmv_sb_head_exists_t1

# Test/demo code:
#     S_RGX="/home/ts2/tmp"
#     S_FP="/home/ts2/tmp/uuuuu/eee"
#
#     func_mmmv_sb_head_exists_t1 "S_CC" $S_RGX $S_FP
#     echo "S_CC: $S_CC"
#--------------------------------------------------------------------------

func_mmmv_include_bashfile_if_possible_t1(){ # S_FP_BASHFILE S_GUID_CANDIDATE SB_THROW_ON_ERROR
    local S_FP_BASHFILE="$1" # Full path to the file
    local S_GUID_CANDIDATE="$2"
    local SB_THROW_ON_ERROR="$3" # ~/.bashrc must not call the "exit" command.
                                 # If the SB_THROW_ON_ERROR=="t", the
                                 # "exit" command can be called in case of error.
                                 # If the SB_THROW_ON_ERROR=="f", the
                                 # "exit" command will not be called,
                                 # only an error message is printed to console.
                                 # default: "f"
    #----------------------------------------------------------------------
    if [ "$SB_THROW_ON_ERROR" == "" ]; then
        SB_THROW_ON_ERROR="f" # the default value
    else
        if [ "$SB_THROW_ON_ERROR" != "t" ]; then
            if [ "$SB_THROW_ON_ERROR" != "f" ]; then
                echo ""
                echo "The SB_THROW_ON_ERROR(==$SB_THROW_ON_ERROR)"
                echo -e "\e[31mhas a wrong vaue\e[39m. Only \"t\" and \"f\" are allowed."
                if [ "$S_GUID_CANDIDATE" != "" ]; then
                    echo "S_GUID_CANDIDATE=='$S_GUID_CANDIDATE'"
                fi
                echo "GUID=='2d1a0251-e3a0-4f85-b606-03622141a9e7'"
                echo ""
            fi
        fi
    fi
    #-----------------------------------------
    local SB_INCLUSION_POSSIBLE="t"
    if [ "$S_FP_BASHFILE" == "" ]; then
        SB_INCLUSION_POSSIBLE="f"
        echo ""
        echo -e "The S_FP_BASHFILE \e[31mhad a value of an empty string\e[39m."
        if [ "$S_GUID_CANDIDATE" != "" ]; then
            echo "S_GUID_CANDIDATE=='$S_GUID_CANDIDATE'"
        fi
        echo "GUID=='89673452-f5ee-4413-a206-03622141a9e7'"
        echo ""
        if [ "$SB_THROW_ON_ERROR" == "t" ]; then
            exit 1
        fi
    fi
    #-----------------------------------------
    if [ "$SB_INCLUSION_POSSIBLE" == "t" ]; then
        if [ ! -e "$S_FP_BASHFILE" ]; then
            SB_INCLUSION_POSSIBLE="f"
            echo ""
            echo "The "
            echo ""
            echo "    $S_FP_BASHFILE"
            echo ""
            echo -e "\e[31mdoes not exist or it is a broken symlink\e[39m."
            if [ "$S_GUID_CANDIDATE" != "" ]; then
                echo "S_GUID_CANDIDATE=='$S_GUID_CANDIDATE'"
            fi
            echo "GUID=='83dc0330-2722-41d4-a2f5-03622141a9e7'"
            echo ""
            if [ "$SB_THROW_ON_ERROR" == "t" ]; then
                exit 1
            fi
        fi
    fi
    #-----------------------------------------
    if [ "$SB_INCLUSION_POSSIBLE" == "t" ]; then
        if [ -d "$S_FP_BASHFILE" ]; then
            SB_INCLUSION_POSSIBLE="f"
            echo ""
            echo "The "
            echo ""
            echo "    $S_FP_BASHFILE"
            echo ""
            echo -e "\e[31mreferences a folder\e[39m, but it must reference a file."
            if [ "$S_GUID_CANDIDATE" != "" ]; then
                echo "S_GUID_CANDIDATE=='$S_GUID_CANDIDATE'"
            fi
            echo "GUID=='9bcce924-73c8-46cc-82f5-03622141a9e7'"
            echo ""
            if [ "$SB_THROW_ON_ERROR" == "t" ]; then
                exit 1
            fi
        fi
    fi
    #----------------------------------------------------------------------
    if [ "$SB_INCLUSION_POSSIBLE" == "t" ]; then
        source "$S_FP_BASHFILE"
    else
        if [ "$SB_INCLUSION_POSSIBLE" != "f" ]; then
            echo ""
            echo -e "\e[31mThe implementation of this function is flawed. \e[39m"
            echo "SB_INCLUSION_POSSIBLE==$SB_INCLUSION_POSSIBLE"
            if [ "$S_GUID_CANDIDATE" != "" ]; then
                echo "S_GUID_CANDIDATE=='$S_GUID_CANDIDATE'"
            fi
            echo "GUID=='97f4fa30-4d19-424e-81f5-03622141a9e7'"
            echo ""
            if [ "$SB_THROW_ON_ERROR" == "t" ]; then
                exit 1
            fi
        fi
    fi
} # func_mmmv_include_bashfile_if_possible_t1

#--------------------------------------------------------------------------

func_mmmv_include_bashfile_if_possible_t2(){ # S_FP_BASHFILE S_GUID_CANDIDATE
    local S_FP_BASHFILE="$1" # Full path to the file
    local S_GUID_CANDIDATE="$2"
    #----------------------------------------------------------------------
    # ~/.bashrc must not call the "exit" command.
    #-----------------------------------------
    local SB_INCLUSION_POSSIBLE="t"
    if [ "$S_FP_BASHFILE" == "" ]; then
        SB_INCLUSION_POSSIBLE="f"
        echo ""
        echo -e "The S_FP_BASHFILE \e[31mhad a value of an empty string\e[39m."
        if [ "$S_GUID_CANDIDATE" != "" ]; then
            echo "S_GUID_CANDIDATE=='$S_GUID_CANDIDATE'"
        fi
        echo "GUID=='3887d074-2f3f-4fd6-b3f5-03622141a9e7'"
        echo ""
    fi
    #-----------------------------------------
    if [ "$SB_INCLUSION_POSSIBLE" == "t" ]; then
        if [ ! -e "$S_FP_BASHFILE" ]; then
            SB_INCLUSION_POSSIBLE="f"
            echo ""
            echo "The "
            echo ""
            echo "    $S_FP_BASHFILE"
            echo ""
            echo -e "\e[31mdoes not exist or it is a broken symlink\e[39m."
            if [ "$S_GUID_CANDIDATE" != "" ]; then
                echo "S_GUID_CANDIDATE=='$S_GUID_CANDIDATE'"
            fi
            echo "GUID=='0682db43-d425-44c4-84f5-03622141a9e7'"
            echo ""
        fi
    fi
    #-----------------------------------------
    if [ "$SB_INCLUSION_POSSIBLE" == "t" ]; then
        if [ -d "$S_FP_BASHFILE" ]; then
            SB_INCLUSION_POSSIBLE="f"
            echo ""
            echo "The "
            echo ""
            echo "    $S_FP_BASHFILE"
            echo ""
            echo -e "\e[31mreferences a folder\e[39m, but it must reference a file."
            if [ "$S_GUID_CANDIDATE" != "" ]; then
                echo "S_GUID_CANDIDATE=='$S_GUID_CANDIDATE'"
            fi
            echo "GUID=='15c3ff51-ef0b-4f55-88f5-03622141a9e7'"
            echo ""
        fi
    fi
    #----------------------------------------------------------------------
    if [ "$SB_INCLUSION_POSSIBLE" == "t" ]; then
        source "$S_FP_BASHFILE"
        func_mmmv_wait_and_sync_t1
        S_FP_DIR="$( cd "$( dirname "${BASH_SOURCE[0]}" )" && pwd )" # to restore its value
    else
        if [ "$SB_INCLUSION_POSSIBLE" != "f" ]; then
            echo ""
            echo -e "\e[31mThe implementation of this function is flawed. \e[39m"
            echo "SB_INCLUSION_POSSIBLE==$SB_INCLUSION_POSSIBLE"
            if [ "$S_GUID_CANDIDATE" != "" ]; then
                echo "S_GUID_CANDIDATE=='$S_GUID_CANDIDATE'"
            fi
            echo "GUID=='d95a9dc3-40d0-4404-b1f5-03622141a9e7'"
            echo ""
        fi
    fi
} # func_mmmv_include_bashfile_if_possible_t2

#--------------------------------------------------------------------------

func_mmmv_assert_exists_on_path_t1() {
    local S_NAME_OF_THE_EXECUTABLE="$1" # first function argument
    #----------------------------------------------------------------------
    func_mmmv_exc_verify_S_FP_ORIG_t2
    local S_TMP_0="\`which $S_NAME_OF_THE_EXECUTABLE 2> /dev/null\`"
    local S_TMP_1=""
    local S_TMP_2="S_TMP_1=$S_TMP_0"
    eval ${S_TMP_2}
    if [ "$S_TMP_1" == "" ]; then
        S_TMP_0="This bash script requires the \""
        S_TMP_1="\" to be on the PATH."
        #--------
        echo ""
        echo -e "$S_TMP_0\e[31m$S_NAME_OF_THE_EXECUTABLE\e[39m$S_TMP_1"
        echo "GUID=='682c2b1f-a644-472f-a4f5-03622141a9e7'"
        echo ""
        cd "$S_FP_ORIG"
        exit 1 # exit with an error
    fi
} # func_mmmv_assert_exists_on_path_t1

# Test/demo code:
#     func_mmmv_assert_exists_on_path_t1 "ruby"
#     func_mmmv_assert_exists_on_path_t1 "rubyy"
#--------------------------------------------------------------------------

func_mmmv_ln_create_or_overwrite_symlink_t1() { # S_FP_TARGET  S_FP_LINK
    local S_FP_TARGET="$1"
    local S_FP_LINK="$2"
    #----------------------------------------------------------------------
    local S_CMD_LN="ln -s $S_FP_TARGET $S_FP_LINK "
    local SB_DELETE_OLD_LINK="f"
    if [ -e "$S_FP_LINK" ]; then
        if [ ! -h "$S_FP_LINK" ]; then # not a symlink
            echo ""
            echo "The "
            echo ""
            echo -e "\e[31m    $S_FP_LINK \e[39m"
            echo ""
            echo -e "is \e[31mnot a symlink \e[39m, but if that path is in use at all, "
            echo "then only a symlink is allowed."
            echo ""
            echo "PWD==`pwd`"
            echo "GUID=='4490c727-8af8-447d-a3f5-03622141a9e7'"
            echo ""
            exit 1 # exit with an error
        fi
        # At this line the old S_FP_LINK is a nonbroken symlink.
        local S_FP_OLDTARGET="`readlink $S_FP_LINK`"
        if [ "$S_FP_OLDTARGET" != "$S_FP_TARGET" ]; then
            # No need to wear Flash memory if the
            # new symlink name and target match with
            # the old symlink name and target.
            SB_DELETE_OLD_LINK="t"
        fi
    else
        if [ -h "$S_FP_LINK" ]; then # a broken symlink
            SB_DELETE_OLD_LINK="t"
        fi
    fi
    #----------------------------------------------------------------------
    if [ "$SB_DELETE_OLD_LINK" == "t" ]; then
        rm -f $S_FP_LINK
        func_mmmv_assert_error_code_zero_t1 "$?" \
            "6232fd46-41f6-44f4-9586-03622141a9e7"
        func_mmmv_wait_and_sync_t1
        if [ -e "$S_FP_LINK" ]; then
            echo ""
            echo ""
            echo -e "\e[31mFailed to delete  \e[39m"
            echo "an old symlink with the path of "
            echo ""
            echo -e "\e[36m    $S_FP_LINK \e[39m"
            echo ""
            echo "PWD==`pwd`"
            echo "GUID=='85aa0525-1918-47d7-b2f5-03622141a9e7'"
            echo ""
            echo ""
            exit 1 # exit with an error
        fi
    fi
    #----------------------------------------------------------------------
    $S_CMD_LN
    func_mmmv_assert_error_code_zero_t1 "$?" \
        "4af219c3-378e-46f6-8286-03622141a9e7"
    func_mmmv_wait_and_sync_t1
    if [ ! -e "$S_FP_LINK" ]; then
        echo ""
        echo ""
        echo -e "\e[31mSymlink creation failed.  \e[39m"
        echo "Could not create a symlink with the path of:"
        echo ""
        echo -e "\e[36m    $S_CMD_LN \e[39m"
        echo ""
        echo "PWD==`pwd`"
        echo "GUID=='4f386b8f-85b1-4330-92f5-03622141a9e7'"
        echo ""
        echo ""
        exit 1 # exit with an error
    fi
    #----------------------------------------------------------------------
} # func_mmmv_ln_create_or_overwrite_symlink_t1

#--------------------------------------------------------------------------

func_mmmv_operatingsystem_is_Linux() { # S_OUTPUT_VARIABLE_NAME
    local S_OUTPUT_VARIABLE_NAME="$1"
    #----------------------------------------------------------------------
    local S_OUT="f"
    local S_X="`uname -a | grep -l Linux `"
    if [ "$S_X" != "" ]; then
        S_OUT="t"
    fi
    local S_SCRIPT_0="$S_OUTPUT_VARIABLE_NAME=\"$S_OUT\""
    eval ${S_SCRIPT_0}
    # echo "ANSWER: $S_OUT"
} # func_mmmv_operatingsystem_is_Linux

#--------------------------------------------------------------------------

func_mmmv_operatingsystem_is_FreeBSD() { # S_OUTPUT_VARIABLE_NAME
    local S_OUTPUT_VARIABLE_NAME="$1"
    #----------------------------------------------------------------------
    local S_OUT="f"
    local S_X="`uname -a | grep -l FreeBSD`"
    if [ "$S_X" != "" ]; then
        S_OUT="t"
    fi
    local S_SCRIPT_0="$S_OUTPUT_VARIABLE_NAME=\"$S_OUT\""
    eval ${S_SCRIPT_0}
    # echo "ANSWER: $S_OUT"
} # func_mmmv_operatingsystem_is_FreeBSD

#--------------------------------------------------------------------------

func_mmmv_operatingsystem_is_NetBSD() { # S_OUTPUT_VARIABLE_NAME
    local S_OUTPUT_VARIABLE_NAME="$1"
    #----------------------------------------------------------------------
    local S_OUT="f"
    local S_X="`uname -a | grep -l NetBSD`"
    if [ "$S_X" != "" ]; then
        S_OUT="t"
    fi
    local S_SCRIPT_0="$S_OUTPUT_VARIABLE_NAME=\"$S_OUT\""
    eval ${S_SCRIPT_0}
    # echo "ANSWER: $S_OUT"
} # func_mmmv_operatingsystem_is_NetBSD

#--------------------------------------------------------------------------

func_mmmv_operatingsystem_is_OpenBSD() { # S_OUTPUT_VARIABLE_NAME
    local S_OUTPUT_VARIABLE_NAME="$1"
    #----------------------------------------------------------------------
    local S_OUT="f"
    local S_X="`uname -a | grep -l OpenBSD`"
    if [ "$S_X" != "" ]; then
        S_OUT="t"
    fi
    local S_SCRIPT_0="$S_OUTPUT_VARIABLE_NAME=\"$S_OUT\""
    eval ${S_SCRIPT_0}
    # echo "ANSWER: $S_OUT"
} # func_mmmv_operatingsystem_is_OpenBSD

#--------------------------------------------------------------------------

func_mmmv_operatingsystem_is_BSD() { # S_OUTPUT_VARIABLE_NAME
    local S_OUTPUT_VARIABLE_NAME="$1"
    #----------------------------------------------------------------------
    local S_OUT="f"
    local SB_TMP_0_orig="$SB_TMP_0"
    #----------------------------------------------------------------------
    func_mmmv_operatingsystem_is_FreeBSD "SB_TMP_0"
    S_OUT="$SB_TMP_0"
    if [ "$S_OUT" == "f" ]; then
        func_mmmv_operatingsystem_is_NetBSD "SB_TMP_0"
        S_OUT="$SB_TMP_0"
        if [ "$S_OUT" == "f" ]; then
            func_mmmv_operatingsystem_is_OpenBSD "SB_TMP_0"
            S_OUT="$SB_TMP_0"
        fi
    fi
    #----------------------------------------------------------------------
    export SB_TMP_0="$SB_TMP_0_orig"
    local S_SCRIPT_0="$S_OUTPUT_VARIABLE_NAME=\"$S_OUT\""
    eval ${S_SCRIPT_0}
    # echo "ANSWER: $S_OUT"
    #----------------------------------------------------------------------
} # func_mmmv_operatingsystem_is_BSD

#--------------------------------------------------------------------------

func_mmmv_operatingsystem_is_macOS() { # S_OUTPUT_VARIABLE_NAME
    local S_OUTPUT_VARIABLE_NAME="$1"
    #----------------------------------------------------------------------
    local S_OUT="f"
    local S_X="`uname -a | grep -i 'Darwin' | grep -i 'Kernel' `"
    if [ "$S_X" != "" ]; then
        S_OUT="t"
    fi
    local S_SCRIPT_0="$S_OUTPUT_VARIABLE_NAME=\"$S_OUT\""
    eval ${S_SCRIPT_0}
    # echo "ANSWER: $S_OUT"
} # func_mmmv_operatingsystem_is_macOS

#--------------------------------------------------------------------------

# Sets the global environment variable S_MMMV_OPERATING_SYSTEM
func_mmmv_determine_operatingsystem_t1() {
    local SB_AVOID_REINITIALISATION_IF_ALREADY_INITIALIZED="$1" # domain: {"","t","f"}
                                                                # default: "t"
                                                                # "" -> "t"
    #----------------------------------------------------------------------
    local SB_REUSE_EXISTING_VALUE="f" # may be there is no old value to use
    local SB_RE_EX_VA_IF_PO_NORMALISED="$SB_AVOID_REINITIALISATION_IF_ALREADY_INITIALIZED"
    if [ "$SB_AVOID_REINITIALISATION_IF_ALREADY_INITIALIZED" == "" ]; then
        SB_RE_EX_VA_IF_PO_NORMALISED="t"
    else
        func_mmmv_assert_sbvar_domain_t_f_t1 \
            "$SB_AVOID_REINITIALISATION_IF_ALREADY_INITIALIZED" \
            "SB_AVOID_REINITIALISATION_IF_ALREADY_INITIALIZED" \
            "02197b5b-5a0d-4dab-8286-03622141a9e7"
    fi
    if [ "$SB_RE_EX_VA_IF_PO_NORMALISED" == "t" ]; then
        if [ "$S_MMMV_OPERATING_SYSTEM" != "" ]; then
            SB_REUSE_EXISTING_VALUE="t"
        fi
    fi
    #----------------------------------------------------------------------
    local SB_TMP_0_orig="$SB_TMP_0"
    if [ "$SB_REUSE_EXISTING_VALUE" == "f" ]; then
        #------------------------------------------------------------------
        func_mmmv_operatingsystem_is_Linux "SB_TMP_0"
        if [ "$SB_TMP_0" == "t" ]; then
            export S_MMMV_OPERATING_SYSTEM="linux"
        else
            func_mmmv_operatingsystem_is_BSD "SB_TMP_0"
            if [ "$SB_TMP_0" == "t" ]; then
                export S_MMMV_OPERATING_SYSTEM="bsd"
            else
                func_mmmv_operatingsystem_is_macOS "SB_TMP_0"
                if [ "$SB_TMP_0" == "t" ]; then
                    export S_MMMV_OPERATING_SYSTEM="macos"
                else
                    export S_MMMV_OPERATING_SYSTEM="unrecognised_operating_system"
                fi
            fi
        fi
        #------------------------------------------------------------------
        export SB_TMP_0="$SB_TMP_0_orig"
        #------------------------------------------------------------------
    fi
    #----------------------------------------------------------------------
} # func_mmmv_determine_operatingsystem_t1

#--------------------------------------------------------------------------

func_mmmv_exit_if_environment_variable_not_set_t1() { # S_ENVIRONMENT_VARIABLE_NAME
    local S_ENVIRONMENT_VARIABLE_NAME="$1"
    local S_ENVIRONMENT_VARIABLE_DOCSTRING="$2" # will be appended to failure-message
    #----------------------------------------------------------------------
    local S_ENVIR_VALUE=""
    local S_SCRIPT_0="S_ENVIR_VALUE=\"\`echo \$$S_ENVIRONMENT_VARIABLE_NAME\`\""
    eval "$S_SCRIPT_0"
    if [ "$S_ENVIR_VALUE" == "" ]; then
        echo ""
        echo -e "The environment variable $S_ENVIRONMENT_VARIABLE_NAME \e[31mis not set\e[39m, but "
        echo "it must be set or this script will not run (properly)."
        if [ "$S_ENVIRONMENT_VARIABLE_DOCSTRING" != "" ]; then
            echo ""
            echo "$S_ENVIRONMENT_VARIABLE_DOCSTRING"
        fi
        echo ""
        exit 1;
    #else
         # echo "S_ENVIR_VALUE==\"$S_ENVIR_VALUE\""
    fi
} # func_mmmv_exit_if_environment_variable_not_set_t1

# Test/demo code:
#     func_mmmv_exit_if_environment_variable_not_set_t1 "CFLAGS"

#--------------------------------------------------------------------------

func_mmmv_assert_Linux_or_BSD_t1(){
    local S_GUID_CANDIDATE="$1"
    #----------------------------------------------------------------------
    func_mmmv_exc_verify_S_FP_ORIG_t2
    if [ "$S_GUID_CANDIDATE" == "" ]; then
        echo ""
        echo -e "\e[31mS_GUID_CANDIDATE==\"\", but it is expected to be a GUID. \e[39m"
        echo "GUID=='4be9f5b2-386c-4366-a3f5-03622141a9e7'"
        echo ""
        # if [ "$S_FP_ORIG" != "" ]; then
        #     func_mmmv_exc_verify_S_FP_ORIG_t1
        #     cd "$S_FP_ORIG"
        # fi
        #--------
        cd "$S_FP_ORIG"
        exit 1 # exit with an error
    fi
    #--------------------
    #S_TMP_0="`uname -a | grep -E \"([Ll][Ii][Nn][Uu][Xx]|[Bb][Ss][Dd]|[Cc][Yy][Gg][Ww][Ii][Nn])\"`"
    S_TMP_0="`uname -a | grep -E \"(([Ll][Ii][Nn][Uu][Xx]|[Bb][Ss][Dd])[ ])\"`"
    if [ "$S_TMP_0" == "" ]; then
        echo ""
        echo -e "The classical command line utilities at different operating"
        echo -e "systems, for example, Linux and BSD, differ. This script is"
        echo -e "designed to run only on Linux and BSD.  If You are willing to"
        echo -e "risk that some of Your data is deleted and/or Your operating"
        echo -e "system instance becomes permanently flawed, to the point that it"
        echo -e "will not even boot, then You may edit the Bash script that calls"
        echo -e "the function that displays this error message by uncommenting"
        echo -e "that function."
        echo -e ""
        echo -e "If You do decide to edit the Bash script, then a recommendation"
        echo -e "is to test Your modifications within a virtual appliance"
        echo -e "or, if virtual appliances are not an option, as some new"
        echo -e "operating system user that does not have any access to the vital"
        echo -e "data/files."
        echo ""
        echo "Aborting script without doing anything."
        echo ""
        echo "GUID=='4c0d9e23-8896-4012-93e5-03622141a9e7'"
        echo ""
        # if [ "$S_FP_ORIG" != "" ]; then
        #     func_mmmv_exc_verify_S_FP_ORIG_t1
        #     cd "$S_FP_ORIG"
        # fi
        #--------
        cd "$S_FP_ORIG"
        exit 1 # exit with an error
    fi
} # func_mmmv_assert_Linux_or_BSD_t1

#--------------------------------------------------------------------------

func_mmmv_verify_that_internet_connection_exists_but_do_not_exit_t1(){
    #----------------------------------------------------------------------
    local S_GUID_CANDIDATE="$1"
    local SB_DISPLAY_NONERROR_FEEDBACK="$2" # domain: {"t","f",""}
                                            # ""==="f", default "f"
    #----------------------------------------------------------------------
    if [ "$S_GUID_CANDIDATE" == "" ]; then
        echo ""
        echo -e "\e[31mThe Bash code that calls this function is flawed \e[39m."
        echo ""
        echo "    S_GUID_CANDIDATE==\"\""
        echo ""
        echo "but it is expected to be a GUID."
        echo "GUID=='22e7b6cb-f41a-461e-81e5-03622141a9e7'"
        echo ""
    fi
    #----------------------------------------------------------------------
    if [ "$SB_DISPLAY_NONERROR_FEEDBACK" == "" ]; then
        SB_DISPLAY_NONERROR_FEEDBACK="f"
    else
        #----------------------------------------
        if [ "$SB_DISPLAY_NONERROR_FEEDBACK" != "t" ]; then
            if [ "$SB_DISPLAY_NONERROR_FEEDBACK" != "f" ]; then
                #----------------------------------------
                if [ "$S_GUID_CANDIDATE" != "" ]; then
                    func_mmmv_assert_sbvar_domain_t_f_but_do_not_exit_t1 \
                        "$SB_DISPLAY_NONERROR_FEEDBACK" \
                        "SB_DISPLAY_NONERROR_FEEDBACK" \
                        "$S_GUID_CANDIDATE"
                else
                    func_mmmv_assert_sbvar_domain_t_f_but_do_not_exit_t1 \
                        "$SB_DISPLAY_NONERROR_FEEDBACK" \
                        "SB_DISPLAY_NONERROR_FEEDBACK" \
                        "8191ec0f-6cfe-477e-a786-03622141a9e7"
                fi
                SB_DISPLAY_NONERROR_FEEDBACK="f"
                #----------------------------------------
            fi
        fi
        #----------------------------------------
    fi
    #----------------------------------------------------------------------
    func_mmmv_assert_exists_on_path_t1 "timeout"
    func_mmmv_assert_exists_on_path_t1 "ping"
    #----------------------------------------------------------------------
    # A global variable for storing function output.
    SB_VERIFICATION_FAILED="t" # domain: "t", "f" .
    #----------------------------------------
    local SB_DOMAIN_IS_REACHABLE="f"
    local S_CMD_PREFIX="timeout 3s nice -n 5 ping -c 30 "
    local SI_ERR_CODE="1"
    #----------------------------------------------------------------------
    if [ "$SB_DISPLAY_NONERROR_FEEDBACK" == "t" ]; then
        echo "Testing, whether there is internet connectivity..."
    fi
    #----------------------------------------------------------------------
# RENESSAATOR_BLOCK_START
# RENESSAATOR_BLOCK_ID=block_e6295e62-4c0c-4fef-a19e-02f1e0f337e7_city
# RENESSAATOR_SOURCE_LANGUAGE=Ruby
# RENESSAATOR_SOURCE_START
# s=""
# s<<'    #----------------------------------------------------------------------'
# s<<"\n"
# s<<'    if [ "$SB_DOMAIN_IS_REACHABLE" == "f" ]; then '
# s<<"\n"
# s<<"        # The redirection to /dev/null at the next line \n"
# s<<'        timeout BLANK41s nice -n 5 ping -c 30 "BLANK42" 2> /dev/null 1> /dev/null '
# s<<"\n"
# s<<"        # has been tested to work on both, Linux and FreeBSD. \n"
# s<<'        SI_ERR_CODE="$?" ; wait ; '
# s<<"\n"
# s<<'        if [ "$SI_ERR_CODE" == "0" ]; then '
# s<<"\n"
# s<<'            SB_DOMAIN_IS_REACHABLE="t" '
# s<<"\n"
# s<<'        else '
# s<<"\n"
# s<<'            if [ "$SI_ERR_CODE" == "124" ]; then '
# s<<"\n"
# s<<'                SB_DOMAIN_IS_REACHABLE="t" '
# s<<"\n"
# s<<'            fi '
# s<<"\n"
# s<<'        fi '
# s<<"\n"
# s<<'    fi '
# s<<"\n"
# ar=["softf1.com", "softf1.net", "google.com", "bing.com", "ibm.com", "eesti.ee"]
# puts((""+s).sub(/BLANK41/,"1").sub(/BLANK42/,ar[0])) # to make the Bash script faster
# ar.each do |s_domain|
# puts((""+s).sub(/BLANK41/,"3").sub(/BLANK42/,s_domain))
# end # loop
# RENESSAATOR_SOURCE_END
#
# RENESSAATOR_AUTOGENERATED_TEXT_START
    #----------------------------------------------------------------------
    if [ "$SB_DOMAIN_IS_REACHABLE" == "f" ]; then
        # The redirection to /dev/null at the next line
        timeout 1s nice -n 5 ping -c 30 "softf1.com" 2> /dev/null 1> /dev/null
        # has been tested to work on both, Linux and FreeBSD.
        SI_ERR_CODE="$?" ; wait ;
        if [ "$SI_ERR_CODE" == "0" ]; then
            SB_DOMAIN_IS_REACHABLE="t"
        else
            if [ "$SI_ERR_CODE" == "124" ]; then
                SB_DOMAIN_IS_REACHABLE="t"
            fi
        fi
    fi
    #----------------------------------------------------------------------
    if [ "$SB_DOMAIN_IS_REACHABLE" == "f" ]; then
        # The redirection to /dev/null at the next line
        timeout 3s nice -n 5 ping -c 30 "softf1.com" 2> /dev/null 1> /dev/null
        # has been tested to work on both, Linux and FreeBSD.
        SI_ERR_CODE="$?" ; wait ;
        if [ "$SI_ERR_CODE" == "0" ]; then
            SB_DOMAIN_IS_REACHABLE="t"
        else
            if [ "$SI_ERR_CODE" == "124" ]; then
                SB_DOMAIN_IS_REACHABLE="t"
            fi
        fi
    fi
    #----------------------------------------------------------------------
    if [ "$SB_DOMAIN_IS_REACHABLE" == "f" ]; then
        # The redirection to /dev/null at the next line
        timeout 3s nice -n 5 ping -c 30 "softf1.net" 2> /dev/null 1> /dev/null
        # has been tested to work on both, Linux and FreeBSD.
        SI_ERR_CODE="$?" ; wait ;
        if [ "$SI_ERR_CODE" == "0" ]; then
            SB_DOMAIN_IS_REACHABLE="t"
        else
            if [ "$SI_ERR_CODE" == "124" ]; then
                SB_DOMAIN_IS_REACHABLE="t"
            fi
        fi
    fi
    #----------------------------------------------------------------------
    if [ "$SB_DOMAIN_IS_REACHABLE" == "f" ]; then
        # The redirection to /dev/null at the next line
        timeout 3s nice -n 5 ping -c 30 "google.com" 2> /dev/null 1> /dev/null
        # has been tested to work on both, Linux and FreeBSD.
        SI_ERR_CODE="$?" ; wait ;
        if [ "$SI_ERR_CODE" == "0" ]; then
            SB_DOMAIN_IS_REACHABLE="t"
        else
            if [ "$SI_ERR_CODE" == "124" ]; then
                SB_DOMAIN_IS_REACHABLE="t"
            fi
        fi
    fi
    #----------------------------------------------------------------------
    if [ "$SB_DOMAIN_IS_REACHABLE" == "f" ]; then
        # The redirection to /dev/null at the next line
        timeout 3s nice -n 5 ping -c 30 "bing.com" 2> /dev/null 1> /dev/null
        # has been tested to work on both, Linux and FreeBSD.
        SI_ERR_CODE="$?" ; wait ;
        if [ "$SI_ERR_CODE" == "0" ]; then
            SB_DOMAIN_IS_REACHABLE="t"
        else
            if [ "$SI_ERR_CODE" == "124" ]; then
                SB_DOMAIN_IS_REACHABLE="t"
            fi
        fi
    fi
    #----------------------------------------------------------------------
    if [ "$SB_DOMAIN_IS_REACHABLE" == "f" ]; then
        # The redirection to /dev/null at the next line
        timeout 3s nice -n 5 ping -c 30 "ibm.com" 2> /dev/null 1> /dev/null
        # has been tested to work on both, Linux and FreeBSD.
        SI_ERR_CODE="$?" ; wait ;
        if [ "$SI_ERR_CODE" == "0" ]; then
            SB_DOMAIN_IS_REACHABLE="t"
        else
            if [ "$SI_ERR_CODE" == "124" ]; then
                SB_DOMAIN_IS_REACHABLE="t"
            fi
        fi
    fi
    #----------------------------------------------------------------------
    if [ "$SB_DOMAIN_IS_REACHABLE" == "f" ]; then
        # The redirection to /dev/null at the next line
        timeout 3s nice -n 5 ping -c 30 "eesti.ee" 2> /dev/null 1> /dev/null
        # has been tested to work on both, Linux and FreeBSD.
        SI_ERR_CODE="$?" ; wait ;
        if [ "$SI_ERR_CODE" == "0" ]; then
            SB_DOMAIN_IS_REACHABLE="t"
        else
            if [ "$SI_ERR_CODE" == "124" ]; then
                SB_DOMAIN_IS_REACHABLE="t"
            fi
        fi
    fi

# RENESSAATOR_AUTOGENERATED_TEXT_END
# RENESSAATOR_BLOCK_END
    #----------------------------------------------------------------------
    if [ "$SB_DOMAIN_IS_REACHABLE" == "f" ]; then
        SB_VERIFICATION_FAILED="t"
        if [ "$SB_DISPLAY_NONERROR_FEEDBACK" == "t" ]; then
            echo -e "\e[33mTest failed\e[39m. Replies to pings were NOT received."
            echo "GUID=='3df3f558-6379-4fc7-a5e5-03622141a9e7'"
            if [ "$S_GUID_CANDIDATE" != "" ]; then
                echo "S_GUID_CANDIDATE=='$S_GUID_CANDIDATE'"
            fi
        fi
    else
        SB_VERIFICATION_FAILED="f"
        if [ "$SB_DISPLAY_NONERROR_FEEDBACK" == "t" ]; then
            echo -e "\e[32mTest passed\e[39m. It was possible to receive replies to pings."
        fi
    fi
    wait # to make sure that the echo commands
         # complete before anything else is printed to stdout
    #----------------------------------------------------------------------
} # func_mmmv_verify_that_internet_connection_exists_but_do_not_exit_t1

#--------------------------------------------------------------------------

SB_FUNC_MMMV_ASSERT_INTERNET_CONNECTION_EXISTS_T1_RESULT_CACHED="f"
SB_FUNC_MMMV_ASSERT_INTERNET_CONNECTION_EXISTS_T1_INTERNET_CONNECTION_EXISTS="f"
func_mmmv_assert_internet_connection_exists_t1(){
    #----------------------------------------------------------------------
    local S_GUID_CANDIDATE="$1"
    local SB_OK_TO_CACHE="$2" # domain: {"t","f",""}
                              # ""==="f", default "f"
    local SB_DISPLAY_NONERROR_FEEDBACK="$3" # domain: {"t","f",""}
                                            # ""==="f", default "f"
    #----------------------------------------------------------------------
    if [ "$S_GUID_CANDIDATE" == "" ]; then
        echo ""
        echo -e "\e[31mThe Bash code that calls this function is flawed \e[39m."
        echo ""
        echo "    S_GUID_CANDIDATE==\"\""
        echo ""
        echo "but it is expected to be a GUID."
        echo "Aborting script."
        echo "GUID=='141dbfe2-3503-4c52-95e5-03622141a9e7'"
        echo ""
        #--------
        cd "$S_FP_ORIG"
        exit 1
    fi
    #----------------------------------------------------------------------
    if [ "$SB_OK_TO_CACHE" == "" ]; then
        SB_OK_TO_CACHE="f"
    else
        func_mmmv_assert_sbvar_domain_t_f_t1 \
            "$SB_OK_TO_CACHE" "SB_OK_TO_CACHE" \
            "21d0e42e-bce3-47b2-8176-03622141a9e7"
    fi
    #----------------------------------------------------------------------
    if [ "$SB_DISPLAY_NONERROR_FEEDBACK" == "" ]; then
        SB_DISPLAY_NONERROR_FEEDBACK="f"
    else
        func_mmmv_assert_sbvar_domain_t_f_t1 \
            "$SB_DISPLAY_NONERROR_FEEDBACK" "SB_DISPLAY_NONERROR_FEEDBACK" \
            "a8e12116-4334-4bad-8476-03622141a9e7"
    fi
    #----------------------------------------------------------------------
    func_mmmv_assert_sbvar_domain_t_f_t1 \
        "$SB_FUNC_MMMV_ASSERT_INTERNET_CONNECTION_EXISTS_T1_RESULT_CACHED" \
        "SB_FUNC_MMMV_ASSERT_INTERNET_CONNECTION_EXISTS_T1_RESULT_CACHED" \
        "3688a8f3-c75c-4620-b276-03622141a9e7"
    func_mmmv_assert_sbvar_domain_t_f_t1 \
        "$SB_FUNC_MMMV_ASSERT_INTERNET_CONNECTION_EXISTS_T1_INTERNET_CONNECTION_EXISTS" \
        "SB_FUNC_MMMV_ASSERT_INTERNET_CONNECTION_EXISTS_T1_INTERNET_CONNECTION_EXISTS" \
        "1e020c21-4123-44ac-b476-03622141a9e7"
    #----------------------------------------------------------------------
    local SB_INTERNET_AVAILABLE="f"
    local SB_STUDY_INTERNET_AVAILABILITY="f"
    #----------------------------------------------------------------------
    if [ "$SB_OK_TO_CACHE" == "t" ]; then
        if [ "$SB_FUNC_MMMV_ASSERT_INTERNET_CONNECTION_EXISTS_T1_RESULT_CACHED" == "t" ]; then
            SB_INTERNET_AVAILABLE="$SB_FUNC_MMMV_ASSERT_INTERNET_CONNECTION_EXISTS_T1_INTERNET_CONNECTION_EXISTS"
            #SB_STUDY_INTERNET_AVAILABILITY="f"
        else
            SB_STUDY_INTERNET_AVAILABILITY="t"
        fi
    else
        SB_STUDY_INTERNET_AVAILABILITY="t"
    fi
    #----------------------------------------------------------------------
    if [ "$SB_STUDY_INTERNET_AVAILABILITY" == "t" ]; then
        #----------------------------------------
        # The
        func_mmmv_verify_that_internet_connection_exists_but_do_not_exit_t1 \
            "3bc1a68a-c217-4f84-a476-03622141a9e7" \
            "$SB_DISPLAY_NONERROR_FEEDBACK"
        # retunrs its result in a global variable named
        # SB_VERIFICATION_FAILED="t" # domain: "t", "f" .
        if [ "$SB_VERIFICATION_FAILED" == "t" ]; then
            SB_INTERNET_AVAILABLE="f"
        else
            if [ "$SB_VERIFICATION_FAILED" == "f" ]; then
                SB_INTERNET_AVAILABLE="t"
            else
                func_mmmv_assert_sbvar_domain_t_f_t1 \
                    "$SB_VERIFICATION_FAILED" \
                    "SB_VERIFICATION_FAILED" \
                    "27e6cf64-eed7-450c-a376-03622141a9e7"
            fi
        fi
        #----------------------------------------
        SB_FUNC_MMMV_ASSERT_INTERNET_CONNECTION_EXISTS_T1_INTERNET_CONNECTION_EXISTS="$SB_INTERNET_AVAILABLE"
        SB_FUNC_MMMV_ASSERT_INTERNET_CONNECTION_EXISTS_T1_RESULT_CACHED="t"
        #----------------------------------------
    fi
    #----------------------------------------------------------------------
    if [ "$SB_INTERNET_AVAILABLE" == "f" ]; then
        echo ""
        echo -e "\e[31mInternet could not be reached\e[39m."
        echo -e "Aborting script."
        echo "GUID=='59869761-26d2-441b-a5e5-03622141a9e7'"
        echo "S_GUID_CANDIDATE=='$S_GUID_CANDIDATE'"
        echo ""
        #--------
        cd "$S_FP_ORIG"
        exit 1
    fi
    #----------------------------------------------------------------------
} # func_mmmv_assert_internet_connection_exists_t1

#--------------------------------------------------------------------------

# TODO: split the function
#       func_mmmv_assert_GUI_applications_can_be_launched_t1(...)
#       the non-exiting part ("do_not_exit") and the exiting/throwing part.

SB_FUNC_MMMV_ASSERT_GUI_APPLICATIONS_CAN_BE_LAUNCHED_T1_RESULT_CACHED="f"
SB_FUNC_MMMV_ASSERT_GUI_APPLICATIONS_CAN_BE_LAUNCHED_T1_GUI_IS_LAUNCHABLE="f"
func_mmmv_assert_GUI_applications_can_be_launched_t1(){
    #----------------------------------------------------------------------
    local S_GUID_CANDIDATE="$1"
    local SB_OK_TO_CACHE="$2" # domain: {"t","f",""}
                              # ""==="f", default "f"
    local SB_DISPLAY_NONERROR_FEEDBACK="$3" # domain: {"t","f",""}
                                            # "" --> "f", default "f"
    #----------------------------------------------------------------------
    if [ "$S_GUID_CANDIDATE" == "" ]; then
        echo ""
        echo -e "\e[31mThe Bash code that calls this function is flawed \e[39m."
        echo ""
        echo "    S_GUID_CANDIDATE==\"\""
        echo ""
        echo "but it is expected to be a GUID."
        echo "Aborting script."
        echo "GUID=='714c1884-72dd-4735-bce5-03622141a9e7'"
        echo ""
        #--------
        cd "$S_FP_ORIG"
        exit 1
    fi
    #----------------------------------------------------------------------
    if [ "$SB_OK_TO_CACHE" == "" ]; then
        SB_OK_TO_CACHE="f"
    else
        func_mmmv_assert_sbvar_domain_t_f_t1 \
            "$SB_OK_TO_CACHE" "SB_OK_TO_CACHE" \
            "aaedaff8-79f1-4864-b476-03622141a9e7"
    fi
    #----------------------------------------------------------------------
    if [ "$SB_DISPLAY_NONERROR_FEEDBACK" == "" ]; then
        SB_DISPLAY_NONERROR_FEEDBACK="f"
    else
        func_mmmv_assert_sbvar_domain_t_f_t1 \
            "$SB_DISPLAY_NONERROR_FEEDBACK" "SB_DISPLAY_NONERROR_FEEDBACK" \
            "b09bcf20-d83a-46fd-9476-03622141a9e7"
    fi
    #----------------------------------------------------------------------
    func_mmmv_assert_sbvar_domain_t_f_t1 \
        "$SB_FUNC_MMMV_ASSERT_GUI_APPLICATIONS_CAN_BE_LAUNCHED_T1_RESULT_CACHED" \
        "SB_FUNC_MMMV_ASSERT_GUI_APPLICATIONS_CAN_BE_LAUNCHED_T1_RESULT_CACHED" \
        "1a88a3c3-2d2e-4ee6-a476-03622141a9e7"
    func_mmmv_assert_sbvar_domain_t_f_t1 \
        "$SB_FUNC_MMMV_ASSERT_GUI_APPLICATIONS_CAN_BE_LAUNCHED_T1_GUI_IS_LAUNCHABLE" \
        "SB_FUNC_MMMV_ASSERT_GUI_APPLICATIONS_CAN_BE_LAUNCHED_T1_GUI_IS_LAUNCHABLE" \
        "22ba8a2b-7125-415f-9176-03622141a9e7"
    #----------------------------------------------------------------------
    local SB_RUN_TEST="t"
    if [ "$SB_OK_TO_CACHE" == "t" ]; then
        if [ "$SB_FUNC_MMMV_ASSERT_GUI_APPLICATIONS_CAN_BE_LAUNCHED_T1_RESULT_CACHED" == "t" ]; then
            SB_RUN_TEST="f"
            if [ "$SB_FUNC_MMMV_ASSERT_GUI_APPLICATIONS_CAN_BE_LAUNCHED_T1_GUI_IS_LAUNCHABLE" == "f" ]; then
                echo ""
                echo -e "\e[31mThis Bash function is flawed \e[39m."
                echo "The control flow should have never reached this if-statement, because"
                echo "the Bash program should have terminated at the "
                echo "previous run of this function, when it was discovered that "
                echo "GUI applications can not be launched."
                echo "Aborting script."
                echo "GUID=='118dd217-d50a-4560-81e5-03622141a9e7'"
                echo "S_GUID_CANDIDATE==\"$S_GUID_CANDIDATE\""
                echo ""
                #--------
                cd "$S_FP_ORIG"
                exit 1
            fi
        fi
    fi
    #----------------------------------------------------------------------
    if [ "$SB_RUN_TEST" == "t" ]; then
        #------------------------------------------------------------------
        func_mmmv_assert_exists_on_path_t1 "timeout"
        func_mmmv_assert_exists_on_path_t1 "xeyes" # needed for fast testing
        #------------------------------------------------------------------
        if [ "$SB_DISPLAY_NONERROR_FEEDBACK" == "t" ]; then
            echo "Launching the xeyes application for about 2 seconds to test, "
            echo "whether it is possible to launch GUI applications..."
        fi
        nice -n 5 timeout 2s xeyes
        local S_TMP_0="$?"
        if [ "$S_TMP_0" != "124" ]; then
            #--------
            SB_FUNC_MMMV_ASSERT_GUI_APPLICATIONS_CAN_BE_LAUNCHED_T1_GUI_IS_LAUNCHABLE="f"
            SB_FUNC_MMMV_ASSERT_GUI_APPLICATIONS_CAN_BE_LAUNCHED_T1_RESULT_CACHED="t"
            #--------
            echo ""
            echo -e "It seems that it is\e[31m NOT possible to launch GUI applications\e[39m."
            echo "Aborting script."
            echo "GUID=='163ef0c5-6d89-4ab8-a4e5-03622141a9e7'"
            echo "S_GUID_CANDIDATE==\"$S_GUID_CANDIDATE\""
            echo ""
            #--------
            cd "$S_FP_ORIG"
            exit 1
        fi
        wait ;
        if [ "$SB_DISPLAY_NONERROR_FEEDBACK" == "t" ]; then
            echo -e "\e[32mTest passed\e[39m. The xeyes could be launched successfully."
        fi
        SB_FUNC_MMMV_ASSERT_GUI_APPLICATIONS_CAN_BE_LAUNCHED_T1_GUI_IS_LAUNCHABLE="t"
        SB_FUNC_MMMV_ASSERT_GUI_APPLICATIONS_CAN_BE_LAUNCHED_T1_RESULT_CACHED="t"
        wait ;
        #------------------------------------------------------------------
    fi
    #----------------------------------------------------------------------
} # func_mmmv_assert_GUI_applications_can_be_launched_t1

#--------------------------------------------------------------------------

func_mmmv_exc_initialize_wine_C_drive_if_needed_t1(){
    #----------------------------------------------------------------------
    local SB_DISPLAY_NONERROR_FEEDBACK="$1" # domain: {"t","f",""}
                                            # ""==="f", default "f"
    #----------------------------------------------------------------------
    if [ "$SB_DISPLAY_NONERROR_FEEDBACK" == "" ]; then
        SB_DISPLAY_NONERROR_FEEDBACK="f"
    else
        func_mmmv_assert_sbvar_domain_t_f_t1 \
            "$SB_DISPLAY_NONERROR_FEEDBACK" "SB_DISPLAY_NONERROR_FEEDBACK" \
            "306af0a5-21da-4d98-a876-03622141a9e7"
    fi
    #----------------------------------------------------------------------
    local S_FP_WINE_HOME="$HOME/.wine"
    local S_FP_C="$S_FP_WINE_HOME/drive_c"
    local SB_OPTIONAL_BAN_SYMLINKS="f"
    local SB_OK_TO_CACHE="t"
    #----------------------------------------------------------------------
    if [ ! -d "$S_FP_C" ]; then # for speed optimisation
        if [ ! -e "$S_FP_C" ]; then
            #--------------------------------------------------------------
            if [ ! -e "$S_FP_WINE_HOME" ]; then
                # The if-clause at the next line is to improve error messages.
                if [ -h "$S_FP_WINE_HOME" ]; then # a broken symlink
                    func_mmmv_assert_folder_exists_t1 "$S_FP_WINE_HOME" \
                        "7c713248-41b7-4b02-8276-03622141a9e7" \
                        "$SB_OPTIONAL_BAN_SYMLINKS"
                fi
            fi
            if [ -h "$S_FP_C" ]; then # a broken symlink
                func_mmmv_assert_folder_exists_t1 "$S_FP_C" \
                    "e2ccfa5e-01b4-4547-b566-03622141a9e7" \
                    "$SB_OPTIONAL_BAN_SYMLINKS"
            fi
            #--------------------------------------------------------------
            if [ "$SB_DISPLAY_NONERROR_FEEDBACK" == "t" ]; then
                echo -e "Starting to create \"\e[33m$S_FP_C\e[39m\" by using wine ..."
            fi
            func_mmmv_assert_exists_on_path_t1 "wine"
            if [ "$SB_DISPLAY_NONERROR_FEEDBACK" == "t" ]; then
                echo "Wine dialogs use GUI."
            fi
            SB_OK_TO_CACHE="t" # domain: {"t","f",""}; default: "" -> "f"
            func_mmmv_assert_GUI_applications_can_be_launched_t1 \
                "cd4255fa-34b9-4187-9466-03622141a9e7" \
                "$SB_OK_TO_CACHE" "$SB_DISPLAY_NONERROR_FEEDBACK"
            if [ "$SB_DISPLAY_NONERROR_FEEDBACK" == "t" ]; then
                echo -e "Creating the \"\e[33m$S_FP_C\e[39m\" and executing the "
                echo -e "Wine version of \"\e[33mC:\\windows\\system32\\hostname.exe\e[39m\" ..."
            fi
            if [ "$SB_DISPLAY_NONERROR_FEEDBACK" == "t" ]; then
                nice -n 5 wine 'hostname' # creates ~/.wine/drive_c and
                                          # executes C:\windows\system32\hostname.exe
            else
                # The redirection part of the
                nice -n 5 wine 'hostname' 2> /dev/null 1> /dev/null
                # has been tested to work on both, Linux and FreeBSD.
            fi
            func_mmmv_assert_error_code_zero_t1 "$?" \
                "45db06cb-fcb5-4c11-9366-03622141a9e7"
            func_mmmv_wait_and_sync_t1
            func_mmmv_assert_folder_exists_t1 "$S_FP_C" \
                "41777511-88c6-49ad-9566-03622141a9e7" \
                "$SB_OPTIONAL_BAN_SYMLINKS"
            if [ "$SB_DISPLAY_NONERROR_FEEDBACK" == "t" ]; then
                echo -e "Creation of \"$S_FP_C\"\e[32m complete\e[39m." ; wait;
            fi
            #--------------------------------------------------------------
        else
            #--------------------------------------------------------------
            func_mmmv_assert_folder_exists_t1 "$S_FP_C" \
                "a854271c-fab1-48a2-b466-03622141a9e7" \
                "$SB_OPTIONAL_BAN_SYMLINKS"
            #--------------------------------------------------------------
        fi
    fi
    #----------------------------------------------------------------------
} # func_mmmv_exc_initialize_wine_C_drive_if_needed_t1

#--------------------------------------------------------------------------

S_FP_PARENT_FOLDER="$S_FP_DIR"  # will be overwritten by the
func_mmmv_uncompress_tar_dot_foo_and_enter_t2(){
    # differs from the func_mmmv_uncompress_tar_dot_foo_and_enter_t1
    # by supporting Foo.zip files in stead of Foo.tar.zip files.
    #----------------------------------------
    local S_FN_FOLDER_NAME="$1"
    local S_FILE_EXTENSION_OF_A_COMPRESSED_FILE="$2"
    local SB_COMPRESSED_FILE_WRAPS_A_SINGLE_TARFILE="$3" # Optional.
                                                         # Domain: {"t","f","",<unassigned>}.
                                                         # default=="t" id est         "" -> "t"
                                                         #              and  <unassigned> -> "t"
    #----------------------------------------
    local SB_TAR_WRAPPED="t" # the default
    if [ "$SB_COMPRESSED_FILE_WRAPS_A_SINGLE_TARFILE" != "" ]; then
        func_mmmv_assert_sbvar_domain_t_f_t1 \
            "$SB_COMPRESSED_FILE_WRAPS_A_SINGLE_TARFILE" \
            "SB_COMPRESSED_FILE_WRAPS_A_SINGLE_TARFILE" \
            "421ae102-916e-406e-8c66-03622141a9e7"
        SB_TAR_WRAPPED="$SB_COMPRESSED_FILE_WRAPS_A_SINGLE_TARFILE"
    fi
    #----------------------------------------
    local SB_COMPRESSION_TYPE_RECOGNIZED="f"
    local S_CMD_NICE_PREFIX="nice -n 5 "
    local S_CMD_UNCOMPRESS="not_set"
    local S_CMD_UNCOMPRESS_CANDIDATE="not_set"
    local SB_COMPRESSIONLESS_TAR="f"
    #----------------------------------------
    #if [ "$SB_COMPRESSION_TYPE_RECOGNIZED" == "f" ]; then
        if [ "`printf \"$S_FILE_EXTENSION_OF_A_COMPRESSED_FILE\" | tr '[:upper:]' '[:lower:]' `" == "tar" ]; then
            SB_COMPRESSIONLESS_TAR="t"
            SB_COMPRESSION_TYPE_RECOGNIZED="t"
        fi
    #fi
    #----------------------------------------
    if [ "$SB_COMPRESSION_TYPE_RECOGNIZED" == "f" ]; then
        #------------------------------
        S_CMD_UNCOMPRESS_CANDIDATE="$S_CMD_NICE_PREFIX plzip --decompress "
        if [ "$MMMV_USERSPACE_DISTRO_T1_SI_N_OF_COMPILATION_THREADS_T1" != "" ]; then
            S_CMD_UNCOMPRESS_CANDIDATE="$S_CMD_UNCOMPRESS_CANDIDATE --threads=$MMMV_USERSPACE_DISTRO_T1_SI_N_OF_COMPILATION_THREADS_T1 "
        fi
        #------------------------------
        if [ "`printf \"$S_FILE_EXTENSION_OF_A_COMPRESSED_FILE\" | tr '[:upper:]' '[:lower:]' `" == "lz" ]; then
            S_CMD_UNCOMPRESS="$S_CMD_UNCOMPRESS_CANDIDATE "
            SB_COMPRESSION_TYPE_RECOGNIZED="t"
        else
            if [ "`printf \"$S_FILE_EXTENSION_OF_A_COMPRESSED_FILE\" | tr '[:upper:]' '[:lower:]' `" == "tlz" ]; then
                S_CMD_UNCOMPRESS="$S_CMD_UNCOMPRESS_CANDIDATE  "
                SB_COMPRESSION_TYPE_RECOGNIZED="t"
            fi
        fi
    fi
    #----------------------------------------
    if [ "$SB_COMPRESSION_TYPE_RECOGNIZED" == "f" ]; then
        if [ "`printf \"$S_FILE_EXTENSION_OF_A_COMPRESSED_FILE\" | tr '[:upper:]' '[:lower:]' `" == "7z" ]; then
            S_CMD_UNCOMPRESS="$S_CMD_NICE_PREFIX 7z x " # The "x" is not a typo.
            SB_COMPRESSION_TYPE_RECOGNIZED="t"
        else
            if [ "`printf \"$S_FILE_EXTENSION_OF_A_COMPRESSED_FILE\" | tr '[:upper:]' '[:lower:]' `" == "t7z" ]; then
                S_CMD_UNCOMPRESS="$S_CMD_NICE_PREFIX 7z x " # The "x" is not a typo.
                SB_COMPRESSION_TYPE_RECOGNIZED="t"
            fi
        fi
    fi
    #----------------------------------------
    if [ "$SB_COMPRESSION_TYPE_RECOGNIZED" == "f" ]; then
        if [ "`printf \"$S_FILE_EXTENSION_OF_A_COMPRESSED_FILE\" | tr '[:upper:]' '[:lower:]' `" == "xz" ]; then
            S_CMD_UNCOMPRESS="$S_CMD_NICE_PREFIX unxz "
            SB_COMPRESSION_TYPE_RECOGNIZED="t"
        else
            if [ "`printf \"$S_FILE_EXTENSION_OF_A_COMPRESSED_FILE\" | tr '[:upper:]' '[:lower:]' `" == "txz" ]; then
                S_CMD_UNCOMPRESS="$S_CMD_NICE_PREFIX unxz "
                SB_COMPRESSION_TYPE_RECOGNIZED="t"
            fi
        fi
    fi
    #----------------------------------------
    if [ "$SB_COMPRESSION_TYPE_RECOGNIZED" == "f" ]; then
        if [ "`printf \"$S_FILE_EXTENSION_OF_A_COMPRESSED_FILE\" | tr '[:upper:]' '[:lower:]' `" == "gz" ]; then
            S_CMD_UNCOMPRESS="$S_CMD_NICE_PREFIX gunzip "
            SB_COMPRESSION_TYPE_RECOGNIZED="t"
        else
            if [ "`printf \"$S_FILE_EXTENSION_OF_A_COMPRESSED_FILE\" | tr '[:upper:]' '[:lower:]' `" == "tgz" ]; then
                S_CMD_UNCOMPRESS="$S_CMD_NICE_PREFIX gunzip "
                SB_COMPRESSION_TYPE_RECOGNIZED="t"
            fi
        fi
    fi
    #----------------------------------------
    if [ "$SB_COMPRESSION_TYPE_RECOGNIZED" == "f" ]; then
        if [ "`printf \"$S_FILE_EXTENSION_OF_A_COMPRESSED_FILE\" | tr '[:upper:]' '[:lower:]' `" == "bz2" ]; then
            S_CMD_UNCOMPRESS="$S_CMD_NICE_PREFIX bunzip2 "
            SB_COMPRESSION_TYPE_RECOGNIZED="t"
        else
            if [ "`printf \"$S_FILE_EXTENSION_OF_A_COMPRESSED_FILE\" | tr '[:upper:]' '[:lower:]' `" == "tbz2" ]; then
                S_CMD_UNCOMPRESS="$S_CMD_NICE_PREFIX bunzip2 "
                SB_COMPRESSION_TYPE_RECOGNIZED="t"
            fi
        fi
    fi
    #----------------------------------------
    local SB_MODE_ZIP="f"
    if [ "$SB_COMPRESSION_TYPE_RECOGNIZED" == "f" ]; then
        if [ "`printf \"$S_FILE_EXTENSION_OF_A_COMPRESSED_FILE\" | tr '[:upper:]' '[:lower:]' `" == "zip" ]; then
            S_CMD_UNCOMPRESS="$S_CMD_NICE_PREFIX unzip "
            SB_COMPRESSION_TYPE_RECOGNIZED="t"
            SB_MODE_ZIP="t"
        fi
    fi
    #----------------------------------------
    if [ "$SB_COMPRESSION_TYPE_RECOGNIZED" == "f" ]; then
        if [ "`printf \"$S_FILE_EXTENSION_OF_A_COMPRESSED_FILE\" | tr '[:upper:]' '[:lower:]' `" == "rar" ]; then
            S_CMD_UNCOMPRESS="$S_CMD_NICE_PREFIX unrar x " # The "x" is not a typo
            SB_COMPRESSION_TYPE_RECOGNIZED="t"
        else
            if [ "`printf \"$S_FILE_EXTENSION_OF_A_COMPRESSED_FILE\" | tr '[:upper:]' '[:lower:]' `" == "trar" ]; then
                S_CMD_UNCOMPRESS="$S_CMD_NICE_PREFIX unrar x " # The "x" is not a typo
                SB_COMPRESSION_TYPE_RECOGNIZED="t"
            fi
        fi
    fi
    #----------------------------------------
    if [ "$SB_COMPRESSION_TYPE_RECOGNIZED" == "f" ]; then
        if [ "`printf \"$S_FILE_EXTENSION_OF_A_COMPRESSED_FILE\" | tr '[:upper:]' '[:lower:]' `" == "xar" ]; then
            S_CMD_UNCOMPRESS="$S_CMD_NICE_PREFIX xar -xf "
            SB_COMPRESSION_TYPE_RECOGNIZED="t"
        else
            if [ "`printf \"$S_FILE_EXTENSION_OF_A_COMPRESSED_FILE\" | tr '[:upper:]' '[:lower:]' `" == "txar" ]; then
                S_CMD_UNCOMPRESS="$S_CMD_NICE_PREFIX xar -xf "
                SB_COMPRESSION_TYPE_RECOGNIZED="t"
            fi
        fi
    fi
    #----------------------------------------
    if [ "$SB_COMPRESSION_TYPE_RECOGNIZED" != "t" ]; then
        echo ""
        echo "Failed to recognize compression type."
        echo "Aborting script."
        echo "GUID=='10db3650-33d0-4a90-a3e5-03622141a9e7'"
        echo ""
        #--------
        cd "$S_FP_ORIG"
        exit 1 # exiting with an error
    fi
    #----------------------------------------
    func_mmmv_assert_folder_exists_t1 "$S_FP_PARENT_FOLDER" \
        "ff9e483f-9631-43f0-8266-03622141a9e7"
    cd $S_FP_PARENT_FOLDER
    func_mmmv_assert_error_code_zero_t1 "$?" \
        "9199a5f2-96e1-4277-8366-03622141a9e7"
    #----------------------------------------
    local S_FP_NEXT_PARENT_FOLDER="$S_FP_PARENT_FOLDER/$S_FN_FOLDER_NAME"
    local S_TMP_0=".tar"
    local S_FP_TAR="$S_FP_NEXT_PARENT_FOLDER$S_TMP_0"
    S_TMP_0=".$S_FILE_EXTENSION_OF_A_COMPRESSED_FILE"
    local S_FP_COMPRESSED="$S_FP_TAR$S_TMP_0"
    #----------------------------------------
    if [ "$SB_TAR_WRAPPED" == "t" ]; then
        #----------------------------------------
        if [ "$SB_COMPRESSIONLESS_TAR" == "f" ]; then
            func_mmmv_assert_file_exists_t1 "$S_FP_COMPRESSED" \
                "a705371f-aab3-498e-9266-03622141a9e7"
            #--------
            if [ "$SB_MODE_ZIP" == "t" ]; then
                $S_CMD_NICE_PREFIX  zip --test $S_FP_COMPRESSED
                func_mmmv_assert_error_code_zero_t1 "$?" \
                    "10a56445-ee12-4edd-8166-03622141a9e7"
            fi
            #--------
            $S_CMD_UNCOMPRESS $S_FP_COMPRESSED
            func_mmmv_assert_error_code_zero_t1 "$?" \
                "37ad6320-1339-4c48-9466-03622141a9e7"
            func_mmmv_wait_and_sync_t1
        fi
        #----------------------------------------
        func_mmmv_assert_file_exists_t1 "$S_FP_TAR" \
            "5d36f413-3a82-4bf9-9b66-03622141a9e7"
        $S_CMD_NICE_PREFIX tar -xf $S_FP_TAR
        func_mmmv_assert_error_code_zero_t1 "$?" \
            "b64b175a-ca5f-4621-9366-03622141a9e7"
        func_mmmv_wait_and_sync_t1
        #----------------------------------------
    else
        #----------------------------------------
        # The next line
        S_FP_COMPRESSED="$S_FP_NEXT_PARENT_FOLDER.$S_FILE_EXTENSION_OF_A_COMPRESSED_FILE"
        # takes to account the different
        # cases, like ".zip",".ZIP" and ".tGz", ".TGZ", etc.
        #----------------------------------------
        func_mmmv_assert_file_exists_t1 "$S_FP_COMPRESSED" \
            "41a5ff54-f193-4a59-9156-03622141a9e7"
        #--------
        if [ "$SB_MODE_ZIP" == "t" ]; then
            $S_CMD_NICE_PREFIX  zip --test $S_FP_COMPRESSED
            func_mmmv_assert_error_code_zero_t1 "$?" \
                "5047b62e-856a-47db-b456-03622141a9e7"
        fi
        #--------
        $S_CMD_UNCOMPRESS $S_FP_COMPRESSED
        func_mmmv_assert_error_code_zero_t1 "$?" \
            "ddc26cd1-d940-44dc-ba56-03622141a9e7"
        func_mmmv_wait_and_sync_t1
        #----------------------------------------
    fi
    #----------------------------------------
    func_mmmv_assert_folder_exists_t1 "$S_FP_NEXT_PARENT_FOLDER" \
        "53146c5e-3e64-47df-b356-03622141a9e7"
    S_FP_PARENT_FOLDER="$S_FP_NEXT_PARENT_FOLDER"
    #----------------------------------------
} # func_mmmv_uncompress_tar_dot_foo_and_enter_t2

#--------------------------------------------------------------------------

S_OWNER="to_be_determined"
func_mmmv_s_owner_of_a_file_or_folder_t1(){
    local S_FP_IN="$1" # file or directory
    #----------------------------------------------------------------------
    # According to the
    #     https://unix.stackexchange.com/questions/7730/find-the-owner-of-a-directory-or-file-but-only-return-that-and-nothing-else
    #     archival copy: https://archive.ph/QqssI
    # the solutions are:
    #     Linux, GNU coreutils (tested to work also on WSL):
    #         stat -c '%U' /path/of/file/or/directory
    #     FreeBSD:
    #         stat -f '%Su' /path/of/file/or/directory
    #     General solution that works on Linux and FreeBSD:
    #         ls -ld /path/of/file/or/directory | awk '{print $3}'
    #----------------------------------------------------------------------
    S_OWNER=""
    #----------------------------------------------------------------------
    if [ ! -e "$S_FP_IN" ]; then
        if [ -h "$S_FP_IN" ]; then
            func_mmmv_exc_exit_with_an_error_t2 \
                "ec96e82d-037b-4c75-8456-03622141a9e7" \
                "The $S_FP_IN is a broken symlink."
        else
            func_mmmv_exc_exit_with_an_error_t2 \
                "563d62bd-1452-4e6b-8a56-03622141a9e7" \
                "The file or folder(==$S_FP_IN ) does not exist."
        fi
    fi
    #----------------------------------------------------------------------
    if [ "$SB_STAT_EXISTS_ON_PATH" == "t" ]; then
        # This is a speedhack branch that
        # takes advantage of the mmmv_userspace_distro_t1
        #     https://github.com/martinvahi/mmmv_userspace_distro_t1
        #     https://sourceforge.net/projects/mmmv-userspace-distro-t1/
        if [ "$SB_OPERATINGSYSTEM_LINUX" == "t" ]; then
            S_OWNER="`stat -c '%U' \"$S_FP_IN\" `"
        else
            if [ "$SB_OPERATINGSYSTEM_BSD_FREEBSD" == "t" ]; then
                S_OWNER="`stat -f '%Su' \"$S_FP_IN\" `"
            fi
        fi
    fi
    #--------
    if [ "$S_OWNER" == "" ]; then
        func_mmmv_exc_determine_Awk_command_t1 # sets the value of S_AWK_CMD
        if [ "$SB_AWK_EXISTS_ON_PATH" != "t" ]; then
            func_mmmv_exit_if_not_on_path_t2 "$S_AWK_CMD"
        fi
        #--------
        # The next line, if uncommented,
        #     S_OWNER="`ls -ld \"$S_FP_IN\" | awk '{print $3}' `"
        # has been tested to work on both, Linux and FreeBSD.
        #--------
        S_OWNER="`ls -ld \"$S_FP_IN\" | $S_AWK_CMD '{print $3}' `"
    fi
    #----------------------------------------------------------------------
} # func_mmmv_s_owner_of_a_file_or_folder_t1

#--------------------------------------------------------------------------

S_FP_DEVICE_FILE="not_yet_initialised"
# Throws if if a block device with the given block device ID candidate
# does not exist. Otherwise sets the S_FP_DEVICE_FILE.
func_mmmv_exc_block_device_ID_to_device_file_name_t1(){ #
    local S_BLOCK_DEVICE_ID_SUBPART_CANDIDATE="$1"
    local S_GUID_CANDIDATE="$2"
    #----------------------------------------------------------------------
    func_mmmv_exc_verify_S_FP_ORIG_t1
    #----------------------------------------------------------------------
    if [ "$S_GUID_CANDIDATE" == "" ]; then
        echo ""
        echo -e "\e[31mThe Bash code that calls this function is flawed \e[39m."
        echo ""
        echo "    S_GUID_CANDIDATE==\"\""
        echo ""
        echo "but it is expected to be a GUID."
        echo "Aborting script."
        echo "GUID=='1532d834-6dac-4a0c-8ce5-03622141a9e7'"
        echo ""
        #--------
        cd "$S_FP_ORIG"
        exit 1
    fi
    #----------------------------------------------------------------------
    if [ "$S_BLOCK_DEVICE_ID_SUBPART_CANDIDATE" == "" ]; then
        echo ""
        echo -e "\e[31mThe Bash code that calls this function is flawed \e[39m."
        echo ""
        echo "    S_BLOCK_DEVICE_ID_SUBPART_CANDIDATE==\"\""
        echo ""
        echo "but it is expected to be non-empty string "
        echo "that is a  subpart of a GUID."
        echo "Aborting script."
        echo "GUID=='31854c72-ccd9-4722-89e5-03622141a9e7'"
        echo "S_GUID_CANDIDATE==\"$S_GUID_CANDIDATE\""
        echo ""
        #--------
        cd "$S_FP_ORIG"
        exit 1
    fi
    #----------------------------------------------------------------------
    func_mmmv_operatingsystem_is_Linux "S_TMP_0"
    if [ "$S_TMP_0" != "t" ]; then
        echo ""
        echo -e "\e[31mThis function is meant to be used only on Linux\e[39m,"
        echo "because the program \"blkid\" is Linux specific."
        echo "Aborting script."
        echo "GUID=='2b28b785-5e73-4b7c-a1e5-03622141a9e7'"
        echo "S_GUID_CANDIDATE==\"$S_GUID_CANDIDATE\""
        echo ""
        #--------
        cd "$S_FP_ORIG"
        exit 1
        # TODO: Upgrade this function to work with BSD.
        #       However, it might not be as trivial as it is with Linux.
        #       https://unix.stackexchange.com/questions/175814/list-connected-storage-devices-in-freebsd
        #       archival copy: https://archive.is/bfXke
    fi
    #----------------------------------------------------------------------
    # The core of this function:
    #     blkid | grep '6dd2a4' | grep -E '^[/]dev[/]' | gsed -e 's/:.\+$//g'
    #----------------------------------------------------------------------
    # The
    func_mmmv_exit_if_not_on_path_t2 "blkid"
    # will not throw on Windows Subsystem for Linux version 2 (WSL2),
    # because the WSL has the "blkid" on the PATH. It just
    # shows an empty list on the WSL2, which
    # is not necessarily a flaw in the current context.
    #----------------------------------------
    func_mmmv_exit_if_not_on_path_t2 "grep"
    func_mmmv_exc_determine_sed_command_t1
    #----------------------------------------------------------------------
    S_FP_DEVICE_FILE="`blkid | grep \"$S_BLOCK_DEVICE_ID_SUBPART_CANDIDATE\" | grep -E '^[/]dev[/]' | $S_SED_CMD -e 's/:.\\+\$//g' `"
    if [ "$S_FP_DEVICE_FILE" == "" ]; then
        echo ""
        echo "A block device with an ID of "
        echo ""
        echo -e "    S_BLOCK_DEVICE_ID_SUBPART_CANDIDATE=\"\e[31m$S_BLOCK_DEVICE_ID_SUBPART_CANDIDATE\e[39m\" "
        echo ""
        echo -e "\e[31mcould not be found\e[39m."
        echo "Aborting script."
        echo "GUID=='d2f37d13-b356-407e-a1e5-03622141a9e7'"
        echo "S_GUID_CANDIDATE==\"$S_GUID_CANDIDATE\""
        echo ""
        #--------
        cd "$S_FP_ORIG"
        exit 1
    fi
    #----------------------------------------------------------------------
} # func_mmmv_exc_block_device_ID_to_device_file_name_t1

#--------------------------------------------------------------------------

func_delete_folder_of_build_folders(){
    #----------------------------------------------------------------------
    local SB_OPTIONAL_BAN_SYMLINKS="t"
    func_mmmv_assert_folder_exists_t1 "$S_FP_FOLDER_OF_BUILD_FOLDERS" \
        "5f003813-409b-48d9-8356-03622141a9e7" \
        "$SB_OPTIONAL_BAN_SYMLINKS"
    #------------------------------
    local S_FP_DELETABLE="$S_FP_DIR/subject_to_deletion_0_$S_TIMESTAMP"
    if [ -e "$S_FP_DELETABLE" ]; then
        echo ""
        echo -e "\e[31mThis Bash script is flawed \e[39m."
        echo ""
        echo "    S_FP_DELETABLE==\"$S_FP_DELETABLE\""
        echo ""
        echo "GUID=='4947c679-02af-433f-b3a5-03622141a9e7'"
        echo ""
        #------------------------------
        cd "$S_FP_ORIG"
        exit 1
    else
        if [ -h "$S_FP_DELETABLE" ]; then # a broken symlink here
            echo ""
            echo -e "\e[31mThis Bash script is flawed \e[39m."
            echo ""
            echo "    S_FP_DELETABLE==\"$S_FP_DELETABLE\""
            echo ""
            echo "GUID=='a9076648-a13c-4e79-a5a5-03622141a9e7'"
            echo ""
            #------------------------------
            cd "$S_FP_ORIG"
            exit 1
        fi
    fi
    #------------------------------
    local S_TMP_0="`echo \"$S_FP_FOLDER_OF_BUILD_FOLDERS\" | grep -E '/temporary_build_folder$' `"
    if [ "$S_TMP_0" != "" ]; then # for safety
        mv $S_FP_FOLDER_OF_BUILD_FOLDERS $S_FP_DELETABLE
        func_mmmv_assert_error_code_zero_t1 "$?" \
            "14d12772-cd04-4c58-a456-03622141a9e7"
        func_mmmv_wait_and_sync_t1
        rm -fr "$S_FP_DELETABLE" &
    else
        echo ""
        echo -e "\e[31mThis Bash script is flawed \e[39m."
        echo ""
        echo "    S_FP_FOLDER_OF_BUILD_FOLDERS==\"$S_FP_FOLDER_OF_BUILD_FOLDERS\""
        echo ""
        echo "GUID=='27e519c1-2577-4dcd-b1a5-03622141a9e7'"
        echo ""
        #------------------------------
        cd "$S_FP_ORIG"
        exit 1
    fi
    #----------------------------------------------------------------------
} # func_delete_folder_of_build_folders

#--------------------------------------------------------------------------

func_first_use_message(){
    echo ""
    echo -e "\e[33mPlease customise this script to Your needs.\e[39m"
    echo "GUID=='97ccc741-6382-49ee-a3a5-03622141a9e7'"
    echo ""
    #------------------------------
    cd "$S_FP_ORIG"
    exit 1
    #------------------------------
} # func_first_use_message

#--------------------------------------------------------------------------

func_display_help_message(){
    echo ""
    echo -e "This script does not take any command line arguments. This script generates"
    echo -e "a set of HTML files to the working directory (\$PWD). The list of files"
    echo -e "and/or folders at the generated HTML has been obtained by processing the"
    echo -e "output of the"
    echo -e "\e[36m"
    echo -e "    find . "
    echo -e "\e[39m"
    echo "Thank You for trying out this script. "
    echo "GUID=='f4b94f4c-b80f-4d7b-8195-03622141a9e7'"
    echo ""
} # func_display_help_message

#--------------------------------------------------------------------------

S_CMD_GNU_AWK="awk"
S_CMD_GNU_MAKE="make"
S_CMD_GNU_SED="sed"
func_check_for_some_dependencies(){
    #----------------------------------------------------------------------
    #func_mmmv_assert_exists_on_path_t1 "ar"
    #func_mmmv_assert_exists_on_path_t1 "bc" # different programs on BSD and Linux
    func_mmmv_assert_exists_on_path_t1 "cat"
    func_mmmv_assert_exists_on_path_t1 "grep"
    #func_mmmv_assert_exists_on_path_t1 "huniq"
    func_mmmv_assert_exists_on_path_t1 "find"
    #func_mmmv_assert_exists_on_path_t1 "flex"
    #func_mmmv_assert_exists_on_path_t1 "ranlib"
    #func_mmmv_assert_exists_on_path_t1 "replace" # part of the MariaDB project
    func_mmmv_assert_exists_on_path_t1 "sort"
    #func_mmmv_assert_exists_on_path_t1 "tee"
    #func_mmmv_assert_exists_on_path_t1 "tr" # different programs on BSD and Linux
    #func_mmmv_assert_exists_on_path_t1 "uniq"
    #func_mmmv_assert_exists_on_path_t1 "xargs"
    #------------------------------
    #func_mmmv_assert_exists_on_path_t1 "7z"      # .7z
    #func_mmmv_assert_exists_on_path_t1 "arj"     # .arj
    #func_mmmv_assert_exists_on_path_t1 "bunzip2" # .bz2
    #func_mmmv_assert_exists_on_path_t1 "gunzip"  # .gz
    #func_mmmv_assert_exists_on_path_t1 "plzip"   # .lz .tlz
    #func_mmmv_assert_exists_on_path_t1 "tar"     # .tar
    #func_mmmv_assert_exists_on_path_t1 "unxz"    # .xz
    #func_mmmv_assert_exists_on_path_t1 "unzip"    # .zip
    #func_mmmv_assert_exists_on_path_t1 "unrar"   # .rar
    #func_mmmv_assert_exists_on_path_t1 "unzstd"
    #func_mmmv_assert_exists_on_path_t1 "xar"     # .xar
    #func_mmmv_assert_exists_on_path_t1 "zip"      # .zip
    #func_mmmv_assert_exists_on_path_t1 "zstd"
    #func_mmmv_assert_exists_on_path_t1 "zstdcat"
    #func_mmmv_assert_exists_on_path_t1 "wget"
    #------------------------------
    #func_mmmv_assert_exists_on_path_t1 "ant"    # Ant is a Java build tool
    #func_mmmv_assert_exists_on_path_t1 "cargo"  # Rust package system
    #func_mmmv_assert_exists_on_path_t1 "fpc"    # FreePascal
    #func_mmmv_assert_exists_on_path_t1 "gem"    # Ruby package system
    #func_mmmv_assert_exists_on_path_t1 "gradle" # Java build tool
    #func_mmmv_assert_exists_on_path_t1 "jam"    # Make analogue
    #func_mmmv_assert_exists_on_path_t1 "java"
    #func_mmmv_assert_exists_on_path_t1 "javac"
    #func_mmmv_assert_exists_on_path_t1 "lazbuild" # Lazarus IDE specific Make analogue
    #func_mmmv_assert_exists_on_path_t1 "lazarus-ide" # FreePascal GUI library and a related IDE
    #func_mmmv_assert_exists_on_path_t1 "make"    # GNU Make and BSD Make differ
    #func_mmmv_assert_exists_on_path_t1 "mvn"    # Maven is a Java build tool
    #func_mmmv_assert_exists_on_path_t1 "perl"
    #func_mmmv_assert_exists_on_path_t1 "python"
    #func_mmmv_assert_exists_on_path_t1 "python3"
    #func_mmmv_assert_exists_on_path_t1 "qmake" # Qt specific build tool
    #func_mmmv_assert_exists_on_path_t1 "rake"  # Make analogue for Ruby applications
    #func_mmmv_assert_exists_on_path_t1 "ruby"
    #func_mmmv_assert_exists_on_path_t1 "rustc"
    #----------------------------------------------------------------------
    # The test for the availability of grep is
    # expected to be somewhere above this line.
    if [ "`uname -a | grep -i 'BSD' `" != '' ]; then
        S_CMD_GNU_AWK="gawk"
        S_CMD_GNU_MAKE="gmake"
        S_CMD_GNU_SED="gsed"
    fi
    #func_mmmv_assert_exists_on_path_t1 "$S_CMD_GNU_AWK"
    #func_mmmv_assert_exists_on_path_t1 "$S_CMD_GNU_MAKE"
    func_mmmv_assert_exists_on_path_t1 "$S_CMD_GNU_SED"
    #----------------------------------------------------------------------
} # func_check_for_some_dependencies

#--------------------------------------------------------------------------
S_ARGV_0="$1" # Bash style command line argument indices versus
              # Ruby style command line argument indices.

func_display_help_message_and_exit_if_needed(){
    #----------------------------------------------------------------------
    func_mmmv_assert_exists_on_path_t1 "grep"
    #------------------------------
    local SB_0="f"
    if [ "$S_ARGV_0" != "" ]; then
        if [ "`echo \"$S_ARGV_0\" | grep -E '^((([-][-]?)?[hH][eE][lL][pP])|([-]?[hH?]))$' `" == "" ]; then
            echo ""
            echo -e "\e[31mUnsupported \e[39mcommand line argument: \"\e[31m$S_ARGV_0\e[39m\""
            echo "GUID=='04740d47-401a-4e9a-8395-03622141a9e7'"
            echo "The only command line argument that is supported is \"help\", which"
            echo "does nothing other than display the following message:"
            func_display_help_message
            #--------
            cd "$S_FP_ORIG"
            exit 1
        else
            SB_0="t"
        fi
    fi
    if [ "$SB_0" == "t" ]; then
        func_display_help_message
        #--------
        cd "$S_FP_ORIG"
        exit 0
    fi
    #----------------------------------------------------------------------
} # func_display_help_message_and_exit_if_needed

#--------------------------------------------------------------------------

func_ls_t1_list_of_files_and_folders_sorted_alphabetically(){
    local S_FP_FOLDER="$1"
    #----------------------------------------------------------------------
    local S_INITIAL_PWD="`pwd`"
    func_mmmv_assert_folder_exists_t1 "$S_FP_FOLDER" \
        "681c9257-a6da-4b3d-8156-03622141a9e7"
    cd $S_FP_FOLDER # to at least partly test access
    func_mmmv_assert_error_code_zero_t1 "$?" \
        "0d22e42a-3ef6-446a-9146-03622141a9e7"
    #------------------------------
    if [ "$S_CMD_PREFIX_NICE" == "" ]; then
        echo ""
        echo "This function is probably fine, but "
        echo -e "\e[31mthis Bash script is flawed \e[39m."
        echo "GUID=='0fe42b47-f0d6-486a-9595-03622141a9e7'"
        echo ""
        #--------
        cd "$S_FP_ORIG"
        exit 1
    fi
    #----------------------------------------------------------------------
    local S_FN="index.html"
    local S_TMP_0="/$S_FN"
    local S_FP="$S_FP_FOLDER$S_TMP_0"
    local SB_OPTIONAL_BAN_SYMLINKS="t"
    if [ -e "$S_FP" ]; then
        func_mmmv_assert_file_exists_t1 "$S_FP" \
            "190cd75c-7e8d-455d-9546-03622141a9e7" \
            "$SB_OPTIONAL_BAN_SYMLINKS"
        #--------
        S_TMP_0="`nice -n 2 cat $S_FP | grep ' MMMV_TAG_THIS_FILE_HAS_BEEN_AUTOGENERATED_T1 '`"
        if [ "$S_TMP_0" == "" ]; then
            echo ""
            echo "The file "
            echo ""
            echo "    $S_FP"
            echo ""
            echo -e "exists, but it\e[31m does not include the string \e[39m"
            echo -e "\"\e[31m MMMV_TAG_THIS_FILE_HAS_BEEN_AUTOGENERATED_T1 \e[39m\"."
            echo "Quotation marks around it are not required, but"
            echo "at least one space at each side of it is compulsory."
            echo "Not overwriting the file. Aborting script."
            echo "GUID=='a19db41b-dbf8-4e44-9395-03622141a9e7'"
            echo ""
            #--------
            cd "$S_FP_ORIG"
            exit 1
        fi
        #--------
        rm -f "$S_FP"
        func_mmmv_assert_error_code_zero_t1 "$?" \
            "1f8710a4-9130-433d-8a46-03622141a9e7"
        func_mmmv_wait_and_sync_t1
    else
        if [ -h "$S_FP" ]; then # a broken symlink
            rm -f "$S_FP"
            func_mmmv_assert_error_code_zero_t1 "$?" \
                "ac378e2d-bfa8-424b-b346-03622141a9e7"
            func_mmmv_wait_and_sync_t1
        fi
    fi
    #------------------------------
    if [ ! -e "$S_FP" ]; then
        printf '<!DOCTYPE HTML>\n<html>\n<head>\n<title>ls</title>\n<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">\n<!-- MMMV_TAG_THIS_FILE_HAS_BEEN_AUTOGENERATED_T1 -->\n</head>\n<body id="the_document_body">\n<h1>ls</h1>\n<ul>\n    <li>\n        <a href="./../">..</a>\n    </li>\n' > $S_FP
        func_mmmv_assert_error_code_zero_t1 "$?" \
            "56de6984-a367-4588-a546-03622141a9e7"
        func_mmmv_wait_and_sync_t1
        $S_CMD_PREFIX_NICE ls -1 | \
            $S_CMD_PREFIX_NICE sort | \
            grep -i -v "$S_FN\$" | \
            $S_CMD_GNU_SED -e 's/\(^.\+$\)/    <li><a href=".\/\1">\1<\/a><\/li>/g' >> $S_FP
        func_mmmv_assert_error_code_zero_t1 "$?" \
            "d6b09f32-6b93-47f4-8146-03622141a9e7"
        func_mmmv_wait_and_sync_t1
        printf '</ul>\n</body>\n</html>\n' >> $S_FP
        func_mmmv_assert_error_code_zero_t1 "$?" \
            "5fb66a1e-9258-4cb3-b546-03622141a9e7"
        func_mmmv_wait_and_sync_t1
        chmod 0700 $S_FP
        func_mmmv_assert_error_code_zero_t1 "$?" \
            "0917cc3b-45c2-461c-8346-03622141a9e7"
        func_mmmv_wait_and_sync_t1
    else
        echo ""
        echo -e "\e[31mThis function is flawed \e[39m."
        echo "A file or a folder with the path of "
        echo ""
        echo "    $S_FP"
        echo ""
        echo -e "\e[31malready exists\e[39m. Not overwriting it."
        echo "GUID=='d2d46e58-9ab4-4239-8395-03622141a9e7'"
        echo ""
        #--------
        cd "$S_FP_ORIG"
        exit 1
    fi
    #----------------------------------------------------------------------
    cd $S_INITIAL_PWD
    func_mmmv_assert_error_code_zero_t1 "$?" \
        "50da6423-5ee1-43dc-b246-03622141a9e7"
    #----------------------------------------------------------------------
} # func_ls_t1_list_of_files_and_folders_sorted_alphabetically

func_ls_t1_files_and_folders(){
    local S_FP_FOLDER="$1"
    func_ls_t1_list_of_files_and_folders_sorted_alphabetically "$S_FP_FOLDER"
} # func_ls_t1_files_and_folders

#--------------------------------------------------------------------------

func_ls_t4_recursive_list_of_files(){
    local S_FP_FOLDER="$1"
    #----------------------------------------------------------------------
    local S_INITIAL_PWD="`pwd`"
    func_mmmv_assert_folder_exists_t1 "$S_FP_FOLDER" \
        "d8b7491d-7a51-4478-8236-03622141a9e7"
    cd $S_FP_FOLDER # to at least partly test access
    func_mmmv_assert_error_code_zero_t1 "$?" \
        "d5299827-4acb-44db-8136-03622141a9e7"
    #------------------------------
    if [ "$S_CMD_PREFIX_NICE" == "" ]; then
        echo ""
        echo "This function is probably fine, but "
        echo -e "\e[31mthis Bash script is flawed \e[39m."
        echo "GUID=='7f9f7052-3d0d-4b40-8395-03622141a9e7'"
        echo ""
        #--------
        cd "$S_FP_ORIG"
        exit 1
    fi
    #----------------------------------------------------------------------
    local S_FN="recursive_list_of_files.html"
    local S_TMP_0="/$S_FN"
    local S_FP="$S_FP_FOLDER$S_TMP_0"
    local SB_OPTIONAL_BAN_SYMLINKS="t"
    if [ -e "$S_FP" ]; then
        func_mmmv_assert_file_exists_t1 "$S_FP" \
            "8c625c4b-3875-4d49-a236-03622141a9e7" \
            "$SB_OPTIONAL_BAN_SYMLINKS"
        #--------
        S_TMP_0="`nice -n 2 cat $S_FP | grep ' MMMV_TAG_THIS_FILE_HAS_BEEN_AUTOGENERATED_T1 '`"
        if [ "$S_TMP_0" == "" ]; then
            echo ""
            echo "The file "
            echo ""
            echo "    $S_FP"
            echo ""
            echo -e "exists, but it\e[31m does not include the string \e[39m"
            echo -e "\"\e[31m MMMV_TAG_THIS_FILE_HAS_BEEN_AUTOGENERATED_T1 \e[39m\"."
            echo "Quotation marks around it are not required, but"
            echo "at least one space at each side of it is compulsory."
            echo "Not overwriting the file. Aborting script."
            echo "GUID=='1e426044-ef0c-42a7-8b95-03622141a9e7'"
            echo ""
            #--------
            cd "$S_FP_ORIG"
            exit 1
        fi
        #--------
        rm -f "$S_FP"
        func_mmmv_assert_error_code_zero_t1 "$?" \
            "6c41002c-05c2-41d5-a436-03622141a9e7"
        func_mmmv_wait_and_sync_t1
    else
        if [ -h "$S_FP" ]; then # a broken symlink
            rm -f "$S_FP"
            func_mmmv_assert_error_code_zero_t1 "$?" \
                "3ba63331-0a94-41e9-bf36-03622141a9e7"
            func_mmmv_wait_and_sync_t1
        fi
    fi
    #------------------------------
    if [ ! -e "$S_FP" ]; then
        $S_CMD_PREFIX_NICE find . -type f | \
            sort | \
            $S_CMD_GNU_SED -e 's/\(^.\+$\)/                <li><a href="\1">\1<\/a><\/li>/g' | \
            $S_CMD_GNU_SED -e '1{s/^/<!DOCTYPE HTML>\n<html>\n    <head>\n        <title>Recursive list of Files<\/title>\n        <meta http-equiv="Content-Type" content="text\/html; charset=UTF-8">\n        <!-- MMMV_TAG_THIS_FILE_HAS_BEEN_AUTOGENERATED_T1 -->\n    <\/head>\n    <body id="the_document_body">\n        <h1>List of Files<\/h1>\n            <ul>\n/g}' | \
            $S_CMD_GNU_SED -e '${s/$/\n            <\/ul>\n            <\/br><\/br>\n    <\/body>\n<\/html>\n/g}' > $S_FP
        func_mmmv_assert_error_code_zero_t1 "$?" \
            "1b79804d-e491-47e4-8136-03622141a9e7"
        func_mmmv_wait_and_sync_t1
        chmod 0700 $S_FP
        func_mmmv_assert_error_code_zero_t1 "$?" \
            "0f55501f-c385-45db-a136-03622141a9e7"
        func_mmmv_wait_and_sync_t1
    else
        echo ""
        echo -e "\e[31mThis function is flawed \e[39m."
        echo "A file or a folder with the path of "
        echo ""
        echo "    $S_FP"
        echo ""
        echo -e "\e[31malready exists\e[39m. Not overwriting it."
        echo "GUID=='420a5ef2-2f11-4ed5-a495-03622141a9e7'"
        echo ""
        #--------
        cd "$S_FP_ORIG"
        exit 1
    fi
    #----------------------------------------------------------------------
    cd $S_INITIAL_PWD
    func_mmmv_assert_error_code_zero_t1 "$?" \
        "1c04c73e-fb49-40d2-9336-03622141a9e7"
    #----------------------------------------------------------------------
} # func_ls_t4_recursive_list_of_files

func_t4_recursive_list_of_all_files(){
    local S_FP_FOLDER="$1"
    func_ls_t4_recursive_list_of_files "$S_FP_FOLDER"
} # func_t4_recursive_list_of_all_files

#--------------------------------------------------------------------------

func_ls_t5_recursive_list_of_folders(){
    local S_FP_FOLDER="$1"
    #----------------------------------------------------------------------
    local S_INITIAL_PWD="`pwd`"
    func_mmmv_assert_folder_exists_t1 "$S_FP_FOLDER" \
        "daa7be19-51aa-4467-9136-03622141a9e7"
    cd $S_FP_FOLDER # to at least partly test access
    func_mmmv_assert_error_code_zero_t1 "$?" \
        "911b2f4e-e9eb-47f7-8236-03622141a9e7"
    #------------------------------
    if [ "$S_CMD_PREFIX_NICE" == "" ]; then
        echo ""
        echo "This function is probably fine, but "
        echo -e "\e[31mthis Bash script is flawed \e[39m."
        echo "GUID=='5ab5d4f4-be0e-461a-b485-03622141a9e7'"
        echo ""
        #--------
        cd "$S_FP_ORIG"
        exit 1
    fi
    #----------------------------------------------------------------------
    local S_FN="recursive_list_of_folders.html"
    local S_TMP_0="/$S_FN"
    local S_FP="$S_FP_FOLDER$S_TMP_0"
    local SB_OPTIONAL_BAN_SYMLINKS="t"
    if [ -e "$S_FP" ]; then
        func_mmmv_assert_file_exists_t1 "$S_FP" \
            "4bfe5e54-4cd1-426b-8536-03622141a9e7" \
            "$SB_OPTIONAL_BAN_SYMLINKS"
        #--------
        S_TMP_0="`nice -n 2 cat $S_FP | grep ' MMMV_TAG_THIS_FILE_HAS_BEEN_AUTOGENERATED_T1 '`"
        if [ "$S_TMP_0" == "" ]; then
            echo ""
            echo "The file "
            echo ""
            echo "    $S_FP"
            echo ""
            echo -e "exists, but it\e[31m does not include the string \e[39m"
            echo -e "\"\e[31m MMMV_TAG_THIS_FILE_HAS_BEEN_AUTOGENERATED_T1 \e[39m\"."
            echo "Quotation marks around it are not required, but"
            echo "at least one space at each side of it is compulsory."
            echo "Not overwriting the file. Aborting script."
            echo "GUID=='76c1b12d-ba06-40f1-9585-03622141a9e7'"
            echo ""
            #--------
            cd "$S_FP_ORIG"
            exit 1
        fi
        #--------
        rm -f "$S_FP"
        func_mmmv_assert_error_code_zero_t1 "$?" \
            "42a46285-2d91-4263-8536-03622141a9e7"
        func_mmmv_wait_and_sync_t1
    else
        if [ -h "$S_FP" ]; then # a broken symlink
            rm -f "$S_FP"
            func_mmmv_assert_error_code_zero_t1 "$?" \
                "001f5d39-8299-4eb3-a226-03622141a9e7"
            func_mmmv_wait_and_sync_t1
        fi
    fi
    #------------------------------
    if [ ! -e "$S_FP" ]; then
        $S_CMD_PREFIX_NICE find . -type d | \
            grep -E -v '^[.]$' | \
            sort | \
            $S_CMD_GNU_SED -e 's/\(^.\+$\)/                <li><a href="\1">\1<\/a><\/li>/g' | \
            $S_CMD_GNU_SED -e '1{s/^/<!DOCTYPE HTML>\n<html>\n    <head>\n        <title>Recursive list of Folders<\/title>\n        <meta http-equiv="Content-Type" content="text\/html; charset=UTF-8">\n        <!-- MMMV_TAG_THIS_FILE_HAS_BEEN_AUTOGENERATED_T1  -->\n    <\/head>\n    <body id="the_document_body">\n        <h1>List of Folders<\/h1>\n            <ul>\n/g}' | \
            $S_CMD_GNU_SED -e '${s/$/\n            <\/ul>\n            <\/br><\/br>\n    <\/body>\n<\/html>\n/g}' > $S_FP
        func_mmmv_assert_error_code_zero_t1 "$?" \
            "5203708b-f39e-48e6-8126-03622141a9e7"
        func_mmmv_wait_and_sync_t1
        chmod 0700 $S_FP
        func_mmmv_assert_error_code_zero_t1 "$?" \
            "276a79a2-d796-4f2b-a426-03622141a9e7"
        func_mmmv_wait_and_sync_t1
    else
        echo ""
        echo -e "\e[31mThis function is flawed \e[39m."
        echo "A file or a folder with the path of "
        echo ""
        echo "    $S_FP"
        echo ""
        echo -e "\e[31malready exists\e[39m. Not overwriting it."
        echo "GUID=='3ae2666a-4d8b-4bf3-8185-03622141a9e7'"
        echo ""
        #--------
        cd "$S_FP_ORIG"
        exit 1
    fi
    #----------------------------------------------------------------------
    cd $S_INITIAL_PWD
    func_mmmv_assert_error_code_zero_t1 "$?" \
        "0e531b43-8423-4a85-a326-03622141a9e7"
    #----------------------------------------------------------------------
} # func_ls_t5_recursive_list_of_folders

func_t5_recursive_list_of_folders(){
    local S_FP_FOLDER="$1"
    func_ls_t5_recursive_list_of_folders "$S_FP_FOLDER"
} # func_t5_recursive_list_of_folders

#--------------------------------------------------------------------------

func_ls_t6_recursive_list_of_folders_without_folders_named_par2_based_error_correction_files(){
    local S_FP_FOLDER="$1"
    #----------------------------------------------------------------------
    local S_INITIAL_PWD="`pwd`"
    func_mmmv_assert_folder_exists_t1 "$S_FP_FOLDER" \
        "d57bb94f-70fb-45f7-9126-03622141a9e7"
    cd $S_FP_FOLDER # to at least partly test access
    func_mmmv_assert_error_code_zero_t1 "$?" \
        "39d3971f-0864-417b-8226-03622141a9e7"
    #------------------------------
    if [ "$S_CMD_PREFIX_NICE" == "" ]; then
        echo ""
        echo "This function is probably fine, but "
        echo -e "\e[31mthis Bash script is flawed \e[39m."
        echo "GUID=='aac51d39-2018-4320-a385-03622141a9e7'"
        echo ""
        #--------
        cd "$S_FP_ORIG"
        exit 1
    fi
    #----------------------------------------------------------------------
    local S_FN="partial_recursive_list_of_folders.html"
    local S_TMP_0="/$S_FN"
    local S_FP="$S_FP_FOLDER$S_TMP_0"
    local SB_OPTIONAL_BAN_SYMLINKS="t"
    if [ -e "$S_FP" ]; then
        func_mmmv_assert_file_exists_t1 "$S_FP" \
            "5838ba4c-73b0-42c8-b326-03622141a9e7" \
            "$SB_OPTIONAL_BAN_SYMLINKS"
        #--------
        S_TMP_0="`nice -n 2 cat $S_FP | grep ' MMMV_TAG_THIS_FILE_HAS_BEEN_AUTOGENERATED_T1 '`"
        if [ "$S_TMP_0" == "" ]; then
            echo ""
            echo "The file "
            echo ""
            echo "    $S_FP"
            echo ""
            echo -e "exists, but it\e[31m does not include the string \e[39m"
            echo -e "\"\e[31m MMMV_TAG_THIS_FILE_HAS_BEEN_AUTOGENERATED_T1 \e[39m\"."
            echo "Quotation marks around it are not required, but"
            echo "at least one space at each side of it is compulsory."
            echo "Not overwriting the file. Aborting script."
            echo "GUID=='f94fe912-b291-436e-9585-03622141a9e7'"
            echo ""
            #--------
            cd "$S_FP_ORIG"
            exit 1
        fi
        #--------
        rm -f "$S_FP"
        func_mmmv_assert_error_code_zero_t1 "$?" \
            "1c63705a-3688-4c16-a126-03622141a9e7"
        func_mmmv_wait_and_sync_t1
    else
        if [ -h "$S_FP" ]; then # a broken symlink
            rm -f "$S_FP"
            func_mmmv_assert_error_code_zero_t1 "$?" \
                "14103b62-3149-432d-8826-03622141a9e7"
            func_mmmv_wait_and_sync_t1
        fi
    fi
    #------------------------------
    if [ ! -e "$S_FP" ]; then
        $S_CMD_PREFIX_NICE find . -type d | \
            grep -E -v '^[.]$' | \
            grep -i -v '[/]par2_based_error_correction_files' | \
            sort | \
            $S_CMD_GNU_SED -e 's/\(^.\+$\)/                <li><a href="\1">\1<\/a><\/li>/g' | \
            $S_CMD_GNU_SED -e '1{s/^/<!DOCTYPE HTML>\n<html>\n    <head>\n        <title>Partial list of Folders<\/title>\n        <meta http-equiv="Content-Type" content="text\/html; charset=UTF-8">        <!-- MMMV_TAG_THIS_FILE_HAS_BEEN_AUTOGENERATED_T1 -->\n    <\/head>\n    <body id="the_document_body">\n        <h1>Partial list of Folders<\/h1>\n            <ul>\n/g}' | \
            $S_CMD_GNU_SED -e '${s/$/\n            <\/ul>\n            <\/br><\/br>\n    <\/body>\n<\/html>\n/g}' > $S_FP
        func_mmmv_assert_error_code_zero_t1 "$?" \
            "08e0c03e-c2cc-4bcc-8526-03622141a9e7"
        func_mmmv_wait_and_sync_t1
        chmod 0700 $S_FP
        func_mmmv_assert_error_code_zero_t1 "$?" \
            "20b2fa50-e415-4daf-b316-03622141a9e7"
        func_mmmv_wait_and_sync_t1
    else
        echo ""
        echo -e "\e[31mThis function is flawed \e[39m."
        echo "A file or a folder with the path of "
        echo ""
        echo "    $S_FP"
        echo ""
        echo -e "\e[31malready exists\e[39m. Not overwriting it."
        echo "GUID=='e7fa1842-a7b8-43fc-b385-03622141a9e7'"
        echo ""
        #--------
        cd "$S_FP_ORIG"
        exit 1
    fi
    #----------------------------------------------------------------------
    cd $S_INITIAL_PWD
    func_mmmv_assert_error_code_zero_t1 "$?" \
        "adf2984d-69f3-4b55-b316-03622141a9e7"
    #----------------------------------------------------------------------
} # func_ls_t6_recursive_list_of_folders_without_folders_named_par2_based_error_correction_files

func_t6_recursive_list_of_folders_without_par2_folders(){
    local S_FP_FOLDER="$1"
    func_ls_t6_recursive_list_of_folders_without_folders_named_par2_based_error_correction_files "$S_FP_FOLDER"
} # func_t6_recursive_list_of_folders_without_par2_folders

#--------------------------------------------------------------------------

func_ls_t8_recursive_list_of_files_like_doc_pdf_ps_xls_txt(){
    local S_FP_FOLDER="$1"
    #----------------------------------------------------------------------
    local S_INITIAL_PWD="`pwd`"
    func_mmmv_assert_folder_exists_t1 "$S_FP_FOLDER" \
        "389357ee-4e65-4251-a216-03622141a9e7"
    cd $S_FP_FOLDER # to at least partly test access
    func_mmmv_assert_error_code_zero_t1 "$?" \
        "a67f3d5c-9e92-4737-9216-03622141a9e7"
    #------------------------------
    if [ "$S_CMD_PREFIX_NICE" == "" ]; then
        echo ""
        echo "This function is probably fine, but "
        echo -e "\e[31mthis Bash script is flawed \e[39m."
        echo "GUID=='ad873e48-7125-4bfb-9285-03622141a9e7'"
        echo ""
        #--------
        cd "$S_FP_ORIG"
        exit 1
    fi
    #----------------------------------------------------------------------
    local S_FN="list_of_PDF_files_and_alike.html"
    local S_TMP_0="/$S_FN"
    local S_FP="$S_FP_FOLDER$S_TMP_0"
    local SB_OPTIONAL_BAN_SYMLINKS="t"
    if [ -e "$S_FP" ]; then
        func_mmmv_assert_file_exists_t1 "$S_FP" \
            "d6f48210-0639-47f7-9216-03622141a9e7" \
            "$SB_OPTIONAL_BAN_SYMLINKS"
        #--------
        S_TMP_0="`nice -n 2 cat $S_FP | grep ' MMMV_TAG_THIS_FILE_HAS_BEEN_AUTOGENERATED_T1 '`"
        if [ "$S_TMP_0" == "" ]; then
            echo ""
            echo "The file "
            echo ""
            echo "    $S_FP"
            echo ""
            echo -e "exists, but it\e[31m does not include the string \e[39m"
            echo -e "\"\e[31m MMMV_TAG_THIS_FILE_HAS_BEEN_AUTOGENERATED_T1 \e[39m\"."
            echo "Quotation marks around it are not required, but"
            echo "at least one space at each side of it is compulsory."
            echo "Not overwriting the file. Aborting script."
            echo "GUID=='9c93734f-7c5a-4c28-b385-03622141a9e7'"
            echo ""
            #--------
            cd "$S_FP_ORIG"
            exit 1
        fi
        #--------
        rm -f "$S_FP"
        func_mmmv_assert_error_code_zero_t1 "$?" \
            "dc49b675-6497-4782-a816-03622141a9e7"
        func_mmmv_wait_and_sync_t1
    else
        if [ -h "$S_FP" ]; then # a broken symlink
            rm -f "$S_FP"
            func_mmmv_assert_error_code_zero_t1 "$?" \
                "81a9254b-e33c-47dd-9516-03622141a9e7"
            func_mmmv_wait_and_sync_t1
        fi
    fi
    #------------------------------
    if [ ! -e "$S_FP" ]; then
        $S_CMD_PREFIX_NICE find . -type f | \
            grep  -E '([.](([pP][dD][fF])|([pP][sS])|([dD][vV][iI])|([eE][pP][uU][bB])|([rR][tT][fF])|([dD][oO][cC])|([dD][oO][cC][xX])|([dD][oO][cC][xX][mM])|([oO][dD][sS])|([oO][dD][fF])|([oO][dD][tT])|([oO][tT][tT])|([xX][lL][sS])|([xX][lL][sS][xX])|([xX][lL][sS][mM])|([xX][lL][tT])|([xX][lL][tT][xX])|([oO][tT][sS])|([tT][xX][tT])))$' | \
            grep -v -E '[.][pP][aA][rR]2[.][lL][zZ]$' | \
            sort | \
            $S_CMD_GNU_SED -e 's/\(^.\+$\)/                <li><a href="\1">\1<\/a><\/li>/g' | \
            $S_CMD_GNU_SED -e '1{s/^/<!DOCTYPE HTML>\n<html>\n    <head>\n        <title>Recursive list of Files: PDF, PS, DOC, ODT, XLS and alike.<\/title>\n        <meta http-equiv="Content-Type" content="text\/html; charset=UTF-8">\n        <!-- MMMV_TAG_THIS_FILE_HAS_BEEN_AUTOGENERATED_T1 -->\n    <\/head>\n    <body id="the_document_body">\n        <h1>Partial list of Files<\/h1>\n            <ul>\n/g}' | \
            $S_CMD_GNU_SED -e '${s/$/\n            <\/ul>\n            <\/br><\/br>\n    <\/body>\n<\/html>\n/g}' > $S_FP
        func_mmmv_assert_error_code_zero_t1 "$?" \
            "8c522791-5148-401a-a216-03622141a9e7"
        func_mmmv_wait_and_sync_t1
        chmod 0700 $S_FP
        func_mmmv_assert_error_code_zero_t1 "$?" \
            "1c6398c0-5f01-49aa-a216-03622141a9e7"
        func_mmmv_wait_and_sync_t1
    else
        echo ""
        echo -e "\e[31mThis function is flawed \e[39m."
        echo "A file or a folder with the path of "
        echo ""
        echo "    $S_FP"
        echo ""
        echo -e "\e[31malready exists\e[39m."
        echo "GUID=='22bd5b10-b964-45c6-a175-03622141a9e7'"
        echo ""
        #--------
        cd "$S_FP_ORIG"
        exit 1
    fi
    #----------------------------------------------------------------------
    cd $S_INITIAL_PWD
    func_mmmv_assert_error_code_zero_t1 "$?" \
        "116ab73c-ca53-4852-a216-03622141a9e7"
    #----------------------------------------------------------------------
} # func_ls_t8_recursive_list_of_files_like_doc_pdf_ps_xls_txt

func_t8_PDF_and_alike(){
    local S_FP_FOLDER="$1"
    func_ls_t8_recursive_list_of_files_like_doc_pdf_ps_xls_txt "$S_FP_FOLDER"
} # func_t8_PDF_and_alike

#--------------------------------------------------------------------------

func_ls_t10_recursive_list_of_files_like_pdf_xls_txt_src_video_audio_image_zip(){
    local S_FP_FOLDER="$1"
    #----------------------------------------------------------------------
    local S_INITIAL_PWD="`pwd`"
    func_mmmv_assert_folder_exists_t1 "$S_FP_FOLDER" \
        "41d14a44-380a-4db1-a516-03622141a9e7"
    cd $S_FP_FOLDER # to at least partly test access
    func_mmmv_assert_error_code_zero_t1 "$?" \
        "0a18d52c-ddc7-4b57-8306-03622141a9e7"
    #------------------------------
    if [ "$S_CMD_PREFIX_NICE" == "" ]; then
        echo ""
        echo "This function is probably fine, but "
        echo -e "\e[31mthis Bash script is flawed \e[39m."
        echo "GUID=='0edccc54-b898-49fc-8175-03622141a9e7'"
        echo ""
        #--------
        cd "$S_FP_ORIG"
        exit 1
    fi
    #----------------------------------------------------------------------
    local S_FN="partial_recursive_list_of_files.html"
    local S_TMP_0="/$S_FN"
    local S_FP="$S_FP_FOLDER$S_TMP_0"
    local SB_OPTIONAL_BAN_SYMLINKS="t"
    if [ -e "$S_FP" ]; then
        func_mmmv_assert_file_exists_t1 "$S_FP" \
            "321a1514-8f4b-44ae-a206-03622141a9e7" \
            "$SB_OPTIONAL_BAN_SYMLINKS"
        #--------
        S_TMP_0="`nice -n 2 cat $S_FP | grep ' MMMV_TAG_THIS_FILE_HAS_BEEN_AUTOGENERATED_T1 '`"
        if [ "$S_TMP_0" == "" ]; then
            echo ""
            echo "The file "
            echo ""
            echo "    $S_FP"
            echo ""
            echo -e "exists, but it\e[31m does not include the string \e[39m"
            echo -e "\"\e[31m MMMV_TAG_THIS_FILE_HAS_BEEN_AUTOGENERATED_T1 \e[39m\"."
            echo "Quotation marks around it are not required, but"
            echo "at least one space at each side of it is compulsory."
            echo "Not overwriting the file. Aborting script."
            echo "GUID=='3a2fb3e1-1b6f-49ab-8375-03622141a9e7'"
            echo ""
            #--------
            cd "$S_FP_ORIG"
            exit 1
        fi
        #--------
        rm -f "$S_FP"
        func_mmmv_assert_error_code_zero_t1 "$?" \
            "b33a9145-79a8-410b-8106-03622141a9e7"
        func_mmmv_wait_and_sync_t1
    else
        if [ -h "$S_FP" ]; then # a broken symlink
            rm -f "$S_FP"
            func_mmmv_assert_error_code_zero_t1 "$?" \
                "2179e364-f26c-43e9-b506-03622141a9e7"
            func_mmmv_wait_and_sync_t1
        fi
    fi
    #------------------------------
    if [ ! -e "$S_FP" ]; then
        # Ruby code for generating subpart of the following grep regex MIGHT
        # reside near one of the mmmv_userspace_distro_t1 Bash aliases and IF it
        # does, THEN it is probably easy to find with "ripgrep/rg" or "ag".
        $S_CMD_PREFIX_NICE find . -type f | \
            grep  -E '((([rR][aA][kK][eE][fF][iI][lL][eE])|([mM][aA][kK][eE][fF][iI][lL][eE])|([cC][oO][nN][fF][iI][gG][uU][rR][eE]))|([.](([pP][dD][fF])|([pP][sS])|([dD][vV][iI])|([eE][pP][uU][bB])|([rR][tT][fF])|([dD][oO][cC])|([dD][oO][cC][xX])|([dD][oO][cC][xX][mM])|([oO][dD][sS])|([oO][dD][fF])|([oO][dD][tT])|([oO][tT][tT])|([xX][lL][sS])|([xX][lL][sS][xX])|([xX][lL][sS][mM])|([xX][lL][tT])|([xX][lL][tT][xX])|([oO][tT][sS])|([uU][oO][tT])|([uU][oO][sS])|([fF][oO][dD][tT])|([fF][oO][dD][sS])|([dD][iI][fF])|([sS][lL][kK])|([tT][xX][tT])|([tT][eE][xX][tT])|([mM][dD])|([dD][oO][tT])|([dD][oO][tT][xX])|([cC][sS][vV])|([iI][nN][iI])|([cC][oO][nN][fF][iI][gG])|([tT][oO][mM][lL])|([cC][fF][gG])|([dD][bB][fF])|([tT][eE][xX])|([lL][tT][xX])|([lL][aA][tT][eE][xX])|([cC])|([cC][pP][pP])|([hH])|([hH][pP][pP])|([hH][cC][cC])|([cC][xX][xX])|([rR][sS])|([aA][sS][mM])|([fF])|([fF][oO][rR])|([fF][9][0])|([fF][9][5])|([fF][0][3])|([fF][0][8])|([pP][aA][sS])|([pP][pP])|([vV])|([gG])|([tT][hH][yY])|([lL][eE][aA][nN])|([aA][gG][dD][aA])|([sS][iI][gG])|([mM][lL])|([pP][vV][sS])|([pP][rR][fF])|([pP][rR][lL])|([eE][lL][fF])|([vV][hH])|([sS][vV])|([sS][vV][hH])|([vV][hH][dD])|([vV][hH][dD][lL])|([bB][sS][vV])|([aA][dD][aA])|([aA][dD][bB])|([aA][dD][sS])|([lL][sS][tT])|([lL][oO][gG])|([bB][aA][sS][hH])|([bB][aA][tT])|([cC][mM][dD])|([pP][sS][1])|([sS][cC][rR])|([rR][bB])|([pP][yY])|([lL][iI][sS][pP])|([bB][aA][sS])|([pP][lL])|([pP][mM])|([dD][yY][lL][aA][nN])|([lL][iI][dD])|([sS][cC][aA][lL][aA])|([hH][sS])|([lL][hH][sS])|([mM][pP][4])|([mM][pP][2])|([aA][vV][iI])|([mM][oO][vV])|([mM][pP][gG])|([wW][eE][bB][mM])|([mM][pP][3])|([wW][eE][bB][aA])|([mM][4][aA])|([mM][4][pP])|([oO][gG][gG])|([oO][pP][uU][sS])|([oO][gG][aA])|([oO][vV][aA])|([fF][lL][aA][cC])|([wW][aA][vV])|([wW][aA][vV][eE])|([sS][pP][xX])|([mM][pP][cC])|([mM][pP][pP])|([wW][eE][bB][pP])|([wW][eE][pP])|([jJ][pP][eE][gG])|([jJ][pP][gG])|([gG][iI][fF])|([bB][mM][pP])|([aA][vV][iI][fF])|([aA][vV][iI][fF][sS])|([sS][vV][gG])|([pP][nN][gG])|([dD][jJ][vV][uU])|([dD][jJ][vV])|([zZ][iI][pP])|([jJ][aA][rR])|([gG][zZ])|([tT][gG][zZ])|([xX][zZ])|([tT][xX][zZ])|([bB][zZ][2])|([tT][bB][zZ][2])|([lL][zZ])|([tT][lL][zZ])|([rR][aA][rR])|([aA][rR][jJ])|([7][zZ])|([tT][7][zZ])|([tT][aA][rR]))))$' | \
            grep -v -E '[.][pP][aA][rR]2[.][lL][zZ]$' | \
            sort | \
            $S_CMD_GNU_SED -e 's/\(^.\+$\)/                <li><a href="\1">\1<\/a><\/li>/g' | \
            $S_CMD_GNU_SED -e '1{s/^/<!DOCTYPE HTML>\n<html>\n    <head>\n        <title>Recursive list of Files: PDF, PS, DOC, ODT, XLS and alike.<\/title>\n        <meta http-equiv="Content-Type" content="text\/html; charset=UTF-8">\n        <!-- MMMV_TAG_THIS_FILE_HAS_BEEN_AUTOGENERATED_T1 -->\n    <\/head>\n    <body id="the_document_body">\n        <h1>Partial list of Files<\/h1>\n            <ul>\n/g}' | \
            $S_CMD_GNU_SED -e '${s/$/\n            <\/ul>\n            <\/br><\/br>\n    <\/body>\n<\/html>\n/g}' > $S_FP
        func_mmmv_assert_error_code_zero_t1 "$?" \
            "2992d977-3acb-4e60-9406-03622141a9e7"
        func_mmmv_wait_and_sync_t1
        chmod 0700 $S_FP
        func_mmmv_assert_error_code_zero_t1 "$?" \
            "21d565f2-f79b-46de-9206-03622141a9e7"
        func_mmmv_wait_and_sync_t1
    else
        echo ""
        echo -e "\e[31mThis function is flawed \e[39m."
        echo "A file or a folder with the path of "
        echo ""
        echo "    $S_FP"
        echo ""
        echo -e "\e[31malready exists\e[39m."
        echo "GUID=='92f21b4b-eb4a-4cc5-8175-03622141a9e7'"
        echo ""
        #--------
        cd "$S_FP_ORIG"
        exit 1
    fi
    #----------------------------------------------------------------------
    cd $S_INITIAL_PWD
    func_mmmv_assert_error_code_zero_t1 "$?" \
        "9b14be3f-59b5-481b-a706-03622141a9e7"
    #----------------------------------------------------------------------
} # func_ls_t10_recursive_list_of_files_like_pdf_xls_txt_src_video_audio_image_zip

func_t10_PDF_xls_txt_src_mp4_mp3_JPEG_zip(){
    local S_FP_FOLDER="$1"
    func_ls_t10_recursive_list_of_files_like_pdf_xls_txt_src_video_audio_image_zip "$S_FP_FOLDER"
} # func_t10_PDF_xls_txt_src_mp4_mp3_JPEG_zip

#--------------------------------------------------------------------------

func_t11_AVFS_specific_links_to_ZIP_root(){
    local S_FP_FOLDER="$1"
    #----------------------------------------------------------------------
    local S_INITIAL_PWD="`pwd`"
    func_mmmv_assert_folder_exists_t1 "$S_FP_FOLDER" \
        "265fb7f8-0365-46d5-a206-03622141a9e7"
    cd $S_FP_FOLDER # to at least partly test access
    func_mmmv_assert_error_code_zero_t1 "$?" \
        "1fd77114-a9b2-4adf-a506-03622141a9e7"
    #------------------------------
    if [ "$S_CMD_PREFIX_NICE" == "" ]; then
        echo ""
        echo "This function is probably fine, but "
        echo -e "\e[31mthis Bash script is flawed \e[39m."
        echo "GUID=='30808ee1-9a78-4507-b475-03622141a9e7'"
        echo ""
        #--------
        cd "$S_FP_ORIG"
        exit 1
    fi
    #----------------------------------------------------------------------
    local S_FN="AVFS_specific_redirection.html"
    local S_TMP_0="/$S_FN"
    local S_FP="$S_FP_FOLDER$S_TMP_0"
    local SB_OPTIONAL_BAN_SYMLINKS="t"
    if [ -e "$S_FP" ]; then
        func_mmmv_assert_file_exists_t1 "$S_FP" \
            "2153aec4-9d4a-4e5e-b306-03622141a9e7" \
            "$SB_OPTIONAL_BAN_SYMLINKS"
        #--------
        S_TMP_0="`nice -n 2 cat $S_FP | grep ' MMMV_TAG_THIS_FILE_HAS_BEEN_AUTOGENERATED_T1 '`"
        if [ "$S_TMP_0" == "" ]; then
            echo ""
            echo "The file "
            echo ""
            echo "    $S_FP"
            echo ""
            echo -e "exists, but it\e[31m does not include the string \e[39m"
            echo -e "\"\e[31m MMMV_TAG_THIS_FILE_HAS_BEEN_AUTOGENERATED_T1 \e[39m\"."
            echo "Quotation marks around it are not required, but"
            echo "at least one space at each side of it is compulsory."
            echo "Not overwriting the file. Aborting script."
            echo "GUID=='3db04a51-1a17-440d-9275-03622141a9e7'"
            echo ""
            #--------
            cd "$S_FP_ORIG"
            exit 1
        fi
        #--------
        rm -f "$S_FP"
        func_mmmv_assert_error_code_zero_t1 "$?" \
            "233f03a3-dec7-48aa-b3f5-03622141a9e7"
        func_mmmv_wait_and_sync_t1
    else
        if [ -h "$S_FP" ]; then # a broken symlink
            rm -f "$S_FP"
            func_mmmv_assert_error_code_zero_t1 "$?" \
                "f82a0345-ad70-4f26-a5f5-03622141a9e7"
            func_mmmv_wait_and_sync_t1
        fi
    fi
    #------------------------------
    if [ ! -e "$S_FP" ]; then
        # Ruby code for generating subpart of the following grep regex MIGHT
        # reside near one of the mmmv_userspace_distro_t1 Bash aliases and IF it
        # does, THEN it is probably easy to find with "ripgrep/rg" or "ag".
        $S_CMD_PREFIX_NICE find . -type f | \
            grep  -E '[.][zZ][iI][pP]$' | \
            grep -v -E '[.][pP][aA][rR]2[.][lL][zZ]$' | \
            sort | \
            $S_CMD_GNU_SED -e 's/\(^.\+$\)/                <li><a href="\1%23\/">\1%23\/<\/a><\/li>/g' | \
            $S_CMD_GNU_SED -e '1{s/^/<!DOCTYPE HTML>\n<html>\n    <head>\n        <title>AVFS Specific Redirection Links<\/title>\n        <meta http-equiv="Content-Type" content="text\/html; charset=UTF-8">\n        <!-- MMMV_TAG_THIS_FILE_HAS_BEEN_AUTOGENERATED_T1 -->\n    <\/head>\n    <body id="the_document_body">\n        <h1><a href="http:\/\/web.archive.org\/web\/20250406065812\/https:\/\/avf.sourceforge.net\/">AVFS<\/a> Specific Redirection Links<\/h1>\n            <ul>\n/g}' | \
            $S_CMD_GNU_SED -e '${s/$/\n            <\/ul>\n            <\/br><\/br>\n    <\/body>\n<\/html>\n/g}' > $S_FP
        func_mmmv_assert_error_code_zero_t1 "$?" \
            "4abfe920-1867-469e-b5f5-03622141a9e7"
        func_mmmv_wait_and_sync_t1
        chmod 0700 $S_FP
        func_mmmv_assert_error_code_zero_t1 "$?" \
            "5195f5f2-ebf6-41a6-bef5-03622141a9e7"
        func_mmmv_wait_and_sync_t1
    else
        echo ""
        echo -e "\e[31mThis function is flawed \e[39m."
        echo "A file or a folder with the path of "
        echo ""
        echo "    $S_FP"
        echo ""
        echo -e "\e[31malready exists\e[39m."
        echo "GUID=='14030a21-160e-45c6-8475-03622141a9e7'"
        echo ""
        #--------
        cd "$S_FP_ORIG"
        exit 1
    fi
    #----------------------------------------------------------------------
    cd $S_INITIAL_PWD
    func_mmmv_assert_error_code_zero_t1 "$?" \
        "107118b2-f649-496a-8df5-03622141a9e7"
    #----------------------------------------------------------------------
} # func_t11_AVFS_specific_links_to_ZIP_root

func_t11_AVFS_specific_links_to_ZIP(){
    local S_FP_FOLDER="$1"
    func_t11_AVFS_specific_links_to_ZIP_root "$S_FP_FOLDER"
} # func_t11_AVFS_specific_links_to_ZIP

#--------------------------------------------------------------------------

func_initialize_configuration_by_initializing_global_variables(){
    #func_first_use_message # Please outcomment this line during the customisation.
    #----------------------------------------------------------------------
    func_mmmv_init_s_timestamp_if_not_inited_t1
    #----------------------------------------------------------------------
    func_mmmv_assert_folder_exists_t1 "$S_FP_DIR" \
        "425fc054-5132-45f7-a2f5-03622141a9e7"
    cd $S_FP_DIR # to at least partially test access
    func_mmmv_assert_error_code_zero_t1 "$?" \
        "88064947-2909-4af6-81f5-03622141a9e7"
    #------------------------------
    S_CMD_PREFIX_NICE="nice -n 4 "
    #----------------------------------------------------------------------
} # func_initialize_configuration_by_initializing_global_variables

#--------------------------------------------------------------------------

func_main(){
    #----------------------------------------------------------------------
    func_check_for_some_dependencies
    func_initialize_configuration_by_initializing_global_variables
    func_display_help_message_and_exit_if_needed
    #----------------------------------------------------------------------
    func_mmmv_wait_and_sync_t1
    func_generate_or_overwrite_file_list_HTML_files
    #----------------------------------------------------------------------
    func_mmmv_wait_and_sync_t1
    #------------------------------
    echo ""
    echo -e "\e[92mGeneration of file lists HTML is complete\e[39m."
    echo "Thank You for trying out this script. "
    echo "GUID=='892949c1-ccc2-48cf-b265-03622141a9e7'"
    echo ""
    #------------------------------
} # func_main
func_main

#--------------------------------------------------------------------------
cd "$S_FP_ORIG"
exit 0
#==========================================================================
# S_VERSION_OF_THIS_FILE="5aca6550-db90-4ebb-84f5-03622141a9e7"
#==========================================================================
