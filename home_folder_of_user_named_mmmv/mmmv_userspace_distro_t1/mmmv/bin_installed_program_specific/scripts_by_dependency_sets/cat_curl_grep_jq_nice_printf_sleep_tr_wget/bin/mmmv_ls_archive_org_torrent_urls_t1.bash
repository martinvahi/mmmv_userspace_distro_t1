#!/usr/bin/env bash
#==========================================================================
# Initial author of this file: Martin.Vahi@softf1.com
# The Microsoft Bing chatbot generated code fragments are under the MIT
# license, but the rest of this file is in public domain.
# The following line is a spdx.org license label line:
# SPDX-License-Identifier: MIT
#
# The main control flow entry in this script is the func_main(),
# which resides near the end of this file. The structure of this file:
#
#     <boilerplate, the library of reusable Bash functions>
#     <various this script specific Bash functions>
#     func_main() # like in C/C++
#
#
#==========================================================================
S_FP_DIR="$( cd "$( dirname "${BASH_SOURCE[0]}" )" && pwd )"
S_FP_ORIG="`pwd`"
#--------------------------------------------------------------------------

MMMV_BASH_BOILERPLATE_VERSION="subject_to_initialisation"
func_mmmv_bash_boilerplate_version(){
    local S_GUID="ba610347-8485-4248-9104-c07380e0a9e7"
    local S_TIMESTAMP="_subject_to_initialisation_"
# RENESSAATOR_BLOCK_START
# RENESSAATOR_BLOCK_ID=block_566c89e2-c6f0-12ed-9d8a-1c6f6552f9e6_city
# RENESSAATOR_SOURCE_LANGUAGE=Ruby
# RENESSAATOR_SOURCE_START
# ob_t=Time.now
# s_t="_⏳_"
# s_t<<("y"+ob_t.year.to_s)
# s_t<<"_"
# s_t<<("m"+ob_t.month.to_s)
# s_t<<"_"
# s_t<<("d"+ob_t.day.to_s)
# s_t<<"_"
# s_t<<("h"+ob_t.hour.to_s)
# s_t<<"_"
# s_t<<("m"+ob_t.min.to_s)
# s_t<<"_"
# s_t<<("s"+ob_t.sec.to_s)
# s_t<<"_"
# s_t<<("μ"+ob_t.usec.to_s)
# s_t<<"_☺_"
# puts("    S_TIMESTAMP=\""+s_t+"\"")
# RENESSAATOR_SOURCE_END
#
# RENESSAATOR_AUTOGENERATED_TEXT_START
    S_TIMESTAMP="_⏳_y2023_m12_d24_h8_m12_s18_μ309806_☺_"

# RENESSAATOR_AUTOGENERATED_TEXT_END
# RENESSAATOR_BLOCK_END
    MMMV_BASH_BOILERPLATE_VERSION="mmmv_bash_boilerplate_t4_$S_TIMESTAMP$S_GUID"
} # func_mmmv_bash_boilerplate_version
func_mmmv_bash_boilerplate_version

#--------------------------------------------------------------------------

func_mmmv_wait_and_sync_t1(){
    wait # for background processes started by this Bash script to exit/finish
    sync # network drives, USB-sticks, etc.
    wait # for sync
} # func_mmmv_wait_and_sync_t1

#--------------------------------------------------------------------------
func_mmmv_init_s_timestamp_if_not_inited_t1(){
    if [ "$S_TIMESTAMP" == "" ]; then
        if [ "`which date 2> /dev/null`" != "" ]; then
            S_TIMESTAMP="`date +%Y`_`date +%m`_`date +%d`_T_`date +%H`h_`date +%M`min_`date +%S`s"
        else
            S_TIMESTAMP="0000_00_00_T_00h_00min_00s"
            echo ""
            echo -e "The console program \"\e[31mdate\e[39m\" is missing from the PATH."
            echo "Using a constant value, "
            echo ""
            echo "    S_TIMESTAMP=\"$S_TIMESTAMP\""
            echo ""
            echo "GUID=='a56a3259-e3e4-4185-8404-c07380e0a9e7'"
            echo ""
        fi
    fi
} # func_mmmv_init_s_timestamp_if_not_inited_t1

#--------------------------------------------------------------------------

func_mmmv_verify_S_FP_ORIG_but_do_not_exit_t1(){
    SB_S_FP_ORIG_VERIFICATION_FAILED="f"
    if [ "$S_FP_ORIG" == "" ]; then
        SB_S_FP_ORIG_VERIFICATION_FAILED="t"
        echo ""
        echo -e "\e[31mThe code of this script has the flaw\e[39m that"
        echo "the variable S_FP_ORIG has not been set."
        echo "GUID=='bce78246-86f4-4f75-8504-c07380e0a9e7'"
        echo ""
    else
        if [ ! -e "$S_FP_ORIG" ]; then
            SB_S_FP_ORIG_VERIFICATION_FAILED="t"
            echo ""
            echo -e "\e[31mThe code of this script has the flaw\e[39m that "
            echo "the variable S_FP_ORIG has been declared, but "
            echo "its value is some string that is not a file or folder path."
            echo "It is expected to be a folder path."
            echo ""
            echo "    S_FP_ORIG==\"$S_FP_ORIG\""
            echo ""
            echo "GUID=='aa52e127-1813-4172-8504-c07380e0a9e7'"
            echo ""
        else
            if [ ! -d "$S_FP_ORIG" ]; then
                SB_S_FP_ORIG_VERIFICATION_FAILED="t"
                echo ""
                echo -e "\e[31mThe code of this script has the flaw\e[39m that "
                echo "the variable S_FP_ORIG references a file, but "
                echo "it is expected to reference a folder."
                echo ""
                echo "    S_FP_ORIG==$S_FP_ORIG"
                echo ""
                echo "GUID=='dd233720-a168-44dc-a104-c07380e0a9e7'"
                echo ""
            fi
        fi
    fi
    #----------------------------------------------------------------------
    # exit 1 # must NOT be called in ~/.bashrc, because
             # exiting from the ~/.bashrc exits the session.
    #----------------------------------------------------------------------
    # Usage example:
    #    func_mmmv_verify_S_FP_ORIG_but_do_not_exit_t1
    #    if [ "$SB_S_FP_ORIG_VERIFICATION_FAILED" == "f" ]; then
    #        cd "$S_FP_ORIG"
    #    else
    #        echo ""
    #        echo "The code of this script is flawed."
    #        echo "GUID=='e9c98e22-976d-4572-84f3-c07380e0a9e7'"
    #        echo ""
    #    fi
} # func_mmmv_verify_S_FP_ORIG_but_do_not_exit_t1

#--------------------------------------------------------------------------

SB_FUNC_MMMV_VERIFY_S_FP_ORIG_BUT_DO_NOT_EXIT_T2_S_FB_ORIG_ALREADY_VERIFIED="f"
func_mmmv_verify_S_FP_ORIG_but_do_not_exit_t2(){
    if [ "$SB_FUNC_MMMV_VERIFY_S_FP_ORIG_BUT_DO_NOT_EXIT_T2_S_FB_ORIG_ALREADY_VERIFIED" != "t" ]; then
        if [ "$SB_FUNC_MMMV_VERIFY_S_FP_ORIG_BUT_DO_NOT_EXIT_T2_S_FB_ORIG_ALREADY_VERIFIED" != "f" ]; then
            echo ""
            echo -e "\e[31mThe code that calls this function is flawed. \e[39m"
            echo "The global variable "
            echo ""
            echo "    SB_FUNC_MMMV_VERIFY_S_FP_ORIG_BUT_DO_NOT_EXIT_T2_S_FB_ORIG_ALREADY_VERIFIED==\"$SB_FUNC_MMMV_VERIFY_S_FP_ORIG_BUT_DO_NOT_EXIT_T2_S_FB_ORIG_ALREADY_VERIFIED\""
            echo ""
            echo "has a domain of {\"f\", \"t\"}."
            echo "GUID=='cd90b220-09c4-4b7a-a2f3-c07380e0a9e7'"
            echo ""
        else
            func_mmmv_verify_S_FP_ORIG_but_do_not_exit_t1
            SB_FUNC_MMMV_VERIFY_S_FP_ORIG_BUT_DO_NOT_EXIT_T2_S_FB_ORIG_ALREADY_VERIFIED="t"
        fi
    fi
} # func_mmmv_verify_S_FP_ORIG_but_do_not_exit_t2

#--------------------------------------------------------------------------

SB_NO_ERRORS_YET="t" # domain=={"t","f"}
func_mmmv_assert_nonempty_string_but_do_not_exit_t1(){
    local S_IN="$1"
    local S_VARIABLE_NAME_IN_CALLING_CODE="$2"
    local S_GUID_CANDIDATE="$3"
    #----------------------------------------------------------------------
    local SB_NO_ERRORS_YET_1="t"
    if [ "$S_GUID_CANDIDATE" == "" ]; then
        echo ""
        echo -e "\e[31mThe code that calls this function is flawed.\e[39m The"
        echo ""
        echo "    S_GUID_CANDIDATE==\"\""
        echo ""
        echo "but it is expected to be a GUID."
        echo "GUID=='d6db7d27-8f46-48f8-a4f3-c07380e0a9e7'"
        echo ""
        SB_NO_ERRORS_YET_1="f"
    fi
    #--------------------
    if [ "$SB_NO_ERRORS_YET" != "t" ]; then
        echo ""
        echo -e "\e[31mThe code that calls this function is flawed. \e[39m"
        echo "The global variable "
        echo ""
        echo "    SB_NO_ERRORS_YET==\"$SB_NO_ERRORS_YET\""
        echo ""
        if [ "$SB_NO_ERRORS_YET" == "f" ]; then
            echo "is expected to be initialized to \"t\" before calling this function."
            echo "GUID=='554ff04b-014f-4082-a3f3-c07380e0a9e7'"
        else
            echo "is expected to be initialized to \"t\" before calling this function"
            echo "and its domain is {\"f\", \"t\"}."
            echo "GUID=='aea8193b-4b28-4e7e-b2f3-c07380e0a9e7'"
        fi
        if [ "$SB_NO_ERRORS_YET_1" == "t" ]; then
            echo "GUID_CANDIDATE=='$S_GUID_CANDIDATE'"
        fi
        echo ""
        SB_NO_ERRORS_YET="f"
    fi
    #--------------------
    if [ "$SB_NO_ERRORS_YET_1" == "f" ]; then
        SB_NO_ERRORS_YET="f"
    fi
    #----------------------------------------------------------------------
    if [ "$SB_NO_ERRORS_YET" == "t" ]; then
        if [ "$S_VARIABLE_NAME_IN_CALLING_CODE" == "" ]; then
            echo ""
            echo -e "\e[31mThe code that calls this function is flawed.\e[39m The"
            echo ""
            echo "    S_VARIABLE_NAME_IN_CALLING_CODE==\"\""
            echo ""
            echo "GUID=='6b159f30-d0f7-482a-83f3-c07380e0a9e7'"
            if [ "$SB_NO_ERRORS_YET_1" == "t" ]; then  # should be always true at this line
                echo "GUID_CANDIDATE=='$S_GUID_CANDIDATE'"
            fi
            echo ""
            SB_NO_ERRORS_YET="f"
        fi
    fi
    #----------------------------------------------------------------------
    if [ "$SB_NO_ERRORS_YET" == "t" ]; then
        if [ "$S_IN" == "" ]; then
            echo ""
            echo -e "\e[31mThere is a flaw somewhere in the code\e[39m that"
            echo "uses a variable named \"$S_VARIABLE_NAME_IN_CALLING_CODE\"."
            echo ""
            echo "    $S_VARIABLE_NAME_IN_CALLING_CODE==\"$S_IN\""
            echo ""
            echo "but it is expected to be something other than an empty string."
            echo "GUID=='44e9e911-3a1e-4b95-a9e3-c07380e0a9e7'"
            if [ "$SB_NO_ERRORS_YET_1" == "t" ]; then  # should be always true at this line
                echo "GUID_CANDIDATE=='$S_GUID_CANDIDATE'"
            fi
            echo ""
            SB_NO_ERRORS_YET="f"
        fi
    fi
    #----------------------------------------------------------------------
} # func_mmmv_assert_nonempty_string_but_do_not_exit_t1

#--------------------------------------------------------------------------

# SB_NO_ERRORS_YET="t" # domain=={"t","f"}, initial declaration resides upwards from this line
func_mmmv_assert_sbvar_domain_t_f_but_do_not_exit_t1(){
    local SB_VARIABLE_VALUE="$1"
    local S_VARIABLE_NAME_IN_CALLING_CODE="$2"
    local S_GUID_CANDIDATE="$3"
    #----------------------------------------------------------------------
    local SB_NO_ERRORS_YET_1="t"
    if [ "$S_GUID_CANDIDATE" == "" ]; then
        echo ""
        echo -e "\e[31mThe code that calls this function is flawed.\e[39m The"
        echo ""
        echo "    S_GUID_CANDIDATE==\"\""
        echo ""
        echo "but it is expected to be a GUID."
        echo "GUID=='f391462d-6924-4136-a1e3-c07380e0a9e7'"
        echo ""
        SB_NO_ERRORS_YET_1="f"
    fi
    #--------------------
    if [ "$SB_NO_ERRORS_YET" != "t" ]; then
        echo ""
        echo -e "\e[31mThe code that calls this function is flawed. \e[39m"
        echo "The global variable "
        echo ""
        echo "    SB_NO_ERRORS_YET==\"$SB_NO_ERRORS_YET\""
        echo ""
        if [ "$SB_NO_ERRORS_YET" == "f" ]; then
            echo "is expected to be initialized to \"t\" before calling this function."
            echo "GUID=='534e1324-2bea-4216-94e3-c07380e0a9e7'"
        else
            echo "is expected to be initialized to \"t\" before calling this function"
            echo "and its domain is {\"f\", \"t\"}."
            echo "GUID=='c19a9a1a-21e8-4934-b5e3-c07380e0a9e7'"
        fi
        if [ "$SB_NO_ERRORS_YET_1" == "t" ]; then
            echo "GUID_CANDIDATE=='$S_GUID_CANDIDATE'"
        fi
        echo ""
        SB_NO_ERRORS_YET="f"
    fi
    #--------------------
    if [ "$SB_NO_ERRORS_YET_1" == "f" ]; then
        SB_NO_ERRORS_YET="f"
    fi
    #----------------------------------------------------------------------
    if [ "$SB_NO_ERRORS_YET" == "t" ]; then
        if [ "$S_VARIABLE_NAME_IN_CALLING_CODE" == "" ]; then
            echo ""
            echo -e "\e[31mThe code that calls this function is flawed.\e[39m The"
            echo ""
            echo "    S_VARIABLE_NAME_IN_CALLING_CODE==\"\""
            echo ""
            echo "GUID=='2778cfee-effc-4613-b3e3-c07380e0a9e7'"
            if [ "$SB_NO_ERRORS_YET_1" == "t" ]; then  # should be always true at this line
                echo "GUID_CANDIDATE=='$S_GUID_CANDIDATE'"
            fi
            echo ""
            SB_NO_ERRORS_YET="f"
        fi
    fi
    #----------------------------------------------------------------------
    if [ "$SB_NO_ERRORS_YET" == "t" ]; then
        if [ "$SB_VARIABLE_VALUE" != "t" ]; then
            if [ "$SB_VARIABLE_VALUE" != "f" ]; then
                echo ""
                echo -e "\e[31mThere is a flaw somewhere in the code\e[39m that"
                echo "uses a variable named \"$S_VARIABLE_NAME_IN_CALLING_CODE\". The "
                echo ""
                echo "    $S_VARIABLE_NAME_IN_CALLING_CODE==\"$SB_VARIABLE_VALUE\""
                echo ""
                echo "but it is expected to be either \"t\" or \"f\"."
                echo "GUID=='18c67d1f-1c7d-428b-85e3-c07380e0a9e7'"
                if [ "$SB_NO_ERRORS_YET_1" == "t" ]; then  # should be always true at this line
                    echo "GUID_CANDIDATE=='$S_GUID_CANDIDATE'"
                fi
                echo ""
                SB_NO_ERRORS_YET="f"
            fi
        fi
    fi
    #----------------------------------------------------------------------
} # func_mmmv_assert_sbvar_domain_t_f_but_do_not_exit_t1

#--------------------------------------------------------------------------

func_mmmv_report_an_error_but_do_not_exit_t1(){
    local S_GUID_CANDIDATE="$1" # first  function argument
    local S_ERR_MSG="$2"        # second function argument
    #----------------------------------------------------------------------
    if [ "$S_GUID_CANDIDATE" == "" ]; then
        echo ""
        echo -e "\e[31mThe code of this script is flawed.\e[39m"
        if [ "$S_ERR_MSG" != "" ]; then
            echo "$S_ERR_MSG"
        fi
        echo "GUID=='119f8e5c-9793-4980-83e3-c07380e0a9e7'"
        echo ""
    else
        echo ""
        echo -e "\e[31mThe code of this script is flawed.\e[39m"
        if [ "$S_ERR_MSG" != "" ]; then
            echo "$S_ERR_MSG"
        fi
        echo "GUID_CANDIDATE=='$S_GUID_CANDIDATE'"
        echo "GUID=='f277dfcc-0736-4b54-a2e3-c07380e0a9e7'"
        echo ""
    fi
    #----------------------------------------------------------------------
    # exit 1 # must NOT be called in ~/.bashrc, because
             # exiting from the ~/.bashrc exits the session.
} # func_mmmv_report_an_error_but_do_not_exit_t1

#--------------------------------------------------------------------------

func_mmmv_report_missing_from_path_and_do_NOT_exit_t1() {
    local S_NAME_OF_THE_EXECUTABLE=$1 # first function argument
    #----------------------------------------------------------------------
    local S_TMP_0="\`which $S_NAME_OF_THE_EXECUTABLE 2> /dev/null\`"
    local S_TMP_1=""
    local S_TMP_2="S_TMP_1=$S_TMP_0"
    eval ${S_TMP_2}
    if [ "$S_TMP_1" == "" ] ; then
        echo ""
        echo "This bash script wished to use the "
        echo "\"$S_NAME_OF_THE_EXECUTABLE\" from the PATH, but "
        echo "it was missing from the PATH."
        echo "GUID=='4e66c7b5-f584-41ba-a5e3-c07380e0a9e7'"
        echo ""
    fi
    #----------------------------------------------------------------------
    # exit 1 # must NOT be called in ~/.bashrc, because
             # exiting from the ~/.bashrc exits the session.
} # func_mmmv_report_missing_from_path_and_do_NOT_exit_t1

#func_mmmv_report_missing_from_path_and_do_NOT_exit_t1 "ln"
#func_mmmv_report_missing_from_path_and_do_NOT_exit_t1 "date"
#func_mmmv_report_missing_from_path_and_do_NOT_exit_t1 "printf"
#func_mmmv_report_missing_from_path_and_do_NOT_exit_t1 "grep"
#func_mmmv_report_missing_from_path_and_do_NOT_exit_t1 "git"

#--------------------------------------------------------------------------

func_mmmv_verify_that_the_file_exists_but_do_not_exit_t1() {  # S_FP, S_GUID_CANDIDATE
    local S_FP="$1"
    local S_GUID_CANDIDATE="$2"
    local SB_DISPLAY_VERIFICATION_FAILURE_MESSAGE="$3" # domain: {"t","f",""}
                                                       # ""==="t", default "t"
    #----------------------------------------------------------------------
    # A global variable for storing function output.
    SB_VERIFICATION_FAILED="f" # domain: "t", "f" .
    #------------------------------
    if [ "$S_GUID_CANDIDATE" == "" ]; then
        echo ""
        echo -e "\e[31mThe code that calls this function is flawed.\e[39m"
        echo "This function requires 2 parameters: S_FP, S_GUID_CANDIDATE"
        echo "and has an optional 3. parameter: SB_DISPLAY_VERIFICATION_FAILURE_MESSAGE"
        echo "GUID=='1ccb4cd2-b48d-4b28-82e3-c07380e0a9e7'"
        echo ""
        #--------
        SB_VERIFICATION_FAILED="t"
    fi
    #------------------------------
    local SB_DISPLAY_VERIF_FAILURE_MSG="t" # the default
    if [ "$SB_VERIFICATION_FAILED" == "f" ]; then
        if [ "$SB_DISPLAY_VERIFICATION_FAILURE_MESSAGE" != "" ]; then
            if [ "$SB_DISPLAY_VERIFICATION_FAILURE_MESSAGE" == "f" ]; then
                SB_DISPLAY_VERIF_FAILURE_MSG="f"
            else
                if [ "$SB_DISPLAY_VERIFICATION_FAILURE_MESSAGE" != "t" ]; then
                    echo ""
                    echo -e "\e[31mThe code that calls this function is flawed.\e[39m"
                    echo ""
                    echo "  SB_DISPLAY_VERIFICATION_FAILURE_MESSAGE==\"$SB_DISPLAY_VERIFICATION_FAILURE_MESSAGE\""
                    echo ""
                    echo "Valid values are: \"t\", \"f\", \"\" ."
                    echo "\"\" defaults to \"t\"."
                    echo "GUID=='196a4f64-5e7d-4dce-afe3-c07380e0a9e7'"
                    echo ""
                    #--------
                    SB_VERIFICATION_FAILED="t"
                fi
            fi
        fi
    fi
    #------------------------------
    if [ "$SB_VERIFICATION_FAILED" == "f" ]; then
        if [ ! -e "$S_FP" ]; then
            if [ -h "$S_FP" ]; then
                if [ "$SB_DISPLAY_VERIF_FAILURE_MSG" == "t" ]; then
                    echo ""
                    echo "The path "
                    echo ""
                    echo "    $S_FP "
                    echo ""
                    echo -e "points to a\e[31m broken symlink\e[39m, but a file or"
                    echo "a symlink to a file is expected."
                    echo "GUID==\"$S_GUID_CANDIDATE\""
                    echo "GUID=='65dce651-971a-417e-95e3-c07380e0a9e7'"
                    echo ""
                fi
                #--------
                SB_VERIFICATION_FAILED="t"
            else
                if [ "$SB_DISPLAY_VERIF_FAILURE_MSG" == "t" ]; then
                    echo ""
                    echo "The file "
                    echo ""
                    echo "    $S_FP "
                    echo ""
                    echo -e "\e[31mdoes not exist\e[39m."
                    echo "GUID==\"$S_GUID_CANDIDATE\""
                    echo "GUID=='836a2b32-2242-44a0-b3e3-c07380e0a9e7'"
                    echo ""
                fi
                #--------
                SB_VERIFICATION_FAILED="t"
            fi
        else
            if [ -d "$S_FP" ]; then
                if [ "$SB_DISPLAY_VERIF_FAILURE_MSG" == "t" ]; then
                    echo ""
                    if [ -h "$S_FP" ]; then
                        echo "The symlink to the folder "
                    else
                        echo "The folder "
                    fi
                    echo ""
                    echo "    $S_FP "
                    echo ""
                    echo -e "exists, but a\e[31m file or a symlink to a file is expected\e[39m."
                    echo "GUID==\"$S_GUID_CANDIDATE\""
                    echo "GUID=='51a58b40-be85-4aba-85e3-c07380e0a9e7'"
                    echo ""
                fi
                #--------
                SB_VERIFICATION_FAILED="t"
            fi
        fi
    fi #  "$SB_VERIFICATION_FAILED" == "f"
    #------------------------------
    if [ "$SB_VERIFICATION_FAILED" != "t" ]; then
        if [ "$SB_VERIFICATION_FAILED" != "f" ]; then
            echo ""
            echo -e "\e[31mThe code of this Bash function is flawed.\e[39m"
            echo "GUID=='d669da39-0857-4e6a-a5d3-c07380e0a9e7'"
            echo ""
        fi
    fi
    #------------------------------
} # func_mmmv_verify_that_the_file_exists_but_do_not_exit_t1

#--------------------------------------------------------------------------

func_mmmv_verify_that_the_folder_exists_but_do_not_exit_t1() {  # S_FP, S_GUID_CANDIDATE
    local S_FP="$1"
    local S_GUID_CANDIDATE="$2"
    local SB_DISPLAY_VERIFICATION_FAILURE_MESSAGE="$3" # domain: {"t","f",""}
                                                       # ""==="t", default "t"
    #----------------------------------------------------------------------
    # A global variable for storing function output.
    SB_VERIFICATION_FAILED="f" # domain: "t", "f" .
    #------------------------------
    if [ "$S_GUID_CANDIDATE" == "" ]; then
        echo ""
        echo -e "\e[31mThe code that calls this function is flawed.\e[39m"
        echo "This function requires 2 parameters: S_FP, S_GUID_CANDIDATE"
        echo "and has an optional 3. parameter: SB_DISPLAY_VERIFICATION_FAILURE_MESSAGE"
        echo "GUID=='318ca834-f58d-47a8-82d3-c07380e0a9e7'"
        echo ""
        #--------
        SB_VERIFICATION_FAILED="t"
    fi
    #------------------------------
    local SB_DISPLAY_VERIF_FAILURE_MSG="t" # the default
    if [ "$SB_VERIFICATION_FAILED" == "f" ]; then
        if [ "$SB_DISPLAY_VERIFICATION_FAILURE_MESSAGE" != "" ]; then
            if [ "$SB_DISPLAY_VERIFICATION_FAILURE_MESSAGE" == "f" ]; then
                SB_DISPLAY_VERIF_FAILURE_MSG="f"
            else
                if [ "$SB_DISPLAY_VERIFICATION_FAILURE_MESSAGE" != "t" ]; then
                    echo ""
                    echo -e "\e[31mThe code that calls this function is flawed.\e[39m"
                    echo ""
                    echo "  SB_DISPLAY_VERIFICATION_FAILURE_MESSAGE==\"$SB_DISPLAY_VERIFICATION_FAILURE_MESSAGE\""
                    echo ""
                    echo "Valid values are: \"t\", \"f\", \"\" ."
                    echo "\"\" defaults to \"t\"."
                    echo "GUID=='21f80145-5042-4cd3-bed3-c07380e0a9e7'"
                    echo ""
                    #--------
                    SB_VERIFICATION_FAILED="t"
                fi
            fi
        fi
    fi
    #------------------------------
    if [ "$SB_VERIFICATION_FAILED" == "f" ]; then
        if [ ! -e "$S_FP" ]; then
            if [ -h "$S_FP" ]; then
                if [ "$SB_DISPLAY_VERIF_FAILURE_MSG" == "t" ]; then
                    echo ""
                    echo "The path "
                    echo ""
                    echo "    $S_FP "
                    echo ""
                    echo -e "points to a\e[31m broken symlink\e[39m, but a folder "
                    echo "or a symlink to a folder is expected."
                    echo "GUID==\"$S_GUID_CANDIDATE\""
                    echo "GUID=='3d36f321-0dac-41bb-a1d3-c07380e0a9e7'"
                    echo ""
                fi
                #--------
                SB_VERIFICATION_FAILED="t"
            else
                if [ "$SB_DISPLAY_VERIF_FAILURE_MSG" == "t" ]; then
                    echo ""
                    echo "The folder "
                    echo ""
                    echo "    $S_FP "
                    echo ""
                    echo -e "\e[31mdoes not exist\e[39m."
                    echo "GUID==\"$S_GUID_CANDIDATE\""
                    echo "GUID=='2d28ce53-dc67-4397-93d3-c07380e0a9e7'"
                    echo ""
                fi
                #--------
                SB_VERIFICATION_FAILED="t"
            fi
        else
            if [ ! -d "$S_FP" ]; then
                if [ "$SB_DISPLAY_VERIF_FAILURE_MSG" == "t" ]; then
                    echo ""
                    if [ -h "$S_FP" ]; then
                        echo "The symlink to an existing file "
                    else
                        echo "The file "
                    fi
                    echo ""
                    echo "    $S_FP "
                    echo ""
                    echo -e "exists, but a\e[31m folder is expected\e[39m."
                    echo "GUID==\"$S_GUID_CANDIDATE\""
                    echo "GUID=='2139af2d-774f-4af8-a3d3-c07380e0a9e7'"
                    echo ""
                fi
                #--------
                SB_VERIFICATION_FAILED="t"
            fi
        fi
    fi #  "$SB_VERIFICATION_FAILED" == "f"
    #------------------------------
    if [ "$SB_VERIFICATION_FAILED" != "t" ]; then
        if [ "$SB_VERIFICATION_FAILED" != "f" ]; then
            echo ""
            echo -e "\e[31mThe code of this Bash function is flawed.\e[39m"
            echo "GUID=='bbc28c39-8178-4897-a5d3-c07380e0a9e7'"
            echo ""
        fi
    fi
    #------------------------------
} # func_mmmv_verify_that_the_folder_exists_but_do_not_exit_t1

#--------------------------------------------------------------------------

func_mmmv_add_bin_2_Z_PATH_and_optionally_share_man_2_MANPATH_t1(){
    local S_FP_INSTALLATION_FOLDER="$1" # is
                      # the folder with the $S_FP_INSTALLATION_FOLDER/bin
                      # and optionally  the $S_FP_INSTALLATION_FOLDER/share/man
    local S_GUID_CANDIDATE="$2"
    local SB_MAN_FOLDER_EXISTENCE_IS_MANDATORY="$3" # domain: {"t","f"} Default: "f"
    #----------------------------------------------------------------------
    # A global variable for storing function output.
    SB_VERIFICATION_FAILED="f" # domain: "t", "f" .
    #------------------------------
    if [ "$SB_VERIFICATION_FAILED" == "f" ]; then
        if [ "$S_GUID_CANDIDATE" == "" ]; then
            echo ""
            echo -e "\e[31mThe code that calls this function is flawed.\e[39m"
            echo ""
            echo "    S_GUID_CANDIDATE==\"\""
            echo ""
            echo "GUID=='45ac9f1f-aaf9-45d8-8fd3-c07380e0a9e7'"
            echo ""
            #--------
            SB_VERIFICATION_FAILED="t"
        fi
    fi
    #------------------------------
    if [ "$SB_VERIFICATION_FAILED" == "f" ]; then
        if [ "$S_FP_INSTALLATION_FOLDER" == "" ]; then
            echo ""
            echo -e "\e[31mThe code that calls this function is flawed.\e[39m"
            echo ""
            echo "    S_FP_INSTALLATION_FOLDER==\"\""
            echo ""
            echo "S_GUID_CANDIDATE=='$S_GUID_CANDIDATE'"
            echo "GUID=='1dd80455-2434-4f60-83d3-c07380e0a9e7'"
            echo ""
            #--------
            SB_VERIFICATION_FAILED="t"
        fi
    fi
    #------------------------------
    if [ "$SB_VERIFICATION_FAILED" == "f" ]; then
        if [ "$SB_MAN_FOLDER_EXISTENCE_IS_MANDATORY" == "" ]; then
            SB_MAN_FOLDER_EXISTENCE_IS_MANDATORY="f" # the default value
        else
            if [ "$SB_MAN_FOLDER_EXISTENCE_IS_MANDATORY" != "t" ]; then
                if [ "$SB_MAN_FOLDER_EXISTENCE_IS_MANDATORY" != "f" ]; then
                    echo ""
                    echo -e "\e[31mThe code that calls this function is flawed.\e[39m"
                    echo ""
                    echo "    SB_MAN_FOLDER_EXISTENCE_IS_MANDATORY==\"$SB_MAN_FOLDER_EXISTENCE_IS_MANDATORY\""
                    echo ""
                    echo "but its valid values are \"t\" and \"f\" and "
                    echo "\"\", which is automatically converted to the "
                    echo "default value of \"f\"."
                    echo "S_GUID_CANDIDATE=='$S_GUID_CANDIDATE'"
                    echo "GUID=='3d787451-58dc-474d-85d3-c07380e0a9e7'"
                    echo ""
                    #--------
                    SB_VERIFICATION_FAILED="t"
                fi
            fi
        fi
    fi
    #------------------------------
    local SB_MAN_FOLDER_OR_NONBROKEN_SYMLINK_TO_IT_EXISTS="f"
    if [ "$SB_VERIFICATION_FAILED" == "f" ]; then
        func_mmmv_verify_that_the_folder_exists_but_do_not_exit_t1 \
            "$S_FP_INSTALLATION_FOLDER" "b56d6ddd-09a9-4a98-9804-c07380e0a9e7"
        if [ "$SB_VERIFICATION_FAILED" == "f" ]; then
            #--------------
            func_mmmv_verify_that_the_folder_exists_but_do_not_exit_t1 \
                "$S_FP_INSTALLATION_FOLDER/bin" "cf12f63d-a9ce-4285-a404-c07380e0a9e7"
            if [ "$SB_VERIFICATION_FAILED" == "f" ]; then
                Z_PATH="$S_FP_INSTALLATION_FOLDER/bin:$Z_PATH"
            fi
            #--------------
            if [ -e "$S_FP_INSTALLATION_FOLDER/share/man" ]; then
                if [ -d "$S_FP_INSTALLATION_FOLDER/share/man" ]; then
                    SB_MAN_FOLDER_OR_NONBROKEN_SYMLINK_TO_IT_EXISTS="t"
                fi
            fi
            if [ "$SB_MAN_FOLDER_OR_NONBROKEN_SYMLINK_TO_IT_EXISTS" == "f" ]; then
                if [ "$SB_MAN_FOLDER_EXISTENCE_IS_MANDATORY" == "t" ]; then
                    # The next 2 lines are for displaying an error message.
                    func_mmmv_verify_that_the_folder_exists_but_do_not_exit_t1 \
                        "$S_FP_INSTALLATION_FOLDER/share/man" "2cb34eb8-7302-44e2-b6f3-c07380e0a9e7"
                fi
            else
                MANPATH="$S_FP_INSTALLATION_FOLDER/share/man:$MANPATH"
            fi
            #--------------
        fi
    fi
    #------------------------------
    if [ "$SB_VERIFICATION_FAILED" != "t" ]; then
        if [ "$SB_VERIFICATION_FAILED" != "f" ]; then
            echo ""
            echo -e "\e[31mThe code of this Bash function is flawed.\e[39m"
            echo "GUID=='5c1a2d74-aea1-40fd-bbd3-c07380e0a9e7'"
            echo ""
        fi
    fi
    #------------------------------
} # func_mmmv_add_bin_2_Z_PATH_and_optionally_share_man_2_MANPATH_t1

#--------------------------------------------------------------------------

func_mmmv_assert_error_code_zero_t1(){
    local S_ERR_CODE="$1" # the "$?"
    local S_GUID_CANDIDATE="$2"
    #----------------------------------------------------------------------
    if [ "$S_GUID_CANDIDATE" == "" ]; then
        echo ""
        echo -e "\e[31mThe Bash code that calls this function is flawed. \e[39m"
        echo ""
        echo "    S_GUID_CANDIDATE==\"\""
        echo ""
        echo "but it is expected to be a GUID."
        echo "Aborting script."
        echo "GUID=='ab48ab5b-3799-4126-94d3-c07380e0a9e7'"
        echo "S_GUID_CANDIDATE=='$S_GUID_CANDIDATE'"
        echo ""
        #--------
        cd "$S_FP_ORIG"
        exit 1
    fi
    #------------------------------
    # If the "$?" were evaluated in this function,
    # then it would be "0" even, if it is
    # something else at the calling code.
    if [ "$S_ERR_CODE" != "0" ];then
        echo ""
        echo "Something went wrong. Error code: $S_ERR_CODE"
        echo -e "\e[31mAborting script. \e[39m"
        echo "GUID=='45f8b2d4-53f9-4c89-8dd3-c07380e0a9e7'"
        echo "S_GUID_CANDIDATE=='$S_GUID_CANDIDATE'"
        echo ""
        #--------
        cd "$S_FP_ORIG"
        exit 1
    fi
    #------------------------------
} # func_mmmv_assert_error_code_zero_t1

#--------------------------------------------------------------------------

# It differs form the
# func_mmmv_assert_error_code_zero_t1
# by the fact that it does not include the
#
#     cd "$S_FP_ORIG"
#
func_mmmv_assert_error_code_zero_t2(){
    local S_ERR_CODE="$1" # the "$?"
    local S_GUID_CANDIDATE="$2"
    #----------------------------------------------------------------------
    if [ "$S_GUID_CANDIDATE" == "" ]; then
        echo ""
        echo -e "\e[31mThe Bash code that calls this function is flawed. \e[39m"
        echo ""
        echo "    S_GUID_CANDIDATE==\"\""
        echo ""
        echo "but it is expected to be a GUID."
        echo "Aborting script."
        echo "GUID=='2b7d99c5-39a7-4191-9ad3-c07380e0a9e7'"
        echo "S_GUID_CANDIDATE=='$S_GUID_CANDIDATE'"
        echo ""
        #--------
        exit 1
    fi
    #------------------------------
    # If the "$?" were evaluated in this function,
    # then it would be "0" even, if it is
    # something else at the calling code.
    if [ "$S_ERR_CODE" != "0" ];then
        echo ""
        echo "Something went wrong. Error code: $S_ERR_CODE"
        echo -e "\e[31mAborting script. \e[39m"
        echo "GUID=='41bcae25-1230-45a0-85d3-c07380e0a9e7'"
        echo "S_GUID_CANDIDATE=='$S_GUID_CANDIDATE'"
        echo ""
        #--------
        exit 1
    fi
    #------------------------------
} # func_mmmv_assert_error_code_zero_t2

#--------------------------------------------------------------------------

func_mmmv_assert_error_code_zero_t3(){
    local S_ERR_CODE="$1" # the "$?"
    local S_GUID_CANDIDATE="$2"
    #----------------------------------------------------------------------
    func_mmmv_assert_error_code_zero_t1 "$S_ERR_CODE" "$S_GUID_CANDIDATE"
    func_mmmv_wait_and_sync_t1
    #------------------------------
} # func_mmmv_assert_error_code_zero_t3

func_mmmv_assert_error_code_zero_t4(){
    local S_ERR_CODE="$1" # the "$?"
    local S_GUID_CANDIDATE="$2"
    #----------------------------------------------------------------------
    func_mmmv_assert_error_code_zero_t2 "$S_ERR_CODE" "$S_GUID_CANDIDATE"
    func_mmmv_wait_and_sync_t1
    #------------------------------
} # func_mmmv_assert_error_code_zero_t4

#--------------------------------------------------------------------------

func_mmmv_exc_verify_S_FP_ORIG_t1() {
    if [ "$S_FP_ORIG" == "" ]; then
        echo ""
        echo -e "\e[31mThe code of this script is flawed. \e[39m"
        echo "The environment variable S_FP_ORIG is expected "
        echo "to be initialized at the start of the script by "
        echo ""
        echo "    S_FP_ORIG=\"\`pwd\`\""
        echo ""
        echo "Aborting script."
        echo "GUID=='554ef225-e888-4a36-a4c3-c07380e0a9e7'"
        echo ""
        exit 1 # exit with an error
    fi
    #------------------------
    local SB_IS_SYMLINK="f"      # possible values: "t", "f"
    if [ -h "$S_FP_ORIG" ]; then # Returns "false" for paths that
                                 # do not refer to anything.
        SB_IS_SYMLINK="t"
    fi
    #--------
    if [ ! -e "$S_FP_ORIG" ]; then
        if [ "$SB_IS_SYMLINK" == "t" ]; then
            echo "The "
        else
            echo "The file or folder "
        fi
        echo ""
        echo "    S_FP_ORIG==$S_FP_ORIG "
        echo ""
        if [ "$SB_IS_SYMLINK" == "t" ]; then
            echo -e "is a\e[31m broken symlink\e[39m. It is expected to be a folder that "
        else
            echo -e "\e[31mdoes not exist\e[39m. It is expected to be a folder that "
        fi
        echo "contains the script that prints this error message."
        echo -e "\e[31mAborting script. \e[39m"
        echo "GUID=='1bcfcb94-ef93-419e-a4c3-c07380e0a9e7'"
        echo ""
        exit 1 # exit with an error
    fi
    #------------------------
    if [ ! -d "$S_FP_ORIG" ]; then
        echo "The "
        echo ""
        echo "    S_FP_ORIG==$S_FP_ORIG "
        echo ""
        echo -e "is\e[31m not a folder\e[39m. It is expected to be a folder that "
        echo "contains the script that prints this error message."
        echo -e "\e[31mAborting script. \e[39m"
        echo "GUID=='5faf601a-7c96-489d-92c3-c07380e0a9e7'"
        echo ""
        exit 1 # exit with an error
    fi
} # func_mmmv_exc_verify_S_FP_ORIG_t1

#--------------------------------------------------------------------------

FUNC_MMMV_EXC_VERIFY_S_FP_ORIG_T2_S_FB_ORIG_ALREADY_VERIFIED="f"
func_mmmv_exc_verify_S_FP_ORIG_t2(){
    if [ "$FUNC_MMMV_EXC_VERIFY_S_FP_ORIG_T2_S_FB_ORIG_ALREADY_VERIFIED" != "t" ]; then
        if [ "$FUNC_MMMV_EXC_VERIFY_S_FP_ORIG_T2_S_FB_ORIG_ALREADY_VERIFIED" != "f" ]; then
            echo ""
            echo -e "\e[31mThe code that calls this function is flawed. \e[39m"
            echo "The global variable "
            echo ""
            echo "    FUNC_MMMV_EXC_VERIFY_S_FP_ORIG_T2_S_FB_ORIG_ALREADY_VERIFIED==\"$FUNC_MMMV_EXC_VERIFY_S_FP_ORIG_T2_S_FB_ORIG_ALREADY_VERIFIED\""
            echo ""
            echo "has a domain of {\"f\", \"t\"}."
            echo "GUID=='426d213f-5e3b-42e4-b4c3-c07380e0a9e7'"
            echo ""
        else
            func_mmmv_exc_verify_S_FP_ORIG_t1
            FUNC_MMMV_EXC_VERIFY_S_FP_ORIG_T2_S_FB_ORIG_ALREADY_VERIFIED="t"
        fi
    fi
} # func_mmmv_exc_verify_S_FP_ORIG_t2

#--------------------------------------------------------------------------

func_mmmv_cd_S_FP_ORIG_and_exit_t1(){
    func_mmmv_exc_verify_S_FP_ORIG_t1
    cd "$S_FP_ORIG"
    func_mmmv_assert_error_code_zero_t2 "$?" \
        "77a93a13-f4bc-4766-82f3-c07380e0a9e7"
    exit 0
} # func_mmmv_cd_S_FP_ORIG_and_exit_t1

#--------------------------------------------------------------------------

func_mmmv_assert_nonempty_string_t1(){
    local S_IN="$1"
    local S_VARIABLE_NAME_IN_CALLING_CODE="$2"
    local S_GUID_CANDIDATE="$3"
    #----------------------------------------------------------------------
    func_mmmv_exc_verify_S_FP_ORIG_t2
    if [ "$S_GUID_CANDIDATE" == "" ]; then
        echo ""
        echo -e "\e[31mThe code that calls this function is flawed.\e[39m The"
        echo ""
        echo "    S_GUID_CANDIDATE==\"\""
        echo ""
        echo "but it is expected to be a GUID."
        echo "GUID=='f14fa55d-e054-4e9a-95c3-c07380e0a9e7'"
        echo ""
        #--------
        cd "$S_FP_ORIG"
        exit 1 # exiting with an error
    fi
    #----------------------------------------------------------------------
    if [ "$S_VARIABLE_NAME_IN_CALLING_CODE" == "" ]; then
        echo ""
        echo -e "\e[31mThe code that calls this function is flawed.\e[39m The"
        echo ""
        echo "    S_VARIABLE_NAME_IN_CALLING_CODE==\"\""
        echo ""
        echo "GUID=='2146d8ae-f0cd-45b8-b4c3-c07380e0a9e7'"
        echo "S_GUID_CANDIDATE=='$S_GUID_CANDIDATE'"
        echo ""
        #--------
        cd "$S_FP_ORIG"
        exit 1 # exiting with an error
    fi
    #----------------------------------------------------------------------
    if [ "$S_IN" == "" ]; then
        echo ""
        echo -e "\e[31mThere is a flaw somewhere in the code\e[39m that"
        echo "uses a variable named \"$S_VARIABLE_NAME_IN_CALLING_CODE\"."
        echo ""
        echo "    $S_VARIABLE_NAME_IN_CALLING_CODE==\"$S_IN\""
        echo ""
        echo "but it is expected to be something other than an empty string."
        echo "GUID=='3260d0b3-c491-4723-85c3-c07380e0a9e7'"
        echo "S_GUID_CANDIDATE=='$S_GUID_CANDIDATE'"
        echo ""
        #--------
        cd "$S_FP_ORIG"
        exit 1 # exiting with an error
    fi
    #----------------------------------------------------------------------
} # func_mmmv_assert_nonempty_string_t1

#--------------------------------------------------------------------------

func_mmmv_assert_sbvar_domain_t_f_t1(){
    local SB_VARIABLE_VALUE="$1"
    local S_VARIABLE_NAME_IN_CALLING_CODE="$2"
    local S_GUID_CANDIDATE="$3"
    #----------------------------------------------------------------------
    func_mmmv_exc_verify_S_FP_ORIG_t2
    if [ "$S_GUID_CANDIDATE" == "" ]; then
        echo ""
        echo -e "\e[31mThe code that calls this function is flawed.\e[39m The"
        echo ""
        echo "    S_GUID_CANDIDATE==\"\""
        echo ""
        echo "but it is expected to be a GUID."
        echo "GUID=='3232a2d3-7ef4-4786-86c3-c07380e0a9e7'"
        echo ""
        #--------
        cd "$S_FP_ORIG"
        exit 1 # exiting with an error
    fi
    #----------------------------------------------------------------------
    if [ "$S_VARIABLE_NAME_IN_CALLING_CODE" == "" ]; then
        echo ""
        echo -e "\e[31mThe code that calls this function is flawed.\e[39m The"
        echo ""
        echo "    S_VARIABLE_NAME_IN_CALLING_CODE==\"\""
        echo ""
        echo "GUID=='08872231-6b58-4840-93c3-c07380e0a9e7'"
        echo "S_GUID_CANDIDATE=='$S_GUID_CANDIDATE'"
        echo ""
        #--------
        cd "$S_FP_ORIG"
        exit 1 # exiting with an error
    fi
    #----------------------------------------------------------------------
    if [ "$SB_VARIABLE_VALUE" != "t" ]; then
        if [ "$SB_VARIABLE_VALUE" != "f" ]; then
            echo ""
            echo -e "\e[31mThere is a flaw somewhere in the code\e[39m that"
            echo "uses a variable named \"$S_VARIABLE_NAME_IN_CALLING_CODE\". The "
            echo ""
            echo "    $S_VARIABLE_NAME_IN_CALLING_CODE==\"$SB_VARIABLE_VALUE\""
            echo ""
            echo "but it is expected to be either \"t\" or \"f\"."
            echo "GUID=='1fec014b-3ca7-4739-a1c3-c07380e0a9e7'"
            echo "GUID_CANDIDATE=='$S_GUID_CANDIDATE'"
            echo ""
            #--------
            cd "$S_FP_ORIG"
            exit 1 # exiting with an error
        fi
    fi
    #----------------------------------------------------------------------
} # func_mmmv_assert_sbvar_domain_t_f_t1

#--------------------------------------------------------------------------

func_mmmv_assert_file_exists_t1() {
    local S_FP="$1"
    local S_GUID_CANDIDATE="$2"
    local SB_OPTIONAL_BAN_SYMLINKS="$3" # domain: {"t", "f", ""} default: "f"
                                        # is the last formal parameter
                                        # in stead of the S_GUID_CANDIDATE,
                                        # because that way this function is
                                        # backwards compatible with
                                        # an earlier version of this
                                        # function.
    #----------------------------------------------------------------------
    func_mmmv_exc_verify_S_FP_ORIG_t2
    local SB_LACK_OF_PARAMETERS="f"
    if [ "$S_FP" == "" ]; then
        SB_LACK_OF_PARAMETERS="t"
    fi
    if [ "$S_GUID_CANDIDATE" == "" ]; then
        SB_LACK_OF_PARAMETERS="t"
    fi
    if [ "$SB_LACK_OF_PARAMETERS" == "t" ]; then
        echo ""
        echo -e "\e[31mThe code that calls this function is flawed. \e[39m"
        echo "This function requires 2 parameters, which are "
        echo "S_FP, S_GUID_CANDIDATE, and it has an optional 3. parameter, "
        echo "which is SB_OPTIONAL_BAN_SYMLINKS."
        if [ "$S_GUID_CANDIDATE" != "" ]; then
            echo "S_GUID_CANDIDATE=='$S_GUID_CANDIDATE'"
        fi
        echo "GUID=='fbb0043c-d39b-4611-91c3-c07380e0a9e7'"
        echo ""
        #--------
        cd "$S_FP_ORIG"
        exit 1 # exiting with an error
    else
        if [ "$SB_LACK_OF_PARAMETERS" != "f" ]; then
            echo -e "\e[31mThis code is flawed. \e[39m"
            echo "GUID=='fc9e882e-8b43-4afa-83c3-c07380e0a9e7'"
            #--------
            cd "$S_FP_ORIG"
            exit 1 # exiting with an error
        fi
    fi
    #------------------------------
    if [ "$SB_OPTIONAL_BAN_SYMLINKS" == "" ]; then
        # The default value of the
        SB_OPTIONAL_BAN_SYMLINKS="f"
        # must be backwards compatible with the
        # version of this function, where
        # symlinks to files were treated as actual files.
    else
        if [ "$SB_OPTIONAL_BAN_SYMLINKS" != "t" ]; then
            if [ "$SB_OPTIONAL_BAN_SYMLINKS" != "f" ]; then
                echo ""
                echo "The "
                echo ""
                echo "    SB_OPTIONAL_BAN_SYMLINKS==\"$SB_OPTIONAL_BAN_SYMLINKS\""
                echo ""
                echo "but the valid values for the SB_OPTIONAL_BAN_SYMLINKS"
                echo "are: \"t\", \"f\", \"\"."
                echo "S_GUID_CANDIDATE=='$S_GUID_CANDIDATE'"
                echo "GUID=='f2c0d384-b82c-4c3b-b2c3-c07380e0a9e7'"
                echo ""
                #--------
                cd "$S_FP_ORIG"
                exit 1 # exiting with an error
            fi
        fi
    fi
    #------------------------------
    if [ ! -e "$S_FP" ]; then
        if [ -h "$S_FP" ]; then
            echo ""
            echo "The path "
            echo ""
            echo "    $S_FP "
            echo ""
            echo -e "points to a\e[31m broken symlink\e[39m, but "
            if [ "$SB_OPTIONAL_BAN_SYMLINKS" == "t" ]; then
                echo "a file is expected."
            else
                echo "a file or a symlink to a file is expected."
            fi
            echo "S_GUID_CANDIDATE==\"$S_GUID_CANDIDATE\""
            echo "GUID=='2156be14-4cef-4e46-9dc3-c07380e0a9e7'"
            echo ""
            #--------
            cd "$S_FP_ORIG"
            exit 1 # exiting with an error
        else
            echo ""
            if [ "$SB_OPTIONAL_BAN_SYMLINKS" == "t" ]; then
                echo "The file "
            else
                echo "The file or a symlink to a file "
            fi
            echo ""
            echo "    $S_FP "
            echo ""
            echo -e "\e[31mdoes not exist\e[39m."
            echo "S_GUID_CANDIDATE==\"$S_GUID_CANDIDATE\""
            echo "GUID=='3b116c32-b676-4368-a2b3-c07380e0a9e7'"
            echo ""
            #--------
            cd "$S_FP_ORIG"
            exit 1 # exiting with an error
        fi
    else
        if [ -d "$S_FP" ]; then
            echo ""
            if [ -h "$S_FP" ]; then
                echo "The symlink to an existing folder "
            else
                echo "The folder "
            fi
            echo ""
            echo "    $S_FP "
            echo ""
            printf "exists, but "
            if [ "$SB_OPTIONAL_BAN_SYMLINKS" == "t" ]; then
                echo -e "a\e[31m file is expected\e[39m."
            else
                echo -e "a\e[31m file or a symlink to a file is expected\e[39m."
            fi
            echo "S_GUID_CANDIDATE==\"$S_GUID_CANDIDATE\""
            echo "GUID=='74e1e74c-2da7-4b4b-a1b3-c07380e0a9e7'"
            echo ""
            #--------
            cd "$S_FP_ORIG"
            exit 1 # exiting with an error
        else
            if [ "$SB_OPTIONAL_BAN_SYMLINKS" == "t" ]; then
                if [ -h "$S_FP" ]; then
                    echo ""
                    echo "The "
                    echo ""
                    echo "    $S_FP"
                    echo ""
                    echo -e "is a symlink to a file, but a\e[31m file is expected\e[39m."
                    echo "S_GUID_CANDIDATE==\"$S_GUID_CANDIDATE\""
                    echo "GUID=='083f3c43-7135-40bd-b5b3-c07380e0a9e7'"
                    echo ""
                    #--------
                    cd "$S_FP_ORIG"
                    exit 1 # exiting with an error
                fi
            fi
        fi
    fi
} # func_mmmv_assert_file_exists_t1

#--------------------------------------------------------------------------

func_mmmv_assert_folder_exists_t1() {
    local S_FP="$1"
    local S_GUID_CANDIDATE="$2"
    local SB_OPTIONAL_BAN_SYMLINKS="$3" # domain: {"t", "f", ""} default: "f"
                                        # is the last formal parameter
                                        # in stead of the S_GUID_CANDIDATE,
                                        # because that way this function is
                                        # backwards compatible with
                                        # an earlier version of this
                                        # function.
    #----------------------------------------------------------------------
    func_mmmv_exc_verify_S_FP_ORIG_t2
    local SB_LACK_OF_PARAMETERS="f"
    if [ "$S_FP" == "" ]; then
        SB_LACK_OF_PARAMETERS="t"
    fi
    if [ "$S_GUID_CANDIDATE" == "" ]; then
        SB_LACK_OF_PARAMETERS="t"
    fi
    if [ "$SB_LACK_OF_PARAMETERS" == "t" ]; then
        echo ""
        echo -e "\e[31mThe code that calls this function is flawed. \e[39m"
        echo "This function requires 2 parameters, which are "
        echo "S_FP, S_GUID_CANDIDATE, and it has an optional 3. parameter, "
        echo "which is SB_OPTIONAL_BAN_SYMLINKS."
        if [ "$S_GUID_CANDIDATE" != "" ]; then
            echo "S_GUID_CANDIDATE=='$S_GUID_CANDIDATE'"
        fi
        echo "GUID=='e8816b55-1763-4152-85b3-c07380e0a9e7'"
        echo ""
        #--------
        cd "$S_FP_ORIG"
        exit 1 # exiting with an error
    else
        if [ "$SB_LACK_OF_PARAMETERS" != "f" ]; then
            echo -e "\e[31mThis code is flawed. \e[39m"
            echo "GUID=='41fa2705-a07f-40a7-bab3-c07380e0a9e7'"
            #--------
            cd "$S_FP_ORIG"
            exit 1 # exiting with an error
        fi
    fi
    #------------------------------
    if [ "$SB_OPTIONAL_BAN_SYMLINKS" == "" ]; then
        # The default value of the
        SB_OPTIONAL_BAN_SYMLINKS="f"
        # must be backwards compatible with the
        # version of this function, where
        # symlinks to folders were treated as actual folders.
    else
        if [ "$SB_OPTIONAL_BAN_SYMLINKS" != "t" ]; then
            if [ "$SB_OPTIONAL_BAN_SYMLINKS" != "f" ]; then
                echo ""
                echo "The "
                echo ""
                echo "    SB_OPTIONAL_BAN_SYMLINKS==\"$SB_OPTIONAL_BAN_SYMLINKS\""
                echo ""
                echo "but the valid values for the SB_OPTIONAL_BAN_SYMLINKS"
                echo "are: \"t\", \"f\", \"\"."
                echo "S_GUID_CANDIDATE=='$S_GUID_CANDIDATE'"
                echo "GUID=='0514ca50-6961-4add-a5b3-c07380e0a9e7'"
                echo ""
                #--------
                cd "$S_FP_ORIG"
                exit 1 # exiting with an error
            fi
        fi
    fi
    #------------------------------
    if [ ! -e "$S_FP" ]; then
        if [ -h "$S_FP" ]; then
            echo ""
            echo "The path "
            echo ""
            echo "    $S_FP "
            echo ""
            echo -e "points to a\e[31m broken symlink\e[39m, but "
            if [ "$SB_OPTIONAL_BAN_SYMLINKS" == "t" ]; then
                echo -e "a\e[31m folder is expected\e[39m."
            else
                echo -e "a\e[31m folder or a symlink to a folder is expected\e[39m."
            fi
            echo "S_GUID_CANDIDATE==\"$S_GUID_CANDIDATE\""
            echo "GUID=='b3833a46-3059-4b0e-83b3-c07380e0a9e7'"
            echo ""
            #--------
            cd "$S_FP_ORIG"
            exit 1 # exiting with an error
        else
            echo ""
            if [ "$SB_OPTIONAL_BAN_SYMLINKS" == "t" ]; then
                echo "The folder "
            else
                echo "The folder or a symlink to a folder "
            fi
            echo ""
            echo "    $S_FP "
            echo ""
            echo -e "\e[31mdoes not exist\e[39m."
            echo "S_GUID_CANDIDATE==\"$S_GUID_CANDIDATE\""
            echo "GUID=='15fcae20-6cae-4e36-a1b3-c07380e0a9e7'"
            echo ""
            #--------
            cd "$S_FP_ORIG"
            exit 1 # exiting with an error
        fi
    else
        if [ ! -d "$S_FP" ]; then
            echo ""
            if [ -h "$S_FP" ]; then
                echo "The symlink to an existing file "
            else
                echo "The file "
            fi
            echo ""
            echo "    $S_FP "
            echo ""
            printf "exists, but "
            if [ "$SB_OPTIONAL_BAN_SYMLINKS" == "t" ]; then
                echo -e "a\e[31m folder is expected\e[39m."
            else
                echo -e "a\e[31m folder or a symlink to a folder is expected\e[39m."
            fi
            echo "S_GUID_CANDIDATE==\"$S_GUID_CANDIDATE\""
            echo "GUID=='4c43c230-462c-4456-93b3-c07380e0a9e7'"
            echo ""
            #--------
            cd "$S_FP_ORIG"
            exit 1 # exiting with an error
        else
            if [ "$SB_OPTIONAL_BAN_SYMLINKS" == "t" ]; then
                if [ -h "$S_FP" ]; then
                    echo ""
                    echo "The "
                    echo ""
                    echo "    $S_FP"
                    echo ""
                    echo -e "is a symlink to a folder, but a\e[31m folder is expected\e[39m."
                    echo "S_GUID_CANDIDATE==\"$S_GUID_CANDIDATE\""
                    echo "GUID=='1e0bc611-ff76-4099-b1b3-c07380e0a9e7'"
                    echo ""
                    #--------
                    cd "$S_FP_ORIG"
                    exit 1 # exiting with an error
                fi
            fi
        fi
    fi
} # func_mmmv_assert_folder_exists_t1

#--------------------------------------------------------------------------

func_mmmv_exit_if_not_on_path_t2() { # S_COMMAND_NAME
    local S_COMMAND_NAME="$1"
    #----------------------------------------------------------------------
    func_mmmv_exc_verify_S_FP_ORIG_t2
    local S_LOCAL_VARIABLE="`which $S_COMMAND_NAME 2> /dev/null`"
    if [ "$S_LOCAL_VARIABLE" == "" ]; then
        echo ""
        echo -e "\e[31mCommand \"$S_COMMAND_NAME\" could not be found from the PATH. \e[39m"
        echo "The execution of this Bash script is aborted."
        echo "GUID=='1b3a4ec4-d8a3-4552-b2b3-c07380e0a9e7'"
        echo ""
        cd "$S_FP_ORIG"
        exit 1;
    fi
} # func_mmmv_exit_if_not_on_path_t2

#--------------------------------------------------------------------------

func_mmmv_exit_t1(){
    local S_GUID_CANDIDATE="$1" # first function argument
    #----------------------------------------------------------------------
    echo ""
    echo -e "\e[32m\e[7m#======================================================="
    echo -e "\e[0m\e[32mIf You want to run this Bash script, the "
    echo "#--------------"
    echo "$S_FP_DIR/$S_FN_SCRIPTFILE_NAME"
    echo "#--------------"
    echo "then please edit it by outcommenting the line with the "
    echo "\"$S_GUID_CANDIDATE\"."
    echo "Thank You."
    echo -e "\e[32m\e[7m#======================================================="
    echo -e "\e[0m" # resets the text terminal style
    cd "$S_FP_ORIG"
    exit 1
} # func_mmmv_exit_t1

#--------------------------------------------------------------------------

func_mmmv_exc_exit_with_an_error_t1(){
    local S_GUID_CANDIDATE="$1" # first function argument
    #----------------------------------------------------------------------
    func_mmmv_exc_verify_S_FP_ORIG_t1
    echo ""
    echo -e "\e[31mThe code of this script is flawed. \e[39m"
    echo "Aborting script."
    if [ "$S_GUID_CANDIDATE" != "" ]; then
        echo "GUID_CANDIDATE=='$S_GUID_CANDIDATE'"
    fi
    echo "GUID=='a84e9226-d75e-4f37-92b3-c07380e0a9e7'"
    echo ""
    cd "$S_FP_ORIG"
    exit 1 # exit with an error
} # func_mmmv_exc_exit_with_an_error_t1

#--------------------------------------------------------------------------

func_mmmv_exc_exit_with_an_error_t2(){
    local S_GUID_CANDIDATE="$1"   # first function argument
    local S_OPTIONAL_ERR_MSG="$2" # second function argument
    #----------------------------------------------------------------------
    func_mmmv_exc_verify_S_FP_ORIG_t1
    if [ "$S_GUID_CANDIDATE" == "" ]; then
        echo ""
        echo -e "\e[31mThe code of this script is flawed. \e[39m"
        if [ "$S_OPTIONAL_ERR_MSG" != "" ]; then
            echo -e "$S_OPTIONAL_ERR_MSG"
        fi
        echo "Aborting script."
        echo "GUID=='538a209c-c640-4c26-92b3-c07380e0a9e7'"
        echo ""
        cd "$S_FP_ORIG"
        exit 1 # exit with an error
    else
        echo ""
        echo -e "\e[31mSomething went wrong. \e[39m"
        if [ "$S_OPTIONAL_ERR_MSG" != "" ]; then
            echo "$S_OPTIONAL_ERR_MSG"
        fi
        echo "Aborting script."
        echo "GUID_CANDIDATE=='$S_GUID_CANDIDATE'"
        echo "GUID=='313b39cc-d6cb-4abb-a293-c07380e0a9e7'"
        echo ""
        cd "$S_FP_ORIG"
        exit 1 # exit with an error
    fi
} # func_mmmv_exc_exit_with_an_error_t2

#--------------------------------------------------------------------------

func_mmmv_assert_exists_on_path_t1() {
    local S_NAME_OF_THE_EXECUTABLE="$1" # first function argument
    #----------------------------------------------------------------------
    func_mmmv_exc_verify_S_FP_ORIG_t2
    local S_TMP_0="\`which $S_NAME_OF_THE_EXECUTABLE 2> /dev/null\`"
    local S_TMP_1=""
    local S_TMP_2="S_TMP_1=$S_TMP_0"
    eval ${S_TMP_2}
    if [ "$S_TMP_1" == "" ]; then
        S_TMP_0="This bash script requires the \""
        S_TMP_1="\" to be on the PATH."
        #--------
        echo ""
        echo -e "$S_TMP_0\e[31m$S_NAME_OF_THE_EXECUTABLE\e[39m$S_TMP_1"
        echo "GUID=='318d0735-2d01-42cf-a493-c07380e0a9e7'"
        echo ""
        cd "$S_FP_ORIG"
        exit 1 # exit with an error
    fi
} # func_mmmv_assert_exists_on_path_t1

# Test/demo code:
#     func_mmmv_assert_exists_on_path_t1 "ruby"
#     func_mmmv_assert_exists_on_path_t1 "rubyy"
#--------------------------------------------------------------------------

func_mmmv_operatingsystem_is_Linux() { # S_OUTPUT_VARIABLE_NAME
    local S_OUTPUT_VARIABLE_NAME="$1"
    #----------------------------------------------------------------------
    local S_OUT="f"
    local S_X="`uname -a | grep -l Linux `"
    if [ "$S_X" != "" ]; then
        S_OUT="t"
    fi
    local S_SCRIPT_0="$S_OUTPUT_VARIABLE_NAME=\"$S_OUT\""
    eval ${S_SCRIPT_0}
    # echo "ANSWER: $S_OUT"
} # func_mmmv_operatingsystem_is_Linux

#--------------------------------------------------------------------------

func_mmmv_operatingsystem_is_FreeBSD() { # S_OUTPUT_VARIABLE_NAME
    local S_OUTPUT_VARIABLE_NAME="$1"
    #----------------------------------------------------------------------
    local S_OUT="f"
    local S_X="`uname -a | grep -l FreeBSD`"
    if [ "$S_X" != "" ]; then
        S_OUT="t"
    fi
    local S_SCRIPT_0="$S_OUTPUT_VARIABLE_NAME=\"$S_OUT\""
    eval ${S_SCRIPT_0}
    # echo "ANSWER: $S_OUT"
} # func_mmmv_operatingsystem_is_FreeBSD

#--------------------------------------------------------------------------

func_mmmv_operatingsystem_is_NetBSD() { # S_OUTPUT_VARIABLE_NAME
    local S_OUTPUT_VARIABLE_NAME="$1"
    #----------------------------------------------------------------------
    local S_OUT="f"
    local S_X="`uname -a | grep -l NetBSD`"
    if [ "$S_X" != "" ]; then
        S_OUT="t"
    fi
    local S_SCRIPT_0="$S_OUTPUT_VARIABLE_NAME=\"$S_OUT\""
    eval ${S_SCRIPT_0}
    # echo "ANSWER: $S_OUT"
} # func_mmmv_operatingsystem_is_NetBSD

#--------------------------------------------------------------------------

func_mmmv_operatingsystem_is_OpenBSD() { # S_OUTPUT_VARIABLE_NAME
    local S_OUTPUT_VARIABLE_NAME="$1"
    #----------------------------------------------------------------------
    local S_OUT="f"
    local S_X="`uname -a | grep -l OpenBSD`"
    if [ "$S_X" != "" ]; then
        S_OUT="t"
    fi
    local S_SCRIPT_0="$S_OUTPUT_VARIABLE_NAME=\"$S_OUT\""
    eval ${S_SCRIPT_0}
    # echo "ANSWER: $S_OUT"
} # func_mmmv_operatingsystem_is_OpenBSD

#--------------------------------------------------------------------------

func_mmmv_operatingsystem_is_BSD() { # S_OUTPUT_VARIABLE_NAME
    local S_OUTPUT_VARIABLE_NAME="$1"
    #----------------------------------------------------------------------
    local S_OUT="f"
    local SB_TMP_0_orig="$SB_TMP_0"
    #----------------------------------------------------------------------
    func_mmmv_operatingsystem_is_FreeBSD "SB_TMP_0"
    S_OUT="$SB_TMP_0"
    if [ "$S_OUT" == "f" ]; then
        func_mmmv_operatingsystem_is_NetBSD "SB_TMP_0"
        S_OUT="$SB_TMP_0"
        if [ "$S_OUT" == "f" ]; then
            func_mmmv_operatingsystem_is_OpenBSD "SB_TMP_0"
            S_OUT="$SB_TMP_0"
        fi
    fi
    #----------------------------------------------------------------------
    export SB_TMP_0="$SB_TMP_0_orig"
    local S_SCRIPT_0="$S_OUTPUT_VARIABLE_NAME=\"$S_OUT\""
    eval ${S_SCRIPT_0}
    # echo "ANSWER: $S_OUT"
    #----------------------------------------------------------------------
} # func_mmmv_operatingsystem_is_BSD

#--------------------------------------------------------------------------

func_mmmv_operatingsystem_is_macOS() { # S_OUTPUT_VARIABLE_NAME
    local S_OUTPUT_VARIABLE_NAME="$1"
    #----------------------------------------------------------------------
    local S_OUT="f"
    local S_X="`uname -a | grep -i 'Darwin' | grep -i 'Kernel' `"
    if [ "$S_X" != "" ]; then
        S_OUT="t"
    fi
    local S_SCRIPT_0="$S_OUTPUT_VARIABLE_NAME=\"$S_OUT\""
    eval ${S_SCRIPT_0}
    # echo "ANSWER: $S_OUT"
} # func_mmmv_operatingsystem_is_macOS

#--------------------------------------------------------------------------

# Sets the global environment variable S_MMMV_OPERATING_SYSTEM
func_mmmv_determine_operatingsystem_t1() {
    local SB_AVOID_REINITIALISATION_IF_ALREADY_INITIALIZED="$1" # domain: {"","t","f"}
                                                                # default: "t"
                                                                # "" -> "t"
    #----------------------------------------------------------------------
    local SB_REUSE_EXISTING_VALUE="f" # may be there is no old value to use
    local SB_RE_EX_VA_IF_PO_NORMALISED="$SB_AVOID_REINITIALISATION_IF_ALREADY_INITIALIZED"
    if [ "$SB_AVOID_REINITIALISATION_IF_ALREADY_INITIALIZED" == "" ]; then
        SB_RE_EX_VA_IF_PO_NORMALISED="t"
    else
        func_mmmv_assert_sbvar_domain_t_f_t1 \
            "$SB_AVOID_REINITIALISATION_IF_ALREADY_INITIALIZED" \
            "SB_AVOID_REINITIALISATION_IF_ALREADY_INITIALIZED" \
            "4825db34-79fb-4063-a2f3-c07380e0a9e7"
    fi
    if [ "$SB_RE_EX_VA_IF_PO_NORMALISED" == "t" ]; then
        if [ "$S_MMMV_OPERATING_SYSTEM" != "" ]; then
            SB_REUSE_EXISTING_VALUE="t"
        fi
    fi
    #----------------------------------------------------------------------
    local SB_TMP_0_orig="$SB_TMP_0"
    if [ "$SB_REUSE_EXISTING_VALUE" == "f" ]; then
        #------------------------------------------------------------------
        func_mmmv_operatingsystem_is_Linux "SB_TMP_0"
        if [ "$SB_TMP_0" == "t" ]; then
            export S_MMMV_OPERATING_SYSTEM="linux"
        else
            func_mmmv_operatingsystem_is_BSD "SB_TMP_0"
            if [ "$SB_TMP_0" == "t" ]; then
                export S_MMMV_OPERATING_SYSTEM="bsd"
            else
                func_mmmv_operatingsystem_is_macOS "SB_TMP_0"
                if [ "$SB_TMP_0" == "t" ]; then
                    export S_MMMV_OPERATING_SYSTEM="macos"
                else
                    export S_MMMV_OPERATING_SYSTEM="unrecognised_operating_system"
                fi
            fi
        fi
        #------------------------------------------------------------------
        export SB_TMP_0="$SB_TMP_0_orig"
        #------------------------------------------------------------------
    fi
    #----------------------------------------------------------------------
} # func_mmmv_determine_operatingsystem_t1

#--------------------------------------------------------------------------

func_mmmv_exit_if_environment_variable_not_set_t1() { # S_ENVIRONMENT_VARIABLE_NAME
    local S_ENVIRONMENT_VARIABLE_NAME="$1"
    local S_ENVIRONMENT_VARIABLE_DOCSTRING="$2" # will be appended to failure-message
    #----------------------------------------------------------------------
    local S_ENVIR_VALUE=""
    local S_SCRIPT_0="S_ENVIR_VALUE=\"\`echo \$$S_ENVIRONMENT_VARIABLE_NAME\`\""
    eval "$S_SCRIPT_0"
    if [ "$S_ENVIR_VALUE" == "" ]; then
        echo ""
        echo -e "The environment variable $S_ENVIRONMENT_VARIABLE_NAME \e[31mis not set\e[39m, but "
        echo "it must be set or this script will not run (properly)."
        if [ "$S_ENVIRONMENT_VARIABLE_DOCSTRING" != "" ]; then
            echo ""
            echo "$S_ENVIRONMENT_VARIABLE_DOCSTRING"
        fi
        echo ""
        exit 1;
    #else
         # echo "S_ENVIR_VALUE==\"$S_ENVIR_VALUE\""
    fi
} # func_mmmv_exit_if_environment_variable_not_set_t1

# Test/demo code:
#     func_mmmv_exit_if_environment_variable_not_set_t1 "CFLAGS"

#--------------------------------------------------------------------------

func_mmmv_assert_Linux_or_BSD_t1(){
    local S_GUID_CANDIDATE="$1"
    #----------------------------------------------------------------------
    func_mmmv_exc_verify_S_FP_ORIG_t2
    if [ "$S_GUID_CANDIDATE" == "" ]; then
        echo ""
        echo -e "\e[31mS_GUID_CANDIDATE==\"\", but it is expected to be a GUID. \e[39m"
        echo "GUID=='eb70e918-a5d4-4688-b583-c07380e0a9e7'"
        echo ""
        # if [ "$S_FP_ORIG" != "" ]; then
        #     func_mmmv_exc_verify_S_FP_ORIG_t1
        #     cd "$S_FP_ORIG"
        # fi
        #--------
        cd "$S_FP_ORIG"
        exit 1 # exit with an error
    fi
    #--------------------
    #S_TMP_0="`uname -a | grep -E \"([Ll][Ii][Nn][Uu][Xx]|[Bb][Ss][Dd]|[Cc][Yy][Gg][Ww][Ii][Nn])\"`"
    S_TMP_0="`uname -a | grep -E \"(([Ll][Ii][Nn][Uu][Xx]|[Bb][Ss][Dd])[ ])\"`"
    if [ "$S_TMP_0" == "" ]; then
        echo ""
        echo "The classical command line utilities at "
        echo "different operating systems, for example, Linux and BSD,"
        echo "differ. This script is designed to run only on Linux and BSD."
        echo "If You are willing to risk that some of Your data "
        echo "is deleted and/or Your operating system instance"
        echo "becomes permanently flawed, to the point that "
        echo "it will not even boot, then You may edit the Bash script that "
        echo "calls the function that displays this error message "
        echo "by uncommenting that function."
        echo ""
        echo "If You do decide to edit the Bash script, then "
        echo "a recommendation is to test Your modifications "
        echo "within a virtual appliance or, if virtual appliances are not"
        echo "an option, as some new operating system user that does not have "
        echo "any access to the vital data/files."
        echo ""
        echo "Aborting script without doing anything."
        echo ""
        echo "GUID=='0cff2e44-1b86-4735-a183-c07380e0a9e7'"
        echo ""
        # if [ "$S_FP_ORIG" != "" ]; then
        #     func_mmmv_exc_verify_S_FP_ORIG_t1
        #     cd "$S_FP_ORIG"
        # fi
        #--------
        cd "$S_FP_ORIG"
        exit 1 # exit with an error
    fi
} # func_mmmv_assert_Linux_or_BSD_t1

#--------------------------------------------------------------------------

S_OWNER="to_be_determined"
func_mmmv_s_owner_of_a_file_or_folder_t1(){
    local S_FP_IN="$1" # file or directory
    #----------------------------------------------------------------------
    # According to the
    #     https://unix.stackexchange.com/questions/7730/find-the-owner-of-a-directory-or-file-but-only-return-that-and-nothing-else
    #     archival copy: https://archive.ph/QqssI
    # the solutions are:
    #     Linux, GNU coreutils (tested to work also on WSL):
    #         stat -c '%U' /path/of/file/or/directory
    #     FreeBSD:
    #         stat -f '%Su' /path/of/file/or/directory
    #     General solution that works on Linux and FreeBSD:
    #         ls -ld /path/of/file/or/directory | awk '{print $3}'
    #----------------------------------------------------------------------
    S_OWNER=""
    #----------------------------------------------------------------------
    if [ ! -e "$S_FP_IN" ]; then
        if [ -h "$S_FP_IN" ]; then
            func_mmmv_exc_exit_with_an_error_t2 \
                "f3b71629-15d6-4c48-b1f3-c07380e0a9e7" \
                "The $S_FP_IN is a broken symlink."
        else
            func_mmmv_exc_exit_with_an_error_t2 \
                "e4da107c-0fd3-4ad1-b5f3-c07380e0a9e7" \
                "The file or folder(==$S_FP_IN ) does not exist."
        fi
    fi
    #----------------------------------------------------------------------
    if [ "$SB_STAT_EXISTS_ON_PATH" == "t" ]; then
        # This is a speedhack branch that
        # takes advantage of the mmmv_userspace_distro_t1
        #     https://github.com/martinvahi/mmmv_userspace_distro_t1
        #     https://sourceforge.net/projects/mmmv-userspace-distro-t1/
        if [ "$SB_OPERATINGSYSTEM_LINUX" == "t" ]; then
            S_OWNER="`stat -c '%U' \"$S_FP_IN\" `"
        else
            if [ "$SB_OPERATINGSYSTEM_BSD_FREEBSD" == "t" ]; then
                S_OWNER="`stat -f '%Su' \"$S_FP_IN\" `"
            fi
        fi
    fi
    #--------
    if [ "$S_OWNER" == "" ]; then
        func_mmmv_exc_determine_Awk_command_t1 # sets the value of S_AWK_CMD
        if [ "$SB_AWK_EXISTS_ON_PATH" != "t" ]; then
            func_mmmv_exit_if_not_on_path_t2 "$S_AWK_CMD"
        fi
        #--------
        # The next line, if uncommented,
        #     S_OWNER="`ls -ld \"$S_FP_IN\" | awk '{print $3}' `"
        # has been tested to work on both, Linux and FreeBSD.
        #--------
        S_OWNER="`ls -ld \"$S_FP_IN\" | $S_AWK_CMD '{print $3}' `"
    fi
    #----------------------------------------------------------------------
} # func_mmmv_s_owner_of_a_file_or_folder_t1

#--------------------------------------------------------------------------

func_display_help_message(){
    echo -e ""
    echo -e "  COMMAND_LINE_ARGS :== HELP | TESTS | DISPLAY_DEMO_SCRIPT | GENERATE_DOWNLOAD_SCRIPT "
    echo -e "                              HELP :== \"\e[33mhelp\e[39m\" | \"-?\" | \"-h\" "
    echo -e "                             TESTS :== \"\e[33mtest1\e[39m\" | \"\e[33mtest2\e[39m\"  "
    echo -e "               DISPLAY_DEMO_SCRIPT :== \"\e[33mdemo\e[39m\"  "
    echo -e "          GENERATE_DOWNLOAD_SCRIPT :== MAX_N_OF_QUERY_RESULTS QUERY_CONJUNCTION_SEARCHSTRINGS "
    echo -e "            MAX_N_OF_QUERY_RESULTS :== <a whole number greater than 0 in base 10> "
    echo -e "   QUERY_CONJUNCTION_SEARCHSTRINGS :== SEARCHSTRING+ // at most 6 searchstrings "
    echo -e "                      SEARCHSTRING :== <space-tab-linebreakless string> "
    echo -e ""
} # func_display_help_message

#--------------------------------------------------------------------------

#S_CMD_GNU_AWK="awk"
#S_CMD_GNU_MAKE="make"
S_CMD_GNU_SED="sed"
func_check_for_some_dependencies(){
    #----------------------------------------------------------------------
    #func_mmmv_assert_exists_on_path_t1 "ar"
    #func_mmmv_assert_exists_on_path_t1 "bc" # different programs on BSD and Linux
    func_mmmv_assert_exists_on_path_t1 "cat"
    func_mmmv_assert_exists_on_path_t1 "curl"
    func_mmmv_assert_exists_on_path_t1 "grep"
    #func_mmmv_assert_exists_on_path_t1 "huniq"
    func_mmmv_assert_exists_on_path_t1 "jq"
    #func_mmmv_assert_exists_on_path_t1 "flex"
    func_mmmv_assert_exists_on_path_t1 "nice"   # here just in case
    func_mmmv_assert_exists_on_path_t1 "printf" # here just in case
    #func_mmmv_assert_exists_on_path_t1 "ranlib"
    func_mmmv_assert_exists_on_path_t1 "sleep"
    #func_mmmv_assert_exists_on_path_t1 "sort"
    #func_mmmv_assert_exists_on_path_t1 "tee"
    func_mmmv_assert_exists_on_path_t1 "tr" # different programs on BSD and Linux
    #func_mmmv_assert_exists_on_path_t1 "uniq"
    #func_mmmv_assert_exists_on_path_t1 "xargs"
    func_mmmv_assert_exists_on_path_t1 "wget"
    #------------------------------
    #func_mmmv_assert_exists_on_path_t1 "7z"      # .7z
    #func_mmmv_assert_exists_on_path_t1 "arj"     # .arj
    #func_mmmv_assert_exists_on_path_t1 "bunzip2" # .bz2
    #func_mmmv_assert_exists_on_path_t1 "gunzip"   # .gz
    #func_mmmv_assert_exists_on_path_t1 "plzip"   # .lz .tlz
    #func_mmmv_assert_exists_on_path_t1 "tar"      # .tar
    #func_mmmv_assert_exists_on_path_t1 "unxz"    # .xz
    #func_mmmv_assert_exists_on_path_t1 "unzip"   # .zip
    #func_mmmv_assert_exists_on_path_t1 "unrar"   # .rar
    #func_mmmv_assert_exists_on_path_t1 "xar"     # .xar
    #------------------------------
    #func_mmmv_assert_exists_on_path_t1 "cargo"
    #func_mmmv_assert_exists_on_path_t1 "gem"
    #func_mmmv_assert_exists_on_path_t1 "java"
    #func_mmmv_assert_exists_on_path_t1 "javac"
    #func_mmmv_assert_exists_on_path_t1 "perl"
    #func_mmmv_assert_exists_on_path_t1 "python3"
    #func_mmmv_assert_exists_on_path_t1 "ruby"
    #func_mmmv_assert_exists_on_path_t1 "rustc"
    #----------------------------------------------------------------------
    # The test for the availability of grep is
    # expected to be somewhere above this line.
    if [ "`uname -a | grep -i 'BSD' `" != '' ]; then
        #S_CMD_GNU_AWK="gawk"
        #S_CMD_GNU_MAKE="gmake"
        S_CMD_GNU_SED="gsed"
    fi
    #func_mmmv_assert_exists_on_path_t1 "$S_CMD_GNU_AWK"
    #func_mmmv_assert_exists_on_path_t1 "$S_CMD_GNU_MAKE"
    func_mmmv_assert_exists_on_path_t1 "$S_CMD_GNU_SED"
    #----------------------------------------------------------------------
} # func_check_for_some_dependencies

#--------------------------------------------------------------------------

func_display_Bash_script_that_was_obtained_on_by_modyfying_copilot_microsoft_com_2025_09_12_generated_Bash_script(){
    echo "#!/usr/bin/env bash"
    echo "#=========================================================================="
    echo "# The script below is a modified version of code generated by the"
    echo "# copilot.microsoft.com and as of 2025_09_11 the copilot.microsoft.com"
    echo "# claims that the code fragments that it generates are under the MIT"
    echo "# license. The modifications of the copilot.microsoft.com generated"
    echo "# code have been done Martin.Vahi@softf1.com and are in the public domain."
    echo "#"
    echo "S_TERMPREFIX='subject:\"'"
    echo "S_TERMSUFFIX='\" '"
    echo "#S_QUERY=\"\$S_TERMPREFIX\"'Моделист-Конструктор'\"\$S_TERMSUFFIX AND \$S_TERMPREFIX\"'Журнальный зал'\"\$S_TERMSUFFIX\""
    echo "#S_QUERY='subject:\"Моделист-Конструктор\" AND subject:\"Журнальный зал\"'"
    echo "S_QUERY='subject:\"Electronics\" AND subject:\"Magazine\"'"
    echo "S_QUERY_ENCODED=\$(echo \"\$S_QUERY\" | jq -sRr @uri)"
    echo "S_SEARCH_API_URL_PREFIX=\"https://archive.org/advancedsearch.php\""
    echo "S_FIELDS=\"identifier\""
    echo "SI_ROWS=10"
    echo "echo \"Downloading torrent file name prefixes from archive.org...\""
    echo "S_RESPONSE=\$(curl -s \"\${S_SEARCH_API_URL_PREFIX}?q=\${S_QUERY_ENCODED}&fl[]=\${S_FIELDS}&rows=\${SI_ROWS}&output=json\")"
    echo "wait"
    echo "# Tested only with GNU sed on Linux, not the BSD sed."
    echo "S_BASHSCRIPT_0=\$(echo \"\$S_RESPONSE\" | \\"
    echo "    jq -r '.response.docs[].identifier' | \\"
    echo "    sed -e 's/^/AR_IDENTIFIERS+=(\"/g' | \\"
    echo "    sed -e 's/\$/\") ; /g')"
    echo "wait"
    echo "local AR_IDENTIFIERS=()"
    echo "eval \${S_BASHSCRIPT_0}"
    echo "S_FN=\"\""
    echo "S_FN_SUFFIX=\"_archive.torrent\""
    echo "echo \"\""
    echo "echo \"At most \$SI_ROWS first torrent URLs:\""
    echo "S_SCRIPT_0=\"AR_0+=(\\\$S_ITER)\""
    echo "for ((i = 0; i < \${#AR_IDENTIFIERS[@]}; i++)) do"
    echo "    S_ID=\"\${AR_IDENTIFIERS[\$i]}\""
    echo "    S_FN=\"\$S_ID\$S_FN_SUFFIX\""
    echo "    S_URL_TORRENT=\"https://archive.org/download/\$S_ID/\$S_FN\""
    echo "    echo \"    \$S_URL_TORRENT\""
    echo "    #echo \"    wget -q --show-progress \\\"\$S_URL_TORRENT\\\" \""
    echo "done"
    echo "echo \"\""
    echo "echo -e \"\\e[32mThank You for trying out this script\\e[39m.\""
    echo "#=========================================================================="
    echo ""
} # func_display_Bash_script_that_was_obtained_on_by_modyfying_copilot_microsoft_com_2025_09_12_generated_Bash_script

#--------------------------------------------------------------------------
S_ARGV_0="$1" # Bash style command line argument indices versus
              # Ruby style command line argument indices.
S_ARGV_1="$2"
S_ARGV_2="$3"
S_ARGV_3="$4"
S_ARGV_4="$5"
S_ARGV_5="$6"
S_ARGV_6="$7"
S_ARGV_7="$8"
S_ARGV_8="$9"

SI_MAX_N_OF_QUERY_RESULTS=""

func_display_help_message_and_exit_if_needed(){
    #----------------------------------------------------------------------
    local S_TMP_0=""
    #------------------------------
    if [ "$S_ARGV_0" == "" ]; then
        echo ""
        echo -e "\e[31mNo command line arguments found\e[39m or"
        echo "the very first command line argument "
        echo "was found to to be an empty string."
        echo "GUID=='597a13ff-8be7-43b9-b283-c07380e0a9e7'"
        func_display_help_message
        #--------
        cd "$S_FP_ORIG"
        exit 1
    fi
    if [ "`echo \"$S_ARGV_0\" | grep -E '^((([-][-]?)?[hH][eE][lL][pP])|([-]?[hH?]))$' `" != "" ]; then
        func_display_help_message
        #--------
        cd "$S_FP_ORIG"
        exit 0 # no errors, just help requested
    fi
    #------------------------------
    if [ "$S_ARGV_0" == "test1"  -o  "$S_ARGV_0" == "test_1" ]; then
            S_MODE="test_1"
    else
        if [ "$S_ARGV_0" == "test2"  -o  "$S_ARGV_0" == "test_2" ]; then
            S_MODE="test_2"
        else
            if [ "$S_ARGV_0" == "demo"  -o  "$S_ARGV_0" == "idee"  -o  "$S_ARGV_0" == "idea" ]; then
                S_MODE="display_demo_script"
            else
                #------------------------------------------------------
                # Bash testline:
                #     echo "012-3" | grep -E '[^0123456789]'
                S_TMP_0="`echo \"$S_ARGV_0\" | grep -E '[^0123456789]' `"
                if [ "$S_TMP_0" != "" ]; then
                    echo ""
                    echo "The maximum number of query results "
                    echo -e "\e[31mmust be a positive whole number\e[39m."
                    echo ""
                    echo "    S_ARGV_0==\"$S_ARGV_0\""
                    echo ""
                    echo "GUID=='a3f208df-7768-4284-9683-c07380e0a9e7'"
                    echo ""
                    func_display_help_message
                    #--------
                    cd "$S_FP_ORIG"
                    exit 1
                fi
                #------------------------------------------------------
                # Bash testline:
                #     echo "000000" | sed -e 's/^0\+$/X/g'
                S_TMP_0="`echo \"$S_ARGV_0\" | $S_CMD_GNU_SED -e 's/^0\+$//g' `"
                if [ "$S_TMP_0" == "" ]; then
                    echo ""
                    echo "The maximum number of query results "
                    echo -e "\e[31mmust be greater than 0\e[39m."
                    echo ""
                    echo "    S_ARGV_0==\"$S_ARGV_0\""
                    echo ""
                    echo "GUID=='223d2894-755b-4651-a283-c07380e0a9e7'"
                    echo ""
                    func_display_help_message
                    #--------
                    cd "$S_FP_ORIG"
                    exit 1
                fi
                #------------------------------------------------------
                # "0042"  -->  "42"
                S_TMP_0="`echo \"$S_ARGV_0\" | $S_CMD_GNU_SED -e 's/^0\+//g' `"
                SI_MAX_N_OF_QUERY_RESULTS="$S_TMP_0"
                S_MODE="generate_download_script"
                #------------------------------------------------------
            fi
        fi
    fi
    #----------------------------------------------------------------------
} # func_display_help_message_and_exit_if_needed

#--------------------------------------------------------------------------

func_initialize_configuration_by_initializing_global_variables(){
    #----------------------------------------------------------------------
    func_mmmv_init_s_timestamp_if_not_inited_t1
    S_MODE="not_yet_set"
    S_CMD_PREFIX_NICE="nice -n 2 "
    SI_MAX_N_OF_QUERY_RESULTS=3 # will be reassigned according to 1. command line argument.
    S_URL_QUERY="" # the empty string value is used at an if-clause
    #----------------------------------------------------------------------
} # func_initialize_configuration_by_initializing_global_variables

#--------------------------------------------------------------------------
S_QUERYSTRING=""

func_exc_argv_2_querystring(){
    local S_ARGV_NAME="$1"
    #----------------------------------------------------------------------
    local S_ARGV=""
    local S_TMP_0=""
    local S_SCRIPT="S_ARGV=\"\$$S_ARGV_NAME\""
    eval ${S_SCRIPT}
    #------------------------------
    S_TMP_0="`echo \"$S_ARGV\" | $S_CMD_GNU_SED -e 's/[[:blank:]]//g' `"
    if [ "$S_TMP_0" != "$S_ARGV" ]; then
        echo ""
        echo -e "\e[31mSearchstring must not contain any \e[39m"
        echo -e "\e[31mspaces or tabulation characters\e[39m."
        echo ""
        echo "    $S_ARGV_NAME==\"$S_ARGV\""
        echo ""
        echo "GUID=='e52d3932-c17c-4cf5-9283-c07380e0a9e7'"
        echo ""
        #--------
        cd "$S_FP_ORIG"
        exit 1
    fi
    #------------------------------
    # Testline:
    #     echo '$a"b'"\\'c\`" | tr -d "'"'"\\`$'
    S_TMP_0="`echo \"$S_ARGV\" | tr -d \"'\"'\"\\\\\`\$' `"
    if [ "$S_TMP_0" != "$S_ARGV" ]; then
        echo ""
        echo "This script does not support any "
        echo -e "\e[31mquotation marks (\"'\`) or backslashes (\\) or\e[39m"
        echo -e "\e[31mdollar signs (\$) in searchstrings\e[39m."
        echo ""
        echo "    $S_ARGV_NAME==[$S_ARGV]"
        echo ""
        echo "GUID=='8250a714-4e97-4088-9383-c07380e0a9e7'"
        echo ""
        #--------
        cd "$S_FP_ORIG"
        exit 1
    fi
    #------------------------------
    S_QUERYSTRING="$S_TMP_0"
    #----------------------------------------------------------------------
} # func_exc_argv_2_querystring

#--------------------------------------------------------------------------
S_QUERY=""

func_assemble_query_for_listing_URLs(){
    #----------------------------------------------------------------------
    local S_TMP_0=""
    S_QUERY="" # meant to be global
    local SB_ERR="f"
    local S_ARGV_NAME="" # for error message test
    #----------------------------------------------------------------------
    # The  idea behind the
    local SB_ARGV_COLLECTION_COMPLETE="f"
    # is that command line arguments like
    #
    #     this_script  42  "<empty string>"  "<only spaces>"  "Foo"
    #     this_script  42  "Bar"             "<only spaces>"
    #     this_script  42  "Bar2"            "<empty string>"
    #
    # are not allowed
    #----------------------------------------------------------------------
    #  In this context the S_ARGV_0 determins
    #  the value of the SI_MAX_N_OF_QUERY_RESULTS .
    #------------------------------
    #S_QUERY='subject:"Моделист-Конструктор" AND subject:"Журнальный зал"'
    if [ "$S_ARGV_1" != "" ]; then
        func_exc_argv_2_querystring "S_ARGV_1"
        if [ "$S_QUERYSTRING" == "" ]; then
            SB_ARGV_COLLECTION_COMPLETE="t"
            echo ""
            echo -e "\e[31mSearchstring must not contain any \e[39m"
            echo -e "\e[31mspaces or tabulation characters\e[39m."
            echo ""
            echo "    S_ARGV_1==\"$S_ARGV_1\""
            echo ""
            echo "GUID=='54148728-948d-4fff-9583-c07380e0a9e7'"
            echo ""
            #--------
            cd "$S_FP_ORIG"
            exit 1
        else
             #S_TMP_0="$S_QUERY subject:\"$S_QUERYSTRING\" "
             S_TMP_0="subject:\"$S_QUERYSTRING\" "
             S_QUERY="$S_TMP_0"
        fi
    else
        SB_ARGV_COLLECTION_COMPLETE="t"
        echo ""
        echo -e "\e[31mSearchstring must not be an empty string\e[39m."
        echo ""
        echo "    S_ARGV_1==\"$S_ARGV_1\""
        echo ""
        echo "GUID=='8292ce2e-d524-46e5-9283-c07380e0a9e7'"
        echo ""
        #--------
        cd "$S_FP_ORIG"
        exit 1
    fi
    #----------------------------------------------------------------------
    if [ "$S_ARGV_2" != "" ]; then
        if [ "$SB_ARGV_COLLECTION_COMPLETE" == "t" ]; then
            #--------
            echo ""
            echo -e "\e[31mThe code of this Bash function is flawed\e[39m."
            echo "The control flow should never reach this place."
            echo "GUID=='3c66f154-0096-41b1-8583-c07380e0a9e7'"
            echo ""
            #--------
            # echo ""
            # echo -e "\e[31m1. searchstring was an empty string\e[39m."
            # echo "None of the searchstrings is allwed to be an empty string."
            # echo "GUID=='8c50702e-2e22-4c01-b383-c07380e0a9e7'"
            # echo ""
            #--------
            cd "$S_FP_ORIG"
            exit 1
        else
            func_exc_argv_2_querystring "S_ARGV_2"
            if [ "$S_QUERYSTRING" == "" ]; then
                SB_ARGV_COLLECTION_COMPLETE="t"
                echo ""
                echo -e "\e[31mSearchstring must not contain any \e[39m"
                echo -e "\e[31mspaces or tabulation characters\e[39m."
                echo ""
                echo "    S_ARGV_2==\"$S_ARGV_2\""
                echo ""
                echo "GUID=='c541271b-dcf0-4d91-b283-c07380e0a9e7'"
                echo ""
                #--------
                cd "$S_FP_ORIG"
                exit 1
            else
                 S_TMP_0="$S_QUERY AND  subject:\"$S_QUERYSTRING\" "
                 S_QUERY="$S_TMP_0"
            fi
        fi
    else
        SB_ARGV_COLLECTION_COMPLETE="t"
    fi
    #----------------------------------------------------------------------
    if [ "$S_ARGV_3" != "" ]; then
        if [ "$SB_ARGV_COLLECTION_COMPLETE" == "t" ]; then
            echo ""
            echo -e "\e[31m2. searchstring was an empty string\e[39m."
            echo "None of the searchstrings is allowed to be an empty string."
            echo "GUID=='9211b35d-e558-4d6f-8583-c07380e0a9e7'"
            echo ""
            #--------
            cd "$S_FP_ORIG"
            exit 1
        else
            func_exc_argv_2_querystring "S_ARGV_3"
            if [ "$S_QUERYSTRING" == "" ]; then
                SB_ARGV_COLLECTION_COMPLETE="t"
                echo ""
                echo -e "\e[31mSearchstring must not contain any \e[39m"
                echo -e "\e[31mspaces or tabulation characters\e[39m."
                echo ""
                echo "    S_ARGV_3==\"$S_ARGV_3\""
                echo ""
                echo "GUID=='5f268c38-2c0a-417b-a383-c07380e0a9e7'"
                echo ""
                #--------
                cd "$S_FP_ORIG"
                exit 1
            else
                 S_TMP_0="$S_QUERY AND  subject:\"$S_QUERYSTRING\" "
                 S_QUERY="$S_TMP_0"
            fi
        fi
    else
        SB_ARGV_COLLECTION_COMPLETE="t"
    fi
    #----------------------------------------------------------------------
    if [ "$S_ARGV_4" != "" ]; then
        if [ "$SB_ARGV_COLLECTION_COMPLETE" == "t" ]; then
            echo ""
            echo -e "\e[31m3. searchstring was an empty string\e[39m."
            echo "None of the searchstrings is allowed to be an empty string."
            echo "GUID=='c6c8ad43-96b7-4a83-8483-c07380e0a9e7'"
            echo ""
            #--------
            cd "$S_FP_ORIG"
            exit 1
        else
            func_exc_argv_2_querystring "S_ARGV_4"
            if [ "$S_QUERYSTRING" == "" ]; then
                SB_ARGV_COLLECTION_COMPLETE="t"
                echo ""
                echo -e "\e[31mSearchstring must not contain any \e[39m"
                echo -e "\e[31mspaces or tabulation characters\e[39m."
                echo ""
                echo "    S_ARGV_4==\"$S_ARGV_4\""
                echo ""
                echo "GUID=='98305a14-557a-479b-8473-c07380e0a9e7'"
                echo ""
                #--------
                cd "$S_FP_ORIG"
                exit 1
            else
                 S_TMP_0="$S_QUERY AND  subject:\"$S_QUERYSTRING\" "
                 S_QUERY="$S_TMP_0"
            fi
        fi
    else
        SB_ARGV_COLLECTION_COMPLETE="t"
    fi
    #----------------------------------------------------------------------
    if [ "$S_ARGV_5" != "" ]; then
        if [ "$SB_ARGV_COLLECTION_COMPLETE" == "t" ]; then
            echo ""
            echo -e "\e[31m4. searchstring was an empty string\e[39m."
            echo "None of the searchstrings is allowed to be an empty string."
            echo "GUID=='a0aedd25-0f56-4eec-a273-c07380e0a9e7'"
            echo ""
            #--------
            cd "$S_FP_ORIG"
            exit 1
        else
            func_exc_argv_2_querystring "S_ARGV_5"
            if [ "$S_QUERYSTRING" == "" ]; then
                SB_ARGV_COLLECTION_COMPLETE="t"
                echo ""
                echo -e "\e[31mSearchstring must not contain any \e[39m"
                echo -e "\e[31mspaces or tabulation characters\e[39m."
                echo ""
                echo "    S_ARGV_5==\"$S_ARGV_5\""
                echo ""
                echo "GUID=='798ad320-bbb9-4f62-8173-c07380e0a9e7'"
                echo ""
                #--------
                cd "$S_FP_ORIG"
                exit 1
            else
                 S_TMP_0="$S_QUERY AND  subject:\"$S_QUERYSTRING\" "
                 S_QUERY="$S_TMP_0"
            fi
        fi
    else
        SB_ARGV_COLLECTION_COMPLETE="t"
    fi
    #----------------------------------------------------------------------
    if [ "$S_ARGV_6" != "" ]; then
        if [ "$SB_ARGV_COLLECTION_COMPLETE" == "t" ]; then
            echo ""
            echo -e "\e[31m5. searchstring was an empty string\e[39m."
            echo "None of the searchstrings is allowed to be an empty string."
            echo "GUID=='ed609333-54e3-4a8d-9473-c07380e0a9e7'"
            echo ""
            #--------
            cd "$S_FP_ORIG"
            exit 1
        else
            func_exc_argv_2_querystring "S_ARGV_6"
            if [ "$S_QUERYSTRING" == "" ]; then
                SB_ARGV_COLLECTION_COMPLETE="t"
                echo ""
                echo -e "\e[31mSearchstring must not contain any \e[39m"
                echo -e "\e[31mspaces or tabulation characters\e[39m."
                echo ""
                echo "    S_ARGV_6==\"$S_ARGV_6\""
                echo ""
                echo "GUID=='e5bdcea7-40dc-40b1-8773-c07380e0a9e7'"
                echo ""
                #--------
                cd "$S_FP_ORIG"
                exit 1
            else
                 S_TMP_0="$S_QUERY AND  subject:\"$S_QUERYSTRING\" "
                 S_QUERY="$S_TMP_0"
            fi
        fi
    else
        SB_ARGV_COLLECTION_COMPLETE="t"
    fi
    #----------------------------------------------------------------------
    if [ "$S_ARGV_7" != "" ]; then
        echo ""
        echo "This script supports "
        echo -e "\e[31mat most 6 searchstrings\e[39m."
        echo "GUID=='ad08171a-f19d-4f83-a173-c07380e0a9e7'"
        func_display_help_message
        #--------
        cd "$S_FP_ORIG"
        exit 1
    fi
    #----------------------------------------------------------------------
    if [ "$S_ARGV_8" != "" ]; then
        echo ""
        echo "This script supports "
        echo -e "\e[31mat most 6 searchstrings\e[39m."
        echo "GUID=='506b8951-48d4-4ede-8473-c07380e0a9e7'"
        func_display_help_message
        #--------
        cd "$S_FP_ORIG"
        exit 1
    fi
    #----------------------------------------------------------------------
} # func_assemble_query_for_listing_URLs

#--------------------------------------------------------------------------

func_submit_query_to_server(){
    local SI_ROWS="$1" # max. number of torrent files in the list
    #----------------------------------------------------------------------
    local S_CURL_CMD="$S_CMD_PREFIX_NICE curl "
    local S_JQ_CMD="$S_CMD_PREFIX_NICE jq "
    local S_SED_CMD="$S_CMD_PREFIX_NICE $S_CMD_GNU_SED "
    #----------------------------------------------------------------------
    local S_QUERY_ENCODED=$(echo "$S_QUERY" | $S_JQ_CMD -sRr @uri)
    local S_SEARCH_API_URL_PREFIX="https://archive.org/advancedsearch.php"
    local S_FIELDS="identifier"
    #echo "Downloading torrent file name prefixes from archive.org..."
    S_URL_QUERY="${S_SEARCH_API_URL_PREFIX}?q=${S_QUERY_ENCODED}&fl[]=${S_FIELDS}&rows=${SI_ROWS}&output=json"
    #local S_RESPONSE=$(${S_CURL_CMD} -s "${S_SEARCH_API_URL_PREFIX}?q=${S_QUERY_ENCODED}&fl[]=${S_FIELDS}&rows=${SI_ROWS}&output=json")
    local S_RESPONSE=$(${S_CURL_CMD} -s "$S_URL_QUERY")
    func_mmmv_assert_error_code_zero_t1 "$?" \
        "860ad572-4ff5-473b-a5f3-c07380e0a9e7"
    wait
    # Tested only with GNU sed on Linux, not the BSD sed.
    local S_BASHSCRIPT_0=$(echo "$S_RESPONSE" | \
        $S_JQ_CMD -r '.response.docs[].identifier' | \
        $S_SED_CMD -e 's/^/AR_IDENTIFIERS+=("/g' | \
        $S_SED_CMD -e 's/$/") ; /g')
    func_mmmv_assert_error_code_zero_t1 "$?" \
        "1575b21e-5605-41dc-a2e3-c07380e0a9e7"
    wait
    local AR_IDENTIFIERS=()
    eval ${S_BASHSCRIPT_0}
    #local SI_AR_IDENTIFIERS_LENGTH=${#AR_IDENTIFIERS[@]}
    local S_FN=""
    local S_FN_SUFFIX="_archive.torrent"
    echo "#!/usr/bin/env bash"
    echo "#=========================================================================="
    echo "# This script has been generated at $S_TIMESTAMP "
    echo "# by using the query "
    echo "#     $S_QUERY"
    echo "# with the results list length limit of $SI_ROWS entries. URL:"
    echo "#"
    echo "#     $S_URL_QUERY"
    echo "#"
    echo "# The following line is a spdx.org license label line:"
    echo "# SPDX-License-Identifier: 0BSD "
    echo "#=========================================================================="
    echo ""
    local S_URL_TORRENT="" # empty string is used at an if clause later
    S_SCRIPT_0="AR_0+=(\$S_ITER)"
    for ((i = 0; i < ${#AR_IDENTIFIERS[@]}; i++)) do
        S_ID="${AR_IDENTIFIERS[$i]}"
        S_FN="$S_ID$S_FN_SUFFIX"
        S_URL_TORRENT="https://archive.org/download/$S_ID/$S_FN"
        #echo "    $S_URL_TORRENT"
        #echo "    wget -q --show-progress \"$S_URL_TORRENT\" "
        echo "    wget --show-progress \"$S_URL_TORRENT\" "
        #echo "    if [ \"\$?\" != \"0\" ]; then echo -e \"\\e[31mDownload failed\\e[39m. $S_ID \" ; exit 1 ;fi ; wait ; sync ; wait ; sleep 1 "
        echo "    if [ \"\$?\" != \"0\" ]; then echo -e \"\\e[103m\\e[30mFailed to download\\e[39m\\e[49m $S_ID .\" ; else sync ; wait ; fi ; sleep 1 "
    done
    #------------------------------
    if [ "$S_URL_TORRENT" == "" ]; then
        echo "    # The query results set that the archive.org returned is an empty set. "
    fi
    #------------------------------
    echo ""
    echo "#=========================================================================="
} # func_submit_query_to_server

#--------------------------------------------------------------------------

func_main(){
    #------------------------------
    func_check_for_some_dependencies
    func_initialize_configuration_by_initializing_global_variables
    func_display_help_message_and_exit_if_needed
    #------------------------------
    if [ "$S_MODE" == "display_demo_script" ]; then
        func_display_Bash_script_that_was_obtained_on_by_modyfying_copilot_microsoft_com_2025_09_12_generated_Bash_script
        #--------
        cd "$S_FP_ORIG"
        exit 0 # no errors, just help requested
    fi
    #------------------------------
    if [ "$S_MODE" == "test_1" ]; then
        SI_MAX_N_OF_QUERY_RESULTS=10 # good enough for a demo
        S_QUERY='subject:"Electronics"  AND  subject:"Magazine"'
    fi
    if [ "$S_MODE" == "test_2" ]; then
        SI_MAX_N_OF_QUERY_RESULTS=50 # good enough for a demo
        S_QUERY='subject:"Моделист-Конструктор"  AND  subject:"Журнальный зал"'
    fi
    if [ "$S_MODE" == "generate_download_script" ]; then
        func_assemble_query_for_listing_URLs
    fi
    #------------------------------
    func_mmmv_wait_and_sync_t1 # to avoid the sync delay during download
    func_submit_query_to_server "$SI_MAX_N_OF_QUERY_RESULTS"
    #------------------------------
} # func_main
func_main

#--------------------------------------------------------------------------
cd "$S_FP_ORIG"
exit 0
#==========================================================================
# S_VERSION_OF_THIS_FILE="64e59a2e-db57-4a64-a1e3-c07380e0a9e7"
#==========================================================================
