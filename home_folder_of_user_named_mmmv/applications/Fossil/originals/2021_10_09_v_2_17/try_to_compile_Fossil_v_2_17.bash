#!/usr/bin/env bash
#==========================================================================
# Initial author of this file: Martin.Vahi@softf1.com
# This file is in public domain.
# The following line is a spdx.org license label line:
# SPDX-License-Identifier: 0BSD
#
# The main control flow entry in this script is the func_main(),
# which resides near the end of this file. The structure of this file:
#
#     <boilerplate, the library of reusable Bash functions>
#     func_initialize_configuration_by_initializing_global_variables
#     func_main() # like in C/C++
#
#==========================================================================
S_FP_DIR="$( cd "$( dirname "${BASH_SOURCE[0]}" )" && pwd )"
S_FP_ORIG="`pwd`"
#--------------------------------------------------------------------------

MMMV_BASH_BOILERPLATE_VERSION="subject_to_initialisation"
func_mmmv_bash_boilerplate_version(){
    local S_GUID="f1d9c246-e705-44e3-b17c-d1c0004128e7"
    local S_TIMESTAMP="_subject_to_initialisation_"
# RENESSAATOR_BLOCK_START
# RENESSAATOR_BLOCK_ID=block_566c89e2-c6f0-12ed-9d8a-1c6f6552f9e6_city
# RENESSAATOR_SOURCE_LANGUAGE=Ruby
# RENESSAATOR_SOURCE_START
# ob_t=Time.now
# s_t="_⏳_"
# s_t<<("y"+ob_t.year.to_s)
# s_t<<"_"
# s_t<<("m"+ob_t.month.to_s)
# s_t<<"_"
# s_t<<("d"+ob_t.day.to_s)
# s_t<<"_"
# s_t<<("h"+ob_t.hour.to_s)
# s_t<<"_"
# s_t<<("m"+ob_t.min.to_s)
# s_t<<"_"
# s_t<<("s"+ob_t.sec.to_s)
# s_t<<"_"
# s_t<<("μ"+ob_t.usec.to_s)
# s_t<<"_☺_"
# puts("    S_TIMESTAMP=\""+s_t+"\"")
# RENESSAATOR_SOURCE_END
# 
# RENESSAATOR_AUTOGENERATED_TEXT_START
    S_TIMESTAMP="_⏳_y2023_m12_d24_h8_m12_s18_μ309806_☺_"

# RENESSAATOR_AUTOGENERATED_TEXT_END
# RENESSAATOR_BLOCK_END
    MMMV_BASH_BOILERPLATE_VERSION="mmmv_bash_boilerplate_t4_$S_TIMESTAMP$S_GUID"
} # func_mmmv_bash_boilerplate_version
func_mmmv_bash_boilerplate_version

#--------------------------------------------------------------------------

func_mmmv_wait_and_sync_t1(){
    wait # for background processes started by this Bash script to exit/finish
    sync # network drives, USB-sticks, etc.
    wait # for sync
} # func_mmmv_wait_and_sync_t1

#--------------------------------------------------------------------------
func_mmmv_init_s_timestamp_if_not_inited_t1(){
    if [ "$S_TIMESTAMP" == "" ]; then
        if [ "`which date 2> /dev/null`" != "" ]; then
            S_TIMESTAMP="`date +%Y`_`date +%m`_`date +%d`_T_`date +%H`h_`date +%M`min_`date +%S`s"
        else
            S_TIMESTAMP="0000_00_00_T_00h_00min_00s"
            echo ""
            echo -e "The console program \"\e[31mdate\e[39m\" is missing from the PATH."
            echo "Using a constant value, "
            echo ""
            echo "    S_TIMESTAMP=\"$S_TIMESTAMP\""
            echo ""
            echo "GUID=='41bd534a-dd57-488c-848c-d1c0004128e7'"
            echo ""
        fi
    fi
} # func_mmmv_init_s_timestamp_if_not_inited_t1

#--------------------------------------------------------------------------

func_mmmv_verify_S_FP_ORIG_but_do_not_exit_t1(){
    SB_S_FP_ORIG_VERIFICATION_FAILED="f"
    if [ "$S_FP_ORIG" == "" ]; then 
        SB_S_FP_ORIG_VERIFICATION_FAILED="t"
        echo ""
        echo -e "\e[31mThe code of this script has the flaw\e[39m that"
        echo "the variable S_FP_ORIG has not been set."
        echo "GUID=='e51cc433-3deb-4bad-b47c-d1c0004128e7'"
        echo ""
    else
        if [ ! -e "$S_FP_ORIG" ]; then 
            SB_S_FP_ORIG_VERIFICATION_FAILED="t"
            echo ""
            echo -e "\e[31mThe code of this script has the flaw\e[39m that "
            echo "the variable S_FP_ORIG has been declared, but "
            echo "its value is some string that is not a file or folder path."
            echo "It is expected to be a folder path."
            echo ""
            echo "    S_FP_ORIG==\"$S_FP_ORIG\""
            echo ""
            echo "GUID=='137b8715-f5d0-4703-b47c-d1c0004128e7'"
            echo ""
        else
            if [ ! -d "$S_FP_ORIG" ]; then 
                SB_S_FP_ORIG_VERIFICATION_FAILED="t"
                echo ""
                echo -e "\e[31mThe code of this script has the flaw\e[39m that "
                echo "the variable S_FP_ORIG references a file, but "
                echo "it is expected to reference a folder."
                echo ""
                echo "    S_FP_ORIG==$S_FP_ORIG"
                echo ""
                echo "GUID=='12d26fb7-ac99-4523-816c-d1c0004128e7'"
                echo ""
            fi
        fi
    fi
    #----------------------------------------------------------------------
    # exit 1 # must NOT be called in ~/.bashrc, because 
             # exiting from the ~/.bashrc exits the session.
    #----------------------------------------------------------------------
    # Usage example:
    #    func_mmmv_verify_S_FP_ORIG_but_do_not_exit_t1
    #    if [ "$SB_S_FP_ORIG_VERIFICATION_FAILED" == "f" ]; then 
    #        cd "$S_FP_ORIG"
    #    else 
    #        echo ""
    #        echo "The code of this script is flawed."
    #        echo "GUID=='d1fb80fb-35c0-40a9-af6c-d1c0004128e7'"
    #        echo ""
    #    fi
} # func_mmmv_verify_S_FP_ORIG_but_do_not_exit_t1

#--------------------------------------------------------------------------

SB_FUNC_MMMV_VERIFY_S_FP_ORIG_BUT_DO_NOT_EXIT_T2_S_FB_ORIG_ALREADY_VERIFIED="f"
func_mmmv_verify_S_FP_ORIG_but_do_not_exit_t2(){
    if [ "$SB_FUNC_MMMV_VERIFY_S_FP_ORIG_BUT_DO_NOT_EXIT_T2_S_FB_ORIG_ALREADY_VERIFIED" != "t" ]; then
        if [ "$SB_FUNC_MMMV_VERIFY_S_FP_ORIG_BUT_DO_NOT_EXIT_T2_S_FB_ORIG_ALREADY_VERIFIED" != "f" ]; then
            echo ""
            echo -e "\e[31mThe code that calls this function is flawed. \e[39m"
            echo "The global variable "
            echo ""
            echo "    SB_FUNC_MMMV_VERIFY_S_FP_ORIG_BUT_DO_NOT_EXIT_T2_S_FB_ORIG_ALREADY_VERIFIED==\"$SB_FUNC_MMMV_VERIFY_S_FP_ORIG_BUT_DO_NOT_EXIT_T2_S_FB_ORIG_ALREADY_VERIFIED\""
            echo ""
            echo "has a domain of {\"f\", \"t\"}."
            echo "GUID=='e73e8617-c222-4616-816c-d1c0004128e7'"
            echo ""
        else
            func_mmmv_verify_S_FP_ORIG_but_do_not_exit_t1
            SB_FUNC_MMMV_VERIFY_S_FP_ORIG_BUT_DO_NOT_EXIT_T2_S_FB_ORIG_ALREADY_VERIFIED="t"
        fi
    fi
} # func_mmmv_verify_S_FP_ORIG_but_do_not_exit_t2

#--------------------------------------------------------------------------

SB_NO_ERRORS_YET="t" # domain=={"t","f"} 
func_mmmv_assert_nonempty_string_but_do_not_exit_t1(){
    local S_IN="$1"
    local S_VARIABLE_NAME_IN_CALLING_CODE="$2"
    local S_GUID_CANDIDATE="$3"
    #----------------------------------------------------------------------
    local SB_NO_ERRORS_YET_1="t"
    if [ "$S_GUID_CANDIDATE" == "" ]; then 
        echo ""
        echo -e "\e[31mThe code that calls this function is flawed.\e[39m The"
        echo ""
        echo "    S_GUID_CANDIDATE==\"\""
        echo ""
        echo "but it is expected to be a GUID."
        echo "GUID=='5edd1042-4333-429b-925c-d1c0004128e7'"
        echo ""
        SB_NO_ERRORS_YET_1="f"
    fi
    #--------------------
    if [ "$SB_NO_ERRORS_YET" != "t" ]; then 
        echo ""
        echo -e "\e[31mThe code that calls this function is flawed. \e[39m"
        echo "The global variable "
        echo ""
        echo "    SB_NO_ERRORS_YET==\"$SB_NO_ERRORS_YET\""
        echo ""
        if [ "$SB_NO_ERRORS_YET" == "f" ]; then 
            echo "is expected to be initialized to \"t\" before calling this function."
            echo "GUID=='24d6d17b-3f3a-4e1c-a95c-d1c0004128e7'"
        else
            echo "is expected to be initialized to \"t\" before calling this function"
            echo "and its domain is {\"f\", \"t\"}."
            echo "GUID=='54a88a46-3602-4fac-922c-d1c0004128e7'"
        fi
        if [ "$SB_NO_ERRORS_YET_1" == "t" ]; then 
            echo "GUID_CANDIDATE=='$S_GUID_CANDIDATE'"
        fi
        echo ""
        SB_NO_ERRORS_YET="f"
    fi
    #--------------------
    if [ "$SB_NO_ERRORS_YET_1" == "f" ]; then 
        SB_NO_ERRORS_YET="f"
    fi
    #----------------------------------------------------------------------
    if [ "$SB_NO_ERRORS_YET" == "t" ]; then 
        if [ "$S_VARIABLE_NAME_IN_CALLING_CODE" == "" ]; then 
            echo ""
            echo -e "\e[31mThe code that calls this function is flawed.\e[39m The"
            echo ""
            echo "    S_VARIABLE_NAME_IN_CALLING_CODE==\"\""
            echo ""
            echo "GUID=='12affe32-5363-455f-852c-d1c0004128e7'"
            if [ "$SB_NO_ERRORS_YET_1" == "t" ]; then  # should be always true at this line
                echo "GUID_CANDIDATE=='$S_GUID_CANDIDATE'"
            fi
            echo ""
            SB_NO_ERRORS_YET="f"
        fi
    fi
    #----------------------------------------------------------------------
    if [ "$SB_NO_ERRORS_YET" == "t" ]; then 
        if [ "$S_IN" == "" ]; then 
            echo ""
            echo -e "\e[31mThere is a flaw somewhere in the code\e[39m that"
            echo "uses a variable named \"$S_VARIABLE_NAME_IN_CALLING_CODE\"." 
            echo ""
            echo "    $S_VARIABLE_NAME_IN_CALLING_CODE==\"$S_IN\""
            echo ""
            echo "but it is expected to be something other than an empty string."
            echo "GUID=='47d6e846-530f-444e-822c-d1c0004128e7'"
            if [ "$SB_NO_ERRORS_YET_1" == "t" ]; then  # should be always true at this line
                echo "GUID_CANDIDATE=='$S_GUID_CANDIDATE'"
            fi
            echo ""
            SB_NO_ERRORS_YET="f"
        fi
    fi
    #----------------------------------------------------------------------
} # func_mmmv_assert_nonempty_string_but_do_not_exit_t1

#--------------------------------------------------------------------------

# SB_NO_ERRORS_YET="t" # domain=={"t","f"}, initial declaration resides upwards from this line
func_mmmv_assert_sbvar_domain_t_f_but_do_not_exit_t1(){
    local SB_VARIABLE_VALUE="$1"
    local S_VARIABLE_NAME_IN_CALLING_CODE="$2"
    local S_GUID_CANDIDATE="$3"
    #----------------------------------------------------------------------
    local SB_NO_ERRORS_YET_1="t"
    if [ "$S_GUID_CANDIDATE" == "" ]; then 
        echo ""
        echo -e "\e[31mThe code that calls this function is flawed.\e[39m The"
        echo ""
        echo "    S_GUID_CANDIDATE==\"\""
        echo ""
        echo "but it is expected to be a GUID."
        echo "GUID=='d43043b1-e019-4dba-a71c-d1c0004128e7'"
        echo ""
        SB_NO_ERRORS_YET_1="f"
    fi
    #--------------------
    if [ "$SB_NO_ERRORS_YET" != "t" ]; then 
        echo ""
        echo -e "\e[31mThe code that calls this function is flawed. \e[39m"
        echo "The global variable "
        echo ""
        echo "    SB_NO_ERRORS_YET==\"$SB_NO_ERRORS_YET\""
        echo ""
        if [ "$SB_NO_ERRORS_YET" == "f" ]; then 
            echo "is expected to be initialized to \"t\" before calling this function."
            echo "GUID=='21319735-eff4-49b6-821c-d1c0004128e7'"
        else
            echo "is expected to be initialized to \"t\" before calling this function"
            echo "and its domain is {\"f\", \"t\"}."
            echo "GUID=='200ba0a5-8a18-4603-a31c-d1c0004128e7'"
        fi
        if [ "$SB_NO_ERRORS_YET_1" == "t" ]; then 
            echo "GUID_CANDIDATE=='$S_GUID_CANDIDATE'"
        fi
        echo ""
        SB_NO_ERRORS_YET="f"
    fi
    #--------------------
    if [ "$SB_NO_ERRORS_YET_1" == "f" ]; then 
        SB_NO_ERRORS_YET="f"
    fi
    #----------------------------------------------------------------------
    if [ "$SB_NO_ERRORS_YET" == "t" ]; then 
        if [ "$S_VARIABLE_NAME_IN_CALLING_CODE" == "" ]; then 
            echo ""
            echo -e "\e[31mThe code that calls this function is flawed.\e[39m The"
            echo ""
            echo "    S_VARIABLE_NAME_IN_CALLING_CODE==\"\""
            echo ""
            echo "GUID=='2f978345-be1c-4084-830c-d1c0004128e7'"
            if [ "$SB_NO_ERRORS_YET_1" == "t" ]; then  # should be always true at this line
                echo "GUID_CANDIDATE=='$S_GUID_CANDIDATE'"
            fi
            echo ""
            SB_NO_ERRORS_YET="f"
        fi
    fi
    #----------------------------------------------------------------------
    if [ "$SB_NO_ERRORS_YET" == "t" ]; then 
        if [ "$SB_VARIABLE_VALUE" != "t" ]; then 
            if [ "$SB_VARIABLE_VALUE" != "f" ]; then 
                echo ""
                echo -e "\e[31mThere is a flaw somewhere in the code\e[39m that"
                echo "uses a variable named \"$S_VARIABLE_NAME_IN_CALLING_CODE\". The " 
                echo ""
                echo "    $S_VARIABLE_NAME_IN_CALLING_CODE==\"$SB_VARIABLE_VALUE\""
                echo ""
                echo "but it is expected to be either \"t\" or \"f\"."
                echo "GUID=='55ee80ec-ed43-4f39-840c-d1c0004128e7'"
                if [ "$SB_NO_ERRORS_YET_1" == "t" ]; then  # should be always true at this line
                    echo "GUID_CANDIDATE=='$S_GUID_CANDIDATE'"
                fi
                echo ""
                SB_NO_ERRORS_YET="f"
            fi
        fi
    fi
    #----------------------------------------------------------------------
} # func_mmmv_assert_sbvar_domain_t_f_but_do_not_exit_t1

#--------------------------------------------------------------------------

func_mmmv_report_an_error_but_do_not_exit_t1(){
    local S_GUID_CANDIDATE="$1" # first  function argument
    local S_ERR_MSG="$2"        # second function argument
    #----------------------------------------------------------------------
    if [ "$S_GUID_CANDIDATE" == "" ]; then 
        echo ""
        echo -e "\e[31mThe code of this script is flawed.\e[39m"
        if [ "$S_ERR_MSG" != "" ]; then 
            echo "$S_ERR_MSG"
        fi
        echo "GUID=='7da0d231-a5e0-4973-85fb-d1c0004128e7'"
        echo ""
    else
        echo ""
        echo -e "\e[31mThe code of this script is flawed.\e[39m"
        if [ "$S_ERR_MSG" != "" ]; then 
            echo "$S_ERR_MSG"
        fi
        echo "GUID_CANDIDATE=='$S_GUID_CANDIDATE'"
        echo "GUID=='54d59e55-18b6-454c-83fb-d1c0004128e7'"
        echo ""
    fi
    #----------------------------------------------------------------------
    # exit 1 # must NOT be called in ~/.bashrc, because 
             # exiting from the ~/.bashrc exits the session.
} # func_mmmv_report_an_error_but_do_not_exit_t1

#--------------------------------------------------------------------------

func_mmmv_report_missing_from_path_and_do_NOT_exit_t1() {
    local S_NAME_OF_THE_EXECUTABLE=$1 # first function argument
    #----------------------------------------------------------------------
    local S_TMP_0="\`which $S_NAME_OF_THE_EXECUTABLE 2> /dev/null\`"
    local S_TMP_1=""
    local S_TMP_2="S_TMP_1=$S_TMP_0"
    eval ${S_TMP_2}
    if [ "$S_TMP_1" == "" ] ; then
        echo ""
        echo "This bash script wished to use the "
        echo "\"$S_NAME_OF_THE_EXECUTABLE\" from the PATH, but "
        echo "it was missing from the PATH."
        echo "GUID=='391358d3-7d08-43f0-85fb-d1c0004128e7'"
        echo ""
    fi
    #----------------------------------------------------------------------
    # exit 1 # must NOT be called in ~/.bashrc, because 
             # exiting from the ~/.bashrc exits the session.
} # func_mmmv_report_missing_from_path_and_do_NOT_exit_t1

#func_mmmv_report_missing_from_path_and_do_NOT_exit_t1 "ln"
#func_mmmv_report_missing_from_path_and_do_NOT_exit_t1 "date"
#func_mmmv_report_missing_from_path_and_do_NOT_exit_t1 "printf"
#func_mmmv_report_missing_from_path_and_do_NOT_exit_t1 "grep"
#func_mmmv_report_missing_from_path_and_do_NOT_exit_t1 "git"

#--------------------------------------------------------------------------

func_mmmv_verify_that_the_file_exists_but_do_not_exit_t1() {  # S_FP, S_GUID_CANDIDATE
    local S_FP="$1"
    local S_GUID_CANDIDATE="$2"
    local SB_DISPLAY_VERIFICATION_FAILURE_MESSAGE="$3" # domain: {"t","f",""}
                                                       # ""==="t", default "t"
    #----------------------------------------------------------------------
    # A global variable for storing function output.
    SB_VERIFICATION_FAILED="f" # domain: "t", "f" .
    #------------------------------
    if [ "$S_GUID_CANDIDATE" == "" ]; then
        echo ""
        echo -e "\e[31mThe code that calls this function is flawed.\e[39m"
        echo "This function requires 2 parameters: S_FP, S_GUID_CANDIDATE"
        echo "and has an optional 3. parameter: SB_DISPLAY_VERIFICATION_FAILURE_MESSAGE"
        echo "GUID=='d8349c1f-9cd8-4c3c-94eb-d1c0004128e7'"
        echo ""
        #--------
        SB_VERIFICATION_FAILED="t"
    fi
    #------------------------------
    local SB_DISPLAY_VERIF_FAILURE_MSG="t" # the default
    if [ "$SB_VERIFICATION_FAILED" == "f" ]; then
        if [ "$SB_DISPLAY_VERIFICATION_FAILURE_MESSAGE" != "" ]; then
            if [ "$SB_DISPLAY_VERIFICATION_FAILURE_MESSAGE" == "f" ]; then
                SB_DISPLAY_VERIF_FAILURE_MSG="f"
            else
                if [ "$SB_DISPLAY_VERIFICATION_FAILURE_MESSAGE" != "t" ]; then
                    echo ""
                    echo -e "\e[31mThe code that calls this function is flawed.\e[39m"
                    echo ""
                    echo "  SB_DISPLAY_VERIFICATION_FAILURE_MESSAGE==\"$SB_DISPLAY_VERIFICATION_FAILURE_MESSAGE\""
                    echo ""
                    echo "Valid values are: \"t\", \"f\", \"\" ."
                    echo "\"\" defaults to \"t\"."
                    echo "GUID=='64f9027e-afdf-498b-a7eb-d1c0004128e7'"
                    echo ""
                    #--------
                    SB_VERIFICATION_FAILED="t"
                fi
            fi
        fi
    fi
    #------------------------------
    if [ "$SB_VERIFICATION_FAILED" == "f" ]; then
        if [ ! -e "$S_FP" ]; then
            if [ -h "$S_FP" ]; then
                if [ "$SB_DISPLAY_VERIF_FAILURE_MSG" == "t" ]; then
                    echo ""
                    echo "The path "
                    echo ""
                    echo "    $S_FP "
                    echo ""
                    echo -e "points to a\e[31m broken symlink\e[39m, but a file or"
                    echo "a symlink to a file is expected."
                    echo "GUID==\"$S_GUID_CANDIDATE\""
                    echo "GUID=='5d150861-ddcd-4a8d-92eb-d1c0004128e7'"
                    echo ""
                fi
                #--------
                SB_VERIFICATION_FAILED="t"
            else
                if [ "$SB_DISPLAY_VERIF_FAILURE_MSG" == "t" ]; then
                    echo ""
                    echo "The file "
                    echo ""
                    echo "    $S_FP "
                    echo ""
                    echo -e "\e[31mdoes not exist\e[39m."
                    echo "GUID==\"$S_GUID_CANDIDATE\""
                    echo "GUID=='5a51e291-50e9-4676-b1db-d1c0004128e7'"
                    echo ""
                fi
                #--------
                SB_VERIFICATION_FAILED="t"
            fi
        else
            if [ -d "$S_FP" ]; then
                if [ "$SB_DISPLAY_VERIF_FAILURE_MSG" == "t" ]; then
                    echo ""
                    if [ -h "$S_FP" ]; then
                        echo "The symlink to the folder "
                    else
                        echo "The folder "
                    fi
                    echo ""
                    echo "    $S_FP "
                    echo ""
                    echo -e "exists, but a\e[31m file or a symlink to a file is expected\e[39m."
                    echo "GUID==\"$S_GUID_CANDIDATE\""
                    echo "GUID=='4162d09f-a0fe-4f06-99db-d1c0004128e7'"
                    echo ""
                fi
                #--------
                SB_VERIFICATION_FAILED="t"
            fi
        fi
    fi #  "$SB_VERIFICATION_FAILED" == "f"
    #------------------------------
    if [ "$SB_VERIFICATION_FAILED" != "t" ]; then
        if [ "$SB_VERIFICATION_FAILED" != "f" ]; then
            echo ""
            echo -e "\e[31mThe code of this Bash function is flawed.\e[39m"
            echo "GUID=='3c96ac4d-9f1d-4f55-95cb-d1c0004128e7'"
            echo ""
        fi
    fi
    #------------------------------
} # func_mmmv_verify_that_the_file_exists_but_do_not_exit_t1

#--------------------------------------------------------------------------

func_mmmv_verify_that_the_folder_exists_but_do_not_exit_t1() {  # S_FP, S_GUID_CANDIDATE
    local S_FP="$1"
    local S_GUID_CANDIDATE="$2"
    local SB_DISPLAY_VERIFICATION_FAILURE_MESSAGE="$3" # domain: {"t","f",""}
                                                       # ""==="t", default "t"
    #----------------------------------------------------------------------
    # A global variable for storing function output.
    SB_VERIFICATION_FAILED="f" # domain: "t", "f" .
    #------------------------------
    if [ "$S_GUID_CANDIDATE" == "" ]; then
        echo ""
        echo -e "\e[31mThe code that calls this function is flawed.\e[39m"
        echo "This function requires 2 parameters: S_FP, S_GUID_CANDIDATE"
        echo "and has an optional 3. parameter: SB_DISPLAY_VERIFICATION_FAILURE_MESSAGE"
        echo "GUID=='41b46bc4-273f-4211-84cb-d1c0004128e7'"
        echo ""
        #--------
        SB_VERIFICATION_FAILED="t"
    fi
    #------------------------------
    local SB_DISPLAY_VERIF_FAILURE_MSG="t" # the default
    if [ "$SB_VERIFICATION_FAILED" == "f" ]; then
        if [ "$SB_DISPLAY_VERIFICATION_FAILURE_MESSAGE" != "" ]; then
            if [ "$SB_DISPLAY_VERIFICATION_FAILURE_MESSAGE" == "f" ]; then
                SB_DISPLAY_VERIF_FAILURE_MSG="f"
            else
                if [ "$SB_DISPLAY_VERIFICATION_FAILURE_MESSAGE" != "t" ]; then
                    echo ""
                    echo -e "\e[31mThe code that calls this function is flawed.\e[39m"
                    echo ""
                    echo "  SB_DISPLAY_VERIFICATION_FAILURE_MESSAGE==\"$SB_DISPLAY_VERIFICATION_FAILURE_MESSAGE\""
                    echo ""
                    echo "Valid values are: \"t\", \"f\", \"\" ."
                    echo "\"\" defaults to \"t\"."
                    echo "GUID=='29efcf64-dd88-44ec-b1cb-d1c0004128e7'"
                    echo ""
                    #--------
                    SB_VERIFICATION_FAILED="t"
                fi
            fi
        fi
    fi
    #------------------------------
    if [ "$SB_VERIFICATION_FAILED" == "f" ]; then
        if [ ! -e "$S_FP" ]; then
            if [ -h "$S_FP" ]; then
                if [ "$SB_DISPLAY_VERIF_FAILURE_MSG" == "t" ]; then
                    echo ""
                    echo "The path "
                    echo ""
                    echo "    $S_FP "
                    echo ""
                    echo -e "points to a\e[31m broken symlink\e[39m, but a folder "
                    echo "or a symlink to a folder is expected."
                    echo "GUID==\"$S_GUID_CANDIDATE\""
                    echo "GUID=='c864cf17-bfab-4091-a1bb-d1c0004128e7'"
                    echo ""
                fi
                #--------
                SB_VERIFICATION_FAILED="t"
            else
                if [ "$SB_DISPLAY_VERIF_FAILURE_MSG" == "t" ]; then
                    echo ""
                    echo "The folder "
                    echo ""
                    echo "    $S_FP "
                    echo ""
                    echo -e "\e[31mdoes not exist\e[39m."
                    echo "GUID==\"$S_GUID_CANDIDATE\""
                    echo "GUID=='20e8d6e2-47bf-4432-a5bb-d1c0004128e7'"
                    echo ""
                fi
                #--------
                SB_VERIFICATION_FAILED="t"
            fi
        else
            if [ ! -d "$S_FP" ]; then
                if [ "$SB_DISPLAY_VERIF_FAILURE_MSG" == "t" ]; then
                    echo ""
                    if [ -h "$S_FP" ]; then
                        echo "The symlink to an existing file "
                    else
                        echo "The file "
                    fi
                    echo ""
                    echo "    $S_FP "
                    echo ""
                    echo -e "exists, but a\e[31m folder is expected\e[39m."
                    echo "GUID==\"$S_GUID_CANDIDATE\""
                    echo "GUID=='a5bcd319-5b04-44fc-a1ab-d1c0004128e7'"
                    echo ""
                fi
                #--------
                SB_VERIFICATION_FAILED="t"
            fi
        fi
    fi #  "$SB_VERIFICATION_FAILED" == "f"
    #------------------------------
    if [ "$SB_VERIFICATION_FAILED" != "t" ]; then
        if [ "$SB_VERIFICATION_FAILED" != "f" ]; then
            echo ""
            echo -e "\e[31mThe code of this Bash function is flawed.\e[39m"
            echo "GUID=='84e49b11-4ba7-46bf-b2ab-d1c0004128e7'"
            echo ""
        fi
    fi
    #------------------------------
} # func_mmmv_verify_that_the_folder_exists_but_do_not_exit_t1

#--------------------------------------------------------------------------

func_mmmv_add_bin_2_Z_PATH_and_optionally_share_man_2_MANPATH_t1(){
    local S_FP_INSTALLATION_FOLDER="$1" # is 
                      # the folder with the $S_FP_INSTALLATION_FOLDER/bin 
                      # and optionally  the $S_FP_INSTALLATION_FOLDER/share/man
    local S_GUID_CANDIDATE="$2"
    local SB_MAN_FOLDER_EXISTENCE_IS_MANDATORY="$3" # domain: {"t","f"} Default: "f"
    #----------------------------------------------------------------------
    # A global variable for storing function output.
    SB_VERIFICATION_FAILED="f" # domain: "t", "f" .
    #------------------------------
    if [ "$SB_VERIFICATION_FAILED" == "f" ]; then
        if [ "$S_GUID_CANDIDATE" == "" ]; then
            echo ""
            echo -e "\e[31mThe code that calls this function is flawed.\e[39m"
            echo ""
            echo "    S_GUID_CANDIDATE==\"\""
            echo ""
            echo "GUID=='22a7599d-011a-4da0-b3ab-d1c0004128e7'"
            echo ""
            #--------
            SB_VERIFICATION_FAILED="t"
        fi
    fi
    #------------------------------
    if [ "$SB_VERIFICATION_FAILED" == "f" ]; then
        if [ "$S_FP_INSTALLATION_FOLDER" == "" ]; then
            echo ""
            echo -e "\e[31mThe code that calls this function is flawed.\e[39m"
            echo ""
            echo "    S_FP_INSTALLATION_FOLDER==\"\""
            echo ""
            echo "S_GUID_CANDIDATE=='$S_GUID_CANDIDATE'"
            echo "GUID=='d407a222-7b00-4202-829b-d1c0004128e7'"
            echo ""
            #--------
            SB_VERIFICATION_FAILED="t"
        fi
    fi
    #------------------------------
    if [ "$SB_VERIFICATION_FAILED" == "f" ]; then
        if [ "$SB_MAN_FOLDER_EXISTENCE_IS_MANDATORY" == "" ]; then
            SB_MAN_FOLDER_EXISTENCE_IS_MANDATORY="f" # the default value
        else
            if [ "$SB_MAN_FOLDER_EXISTENCE_IS_MANDATORY" != "t" ]; then
                if [ "$SB_MAN_FOLDER_EXISTENCE_IS_MANDATORY" != "f" ]; then
                    echo ""
                    echo -e "\e[31mThe code that calls this function is flawed.\e[39m"
                    echo ""
                    echo "    SB_MAN_FOLDER_EXISTENCE_IS_MANDATORY==\"$SB_MAN_FOLDER_EXISTENCE_IS_MANDATORY\""
                    echo ""
                    echo "but its valid values are \"t\" and \"f\" and "
                    echo "\"\", which is automatically converted to the "
                    echo "default value of \"f\"."
                    echo "S_GUID_CANDIDATE=='$S_GUID_CANDIDATE'"
                    echo "GUID=='3628492e-279b-4f04-a29b-d1c0004128e7'"
                    echo ""
                    #--------
                    SB_VERIFICATION_FAILED="t"
                fi
            fi
        fi
    fi
    #------------------------------
    local SB_MAN_FOLDER_OR_NONBROKEN_SYMLINK_TO_IT_EXISTS="f"
    if [ "$SB_VERIFICATION_FAILED" == "f" ]; then
        func_mmmv_verify_that_the_folder_exists_but_do_not_exit_t1 \
            "$S_FP_INSTALLATION_FOLDER" "03fe2037-f31e-4d80-947c-d1c0004128e7"
        if [ "$SB_VERIFICATION_FAILED" == "f" ]; then
            #--------------
            func_mmmv_verify_that_the_folder_exists_but_do_not_exit_t1 \
                "$S_FP_INSTALLATION_FOLDER/bin" "3bf7f331-a69a-442b-937c-d1c0004128e7"
            if [ "$SB_VERIFICATION_FAILED" == "f" ]; then
                Z_PATH="$S_FP_INSTALLATION_FOLDER/bin:$Z_PATH"
            fi
            #--------------
            if [ -e "$S_FP_INSTALLATION_FOLDER/share/man" ]; then
                if [ -d "$S_FP_INSTALLATION_FOLDER/share/man" ]; then
                    SB_MAN_FOLDER_OR_NONBROKEN_SYMLINK_TO_IT_EXISTS="t"
                fi
            fi
            if [ "$SB_MAN_FOLDER_OR_NONBROKEN_SYMLINK_TO_IT_EXISTS" == "f" ]; then
                if [ "$SB_MAN_FOLDER_EXISTENCE_IS_MANDATORY" == "t" ]; then
                    # The next 2 lines are for displaying an error message.
                    func_mmmv_verify_that_the_folder_exists_but_do_not_exit_t1 \
                        "$S_FP_INSTALLATION_FOLDER/share/man" "47e1da15-ec29-4257-b46c-d1c0004128e7"
                fi
            else
                MANPATH="$S_FP_INSTALLATION_FOLDER/share/man:$MANPATH"
            fi
            #--------------
        fi
    fi
    #------------------------------
    if [ "$SB_VERIFICATION_FAILED" != "t" ]; then
        if [ "$SB_VERIFICATION_FAILED" != "f" ]; then
            echo ""
            echo -e "\e[31mThe code of this Bash function is flawed.\e[39m"
            echo "GUID=='5888bc05-65d2-4dae-a99b-d1c0004128e7'"
            echo ""
        fi
    fi
    #------------------------------
} # func_mmmv_add_bin_2_Z_PATH_and_optionally_share_man_2_MANPATH_t1

#--------------------------------------------------------------------------

func_mmmv_assert_error_code_zero_t1(){
    local S_ERR_CODE="$1" # the "$?"
    local S_GUID_CANDIDATE="$2"
    #----------------------------------------------------------------------
    if [ "$S_GUID_CANDIDATE" == "" ]; then
        echo ""
        echo -e "\e[31mThe Bash code that calls this function is flawed. \e[39m"
        echo ""
        echo "    S_GUID_CANDIDATE==\"\""
        echo ""
        echo "but it is expected to be a GUID."
        echo "Aborting script."
        echo "GUID=='2bbc5e84-0302-4d22-a58b-d1c0004128e7'"
        echo "S_GUID_CANDIDATE=='$S_GUID_CANDIDATE'"
        echo ""
        #--------
        cd "$S_FP_ORIG"
        exit 1
    fi
    #------------------------------
    # If the "$?" were evaluated in this function, 
    # then it would be "0" even, if it is
    # something else at the calling code.
    if [ "$S_ERR_CODE" != "0" ];then
        echo ""
        echo "Something went wrong. Error code: $S_ERR_CODE"
        echo -e "\e[31mAborting script. \e[39m"
        echo "GUID=='240c7720-292f-4f42-a38b-d1c0004128e7'"
        echo "S_GUID_CANDIDATE=='$S_GUID_CANDIDATE'"
        echo ""
        #--------
        cd "$S_FP_ORIG"
        exit 1
    fi
    #------------------------------
} # func_mmmv_assert_error_code_zero_t1

#--------------------------------------------------------------------------

# It differs form the 
# func_mmmv_assert_error_code_zero_t1 
# by the fact that it does not include the 
#
#     cd "$S_FP_ORIG"
#
func_mmmv_assert_error_code_zero_t2(){
    local S_ERR_CODE="$1" # the "$?"
    local S_GUID_CANDIDATE="$2"
    #----------------------------------------------------------------------
    if [ "$S_GUID_CANDIDATE" == "" ]; then
        echo ""
        echo -e "\e[31mThe Bash code that calls this function is flawed. \e[39m"
        echo ""
        echo "    S_GUID_CANDIDATE==\"\""
        echo ""
        echo "but it is expected to be a GUID."
        echo "Aborting script."
        echo "GUID=='d20cc69c-799a-4010-bb7b-d1c0004128e7'"
        echo "S_GUID_CANDIDATE=='$S_GUID_CANDIDATE'"
        echo ""
        #--------
        exit 1
    fi
    #------------------------------
    # If the "$?" were evaluated in this function, 
    # then it would be "0" even, if it is
    # something else at the calling code.
    if [ "$S_ERR_CODE" != "0" ];then
        echo ""
        echo "Something went wrong. Error code: $S_ERR_CODE"
        echo -e "\e[31mAborting script. \e[39m"
        echo "GUID=='85f07057-5db1-486e-b57b-d1c0004128e7'"
        echo "S_GUID_CANDIDATE=='$S_GUID_CANDIDATE'"
        echo ""
        #--------
        exit 1
    fi
    #------------------------------
} # func_mmmv_assert_error_code_zero_t2

#--------------------------------------------------------------------------

func_mmmv_assert_error_code_zero_t3(){
    local S_ERR_CODE="$1" # the "$?"
    local S_GUID_CANDIDATE="$2"
    #----------------------------------------------------------------------
    func_mmmv_assert_error_code_zero_t1 "$S_ERR_CODE" "$S_GUID_CANDIDATE"
    func_mmmv_wait_and_sync_t1
    #------------------------------
} # func_mmmv_assert_error_code_zero_t3

func_mmmv_assert_error_code_zero_t4(){
    local S_ERR_CODE="$1" # the "$?"
    local S_GUID_CANDIDATE="$2"
    #----------------------------------------------------------------------
    func_mmmv_assert_error_code_zero_t2 "$S_ERR_CODE" "$S_GUID_CANDIDATE"
    func_mmmv_wait_and_sync_t1
    #------------------------------
} # func_mmmv_assert_error_code_zero_t4

#--------------------------------------------------------------------------

func_mmmv_exc_verify_S_FP_ORIG_t1() {
    if [ "$S_FP_ORIG" == "" ]; then
        echo ""
        echo -e "\e[31mThe code of this script is flawed. \e[39m"
        echo "The environment variable S_FP_ORIG is expected "
        echo "to be initialized at the start of the script by "
        echo ""
        echo "    S_FP_ORIG=\"\`pwd\`\""
        echo ""
        echo "Aborting script."
        echo "GUID=='3733c619-6dfa-49fc-a27b-d1c0004128e7'"
        echo ""
        exit 1 # exit with an error
    fi
    #------------------------
    local SB_IS_SYMLINK="f"      # possible values: "t", "f"
    if [ -h "$S_FP_ORIG" ]; then # Returns "false" for paths that 
                                 # do not refer to anything.
        SB_IS_SYMLINK="t"
    fi
    #--------
    if [ ! -e "$S_FP_ORIG" ]; then
        if [ "$SB_IS_SYMLINK" == "t" ]; then
            echo "The "
        else
            echo "The file or folder "
        fi
        echo ""
        echo "    S_FP_ORIG==$S_FP_ORIG "
        echo ""
        if [ "$SB_IS_SYMLINK" == "t" ]; then
            echo -e "is a\e[31m broken symlink\e[39m. It is expected to be a folder that "
        else
            echo -e "\e[31mdoes not exist\e[39m. It is expected to be a folder that "
        fi
        echo "contains the script that prints this error message."
        echo -e "\e[31mAborting script. \e[39m"
        echo "GUID=='32852b94-01e9-464d-b16b-d1c0004128e7'"
        echo ""
        exit 1 # exit with an error
    fi
    #------------------------
    if [ ! -d "$S_FP_ORIG" ]; then
        echo "The "
        echo ""
        echo "    S_FP_ORIG==$S_FP_ORIG "
        echo ""
        echo -e "is\e[31m not a folder\e[39m. It is expected to be a folder that "
        echo "contains the script that prints this error message."
        echo -e "\e[31mAborting script. \e[39m"
        echo "GUID=='b1ce3e20-ae27-4f20-a16b-d1c0004128e7'"
        echo ""
        exit 1 # exit with an error
    fi
} # func_mmmv_exc_verify_S_FP_ORIG_t1

#--------------------------------------------------------------------------

FUNC_MMMV_EXC_VERIFY_S_FP_ORIG_T2_S_FB_ORIG_ALREADY_VERIFIED="f"
func_mmmv_exc_verify_S_FP_ORIG_t2(){
    if [ "$FUNC_MMMV_EXC_VERIFY_S_FP_ORIG_T2_S_FB_ORIG_ALREADY_VERIFIED" != "t" ]; then
        if [ "$FUNC_MMMV_EXC_VERIFY_S_FP_ORIG_T2_S_FB_ORIG_ALREADY_VERIFIED" != "f" ]; then
            echo ""
            echo -e "\e[31mThe code that calls this function is flawed. \e[39m"
            echo "The global variable "
            echo ""
            echo "    FUNC_MMMV_EXC_VERIFY_S_FP_ORIG_T2_S_FB_ORIG_ALREADY_VERIFIED==\"$FUNC_MMMV_EXC_VERIFY_S_FP_ORIG_T2_S_FB_ORIG_ALREADY_VERIFIED\""
            echo ""
            echo "has a domain of {\"f\", \"t\"}."
            echo "GUID=='593cd442-238d-42ff-9e5b-d1c0004128e7'"
            echo ""
        else
            func_mmmv_exc_verify_S_FP_ORIG_t1
            FUNC_MMMV_EXC_VERIFY_S_FP_ORIG_T2_S_FB_ORIG_ALREADY_VERIFIED="t"
        fi
    fi
} # func_mmmv_exc_verify_S_FP_ORIG_t2

#--------------------------------------------------------------------------

func_mmmv_cd_S_FP_ORIG_and_exit_t1(){
    func_mmmv_exc_verify_S_FP_ORIG_t1
    cd "$S_FP_ORIG"
    func_mmmv_assert_error_code_zero_t2 "$?" \
        "3889db2a-c5b5-4c44-816c-d1c0004128e7"
    exit 0
} # func_mmmv_cd_S_FP_ORIG_and_exit_t1

#--------------------------------------------------------------------------

func_mmmv_assert_nonempty_string_t1(){
    local S_IN="$1"
    local S_VARIABLE_NAME_IN_CALLING_CODE="$2"
    local S_GUID_CANDIDATE="$3"
    #----------------------------------------------------------------------
    func_mmmv_exc_verify_S_FP_ORIG_t2
    if [ "$S_GUID_CANDIDATE" == "" ]; then 
        echo ""
        echo -e "\e[31mThe code that calls this function is flawed.\e[39m The"
        echo ""
        echo "    S_GUID_CANDIDATE==\"\""
        echo ""
        echo "but it is expected to be a GUID."
        echo "GUID=='1c356439-2697-4493-b25b-d1c0004128e7'"
        echo ""
        #--------
        cd "$S_FP_ORIG"
        exit 1 # exiting with an error
    fi
    #----------------------------------------------------------------------
    if [ "$S_VARIABLE_NAME_IN_CALLING_CODE" == "" ]; then 
        echo ""
        echo -e "\e[31mThe code that calls this function is flawed.\e[39m The"
        echo ""
        echo "    S_VARIABLE_NAME_IN_CALLING_CODE==\"\""
        echo ""
        echo "GUID=='9b625e2a-7a45-43d1-b55b-d1c0004128e7'"
        echo "S_GUID_CANDIDATE=='$S_GUID_CANDIDATE'"
        echo ""
        #--------
        cd "$S_FP_ORIG"
        exit 1 # exiting with an error
    fi
    #----------------------------------------------------------------------
    if [ "$S_IN" == "" ]; then 
        echo ""
        echo -e "\e[31mThere is a flaw somewhere in the code\e[39m that"
        echo "uses a variable named \"$S_VARIABLE_NAME_IN_CALLING_CODE\"." 
        echo ""
        echo "    $S_VARIABLE_NAME_IN_CALLING_CODE==\"$S_IN\""
        echo ""
        echo "but it is expected to be something other than an empty string."
        echo "GUID=='32ba301e-c32a-4788-a24b-d1c0004128e7'"
        echo "S_GUID_CANDIDATE=='$S_GUID_CANDIDATE'"
        echo ""
        #--------
        cd "$S_FP_ORIG"
        exit 1 # exiting with an error
    fi
    #----------------------------------------------------------------------
} # func_mmmv_assert_nonempty_string_t1

#--------------------------------------------------------------------------

func_mmmv_assert_sbvar_domain_t_f_t1(){
    local SB_VARIABLE_VALUE="$1"
    local S_VARIABLE_NAME_IN_CALLING_CODE="$2"
    local S_GUID_CANDIDATE="$3"
    #----------------------------------------------------------------------
    func_mmmv_exc_verify_S_FP_ORIG_t2
    if [ "$S_GUID_CANDIDATE" == "" ]; then 
        echo ""
        echo -e "\e[31mThe code that calls this function is flawed.\e[39m The"
        echo ""
        echo "    S_GUID_CANDIDATE==\"\""
        echo ""
        echo "but it is expected to be a GUID."
        echo "GUID=='b674c54e-d335-463e-944b-d1c0004128e7'"
        echo ""
        #--------
        cd "$S_FP_ORIG"
        exit 1 # exiting with an error
    fi
    #----------------------------------------------------------------------
    if [ "$S_VARIABLE_NAME_IN_CALLING_CODE" == "" ]; then 
        echo ""
        echo -e "\e[31mThe code that calls this function is flawed.\e[39m The"
        echo ""
        echo "    S_VARIABLE_NAME_IN_CALLING_CODE==\"\""
        echo ""
        echo "GUID=='98a7b43d-b8c4-42ec-b23b-d1c0004128e7'"
        echo "S_GUID_CANDIDATE=='$S_GUID_CANDIDATE'"
        echo ""
        #--------
        cd "$S_FP_ORIG"
        exit 1 # exiting with an error
    fi
    #----------------------------------------------------------------------
    if [ "$SB_VARIABLE_VALUE" != "t" ]; then 
        if [ "$SB_VARIABLE_VALUE" != "f" ]; then 
            echo ""
            echo -e "\e[31mThere is a flaw somewhere in the code\e[39m that"
            echo "uses a variable named \"$S_VARIABLE_NAME_IN_CALLING_CODE\". The " 
            echo ""
            echo "    $S_VARIABLE_NAME_IN_CALLING_CODE==\"$SB_VARIABLE_VALUE\""
            echo ""
            echo "but it is expected to be either \"t\" or \"f\"."
            echo "GUID=='d222ce69-206b-457f-a33b-d1c0004128e7'"
            echo "GUID_CANDIDATE=='$S_GUID_CANDIDATE'"
            echo ""
            #--------
            cd "$S_FP_ORIG"
            exit 1 # exiting with an error
        fi
    fi
    #----------------------------------------------------------------------
} # func_mmmv_assert_sbvar_domain_t_f_t1

#--------------------------------------------------------------------------

func_mmmv_assert_file_exists_t1() {
    local S_FP="$1"
    local S_GUID_CANDIDATE="$2"
    local SB_OPTIONAL_BAN_SYMLINKS="$3" # domain: {"t", "f", ""} default: "f"
                                        # is the last formal parameter 
                                        # in stead of the S_GUID_CANDIDATE, 
                                        # because that way this function is 
                                        # backwards compatible with 
                                        # an earlier version of this 
                                        # function.
    #----------------------------------------------------------------------
    func_mmmv_exc_verify_S_FP_ORIG_t2
    local SB_LACK_OF_PARAMETERS="f"
    if [ "$S_FP" == "" ]; then
        SB_LACK_OF_PARAMETERS="t"
    fi
    if [ "$S_GUID_CANDIDATE" == "" ]; then
        SB_LACK_OF_PARAMETERS="t"
    fi
    if [ "$SB_LACK_OF_PARAMETERS" == "t" ]; then
        echo ""
        echo -e "\e[31mThe code that calls this function is flawed. \e[39m"
        echo "This function requires 2 parameters, which are "
        echo "S_FP, S_GUID_CANDIDATE, and it has an optional 3. parameter, "
        echo "which is SB_OPTIONAL_BAN_SYMLINKS."
        if [ "$S_GUID_CANDIDATE" != "" ]; then
            echo "S_GUID_CANDIDATE=='$S_GUID_CANDIDATE'"
        fi
        echo "GUID=='b7c38134-92ce-4db5-953b-d1c0004128e7'"
        echo ""
        #--------
        cd "$S_FP_ORIG"
        exit 1 # exiting with an error
    else
        if [ "$SB_LACK_OF_PARAMETERS" != "f" ]; then
            echo -e "\e[31mThis code is flawed. \e[39m"
            echo "GUID=='35baf2b8-e041-4cc1-822b-d1c0004128e7'"
            #--------
            cd "$S_FP_ORIG"
            exit 1 # exiting with an error
        fi
    fi
    #------------------------------
    if [ "$SB_OPTIONAL_BAN_SYMLINKS" == "" ]; then
        # The default value of the 
        SB_OPTIONAL_BAN_SYMLINKS="f"
        # must be backwards compatible with the
        # version of this function, where 
        # symlinks to files were treated as actual files.
    else
        if [ "$SB_OPTIONAL_BAN_SYMLINKS" != "t" ]; then
            if [ "$SB_OPTIONAL_BAN_SYMLINKS" != "f" ]; then
                echo ""
                echo "The "
                echo ""
                echo "    SB_OPTIONAL_BAN_SYMLINKS==\"$SB_OPTIONAL_BAN_SYMLINKS\""
                echo ""
                echo "but the valid values for the SB_OPTIONAL_BAN_SYMLINKS"
                echo "are: \"t\", \"f\", \"\"."
                echo "S_GUID_CANDIDATE=='$S_GUID_CANDIDATE'"
                echo "GUID=='55c788aa-c9c5-4eba-982b-d1c0004128e7'"
                echo ""
                #--------
                cd "$S_FP_ORIG"
                exit 1 # exiting with an error
            fi
        fi
    fi
    #------------------------------
    if [ ! -e "$S_FP" ]; then
        if [ -h "$S_FP" ]; then
            echo ""
            echo "The path "
            echo ""
            echo "    $S_FP "
            echo ""
            echo -e "points to a\e[31m broken symlink\e[39m, but "
            if [ "$SB_OPTIONAL_BAN_SYMLINKS" == "t" ]; then
                echo "a file is expected."
            else
                echo "a file or a symlink to a file is expected."
            fi
            echo "S_GUID_CANDIDATE==\"$S_GUID_CANDIDATE\""
            echo "GUID=='b41a171b-5399-4673-b42b-d1c0004128e7'"
            echo ""
            #--------
            cd "$S_FP_ORIG"
            exit 1 # exiting with an error
        else
            echo ""
            if [ "$SB_OPTIONAL_BAN_SYMLINKS" == "t" ]; then
                echo "The file "
            else
                echo "The file or a symlink to a file "
            fi
            echo ""
            echo "    $S_FP "
            echo ""
            echo -e "\e[31mdoes not exist\e[39m."
            echo "S_GUID_CANDIDATE==\"$S_GUID_CANDIDATE\""
            echo "GUID=='c8760032-dd60-4f8d-811b-d1c0004128e7'"
            echo ""
            #--------
            cd "$S_FP_ORIG"
            exit 1 # exiting with an error
        fi
    else
        if [ -d "$S_FP" ]; then
            echo ""
            if [ -h "$S_FP" ]; then
                echo "The symlink to an existing folder "
            else
                echo "The folder "
            fi
            echo ""
            echo "    $S_FP "
            echo ""
            printf "exists, but "
            if [ "$SB_OPTIONAL_BAN_SYMLINKS" == "t" ]; then
                echo -e "a\e[31m file is expected\e[39m."
            else
                echo -e "a\e[31m file or a symlink to a file is expected\e[39m."
            fi
            echo "S_GUID_CANDIDATE==\"$S_GUID_CANDIDATE\""
            echo "GUID=='7be2ae5b-7dcf-42bb-b51b-d1c0004128e7'"
            echo ""
            #--------
            cd "$S_FP_ORIG"
            exit 1 # exiting with an error
        else
            if [ "$SB_OPTIONAL_BAN_SYMLINKS" == "t" ]; then
                if [ -h "$S_FP" ]; then 
                    echo ""
                    echo "The "
                    echo ""
                    echo "    $S_FP"
                    echo ""
                    echo -e "is a symlink to a file, but a\e[31m file is expected\e[39m."
                    echo "S_GUID_CANDIDATE==\"$S_GUID_CANDIDATE\""
                    echo "GUID=='7568ea38-3e4a-4882-a50b-d1c0004128e7'"
                    echo ""
                    #--------
                    cd "$S_FP_ORIG"
                    exit 1 # exiting with an error
                fi
            fi
        fi
    fi
} # func_mmmv_assert_file_exists_t1

#--------------------------------------------------------------------------

func_mmmv_assert_folder_exists_t1() {
    local S_FP="$1"
    local S_GUID_CANDIDATE="$2"
    local SB_OPTIONAL_BAN_SYMLINKS="$3" # domain: {"t", "f", ""} default: "f"
                                        # is the last formal parameter 
                                        # in stead of the S_GUID_CANDIDATE, 
                                        # because that way this function is 
                                        # backwards compatible with 
                                        # an earlier version of this 
                                        # function.
    #----------------------------------------------------------------------
    func_mmmv_exc_verify_S_FP_ORIG_t2
    local SB_LACK_OF_PARAMETERS="f"
    if [ "$S_FP" == "" ]; then
        SB_LACK_OF_PARAMETERS="t"
    fi
    if [ "$S_GUID_CANDIDATE" == "" ]; then
        SB_LACK_OF_PARAMETERS="t"
    fi
    if [ "$SB_LACK_OF_PARAMETERS" == "t" ]; then
        echo ""
        echo -e "\e[31mThe code that calls this function is flawed. \e[39m"
        echo "This function requires 2 parameters, which are "
        echo "S_FP, S_GUID_CANDIDATE, and it has an optional 3. parameter, "
        echo "which is SB_OPTIONAL_BAN_SYMLINKS."
        if [ "$S_GUID_CANDIDATE" != "" ]; then
            echo "S_GUID_CANDIDATE=='$S_GUID_CANDIDATE'"
        fi
        echo "GUID=='d55dd216-597e-4d5c-820b-d1c0004128e7'"
        echo ""
        #--------
        cd "$S_FP_ORIG"
        exit 1 # exiting with an error
    else
        if [ "$SB_LACK_OF_PARAMETERS" != "f" ]; then
            echo -e "\e[31mThis code is flawed. \e[39m"
            echo "GUID=='fd214151-9c42-4bdb-a10b-d1c0004128e7'"
            #--------
            cd "$S_FP_ORIG"
            exit 1 # exiting with an error
        fi
    fi
    #------------------------------
    if [ "$SB_OPTIONAL_BAN_SYMLINKS" == "" ]; then
        # The default value of the 
        SB_OPTIONAL_BAN_SYMLINKS="f"
        # must be backwards compatible with the
        # version of this function, where 
        # symlinks to folders were treated as actual folders.
    else
        if [ "$SB_OPTIONAL_BAN_SYMLINKS" != "t" ]; then
            if [ "$SB_OPTIONAL_BAN_SYMLINKS" != "f" ]; then
                echo ""
                echo "The "
                echo ""
                echo "    SB_OPTIONAL_BAN_SYMLINKS==\"$SB_OPTIONAL_BAN_SYMLINKS\""
                echo ""
                echo "but the valid values for the SB_OPTIONAL_BAN_SYMLINKS"
                echo "are: \"t\", \"f\", \"\"."
                echo "S_GUID_CANDIDATE=='$S_GUID_CANDIDATE'"
                echo "GUID=='ee973050-bed5-4d4e-93fa-d1c0004128e7'"
                echo ""
                #--------
                cd "$S_FP_ORIG"
                exit 1 # exiting with an error
            fi
        fi
    fi
    #------------------------------
    if [ ! -e "$S_FP" ]; then
        if [ -h "$S_FP" ]; then
            echo ""
            echo "The path "
            echo ""
            echo "    $S_FP "
            echo ""
            echo -e "points to a\e[31m broken symlink\e[39m, but "
            if [ "$SB_OPTIONAL_BAN_SYMLINKS" == "t" ]; then
                echo -e "a\e[31m folder is expected\e[39m."
            else
                echo -e "a\e[31m folder or a symlink to a folder is expected\e[39m."
            fi
            echo "S_GUID_CANDIDATE==\"$S_GUID_CANDIDATE\""
            echo "GUID=='2260ea91-d211-437f-91fa-d1c0004128e7'"
            echo ""
            #--------
            cd "$S_FP_ORIG"
            exit 1 # exiting with an error
        else
            echo ""
            if [ "$SB_OPTIONAL_BAN_SYMLINKS" == "t" ]; then
                echo "The folder "
            else
                echo "The folder or a symlink to a folder "
            fi
            echo ""
            echo "    $S_FP "
            echo ""
            echo -e "\e[31mdoes not exist\e[39m."
            echo "S_GUID_CANDIDATE==\"$S_GUID_CANDIDATE\""
            echo "GUID=='d79ff838-b8cd-48e5-94fa-d1c0004128e7'"
            echo ""
            #--------
            cd "$S_FP_ORIG"
            exit 1 # exiting with an error
        fi
    else
        if [ ! -d "$S_FP" ]; then
            echo ""
            if [ -h "$S_FP" ]; then
                echo "The symlink to an existing file "
            else
                echo "The file "
            fi
            echo ""
            echo "    $S_FP "
            echo ""
            printf "exists, but "
            if [ "$SB_OPTIONAL_BAN_SYMLINKS" == "t" ]; then
                echo -e "a\e[31m folder is expected\e[39m."
            else
                echo -e "a\e[31m folder or a symlink to a folder is expected\e[39m."
            fi
            echo "S_GUID_CANDIDATE==\"$S_GUID_CANDIDATE\""
            echo "GUID=='2d725b48-c529-4fe7-94fa-d1c0004128e7'"
            echo ""
            #--------
            cd "$S_FP_ORIG"
            exit 1 # exiting with an error
        else
            if [ "$SB_OPTIONAL_BAN_SYMLINKS" == "t" ]; then
                if [ -h "$S_FP" ]; then 
                    echo ""
                    echo "The "
                    echo ""
                    echo "    $S_FP"
                    echo ""
                    echo -e "is a symlink to a folder, but a\e[31m folder is expected\e[39m."
                    echo "S_GUID_CANDIDATE==\"$S_GUID_CANDIDATE\""
                    echo "GUID=='49c3b655-07d0-48f3-a4fa-d1c0004128e7'"
                    echo ""
                    #--------
                    cd "$S_FP_ORIG"
                    exit 1 # exiting with an error
                fi
            fi
        fi
    fi
} # func_mmmv_assert_folder_exists_t1

#--------------------------------------------------------------------------

func_mmmv_exit_if_not_on_path_t2() { # S_COMMAND_NAME
    local S_COMMAND_NAME="$1"
    #----------------------------------------------------------------------
    func_mmmv_exc_verify_S_FP_ORIG_t2
    local S_LOCAL_VARIABLE="`which $S_COMMAND_NAME 2> /dev/null`"
    if [ "$S_LOCAL_VARIABLE" == "" ]; then
        echo ""
        echo -e "\e[31mCommand \"$S_COMMAND_NAME\" could not be found from the PATH. \e[39m"
        echo "The execution of this Bash script is aborted."
        echo "GUID=='76b7425d-2ec5-4b56-95ea-d1c0004128e7'"
        echo ""
        cd "$S_FP_ORIG"
        exit 1;
    fi
} # func_mmmv_exit_if_not_on_path_t2

#--------------------------------------------------------------------------

func_mmmv_exit_t1(){
    local S_GUID_CANDIDATE="$1" # first function argument
    #----------------------------------------------------------------------
    echo ""
    echo -e "\e[32m\e[7m#======================================================="
    echo -e "\e[0m\e[32mIf You want to run this Bash script, the "
    echo "#--------------"
    echo "$S_FP_DIR/$S_FN_SCRIPTFILE_NAME"
    echo "#--------------"
    echo "then please edit it by outcommenting the line with the "
    echo "\"$S_GUID_CANDIDATE\"."
    echo "Thank You."
    echo -e "\e[32m\e[7m#======================================================="
    echo -e "\e[0m" # resets the text terminal style
    cd "$S_FP_ORIG"
    exit 1
} # func_mmmv_exit_t1

#--------------------------------------------------------------------------

func_mmmv_exc_exit_with_an_error_t1(){
    local S_GUID_CANDIDATE="$1" # first function argument
    #----------------------------------------------------------------------
    func_mmmv_exc_verify_S_FP_ORIG_t1
    echo ""
    echo -e "\e[31mThe code of this script is flawed. \e[39m"
    echo "Aborting script."
    if [ "$S_GUID_CANDIDATE" != "" ]; then 
        echo "GUID_CANDIDATE=='$S_GUID_CANDIDATE'"
    fi
    echo "GUID=='d4e1e1c4-58ba-4fa6-94ea-d1c0004128e7'"
    echo ""
    cd "$S_FP_ORIG"
    exit 1 # exit with an error
} # func_mmmv_exc_exit_with_an_error_t1

#--------------------------------------------------------------------------

func_mmmv_exc_exit_with_an_error_t2(){
    local S_GUID_CANDIDATE="$1"   # first function argument
    local S_OPTIONAL_ERR_MSG="$2" # second function argument
    #----------------------------------------------------------------------
    func_mmmv_exc_verify_S_FP_ORIG_t1
    if [ "$S_GUID_CANDIDATE" == "" ]; then 
        echo ""
        echo -e "\e[31mThe code of this script is flawed. \e[39m"
        if [ "$S_OPTIONAL_ERR_MSG" != "" ]; then 
            echo -e "$S_OPTIONAL_ERR_MSG"
        fi
        echo "Aborting script."
        echo "GUID=='6481cb18-c76c-466c-b2ea-d1c0004128e7'"
        echo ""
        cd "$S_FP_ORIG"
        exit 1 # exit with an error
    else
        echo ""
        echo -e "\e[31mSomething went wrong. \e[39m"
        if [ "$S_OPTIONAL_ERR_MSG" != "" ]; then 
            echo "$S_OPTIONAL_ERR_MSG"
        fi
        echo "Aborting script."
        echo "GUID_CANDIDATE=='$S_GUID_CANDIDATE'"
        echo "GUID=='03aee915-13d7-4261-84ea-d1c0004128e7'"
        echo ""
        cd "$S_FP_ORIG"
        exit 1 # exit with an error
    fi
} # func_mmmv_exc_exit_with_an_error_t2

#--------------------------------------------------------------------------

S_AWK_CMD="exit 1;"
func_mmmv_exc_determine_Awk_command_t1() { # prefers the GNU Awk to the BSD Awk
    local SB_AVOID_REINITIALISATION_IF_ALREADY_INITIALIZED="$1" # domain: {"","t","f"}
                                                                # default: "t"
                                                                # "" -> "t"
    #----------------------------------------------------------------------
    local SB_AVOID_REINIT="t" # the default
    if [ "$SB_AVOID_REINITIALISATION_IF_ALREADY_INITIALIZED" != "" ]; then
        func_mmmv_assert_sbvar_domain_t_f_t1 \
            "$SB_AVOID_REINITIALISATION_IF_ALREADY_INITIALIZED" \
            "SB_AVOID_REINITIALISATION_IF_ALREADY_INITIALIZED" \
            "c570335d-c582-4477-836c-d1c0004128e7" 
        SB_AVOID_REINIT="$SB_AVOID_REINITIALISATION_IF_ALREADY_INITIALIZED"
    fi
    #----------------------------------------------------------------------
    local SB_REINIT="t"
    if [ "$SB_AVOID_REINIT" == "t" ]; then
        if [ "$S_AWK_CMD" != "exit 1;" ]; then
            SB_REINIT="f"
        fi
    fi
    #----------------------------------------------------------------------
    if [ "$SB_REINIT" == "t" ]; then
        #------------------------------------------------------------------
        func_mmmv_exc_verify_S_FP_ORIG_t2
        S_AWK_CMD="exit 1;" # for reliability
        local SB_THROW="f"
        local S_TMP_0="a147f82d-e820-4f38-b35c-d1c0004128e7"
        local S_FP_0="/tmp/this/proB9bably/do00es/noTt/eXXXist/ㄫ/$S_TMP_0"
        #------------------------------------------------------------------
        if [ "$SB_GAWK_EXISTS_ON_PATH" == "f" ]; then # empty string, "", is also in domain
            # This if-branch is a speedhack for a case, where 
            # the mmmv_userspace_distro_t1 is in use.
            if [ "$SB_AWK_EXISTS_ON_PATH" == "f" ]; then # empty string, "", is also in domain
                SB_THROW="t"
            else
                S_FP_0="`which awk 2> /dev/null`"
                if [ "$S_FP_0" != "" ]; then
                    S_AWK_CMD="$S_FP_0" # assigns a full path
                else
                    SB_THROW="t"
                fi
            fi
        else
            S_FP_0="`which gawk 2> /dev/null`"
            if [ "$S_FP_0" != "" ]; then
                S_AWK_CMD="$S_FP_0" # assigns a full path
            else
                S_FP_0="`which awk 2> /dev/null`"
                if [ "$S_FP_0" != "" ]; then
                    S_AWK_CMD="$S_FP_0" # assigns a full path
                else
                    SB_THROW="t"
                fi
            fi
        fi
        #------------------------------------------------------------------
        if [ "$SB_THROW" == "t" ]; then
            echo ""
            echo -e "\e[31mNeither 'gawk', nor 'awk' was available on PATH. \e[39m"
            echo "The execution of this Bash script is aborted."
            echo "GUID=='c52afa1a-1d7e-4d92-92ea-d1c0004128e7'"
            echo ""
            cd "$S_FP_ORIG"
            exit 1;
        fi
        #------------------------------------------------------------------
    fi
    #----------------------------------------------------------------------
} # func_mmmv_exc_determine_Awk_command_t1

#--------------------------------------------------------------------------

S_SED_CMD="exit 1;"
func_mmmv_exc_determine_sed_command_t1() { # prefers the GNU sed to the BSD sed
    local SB_AVOID_REINITIALISATION_IF_ALREADY_INITIALIZED="$1" # domain: {"","t","f"}
                                                              # default: "t"
                                                              # "" -> "t"
    #----------------------------------------------------------------------
    local SB_AVOID_REINIT="t" # the default
    if [ "$SB_AVOID_REINITIALISATION_IF_ALREADY_INITIALIZED" != "" ]; then
        func_mmmv_assert_sbvar_domain_t_f_t1 \
            "$SB_AVOID_REINITIALISATION_IF_ALREADY_INITIALIZED" \
            "SB_AVOID_REINITIALISATION_IF_ALREADY_INITIALIZED" \
            "6a15ad37-b39c-45ee-a15c-d1c0004128e7" 
        SB_AVOID_REINIT="$SB_AVOID_REINITIALISATION_IF_ALREADY_INITIALIZED"
    fi
    #----------------------------------------------------------------------
    local SB_REINIT="t"
    if [ "$SB_AVOID_REINIT" == "t" ]; then
        if [ "$S_AWK_CMD" != "exit 1;" ]; then
            SB_REINIT="f"
        fi
    fi
    #----------------------------------------------------------------------
    if [ "$SB_REINIT" == "t" ]; then
        #------------------------------------------------------------------
        func_mmmv_exc_verify_S_FP_ORIG_t2
        S_SED_CMD="exit 1;" # for reliability
        local SB_THROW="f"
        local S_TMP_0="eaf2ec16-3cc7-4280-812c-d1c0004128e7"
        local S_FP_0="/tmp/this/proB9bably/do00es/noTt/eXXXist/ㄫ/$S_TMP_0"
        #------------------------------------------------------------------
        if [ "$SB_GSED_EXISTS_ON_PATH" == "f" ]; then # empty string, "", is also in domain
            # This if-branch is a speedhack for a case, where 
            # the mmmv_userspace_distro_t1 is in use.
            if [ "$SB_SED_EXISTS_ON_PATH" == "f" ]; then # empty string, "", is also in domain
                SB_THROW="t"
            else
                S_FP_0="`which sed 2> /dev/null`"
                if [ "$S_FP_0" != "" ]; then
                    S_SED_CMD="$S_FP_0" # assigns a full path
                else
                    SB_THROW="t"
                fi
            fi
        else
            S_FP_0="`which gsed 2> /dev/null`"
            if [ "$S_FP_0" != "" ]; then
                S_SED_CMD="$S_FP_0" # assigns a full path
            else
                if [ "`which sed`" != "" ]; then
                    S_SED_CMD="sed"
                else
                    SB_THROW="t"
                fi
            fi
        fi
        #------------------------------------------------------------------
        if [ "$SB_THROW" != "f" ]; then
            echo ""
            echo -e "\e[31mNeither 'gsed', nor 'sed' was available on PATH. \e[39m"
            echo "The execution of this Bash script is aborted."
            echo "GUID=='d0c18848-b851-466b-b1da-d1c0004128e7'"
            echo ""
            cd "$S_FP_ORIG"
            exit 1;
        fi
        #------------------------------------------------------------------
    fi
} # func_mmmv_exc_determine_sed_command_t1

#--------------------------------------------------------------------------

func_mmmv_exc_is_file_t1() {
    local S_FP_CANDIDATE="$1" # folder path
    #----------------------------------------------------------------------
    if [ ! -e "$S_FP_CANDIDATE" ]; then 
        echo ""
        echo "The file"
        echo ""
        echo "    $S_FP_CANDIDATE "
        echo ""
        echo -e "\e[31mdoes not exist\e[39m."
        echo "GUID=='bc535d27-e410-4bf6-94da-d1c0004128e7'"
        echo "Aborting without doing anything."
        echo ""
        exit 1 # exit with an error
    fi
    if [ -d "$S_FP_CANDIDATE" ]; then 
        echo ""
        echo "The path"
        echo ""
        echo "    $S_FP_CANDIDATE "
        echo ""
        if [ -h "$S_FP_CANDIDATE" ]; then 
            echo "references a symbolic link to a folder, "
        else
            echo "references a folder, "
        fi
        echo -e "but it is\e[31m required to reference a file\e[39m."
        echo "GUID=='da5b115a-cb39-4cf9-a5da-d1c0004128e7'"
        echo "Aborting without doing anything."
        echo ""
        exit 1 # exit with an error
    fi
} # func_mmmv_exc_is_file_t1

#--------------------------------------------------------------------------

func_mmmv_exc_is_folder_t1() {
    local S_FP_CANDIDATE="$1" # folder path
    #----------------------------------------------------------------------
    if [ ! -e "$S_FP_CANDIDATE" ]; then 
        echo ""
        echo "The folder"
        echo ""
        echo "    $S_FP_CANDIDATE "
        echo ""
        echo -e "\e[31mdoes not exist\e[39m."
        echo "GUID=='4b623d25-1c50-4b2a-86da-d1c0004128e7'"
        echo "Aborting without doing anything."
        echo ""
        exit 1 # exit with an error
    fi
    if [ ! -d "$S_FP_CANDIDATE" ]; then 
        echo ""
        echo "The path"
        echo ""
        echo "    $S_FP_CANDIDATE "
        echo ""
        if [ -h "$S_FP_CANDIDATE" ]; then 
            echo "references a symbolic link to a file, "
        else
            echo "references a file, "
        fi
        echo -e "but it is\e[31m required to reference a folder\e[39m."
        echo "GUID=='82763af3-61ee-4dc5-a1da-d1c0004128e7'"
        echo "Aborting without doing anything."
        echo ""
        exit 1 # exit with an error
    fi
} # func_mmmv_exc_is_folder_t1

# S_FP_TMP_0="/tmp/fff_testimine"
# S_FP_TMP_FF1="$S_FP_TMP_0/ff1"
# S_FP_TMP_FILE_1="$S_FP_TMP_0/file1.txt"
# S_FP_TMP_0_SYM_FLDR_OK="$S_FP_TMP_0/sym_folder_exists"
# S_FP_TMP_0_SYM_X_MISSING="$S_FP_TMP_0/sym_x_missing"
# S_FP_TMP_0_SYM_FILE_OK="$S_FP_TMP_0/sym_file_exists"
# rm -fr $S_FP_TMP_0
# mkdir -p $S_FP_TMP_FF1
# echo "Hello World :-)" > $S_FP_TMP_FILE_1
# ln -s $S_FP_TMP_FILE_1  $S_FP_TMP_0_SYM_FILE_OK
# ln -s $S_FP_TMP_FF1  $S_FP_TMP_0_SYM_FLDR_OK
# ln -s $S_FP_TMP_FF1/this_does_not_exist $S_FP_TMP_0_SYM_X_MISSING
# 
# # The following assertions must pass:
#     func_mmmv_exc_is_folder_t1 "$S_FP_TMP_FF1"
#     func_mmmv_exc_is_folder_t1 "$S_FP_TMP_0_SYM_FLDR_OK"
#     func_mmmv_exc_is_file_t1 "$S_FP_TMP_FILE_1"
#     func_mmmv_exc_is_file_t1 "$S_FP_TMP_0_SYM_FILE_OK"
# 
# # The following assertions must fail:
#     #func_mmmv_exc_is_folder_t1 "$S_FP_TMP_0_SYM_X_MISSING"
#     #func_mmmv_exc_is_file_t1 "$S_FP_TMP_0_SYM_X_MISSING"
# 
# rm -fr $S_FP_TMP_0
# exit 0

#--------------------------------------------------------------------------

func_mmmv_create_folder_t1(){
    local S_FP_FOLDER="$1" # first function argument
    #--------
    # The reason, why this function is used instead of the 
    #     mkdir -p $S_FP_FOLDER
    # is that there is no guarantee that the 
    #     mkdir -p $S_FP_FOLDER
    # succeeds and it would be a waste of
    # development time to write the file system related
    # tests from scratch every time a folder 
    # needs to be created.
    #----------------------------------------------------------------------
    func_mmmv_exc_verify_S_FP_ORIG_t2
    if [ "$S_FP_FOLDER" == "" ]; then
        echo ""
        echo "The function formal parameter S_FP_FOLDER "
        echo "is expected to be a full path to a folder that "
        echo "either already exists or that has to be created."
        echo "Aborting script."
        echo "GUID=='d2d54e2b-341b-49bf-b4da-d1c0004128e7'"
        echo ""
        cd "$S_FP_ORIG"
        exit 1 # exit with an error
    fi
    #--------
    if [ -e "$S_FP_FOLDER" ]; then 
        if [ ! -d "$S_FP_FOLDER" ]; then 
            echo ""
            echo "The "
            echo ""
            echo "    $S_FP_FOLDER"
            echo ""
            echo "is a file or a symlink to a file, but it "
            echo "is expected to be a full path to a folder, "
            echo "a symlink to a folder or it should not "
            echo "reference anything that already exists."
            echo "Aborting script."
            echo "GUID=='237cd344-1cc7-4fe0-b3ca-d1c0004128e7'"
            echo ""
            cd "$S_FP_ORIG"
            exit 1 # exit with an error
        fi
    else
        mkdir -p $S_FP_FOLDER
        local S_TMP_0="$?"
        wait # just in case
        sync # for network drives and USB-sticks
        wait # just in case
        if [ "$S_TMP_0" != "0" ]; then 
            func_mmmv_exc_exit_with_an_error_t2 "b0a49140-34d2-491a-a32c-d1c0004128e7" \
                "S_FP_FOLDER==$S_FP_FOLDER"
        fi
        if [ ! -e "$S_FP_FOLDER" ]; then 
            func_mmmv_exc_exit_with_an_error_t2 "3ac9e999-e7f9-4d4a-841c-d1c0004128e7" \
                "Folder creation failed. S_FP_FOLDER==$S_FP_FOLDER"
        fi
    fi
    #--------
} # func_mmmv_create_folder_t1

#--------------------------------------------------------------------------

func_mmmv_exc_assure_tmp_folder_existence_t1() {  # S_FP_TMP, S_GUID
    local S_FP_TMP="$1"
    local S_GUID="$2"
    #----------------------------------------------------------------------
    func_mmmv_exc_verify_S_FP_ORIG_t2
    if [ "$S_GUID" == "" ]; then
        echo ""
        echo -e "\e[31mThe code that calls this function is flawed. \e[39m"
        echo "This function requires 2 parameters: S_FP_TMP, S_GUID"
        echo "GUID=='87257d2c-b7aa-463d-95ca-d1c0004128e7'"
        echo ""
        #--------
        cd "$S_FP_ORIG"
        exit 1 # exiting with an error
    fi
    #------------------------------
    if [ ! -e "$S_FP_TMP" ]; then
        if [ -h "$S_FP_TMP" ]; then
            rm -f "$S_FP_TMP" # deletes a broken symlink
            func_mmmv_assert_error_code_zero_t1 \
                "$?" "53d318b5-3432-4aea-b21c-d1c0004128e7"
            func_mmmv_wait_and_sync_t1
            if [ -h "$S_FP_TMP" ]; then
                echo ""
                echo "The path "
                echo ""
                echo "    $S_FP_TMP"
                echo ""
                echo -e "points to a\e[31m broken symlink\e[39m, but a folder "
                echo "or a symlink to a folder is expected."
                echo "An attempt to delete the broken symlink failed."
                echo "GUID==\"$S_GUID\""
                echo "GUID=='aa0d4a17-8c2d-46c5-a2ca-d1c0004128e7'"
                echo ""
                #--------
                cd "$S_FP_ORIG"
                exit 1 # exiting with an error
            fi
        fi
        mkdir -p "$S_FP_TMP"
        func_mmmv_assert_error_code_zero_t1 \
            "$?" "714f18fb-2bee-4542-b21c-d1c0004128e7"
        func_mmmv_wait_and_sync_t1
        func_mmmv_assert_folder_exists_t1 "$S_FP_TMP" \
            'f961d23e-0694-49ba-82ca-d1c0004128e7'
    else
        if [ ! -d "$S_FP_TMP" ]; then
            echo ""
            if [ -h "$S_FP_TMP" ]; then
                echo "The symlink to an existing file "
            else
                echo "The file "
            fi
            echo ""
            echo "    $S_FP_TMP"
            echo ""
            echo -e "exists, but a\e[31m folder or a symlink to a folder is expected\e[39m."
            echo "GUID==\"$S_GUID\""
            echo "GUID=='43d49e16-682f-4a44-b7ca-d1c0004128e7'"
            echo ""
            #--------
            cd "$S_FP_ORIG"
            exit 1 # exiting with an error
        fi
    fi
} # func_mmmv_exc_assure_tmp_folder_existence_t1

#--------------------------------------------------------------------------

func_mmmv_ln_create_hardlink_t1() { # S_FP_TARGET  S_FP_LINK
    local S_FP_TARGET="$1" # is allowed to be a broken symlink, but 
                           # must NOT be a folder and must be 
                           # on the same filesystem volume with the S_FP_LINK .

    local S_FP_LINK="$2"   # must not exist during the call of this function .

    local SB_THROW_ON_INVALID_DATA="$3" # Optional.
                                        # Domain: {"t","f","",<unassigned>}.
                                        # default=="t"
    #----------------------------------------------------------------------
    if [ "$SB_THROW_ON_INVALID_DATA" == "" ]; then
        SB_THROW_ON_INVALID_DATA="t"
    else
        if [ "$SB_THROW_ON_INVALID_DATA" != "t" ]; then
            if [ "$SB_THROW_ON_INVALID_DATA" != "f" ]; then
                echo ""
                echo -e "\e[31mThe code that calls this function is flawed. \e[39m"
                echo "Domain(SB_THROW_ON_INVALID_DATA) == "
                echo "    {\"t\",\"f\",\"\",<unassigned>}"
                echo ""
                echo "    SB_THROW_ON_INVALID_DATA==\"$SB_THROW_ON_INVALID_DATA\""
                echo ""
                echo "Aborting script."
                echo "GUID=='a09f9612-0de7-4ecc-a3ba-d1c0004128e7'"
                echo ""
                exit 1 # because of a code defect, not just invalid data.
            fi
        fi
    fi
    local SB_DO_NOT_CREATE_THE_HARDLINK="f" #a fallback for not throwing/exiting
    #----------------------------------------------------------------------
    # The original file and the hardlink share the same inode 
    # and therefore the original file and the hardlink are
    # distinguishable from each other only by their paths. Hardlinks
    # to folders do not exist, can not be made, because that would
    # change a file system tree into a graph that has true loops,
    # not just symlink based loops. Hardlinks form a relation
    # between a file path and an inode of a file. Hardlinks to 
    # symlinks are possible, because symlinks are special purpose files
    # regardless of whether the symlinks reference a folder or a file or another symlink.
    # Revision control systems (Git, Subversion, etc.)
    # can/at_least_sometimes_do break hardlinks by making physical
    # copies of the files that are referenced by hardlinks.
    #
    #     https://superuser.com/questions/12972/how-can-you-see-the-actual-hard-link-by-ls
    #     (archival copy: https://archive.is/8feTw )
    #
    #     http://www.linfo.org/hard_link.html
    #     (archival copy: https://archive.is/HXFYC )
    #
    # Inode numbers can be displayed by executing
    #
    #     ls -l --inode   # short version is: "ls -li "
    # 
    # A 2019_06_30 citation of user "ninjalj" 2017_05_02 comment from  
    # 
    #     https://stackoverflow.com/questions/43733893/when-rm-a-file-but-hard-link-still-there-the-inode-will-be-marked-unused
    #     (archival copy: https://archive.is/5j0cv )
    #     ----citation--start----
    #     i-nodes contain a link count (visible in ls -l output). 
    #     Each hard link increments that count. Unlinking 
    #     (removing a link, be it the original filename->inode 
    #     link, or some hard link added later, which is the only thing 
    #     users can request) decrements the count.  
    #     ----citation--end------
    #
    #----------------------------------------------------------------------
    if [ -e "$S_FP_LINK" ]; then 
        if [ -d "$S_FP_LINK" ]; then # folder or a symlink to a folder
            if [ ! -h "$S_FP_LINK" ]; then # not a symlink, therefore a folder
                echo ""
                echo "The hardlink candidate, the "
                echo ""
                echo "    $S_FP_LINK"
                echo ""
                echo "already exists and it is a folder, not a symlink."
                echo "According to the implementation of this function "
                echo "this is a situation, where there is probably something wrong,"
                echo "because hardlinks can be made only to files and symlinks, "
                echo "regardless of whether the symlinks are broken or not."
                echo "Skipping the creation of the hardlink with the target path of "
                echo ""
                echo "    $S_FP_TARGET"
                echo ""
                echo "GUID=='a936ee35-45d5-465c-84ba-d1c0004128e7'"
                echo ""
                if [ "$SB_THROW_ON_INVALID_DATA" == "t" ]; then
                    exit 1
                fi
                SB_DO_NOT_CREATE_THE_HARDLINK="t"
            # else # symlink to a folder
            fi
        # else # file or a symlink to a file
        fi
        if [ "$SB_DO_NOT_CREATE_THE_HARDLINK" == "f" ]; then
            echo ""
            echo "According to the specification of this function "
            echo "the hardlink, which in the case of this function call "
            echo "has the path of "
            echo ""
            echo "    $S_FP_LINK"
            echo ""
            echo "must not exist before the call to this function."
            echo "GUID=='bd39c74c-182b-4373-95ba-d1c0004128e7'"
            echo ""
            if [ "$SB_THROW_ON_INVALID_DATA" == "t" ]; then
                exit 1
            fi
            SB_DO_NOT_CREATE_THE_HARDLINK="t"
        fi
    else # missing or a broken symlink
        if [ "$SB_DO_NOT_CREATE_THE_HARDLINK" == "f" ]; then
            if [ -h "$S_FP_LINK" ]; then # a broken symlink, therefore NOT missing
                echo ""
                echo "The hardlink candidate, the "
                echo ""
                echo "    $S_FP_LINK"
                echo ""
                echo "already exists and it is a broken symlink. According to "
                echo "the specification of this function the hardlink "
                echo "must not exist before the call to this function."
                echo "GUID=='f57e0621-fcb7-4d4a-b5ba-d1c0004128e7'"
                echo ""
                if [ "$SB_THROW_ON_INVALID_DATA" == "t" ]; then
                    exit 1
                fi
                SB_DO_NOT_CREATE_THE_HARDLINK="t"
            fi
        fi
    fi
    #----------------------------------------------------------------------
    if [ "$SB_DO_NOT_CREATE_THE_HARDLINK" == "f" ]; then
        if [ -e "$S_FP_TARGET" ]; then
            if [ -d "$S_FP_TARGET" ]; then # a folder or a symlink to a folder
                if [ ! -h "$S_FP_TARGET" ]; then # not a symlink, therefore a folder
                    echo ""
                    echo "The hardlink target candidate, the "
                    echo ""
                    echo "    $S_FP_TARGET"
                    echo ""
                    echo "is a folder, not a symlink to a folder. "
                    echo "Hardlinks can be made only to files and symlinks, "
                    echo "regardless of whether the symlinks are broken or not."
                    echo "Skipping the creation of the hardlink with the path of "
                    echo ""
                    echo "    $S_FP_LINK"
                    echo ""
                    echo "GUID=='8c43e7b7-cd80-40ae-82aa-d1c0004128e7'"
                    echo ""
                    if [ "$SB_THROW_ON_INVALID_DATA" == "t" ]; then
                        exit 1
                    fi
                    SB_DO_NOT_CREATE_THE_HARDLINK="t"
                # else # symlink to a folder
                fi
            # else # file or a symlink to a file
            fi
        else # missing or a broken symlink
            if [ ! -h "$S_FP_TARGET" ]; then # not a symlink, therefore missing
                echo ""
                echo "The hardlink target candidate with the path of  "
                echo ""
                echo "    $S_FP_TARGET"
                echo ""
                echo -e "\e[31mdoes not exist\e[39m. Skipping the creation of a hardlink"
                echo "with the path of "
                echo ""
                echo "    $S_FP_LINK"
                echo ""
                echo "GUID=='b5b6cc4e-56e5-4272-a3aa-d1c0004128e7'"
                echo ""
                if [ "$SB_THROW_ON_INVALID_DATA" == "t" ]; then
                    exit 1
                fi
                SB_DO_NOT_CREATE_THE_HARDLINK="t"
            # else # broken symlink
                   # It is possible to create hardlinks to broken symlinks.
            fi
        fi
    fi
    #----------------------------------------------------------------------
    local S_TMP_0="not_set_yet GUID=='434088e3-aa12-41d9-95aa-d1c0004128e7'"
    if [ "$SB_DO_NOT_CREATE_THE_HARDLINK" == "f" ]; then
        ln  "$S_FP_TARGET" "$S_FP_LINK" 
        S_TMP_0="$?"
        if [ "$S_TMP_0" != "0" ]; then
            echo ""
            echo "The creation of a hardlink with the path of "
            echo ""
            echo "    $S_FP_LINK"
            echo ""
            echo "and the target path of "
            echo ""
            echo "    $S_FP_TARGET"
            echo ""
            echo -e "\e[31mfailed\e[39m. The ln exited with the error code of $S_TMP_0 ."
            echo "GUID=='62981b64-f3f1-4f7a-91aa-d1c0004128e7'"
            echo ""
            if [ "$SB_THROW_ON_INVALID_DATA" == "t" ]; then
                exit 1
            fi
            SB_DO_NOT_CREATE_THE_HARDLINK="t" # here to skip some tests later
        fi
        #------------------------------------------------------------------
        #func_mmmv_wait_and_sync_t1 # inlined at the next 2 lines
        wait # for background processes started by this Bash script to exit/finish
        sync # USB-sticks, etc.
        wait # for sync
        #------------------------------------------------------------------
        if [ "$SB_DO_NOT_CREATE_THE_HARDLINK" == "f" ]; then
            #--------------------------------------------------------------
            S_TMP_0="f" # "t" --- potential error condition detected
                        # "f" --- no error detected
            #--------------------------------------------------------------
            if [ -h "$S_FP_TARGET" ]; then
                # A broken symlink, including a hardlink to a broken symlink
                # gives "false" with the Bash "-e".
                if [ ! -h "$S_FP_LINK" ]; then
                    echo ""
                    echo "Problem detection branch marker "
                    echo "GUID=='25dd51d3-1e18-4dca-85aa-d1c0004128e7'"
                    echo ""
                    S_TMP_0="t"
                else
                    if [ -e "$S_FP_TARGET" ]; then # symlink to a folder or a file
                        if [ ! -e "$S_FP_LINK" ]; then
                            echo ""
                            echo "Problem detection branch marker "
                            echo "GUID=='fdffe3d4-c283-436b-939a-d1c0004128e7'"
                            echo ""
                            S_TMP_0="t"
                        else
                            if [ -d "$S_FP_TARGET" ]; then
                                if [ ! -d "$S_FP_LINK" ]; then
                                    echo ""
                                    echo "Problem detection branch marker "
                                    echo "GUID=='67ef2c3f-af84-4821-959a-d1c0004128e7'"
                                    echo ""
                                    S_TMP_0="t"
                                fi
                            else
                                if [ -d "$S_FP_LINK" ]; then
                                    echo ""
                                    echo "Problem detection branch marker "
                                    echo "GUID=='16c8182a-d005-46ef-819a-d1c0004128e7'"
                                    echo ""
                                    S_TMP_0="t"
                                fi
                            fi
                        fi
                    else # broken symlink
                        if [ -e "$S_FP_LINK" ]; then
                            echo ""
                            echo "Problem detection branch marker "
                            echo "GUID=='562096a0-c9af-4ff1-929a-d1c0004128e7'"
                            echo ""
                            S_TMP_0="t"
                        fi
                    fi
                fi
            else # As the S_FP_LINK can never be a hardlink to a folder and
                 # the S_FP_TARGET is not a symlink at this branch, the 
                 # S_FP_TARGET is a file. Therefore at this branch 
                 # the S_FP_LINK is also a file.
                if [ ! -e "$S_FP_TARGET" ]; then # just an extra test
                    echo ""
                    echo "Problem detection branch marker "
                    echo "GUID=='10748e54-e837-4564-969a-d1c0004128e7'"
                    echo ""
                    S_TMP_0="t"
                else
                    if [ -d "$S_FP_TARGET" ]; then # just an extra test
                        echo ""
                        echo "Problem detection branch marker "
                        echo "GUID=='57238ad1-9717-4924-b18a-d1c0004128e7'"
                        echo ""
                        S_TMP_0="t"
                    else
                        if [ -h "$S_FP_LINK" ]; then
                            echo ""
                            echo "Problem detection branch marker "
                            echo "GUID=='e2ca6124-7faf-4b75-948a-d1c0004128e7'"
                            echo ""
                            S_TMP_0="t"
                        else
                            if [ ! -e "$S_FP_LINK" ]; then
                                echo ""
                                echo "Problem detection branch marker "
                                echo "GUID=='3dd1e3c3-0776-41b8-b48a-d1c0004128e7'"
                                echo ""
                                S_TMP_0="t"
                            else
                                if [ -d "$S_FP_LINK" ]; then
                                    echo ""
                                    echo "Problem detection branch marker "
                                    echo "GUID=='f4be203d-fddc-47b5-b38a-d1c0004128e7'"
                                    echo ""
                                    S_TMP_0="t"
                                fi
                            fi
                        fi
                    fi
                fi
            fi
            #--------------------------------------------------------------
            if [ "$S_TMP_0" == "t" ]; then
                echo ""
                echo "The creation of a hardlink with the path of "
                echo ""
                echo "    $S_FP_LINK "
                echo ""
                echo "and the target path of "
                echo ""
                echo "    $S_FP_TARGET"
                echo ""
                echo "might have succeeded, but did not go as expected."
                echo "The ln command succeeded, but there might have been "
                echo "some other operating system processes that altered some "
                echo "related files or folders or symlinks on disk before "
                echo "this Bash function could exit. One possible debugging "
                echo "idea is that it is possible to chain symlinks "
                echo "together by making a symlink to symlink that references "
                echo "a symlink that references "
                echo "a symlink that references "
                echo "a symlink that references "
                echo "a symlink that references ..."
                echo "and the operating system processes might have "
                echo "altered any of the symlinks in the chain, including "
                echo "the file or folder at the very end of the symlink chain."
                echo "GUID=='9ef4f4bc-4f3c-459d-938a-d1c0004128e7'"
                echo ""
                if [ "$SB_THROW_ON_INVALID_DATA" == "t" ]; then
                    exit 1
                fi
            else
                if [ "$S_TMP_0" != "f" ]; then
                    echo ""
                    echo -e "\e[31mThe implementation of this function is flawed. \e[39m"
                    echo "Aborting script."
                    echo "GUID=='1765e232-9ffe-45d9-b47a-d1c0004128e7'"
                    echo ""
                    exit 1
                fi
            fi
            #--------------------------------------------------------------
        fi
        #------------------------------------------------------------------
    else
        if [ "$SB_DO_NOT_CREATE_THE_HARDLINK" != "t" ]; then
            echo ""
            echo -e "\e[31mThe implementation of this function is flawed. \e[39m"
            echo "Aborting script."
            echo "GUID=='c1eea33a-1ea6-49b1-927a-d1c0004128e7'"
            echo ""
            exit 1
        fi
    fi
} # func_mmmv_ln_create_hardlink_t1

#--------------------------------------------------------------------------

func_mmmv_assert_environment_variable_set_t1() { 
    local S_ENVIRONMENT_VARIABLE_NAME="$1"
    local S_GUID_CANDIDATE="$2" 
    local S_OPTIONAL_ERR_MSG="$3" # will be appended to failure-message
    #----------------------------------------------------------------------
    local S_ENVIR_VALUE=""
    local S_SCRIPT_0="S_ENVIR_VALUE=\"\`echo \\\"\$$S_ENVIRONMENT_VARIABLE_NAME\\\" \`\""
    eval "$S_SCRIPT_0"
    if [ "$S_ENVIR_VALUE" == "" ]; then
        echo ""
        echo "The environment variable $S_ENVIRONMENT_VARIABLE_NAME is "
        echo -e "\e[31meither not set or it has the value of an empty string\e[39m."
        if [ "$S_OPTIONAL_ERR_MSG" != "" ]; then
            printf "%b" "$S_OPTIONAL_ERR_MSG"
        fi
        if [ "$S_GUID_CANDIDATE" != "" ]; then
            echo "S_GUID_CANDIDATE=='$S_GUID_CANDIDATE'"
        fi 
        echo "GUID=='cec4e6b7-d34a-4214-827a-d1c0004128e7'"
        echo ""
        exit 1 # exit with an error
    #else 
         # echo "S_ENVIR_VALUE==\"$S_ENVIR_VALUE\""
    fi
} # func_mmmv_assert_environment_variable_set_t1

#--------------------------------------------------------------------------

func_mmmv_ar_ls_t1() { # S_ARRAY_VARIABLE_NAME S_FP_LS
    local S_ARRAY_VARIABLE_NAME="$1"
    local S_FP_LS="$2"
    #----------------------------------------------------------------------
    # The "ls -m " works on both, BSD and Linux.
    local AR_0=$( ls -m $S_FP_LS )
    #--------
    local S_SCRIPT_0="$S_ARRAY_VARIABLE_NAME=()"
    eval "$S_SCRIPT_0"
    local S_ITER=""
    S_SCRIPT_0="$S_ARRAY_VARIABLE_NAME+=(\$S_ITER)"
    local S_TMP_IFS="$IFS"
    # The IFS is an internal Bash variable, "Internal Field Separator".
    IFS="," # That should handle file names that contain spaces.
    for ((i = 0; i < ${#AR_0[@]}; i++)) do
        S_ITER="${AR_0[$i]}"
        eval "$S_SCRIPT_0"
    done
    IFS="$S_TMP_IFS"
    if [ -z "$IFS" ]; then  # The "-z" returns true, if the string length is zero.
        unset IFS
    fi
} # func_mmmv_ar_ls_t1

# Test/demo code:
#    func_mmmv_ar_ls_t1 "AR_X" "$HOME"
# 
#    AR_2=${AR_X[@]}  # flawed array assignment that tokenizes by space
#    S_TMP=${#AR_X[@]}
#    echo "AR_X length: $S_TMP"
#    echo ""
#    for s_iter in ${AR_X[@]}; do
#         echo "AR_X element:[$s_iter]" 
#    done
#
#--------------------------------------------------------------------------

func_mmmv_exec_with_every_ar_element_t1() { # S_CMD_PART_0  S_ARRAY_VARIABLE_NAME_OF_AR_S_CMD_PART_1 S_CMD_PART_2
    local S_CMD_PART_0="$1"
    local S_ARRAY_VARIABLE_NAME_OF_AR_S_CMD_PART_1="$2"
    local S_CMD_PART_2="$3"
    #----------------------------------------------------------------------
    local S_SCRIPT_0=""
    local S_SCRIPT_1=""
    local S_SCRIPT_2=""
    local S_SCRIPT_x0=""
    local S_SCRIPT_x1=""
    local S_SCRIPT_x2=""
    #----------------
    # Wastefully left uncommented to detect flaws and to make life more comfortable :-)
    local S_TMP=""
    S_SCRIPT_0="S_TMP=\${#"
    S_SCRIPT_1="$S_ARRAY_VARIABLE_NAME_OF_AR_S_CMD_PART_1"
    S_SCRIPT_2="[@]}"
    eval "$S_SCRIPT_0$S_SCRIPT_1$S_SCRIPT_2" 
    #echo "The length of the $S_ARRAY_VARIABLE_NAME_OF_AR_S_CMD_PART_1 is: $S_TMP"
    #----------------
    # The newline trick 
    local S_NEWLINE=$'\n'
    # originates from the answer of Gordon Davisson:
    # https://stackoverflow.com/questions/17821277/how-to-separate-multiple-commands-passed-to-eval-in-bash
    # archival copy: https://archive.fo/7XI3a 
    #--------
    local S_ITER=""
    S_SCRIPT_0="for S_ITER in \${$S_ARRAY_VARIABLE_NAME_OF_AR_S_CMD_PART_1[@]}; do " 
    S_SCRIPT_x0="echo \"\"; echo \"\$S_ITER\""
    #S_SCRIPT_1="echo \"\$S_ITER\" " 
    S_SCRIPT_1="$S_CMD_PART_0 \$S_ITER  $S_CMD_PART_2 ;" 
    S_SCRIPT_x1="echo \"\""
    S_SCRIPT_2="done"
    S_SCRIPT_x2=""
    #----
    local S_TMP_0="$S_SCRIPT_0$S_NEWLINE$S_SCRIPT_x0$S_NEWLINE"
    local S_TMP_1="$S_SCRIPT_1$S_NEWLINE$S_SCRIPT_x1$S_NEWLINE"
    local S_TMP_2="$S_SCRIPT_2$S_NEWLINE$S_SCRIPT_x2$S_NEWLINE"
    eval "$S_TMP_0$S_TMP_1$S_TMP_2"
} # func_mmmv_exec_with_every_ar_element_t1

#--------------------------------------------------------------------------

func_mmmv_ar_range_t1() { #S_ARRAY_VARIABLE_NAME I_MINIMUM_INDEX I_MAXIMUM_INDEX
    local S_ARRAY_VARIABLE_NAME="$1"
    local I_MIN=$2
    local I_MAX_PLUS_ONE=`expr $3 + 1`
    #----------------------------------------------------------------------
    local S_SCRIPT_0="$S_ARRAY_VARIABLE_NAME=()"
    eval "$S_SCRIPT_0"
    local i_n=""
    S_SCRIPT_0="$S_ARRAY_VARIABLE_NAME+=(\$i_n)"
    for ((i_n=$I_MIN;i_n<$I_MAX_PLUS_ONE;i_n++))
    do
        eval "$S_SCRIPT_0"
    done
} # func_mmmv_ar_range_t1

# # Test/demo code:
# 
#     AR_A_GLOBAL_VARIABLE=()
#     S_TMP="9"
#     func_mmmv_ar_range_t1 "AR_A_GLOBAL_VARIABLE" 4 $S_TMP
#     for ((i = 0; i < ${#AR_A_GLOBAL_VARIABLE[@]}; i++)) do
#         S_ITER="${AR_A_GLOBAL_VARIABLE[$i]}"
#         echo "s_iter==[$S_ITER]"
#     done

#--------------------------------------------------------------------------

func_mmmv_create_array_t1() {
    local ARRR=()
    #------- 
    ARRR+=("first value as string")
    ARRR+=("second value as string") 
    ARRR+=("third value as string")
    ARRR+=("fourth value as string")
    #------- 
    export ARRR_sz=`declare -p ARRR`
} # func_mmmv_create_array_t1

#--------------------------------------------------------------------------

func_mmmv_iterate_over_array_02n_t1() {
    local S_ARRAY_VARIABLE_NAME="$1" 
    local S_ARRAY_SERIALIZED="$2" # `declare -p VARIABLENAME` or an empty string
    local S_ITERATION_FUNCTION_NAME="$3" # that accepts "$s_iter" as a parameter
    #----------------------------------------------------------------------
    func_mmmv_exc_verify_S_FP_ORIG_t2
    if [ "$S_ARRAY_VARIABLE_NAME" == "" ]; then
        echo ""
        echo -e "\e[31mS_ARRAY_VARIABLE_NAME\e[39m is not allowed to be an empty string."
        echo "GUID=='c2d7bf42-c25b-4105-a57a-d1c0004128e7'"
        echo ""
        #--------
        cd "$S_FP_ORIG"
        exit 1
    fi
    #----------------------------------------------------------------------
    if [ "$S_ITERATION_FUNCTION_NAME" == "" ]; then
        echo ""
        echo -e "\e[31mS_ITERATION_FUNCTION_NAME\e[39m is not allowed to be an empty string."
        echo "GUID=='035bd522-5a9d-4887-b17a-d1c0004128e7'"
        echo ""
        #--------
        cd "$S_FP_ORIG"
        exit 1
    fi
    #----------------------------------------------------------------------
    eval ${S_ARRAY_SERIALIZED}
    #-------
    local S_SCRIPT_0="local S_LEN=\${#$S_ARRAY_VARIABLE_NAME[@]}"
    eval ${S_SCRIPT_0}
    #echo "ARRR length: $S_LEN"
    local I_MAX=`expr $S_LEN + 0`
    #-------
    local i_n=42
    local s_iter=""
    local S_SCRIPT_LINE_1="for ((i_n=0;i_n<\$I_MAX;i_n++))"
    local S_SCRIPT_LINE_2="s_iter=\${$S_ARRAY_VARIABLE_NAME[\$i_n]}"
    local S_SCRIPT_LINE_3="$S_ITERATION_FUNCTION_NAME \"\$s_iter\""
    S_SCRIPT_0="$S_SCRIPT_LINE_1 "$'\n'"do"$'\n'"$S_SCRIPT_LINE_2 "$'\n'"$S_SCRIPT_LINE_3 "$'\n'"done"
    #echo "$S_SCRIPT_0"
    eval "$S_SCRIPT_0"
} # func_mmmv_iterate_over_array_02n_t1

# Test/demo code:
#     func_iter() {
#         local S_ITER="$1"
#         echo "Greetings from func_iter: $S_ITER"
#     } # func_iter
#     
#     func_mmmv_create_array_t1
#     func_mmmv_iterate_over_array_02n_t1 "ARRR" "$ARRR_sz" "func_iter"
#--------------------------------------------------------------------------

func_mmmv_sb_head_exists_t1() { # S_OUTPUT_VARIABLE_NAME, S_HEAD_REGEX , S_HAYSTACK
    local S_OUTPUT_VARIABLE_NAME="$1"
    local S_HEAD_REGEX="$2"
    local S_HAYSTACK="$3"
    #----------------------------------------------------------------------
    local S_SCRIPT_0="$S_OUTPUT_VARIABLE_NAME=\"f\""
    eval "$S_SCRIPT_0"
    local S_NUMBER_OF_MATCHING_CHARACTERS=`expr match "$S_HAYSTACK" "$S_HEAD_REGEX"`
    if [ "$S_NUMBER_OF_MATCHING_CHARACTERS" != "0" ]; then
        S_SCRIPT_0="$S_OUTPUT_VARIABLE_NAME=\"t\""
        eval "$S_SCRIPT_0"
    fi
} # func_mmmv_sb_head_exists_t1 

# Test/demo code:
#     S_RGX="/home/ts2/tmp"
#     S_FP="/home/ts2/tmp/uuuuu/eee"
#     
#     func_mmmv_sb_head_exists_t1 "S_CC" $S_RGX $S_FP
#     echo "S_CC: $S_CC"
#--------------------------------------------------------------------------

func_mmmv_include_bashfile_if_possible_t1(){ # S_FP_BASHFILE S_GUID_CANDIDATE SB_THROW_ON_ERROR
    local S_FP_BASHFILE="$1" # Full path to the file   
    local S_GUID_CANDIDATE="$2" 
    local SB_THROW_ON_ERROR="$3" # ~/.bashrc must not call the "exit" command.
                                 # If the SB_THROW_ON_ERROR=="t", the 
                                 # "exit" command can be called in case of error.
                                 # If the SB_THROW_ON_ERROR=="f", the 
                                 # "exit" command will not be called, 
                                 # only an error message is printed to console.
                                 # default: "f"
    #----------------------------------------------------------------------
    if [ "$SB_THROW_ON_ERROR" == "" ]; then
        SB_THROW_ON_ERROR="f" # the default value
    else
        if [ "$SB_THROW_ON_ERROR" != "t" ]; then
            if [ "$SB_THROW_ON_ERROR" != "f" ]; then
                echo ""
                echo "The SB_THROW_ON_ERROR(==$SB_THROW_ON_ERROR)"
                echo -e "\e[31mhas a wrong vaue\e[39m. Only \"t\" and \"f\" are allowed."
                if [ "$S_GUID_CANDIDATE" != "" ]; then
                    echo "S_GUID_CANDIDATE=='$S_GUID_CANDIDATE'"
                fi 
                echo "GUID=='30ea0a54-3588-4abd-926a-d1c0004128e7'"
                echo ""
            fi
        fi
    fi
    #-----------------------------------------
    local SB_INCLUSION_POSSIBLE="t"
    if [ "$S_FP_BASHFILE" == "" ]; then
        SB_INCLUSION_POSSIBLE="f"
        echo ""
        echo -e "The S_FP_BASHFILE \e[31mhad a value of an empty string\e[39m."
        if [ "$S_GUID_CANDIDATE" != "" ]; then
            echo "S_GUID_CANDIDATE=='$S_GUID_CANDIDATE'"
        fi 
        echo "GUID=='80d0781f-5399-41b6-b36a-d1c0004128e7'"
        echo ""
        if [ "$SB_THROW_ON_ERROR" == "t" ]; then
            exit 1
        fi
    fi
    #-----------------------------------------
    if [ "$SB_INCLUSION_POSSIBLE" == "t" ]; then
        if [ ! -e "$S_FP_BASHFILE" ]; then
            SB_INCLUSION_POSSIBLE="f"
            echo ""
            echo "The "
            echo ""
            echo "    $S_FP_BASHFILE"
            echo ""
            echo -e "\e[31mdoes not exist or it is a broken symlink\e[39m."
            if [ "$S_GUID_CANDIDATE" != "" ]; then
                echo "S_GUID_CANDIDATE=='$S_GUID_CANDIDATE'"
            fi 
            echo "GUID=='7fa94c20-3969-43a6-a26a-d1c0004128e7'"
            echo ""
            if [ "$SB_THROW_ON_ERROR" == "t" ]; then
                exit 1
            fi
        fi
    fi
    #-----------------------------------------
    if [ "$SB_INCLUSION_POSSIBLE" == "t" ]; then
        if [ -d "$S_FP_BASHFILE" ]; then
            SB_INCLUSION_POSSIBLE="f"
            echo ""
            echo "The "
            echo ""
            echo "    $S_FP_BASHFILE"
            echo ""
            echo -e "\e[31mreferences a folder\e[39m, but it must reference a file."
            if [ "$S_GUID_CANDIDATE" != "" ]; then
                echo "S_GUID_CANDIDATE=='$S_GUID_CANDIDATE'"
            fi 
            echo "GUID=='d87b9733-24fc-4958-af6a-d1c0004128e7'"
            echo ""
            if [ "$SB_THROW_ON_ERROR" == "t" ]; then
                exit 1
            fi
        fi
    fi
    #----------------------------------------------------------------------
    if [ "$SB_INCLUSION_POSSIBLE" == "t" ]; then
        source "$S_FP_BASHFILE"
    else
        if [ "$SB_INCLUSION_POSSIBLE" != "f" ]; then
            echo ""
            echo -e "\e[31mThe implementation of this function is flawed. \e[39m"
            echo "SB_INCLUSION_POSSIBLE==$SB_INCLUSION_POSSIBLE"
            if [ "$S_GUID_CANDIDATE" != "" ]; then
                echo "S_GUID_CANDIDATE=='$S_GUID_CANDIDATE'"
            fi 
            echo "GUID=='5fd5963f-7bfe-4c90-b15a-d1c0004128e7'"
            echo ""
            if [ "$SB_THROW_ON_ERROR" == "t" ]; then
                exit 1 
            fi
        fi
    fi
} # func_mmmv_include_bashfile_if_possible_t1

#--------------------------------------------------------------------------

func_mmmv_include_bashfile_if_possible_t2(){ # S_FP_BASHFILE S_GUID_CANDIDATE 
    local S_FP_BASHFILE="$1" # Full path to the file   
    local S_GUID_CANDIDATE="$2" 
    #----------------------------------------------------------------------
    # ~/.bashrc must not call the "exit" command.
    #-----------------------------------------
    local SB_INCLUSION_POSSIBLE="t"
    if [ "$S_FP_BASHFILE" == "" ]; then
        SB_INCLUSION_POSSIBLE="f"
        echo ""
        echo -e "The S_FP_BASHFILE \e[31mhad a value of an empty string\e[39m."
        if [ "$S_GUID_CANDIDATE" != "" ]; then
            echo "S_GUID_CANDIDATE=='$S_GUID_CANDIDATE'"
        fi 
        echo "GUID=='816e6144-ab7f-46f7-835a-d1c0004128e7'"
        echo ""
    fi
    #-----------------------------------------
    if [ "$SB_INCLUSION_POSSIBLE" == "t" ]; then
        if [ ! -e "$S_FP_BASHFILE" ]; then
            SB_INCLUSION_POSSIBLE="f"
            echo ""
            echo "The "
            echo ""
            echo "    $S_FP_BASHFILE"
            echo ""
            echo -e "\e[31mdoes not exist or it is a broken symlink\e[39m."
            if [ "$S_GUID_CANDIDATE" != "" ]; then
                echo "S_GUID_CANDIDATE=='$S_GUID_CANDIDATE'"
            fi 
            echo "GUID=='b0453d31-2aaf-4775-a45a-d1c0004128e7'"
            echo ""
        fi
    fi
    #-----------------------------------------
    if [ "$SB_INCLUSION_POSSIBLE" == "t" ]; then
        if [ -d "$S_FP_BASHFILE" ]; then
            SB_INCLUSION_POSSIBLE="f"
            echo ""
            echo "The "
            echo ""
            echo "    $S_FP_BASHFILE"
            echo ""
            echo -e "\e[31mreferences a folder\e[39m, but it must reference a file."
            if [ "$S_GUID_CANDIDATE" != "" ]; then
                echo "S_GUID_CANDIDATE=='$S_GUID_CANDIDATE'"
            fi 
            echo "GUID=='0c868229-0881-4f37-b45a-d1c0004128e7'"
            echo ""
        fi
    fi
    #----------------------------------------------------------------------
    if [ "$SB_INCLUSION_POSSIBLE" == "t" ]; then
        source "$S_FP_BASHFILE"
        func_mmmv_wait_and_sync_t1
        S_FP_DIR="$( cd "$( dirname "${BASH_SOURCE[0]}" )" && pwd )" # to restore its value
    else
        if [ "$SB_INCLUSION_POSSIBLE" != "f" ]; then
            echo ""
            echo -e "\e[31mThe implementation of this function is flawed. \e[39m"
            echo "SB_INCLUSION_POSSIBLE==$SB_INCLUSION_POSSIBLE"
            if [ "$S_GUID_CANDIDATE" != "" ]; then
                echo "S_GUID_CANDIDATE=='$S_GUID_CANDIDATE'"
            fi 
            echo "GUID=='70e6882f-f7cb-419a-b34a-d1c0004128e7'"
            echo ""
        fi
    fi
} # func_mmmv_include_bashfile_if_possible_t2

#--------------------------------------------------------------------------

func_mmmv_assert_exists_on_path_t1() {
    local S_NAME_OF_THE_EXECUTABLE="$1" # first function argument
    #----------------------------------------------------------------------
    func_mmmv_exc_verify_S_FP_ORIG_t2
    local S_TMP_0="\`which $S_NAME_OF_THE_EXECUTABLE 2> /dev/null\`"
    local S_TMP_1=""
    local S_TMP_2="S_TMP_1=$S_TMP_0"
    eval ${S_TMP_2}
    if [ "$S_TMP_1" == "" ]; then
        S_TMP_0="This bash script requires the \""
        S_TMP_1="\" to be on the PATH."
        #--------
        echo ""
        echo -e "$S_TMP_0\e[31m$S_NAME_OF_THE_EXECUTABLE\e[39m$S_TMP_1"
        echo "GUID=='945e5053-e38e-4eee-954a-d1c0004128e7'"
        echo ""
        cd "$S_FP_ORIG"
        exit 1 # exit with an error
    fi
} # func_mmmv_assert_exists_on_path_t1

# Test/demo code:
#     func_mmmv_assert_exists_on_path_t1 "ruby"
#     func_mmmv_assert_exists_on_path_t1 "rubyy"
#--------------------------------------------------------------------------

func_mmmv_ln_create_or_overwrite_symlink_t1() { # S_FP_TARGET  S_FP_LINK
    local S_FP_TARGET="$1"
    local S_FP_LINK="$2"
    #----------------------------------------------------------------------
    local S_CMD_LN="ln -s $S_FP_TARGET $S_FP_LINK "
    local SB_DELETE_OLD_LINK="f"
    if [ -e "$S_FP_LINK" ]; then
        if [ ! -h "$S_FP_LINK" ]; then # not a symlink
            echo ""
            echo "The "
            echo ""
            echo -e "\e[31m    $S_FP_LINK \e[39m"
            echo ""
            echo -e "is \e[31mnot a symlink \e[39m, but if that path is in use at all, "
            echo "then only a symlink is allowed."
            echo ""
            echo "PWD==`pwd`"
            echo "GUID=='2678e133-e727-414a-bc4a-d1c0004128e7'"
            echo ""
            exit 1 # exit with an error
        fi
        # At this line the old S_FP_LINK is a nonbroken symlink.
        local S_FP_OLDTARGET="`readlink $S_FP_LINK`"
        if [ "$S_FP_OLDTARGET" != "$S_FP_TARGET" ]; then
            # No need to wear Flash memory if the 
            # new symlink name and target match with 
            # the old symlink name and target.
            SB_DELETE_OLD_LINK="t"
        fi
    else
        if [ -h "$S_FP_LINK" ]; then # a broken symlink
            SB_DELETE_OLD_LINK="t"
        fi
    fi
    #----------------------------------------------------------------------
    if [ "$SB_DELETE_OLD_LINK" == "t" ]; then
        rm -f $S_FP_LINK
        func_mmmv_assert_error_code_zero_t1 "$?" \
            "9dea8f4b-de8e-4af5-850c-d1c0004128e7"
        func_mmmv_wait_and_sync_t1
        if [ -e "$S_FP_LINK" ]; then
            echo ""
            echo ""
            echo -e "\e[31mFailed to delete  \e[39m"
            echo "an old symlink with the path of "
            echo ""
            echo -e "\e[36m    $S_FP_LINK \e[39m"
            echo ""
            echo "PWD==`pwd`"
            echo "GUID=='44210d36-cc72-4abe-a24a-d1c0004128e7'"
            echo ""
            echo ""
            exit 1 # exit with an error
        fi
    fi
    #----------------------------------------------------------------------
    $S_CMD_LN
    func_mmmv_assert_error_code_zero_t1 "$?" \
        "16734a17-590e-4df8-810c-d1c0004128e7"
    func_mmmv_wait_and_sync_t1
    if [ ! -e "$S_FP_LINK" ]; then
        echo ""
        echo ""
        echo -e "\e[31mSymlink creation failed.  \e[39m"
        echo "Could not create a symlink with the path of:"
        echo ""
        echo -e "\e[36m    $S_CMD_LN \e[39m"
        echo ""
        echo "PWD==`pwd`"
        echo "GUID=='8c99dba3-7fbd-45f5-a14a-d1c0004128e7'"
        echo ""
        echo ""
        exit 1 # exit with an error
    fi
    #----------------------------------------------------------------------
} # func_mmmv_ln_create_or_overwrite_symlink_t1

#--------------------------------------------------------------------------

func_mmmv_operatingsystem_is_Linux() { # S_OUTPUT_VARIABLE_NAME
    local S_OUTPUT_VARIABLE_NAME="$1"
    #----------------------------------------------------------------------
    local S_OUT="f"
    local S_X="`uname -a | grep -l Linux `"
    if [ "$S_X" != "" ]; then
        S_OUT="t"
    fi
    local S_SCRIPT_0="$S_OUTPUT_VARIABLE_NAME=\"$S_OUT\""
    eval ${S_SCRIPT_0}
    # echo "ANSWER: $S_OUT"
} # func_mmmv_operatingsystem_is_Linux

#--------------------------------------------------------------------------

func_mmmv_operatingsystem_is_FreeBSD() { # S_OUTPUT_VARIABLE_NAME
    local S_OUTPUT_VARIABLE_NAME="$1"
    #----------------------------------------------------------------------
    local S_OUT="f"
    local S_X="`uname -a | grep -l FreeBSD`"
    if [ "$S_X" != "" ]; then
        S_OUT="t"
    fi
    local S_SCRIPT_0="$S_OUTPUT_VARIABLE_NAME=\"$S_OUT\""
    eval ${S_SCRIPT_0}
    # echo "ANSWER: $S_OUT"
} # func_mmmv_operatingsystem_is_FreeBSD

#--------------------------------------------------------------------------

func_mmmv_operatingsystem_is_NetBSD() { # S_OUTPUT_VARIABLE_NAME
    local S_OUTPUT_VARIABLE_NAME="$1"
    #----------------------------------------------------------------------
    local S_OUT="f"
    local S_X="`uname -a | grep -l NetBSD`"
    if [ "$S_X" != "" ]; then
        S_OUT="t"
    fi
    local S_SCRIPT_0="$S_OUTPUT_VARIABLE_NAME=\"$S_OUT\""
    eval ${S_SCRIPT_0}
    # echo "ANSWER: $S_OUT"
} # func_mmmv_operatingsystem_is_NetBSD

#--------------------------------------------------------------------------

func_mmmv_operatingsystem_is_OpenBSD() { # S_OUTPUT_VARIABLE_NAME
    local S_OUTPUT_VARIABLE_NAME="$1"
    #----------------------------------------------------------------------
    local S_OUT="f"
    local S_X="`uname -a | grep -l OpenBSD`"
    if [ "$S_X" != "" ]; then
        S_OUT="t"
    fi
    local S_SCRIPT_0="$S_OUTPUT_VARIABLE_NAME=\"$S_OUT\""
    eval ${S_SCRIPT_0}
    # echo "ANSWER: $S_OUT"
} # func_mmmv_operatingsystem_is_OpenBSD

#--------------------------------------------------------------------------

func_mmmv_operatingsystem_is_BSD() { # S_OUTPUT_VARIABLE_NAME
    local S_OUTPUT_VARIABLE_NAME="$1"
    #----------------------------------------------------------------------
    local S_OUT="f"
    local SB_TMP_0_orig="$SB_TMP_0"
    #----------------------------------------------------------------------
    func_mmmv_operatingsystem_is_FreeBSD "SB_TMP_0"
    S_OUT="$SB_TMP_0"
    if [ "$S_OUT" == "f" ]; then
        func_mmmv_operatingsystem_is_NetBSD "SB_TMP_0"
        S_OUT="$SB_TMP_0"
        if [ "$S_OUT" == "f" ]; then
            func_mmmv_operatingsystem_is_OpenBSD "SB_TMP_0"
            S_OUT="$SB_TMP_0"
        fi
    fi
    #----------------------------------------------------------------------
    export SB_TMP_0="$SB_TMP_0_orig"
    local S_SCRIPT_0="$S_OUTPUT_VARIABLE_NAME=\"$S_OUT\""
    eval ${S_SCRIPT_0}
    # echo "ANSWER: $S_OUT"
    #----------------------------------------------------------------------
} # func_mmmv_operatingsystem_is_BSD

#--------------------------------------------------------------------------

func_mmmv_operatingsystem_is_macOS() { # S_OUTPUT_VARIABLE_NAME
    local S_OUTPUT_VARIABLE_NAME="$1"
    #----------------------------------------------------------------------
    local S_OUT="f"
    local S_X="`uname -a | grep -i 'Darwin' | grep -i 'Kernel' `"
    if [ "$S_X" != "" ]; then
        S_OUT="t"
    fi
    local S_SCRIPT_0="$S_OUTPUT_VARIABLE_NAME=\"$S_OUT\""
    eval ${S_SCRIPT_0}
    # echo "ANSWER: $S_OUT"
} # func_mmmv_operatingsystem_is_macOS

#--------------------------------------------------------------------------

# Sets the global environment variable S_MMMV_OPERATING_SYSTEM
func_mmmv_determine_operatingsystem_t1() {
    local SB_AVOID_REINITIALISATION_IF_ALREADY_INITIALIZED="$1" # domain: {"","t","f"}
                                                                # default: "t"
                                                                # "" -> "t"
    #----------------------------------------------------------------------
    local SB_REUSE_EXISTING_VALUE="f" # may be there is no old value to use
    local SB_RE_EX_VA_IF_PO_NORMALISED="$SB_AVOID_REINITIALISATION_IF_ALREADY_INITIALIZED"
    if [ "$SB_AVOID_REINITIALISATION_IF_ALREADY_INITIALIZED" == "" ]; then
        SB_RE_EX_VA_IF_PO_NORMALISED="t"
    else
        func_mmmv_assert_sbvar_domain_t_f_t1 \
            "$SB_AVOID_REINITIALISATION_IF_ALREADY_INITIALIZED" \
            "SB_AVOID_REINITIALISATION_IF_ALREADY_INITIALIZED" \
            "504b3253-90d5-4170-b10c-d1c0004128e7" 
    fi
    if [ "$SB_RE_EX_VA_IF_PO_NORMALISED" == "t" ]; then
        if [ "$S_MMMV_OPERATING_SYSTEM" != "" ]; then
            SB_REUSE_EXISTING_VALUE="t"
        fi
    fi
    #----------------------------------------------------------------------
    local SB_TMP_0_orig="$SB_TMP_0"
    if [ "$SB_REUSE_EXISTING_VALUE" == "f" ]; then
        #------------------------------------------------------------------
        func_mmmv_operatingsystem_is_Linux "SB_TMP_0"
        if [ "$SB_TMP_0" == "t" ]; then
            export S_MMMV_OPERATING_SYSTEM="linux"
        else
            func_mmmv_operatingsystem_is_BSD "SB_TMP_0"
            if [ "$SB_TMP_0" == "t" ]; then
                export S_MMMV_OPERATING_SYSTEM="bsd"
            else
                func_mmmv_operatingsystem_is_macOS "SB_TMP_0"
                if [ "$SB_TMP_0" == "t" ]; then
                    export S_MMMV_OPERATING_SYSTEM="macos"
                else
                    export S_MMMV_OPERATING_SYSTEM="unrecognised_operating_system"
                fi
            fi
        fi
        #------------------------------------------------------------------
        export SB_TMP_0="$SB_TMP_0_orig"
        #------------------------------------------------------------------
    fi
    #----------------------------------------------------------------------
} # func_mmmv_determine_operatingsystem_t1

#--------------------------------------------------------------------------

func_mmmv_exit_if_environment_variable_not_set_t1() { # S_ENVIRONMENT_VARIABLE_NAME
    local S_ENVIRONMENT_VARIABLE_NAME="$1"
    local S_ENVIRONMENT_VARIABLE_DOCSTRING="$2" # will be appended to failure-message
    #----------------------------------------------------------------------
    local S_ENVIR_VALUE=""
    local S_SCRIPT_0="S_ENVIR_VALUE=\"\`echo \$$S_ENVIRONMENT_VARIABLE_NAME\`\""
    eval "$S_SCRIPT_0"
    if [ "$S_ENVIR_VALUE" == "" ]; then
        echo ""
        echo -e "The environment variable $S_ENVIRONMENT_VARIABLE_NAME \e[31mis not set\e[39m, but "
        echo "it must be set or this script will not run (properly)."
        if [ "$S_ENVIRONMENT_VARIABLE_DOCSTRING" != "" ]; then
            echo ""
            echo "$S_ENVIRONMENT_VARIABLE_DOCSTRING"
        fi
        echo ""
        exit 1;
    #else 
         # echo "S_ENVIR_VALUE==\"$S_ENVIR_VALUE\""
    fi
} # func_mmmv_exit_if_environment_variable_not_set_t1

# Test/demo code:
#     func_mmmv_exit_if_environment_variable_not_set_t1 "CFLAGS" 

#--------------------------------------------------------------------------

func_mmmv_assert_Linux_or_BSD_t1(){
    local S_GUID_CANDIDATE="$1"
    #----------------------------------------------------------------------
    func_mmmv_exc_verify_S_FP_ORIG_t2
    if [ "$S_GUID_CANDIDATE" == "" ]; then
        echo ""
        echo -e "\e[31mS_GUID_CANDIDATE==\"\", but it is expected to be a GUID. \e[39m"
        echo "GUID=='b224771c-0481-4827-a24a-d1c0004128e7'"
        echo ""
        # if [ "$S_FP_ORIG" != "" ]; then
        #     func_mmmv_exc_verify_S_FP_ORIG_t1
        #     cd "$S_FP_ORIG"
        # fi
        #--------
        cd "$S_FP_ORIG"
        exit 1 # exit with an error
    fi 
    #--------------------
    #S_TMP_0="`uname -a | grep -E \"([Ll][Ii][Nn][Uu][Xx]|[Bb][Ss][Dd]|[Cc][Yy][Gg][Ww][Ii][Nn])\"`"
    S_TMP_0="`uname -a | grep -E \"(([Ll][Ii][Nn][Uu][Xx]|[Bb][Ss][Dd])[ ])\"`"
    if [ "$S_TMP_0" == "" ]; then
        echo ""
        echo "The classical command line utilities at "
        echo "different operating systems, for example, Linux and BSD,"
        echo "differ. This script is designed to run only on Linux and BSD."
        echo "If You are willing to risk that some of Your data "
        echo "is deleted and/or Your operating system instance"
        echo "becomes permanently flawed, to the point that "
        echo "it will not even boot, then You may edit the Bash script that "
        echo "calls the function that displays this error message "
        echo "by uncommenting that function."
        echo ""
        echo "If You do decide to edit the Bash script, then "
        echo "a recommendation is to test Your modifications "
        echo "within a virtual appliance or, if virtual appliances are not"
        echo "an option, as some new operating system user that does not have "
        echo "any access to the vital data/files."
        echo ""
        echo "Aborting script without doing anything."
        echo ""
        echo "GUID=='d2071e35-0a1f-4cff-b43a-d1c0004128e7'"
        echo ""
        # if [ "$S_FP_ORIG" != "" ]; then
        #     func_mmmv_exc_verify_S_FP_ORIG_t1
        #     cd "$S_FP_ORIG"
        # fi
        #--------
        cd "$S_FP_ORIG"
        exit 1 # exit with an error
    fi
} # func_mmmv_assert_Linux_or_BSD_t1

#--------------------------------------------------------------------------

func_mmmv_verify_that_internet_connection_exists_but_do_not_exit_t1(){
    #----------------------------------------------------------------------
    local S_GUID_CANDIDATE="$1"
    local SB_DISPLAY_NONERROR_FEEDBACK="$2" # domain: {"t","f",""}
                                            # ""==="f", default "f"
    #----------------------------------------------------------------------
    if [ "$S_GUID_CANDIDATE" == "" ]; then
        echo ""
        echo -e "\e[31mThe Bash code that calls this function is flawed \e[39m."
        echo ""
        echo "    S_GUID_CANDIDATE==\"\""
        echo ""
        echo "but it is expected to be a GUID."
        echo "GUID=='5c29302f-c6d4-476c-813a-d1c0004128e7'"
        echo ""
    fi
    #----------------------------------------------------------------------
    if [ "$SB_DISPLAY_NONERROR_FEEDBACK" == "" ]; then
        SB_DISPLAY_NONERROR_FEEDBACK="f"
    else
        #----------------------------------------
        if [ "$SB_DISPLAY_NONERROR_FEEDBACK" != "t" ]; then
            if [ "$SB_DISPLAY_NONERROR_FEEDBACK" != "f" ]; then
                #----------------------------------------
                if [ "$S_GUID_CANDIDATE" != "" ]; then
                    func_mmmv_assert_sbvar_domain_t_f_but_do_not_exit_t1 \
                        "$SB_DISPLAY_NONERROR_FEEDBACK" \
                        "SB_DISPLAY_NONERROR_FEEDBACK" \
                        "$S_GUID_CANDIDATE"
                else
                    func_mmmv_assert_sbvar_domain_t_f_but_do_not_exit_t1 \
                        "$SB_DISPLAY_NONERROR_FEEDBACK" \
                        "SB_DISPLAY_NONERROR_FEEDBACK" \
                        "e6599b11-543f-45a7-95fb-d1c0004128e7"
                fi
                SB_DISPLAY_NONERROR_FEEDBACK="f"
                #----------------------------------------
            fi
        fi
        #----------------------------------------
    fi
    #----------------------------------------------------------------------
    func_mmmv_assert_exists_on_path_t1 "timeout"
    func_mmmv_assert_exists_on_path_t1 "ping"
    #----------------------------------------------------------------------
    # A global variable for storing function output.
    SB_VERIFICATION_FAILED="t" # domain: "t", "f" .
    #----------------------------------------
    local SB_DOMAIN_IS_REACHABLE="f"
    local S_CMD_PREFIX="timeout 3s nice -n 5 ping -c 30 "
    local SI_ERR_CODE="1" 
    #----------------------------------------------------------------------
    if [ "$SB_DISPLAY_NONERROR_FEEDBACK" == "t" ]; then
        echo "Testing, whether there is internet connectivity..."
    fi
    #----------------------------------------------------------------------
# RENESSAATOR_BLOCK_START
# RENESSAATOR_BLOCK_ID=block_e6295e62-4c0c-4fef-a19e-02f1e0f337e7_city
# RENESSAATOR_SOURCE_LANGUAGE=Ruby
# RENESSAATOR_SOURCE_START
# s=""
# s<<'    #----------------------------------------------------------------------'
# s<<"\n"
# s<<'    if [ "$SB_DOMAIN_IS_REACHABLE" == "f" ]; then '
# s<<"\n"
# s<<"        # The redirection to /dev/null at the next line \n"
# s<<'        timeout BLANK41s nice -n 5 ping -c 30 "BLANK42" 2> /dev/null 1> /dev/null '
# s<<"\n"
# s<<"        # has been tested to work on both, Linux and FreeBSD. \n"
# s<<'        SI_ERR_CODE="$?" ; wait ; '
# s<<"\n"
# s<<'        if [ "$SI_ERR_CODE" == "0" ]; then '
# s<<"\n"
# s<<'            SB_DOMAIN_IS_REACHABLE="t" '
# s<<"\n"
# s<<'        else '
# s<<"\n"
# s<<'            if [ "$SI_ERR_CODE" == "124" ]; then '
# s<<"\n"
# s<<'                SB_DOMAIN_IS_REACHABLE="t" '
# s<<"\n"
# s<<'            fi '
# s<<"\n"
# s<<'        fi '
# s<<"\n"
# s<<'    fi '
# s<<"\n"
# ar=["softf1.com", "softf1.net", "google.com", "bing.com", "ibm.com", "eesti.ee"]
# puts((""+s).sub(/BLANK41/,"1").sub(/BLANK42/,ar[0])) # to make the Bash script faster
# ar.each do |s_domain|
# puts((""+s).sub(/BLANK41/,"3").sub(/BLANK42/,s_domain))
# end # loop
# RENESSAATOR_SOURCE_END
# 
# RENESSAATOR_AUTOGENERATED_TEXT_START
    #----------------------------------------------------------------------
    if [ "$SB_DOMAIN_IS_REACHABLE" == "f" ]; then 
        # The redirection to /dev/null at the next line 
        timeout 1s nice -n 5 ping -c 30 "softf1.com" 2> /dev/null 1> /dev/null 
        # has been tested to work on both, Linux and FreeBSD. 
        SI_ERR_CODE="$?" ; wait ; 
        if [ "$SI_ERR_CODE" == "0" ]; then 
            SB_DOMAIN_IS_REACHABLE="t" 
        else 
            if [ "$SI_ERR_CODE" == "124" ]; then 
                SB_DOMAIN_IS_REACHABLE="t" 
            fi 
        fi 
    fi 
    #----------------------------------------------------------------------
    if [ "$SB_DOMAIN_IS_REACHABLE" == "f" ]; then 
        # The redirection to /dev/null at the next line 
        timeout 3s nice -n 5 ping -c 30 "softf1.com" 2> /dev/null 1> /dev/null 
        # has been tested to work on both, Linux and FreeBSD. 
        SI_ERR_CODE="$?" ; wait ; 
        if [ "$SI_ERR_CODE" == "0" ]; then 
            SB_DOMAIN_IS_REACHABLE="t" 
        else 
            if [ "$SI_ERR_CODE" == "124" ]; then 
                SB_DOMAIN_IS_REACHABLE="t" 
            fi 
        fi 
    fi 
    #----------------------------------------------------------------------
    if [ "$SB_DOMAIN_IS_REACHABLE" == "f" ]; then 
        # The redirection to /dev/null at the next line 
        timeout 3s nice -n 5 ping -c 30 "softf1.net" 2> /dev/null 1> /dev/null 
        # has been tested to work on both, Linux and FreeBSD. 
        SI_ERR_CODE="$?" ; wait ; 
        if [ "$SI_ERR_CODE" == "0" ]; then 
            SB_DOMAIN_IS_REACHABLE="t" 
        else 
            if [ "$SI_ERR_CODE" == "124" ]; then 
                SB_DOMAIN_IS_REACHABLE="t" 
            fi 
        fi 
    fi 
    #----------------------------------------------------------------------
    if [ "$SB_DOMAIN_IS_REACHABLE" == "f" ]; then 
        # The redirection to /dev/null at the next line 
        timeout 3s nice -n 5 ping -c 30 "google.com" 2> /dev/null 1> /dev/null 
        # has been tested to work on both, Linux and FreeBSD. 
        SI_ERR_CODE="$?" ; wait ; 
        if [ "$SI_ERR_CODE" == "0" ]; then 
            SB_DOMAIN_IS_REACHABLE="t" 
        else 
            if [ "$SI_ERR_CODE" == "124" ]; then 
                SB_DOMAIN_IS_REACHABLE="t" 
            fi 
        fi 
    fi 
    #----------------------------------------------------------------------
    if [ "$SB_DOMAIN_IS_REACHABLE" == "f" ]; then 
        # The redirection to /dev/null at the next line 
        timeout 3s nice -n 5 ping -c 30 "bing.com" 2> /dev/null 1> /dev/null 
        # has been tested to work on both, Linux and FreeBSD. 
        SI_ERR_CODE="$?" ; wait ; 
        if [ "$SI_ERR_CODE" == "0" ]; then 
            SB_DOMAIN_IS_REACHABLE="t" 
        else 
            if [ "$SI_ERR_CODE" == "124" ]; then 
                SB_DOMAIN_IS_REACHABLE="t" 
            fi 
        fi 
    fi 
    #----------------------------------------------------------------------
    if [ "$SB_DOMAIN_IS_REACHABLE" == "f" ]; then 
        # The redirection to /dev/null at the next line 
        timeout 3s nice -n 5 ping -c 30 "ibm.com" 2> /dev/null 1> /dev/null 
        # has been tested to work on both, Linux and FreeBSD. 
        SI_ERR_CODE="$?" ; wait ; 
        if [ "$SI_ERR_CODE" == "0" ]; then 
            SB_DOMAIN_IS_REACHABLE="t" 
        else 
            if [ "$SI_ERR_CODE" == "124" ]; then 
                SB_DOMAIN_IS_REACHABLE="t" 
            fi 
        fi 
    fi 
    #----------------------------------------------------------------------
    if [ "$SB_DOMAIN_IS_REACHABLE" == "f" ]; then 
        # The redirection to /dev/null at the next line 
        timeout 3s nice -n 5 ping -c 30 "eesti.ee" 2> /dev/null 1> /dev/null 
        # has been tested to work on both, Linux and FreeBSD. 
        SI_ERR_CODE="$?" ; wait ; 
        if [ "$SI_ERR_CODE" == "0" ]; then 
            SB_DOMAIN_IS_REACHABLE="t" 
        else 
            if [ "$SI_ERR_CODE" == "124" ]; then 
                SB_DOMAIN_IS_REACHABLE="t" 
            fi 
        fi 
    fi 

# RENESSAATOR_AUTOGENERATED_TEXT_END
# RENESSAATOR_BLOCK_END
    #----------------------------------------------------------------------
    if [ "$SB_DOMAIN_IS_REACHABLE" == "f" ]; then
        SB_VERIFICATION_FAILED="t"
        if [ "$SB_DISPLAY_NONERROR_FEEDBACK" == "t" ]; then
            echo -e "\e[33mTest failed\e[39m. Replies to pings were NOT received."
            echo "GUID=='47af6020-2949-45ad-a43a-d1c0004128e7'"
            if [ "$S_GUID_CANDIDATE" != "" ]; then
                echo "S_GUID_CANDIDATE=='$S_GUID_CANDIDATE'"
            fi
        fi
    else
        SB_VERIFICATION_FAILED="f"
        if [ "$SB_DISPLAY_NONERROR_FEEDBACK" == "t" ]; then
            echo -e "\e[32mTest passed\e[39m. It was possible to receive replies to pings."
        fi
    fi
    wait # to make sure that the echo commands 
         # complete before anything else is printed to stdout
    #----------------------------------------------------------------------
} # func_mmmv_verify_that_internet_connection_exists_but_do_not_exit_t1

#--------------------------------------------------------------------------

SB_FUNC_MMMV_ASSERT_INTERNET_CONNECTION_EXISTS_T1_RESULT_CACHED="f"
SB_FUNC_MMMV_ASSERT_INTERNET_CONNECTION_EXISTS_T1_INTERNET_CONNECTION_EXISTS="f"
func_mmmv_assert_internet_connection_exists_t1(){
    #----------------------------------------------------------------------
    local S_GUID_CANDIDATE="$1"
    local SB_OK_TO_CACHE="$2" # domain: {"t","f",""}
                              # ""==="f", default "f"
    local SB_DISPLAY_NONERROR_FEEDBACK="$3" # domain: {"t","f",""}
                                            # ""==="f", default "f"
    #----------------------------------------------------------------------
    if [ "$S_GUID_CANDIDATE" == "" ]; then
        echo ""
        echo -e "\e[31mThe Bash code that calls this function is flawed \e[39m."
        echo ""
        echo "    S_GUID_CANDIDATE==\"\""
        echo ""
        echo "but it is expected to be a GUID."
        echo "Aborting script."
        echo "GUID=='856dcb52-109e-4906-b13a-d1c0004128e7'"
        echo ""
        #--------
        cd "$S_FP_ORIG"
        exit 1
    fi
    #----------------------------------------------------------------------
    if [ "$SB_OK_TO_CACHE" == "" ]; then
        SB_OK_TO_CACHE="f"
    else
        func_mmmv_assert_sbvar_domain_t_f_t1 \
            "$SB_OK_TO_CACHE" "SB_OK_TO_CACHE" \
            "7b76e916-701a-437e-a3fb-d1c0004128e7"
    fi
    #----------------------------------------------------------------------
    if [ "$SB_DISPLAY_NONERROR_FEEDBACK" == "" ]; then
        SB_DISPLAY_NONERROR_FEEDBACK="f"
    else
        func_mmmv_assert_sbvar_domain_t_f_t1 \
            "$SB_DISPLAY_NONERROR_FEEDBACK" "SB_DISPLAY_NONERROR_FEEDBACK" \
            "949cac58-4e69-46f9-a1eb-d1c0004128e7" 
    fi
    #----------------------------------------------------------------------
    func_mmmv_assert_sbvar_domain_t_f_t1 \
        "$SB_FUNC_MMMV_ASSERT_INTERNET_CONNECTION_EXISTS_T1_RESULT_CACHED" \
        "SB_FUNC_MMMV_ASSERT_INTERNET_CONNECTION_EXISTS_T1_RESULT_CACHED" \
        "1127ccb1-efb0-43ae-8feb-d1c0004128e7"
    func_mmmv_assert_sbvar_domain_t_f_t1 \
        "$SB_FUNC_MMMV_ASSERT_INTERNET_CONNECTION_EXISTS_T1_INTERNET_CONNECTION_EXISTS" \
        "SB_FUNC_MMMV_ASSERT_INTERNET_CONNECTION_EXISTS_T1_INTERNET_CONNECTION_EXISTS" \
        "a469d241-924c-4544-b4eb-d1c0004128e7"
    #----------------------------------------------------------------------
    local SB_INTERNET_AVAILABLE="f"
    local SB_STUDY_INTERNET_AVAILABILITY="f"
    #----------------------------------------------------------------------
    if [ "$SB_OK_TO_CACHE" == "t" ]; then
        if [ "$SB_FUNC_MMMV_ASSERT_INTERNET_CONNECTION_EXISTS_T1_RESULT_CACHED" == "t" ]; then
            SB_INTERNET_AVAILABLE="$SB_FUNC_MMMV_ASSERT_INTERNET_CONNECTION_EXISTS_T1_INTERNET_CONNECTION_EXISTS"
            #SB_STUDY_INTERNET_AVAILABILITY="f"
        else
            SB_STUDY_INTERNET_AVAILABILITY="t"
        fi
    else
        SB_STUDY_INTERNET_AVAILABILITY="t"
    fi
    #----------------------------------------------------------------------
    if [ "$SB_STUDY_INTERNET_AVAILABILITY" == "t" ]; then
        #----------------------------------------
        # The 
        func_mmmv_verify_that_internet_connection_exists_but_do_not_exit_t1 \
            "f1264818-02bc-4555-b4db-d1c0004128e7" \
            "$SB_DISPLAY_NONERROR_FEEDBACK"
        # retunrs its result in a global variable named 
        # SB_VERIFICATION_FAILED="t" # domain: "t", "f" .
        if [ "$SB_VERIFICATION_FAILED" == "t" ]; then
            SB_INTERNET_AVAILABLE="f"
        else
            if [ "$SB_VERIFICATION_FAILED" == "f" ]; then
                SB_INTERNET_AVAILABLE="t"
            else
                func_mmmv_assert_sbvar_domain_t_f_t1 \
                    "$SB_VERIFICATION_FAILED" \
                    "SB_VERIFICATION_FAILED" \
                    "e49978b2-5da1-486f-95db-d1c0004128e7"
            fi
        fi
        #----------------------------------------
        SB_FUNC_MMMV_ASSERT_INTERNET_CONNECTION_EXISTS_T1_INTERNET_CONNECTION_EXISTS="$SB_INTERNET_AVAILABLE"
        SB_FUNC_MMMV_ASSERT_INTERNET_CONNECTION_EXISTS_T1_RESULT_CACHED="t"
        #----------------------------------------
    fi
    #----------------------------------------------------------------------
    if [ "$SB_INTERNET_AVAILABLE" == "f" ]; then
        echo ""
        echo -e "\e[31mInternet could not be reached\e[39m."
        echo -e "Aborting script."
        echo "GUID=='4a5a4d38-c03b-4db3-b33a-d1c0004128e7'"
        echo "S_GUID_CANDIDATE=='$S_GUID_CANDIDATE'"
        echo ""
        #--------
        cd "$S_FP_ORIG"
        exit 1
    fi
    #----------------------------------------------------------------------
} # func_mmmv_assert_internet_connection_exists_t1

#--------------------------------------------------------------------------

# TODO: split the function 
#       func_mmmv_assert_GUI_applications_can_be_launched_t1(...)
#       the non-exiting part ("do_not_exit") and the exiting/throwing part.

SB_FUNC_MMMV_ASSERT_GUI_APPLICATIONS_CAN_BE_LAUNCHED_T1_RESULT_CACHED="f"
SB_FUNC_MMMV_ASSERT_GUI_APPLICATIONS_CAN_BE_LAUNCHED_T1_GUI_IS_LAUNCHABLE="f"
func_mmmv_assert_GUI_applications_can_be_launched_t1(){
    #----------------------------------------------------------------------
    local S_GUID_CANDIDATE="$1"
    local SB_OK_TO_CACHE="$2" # domain: {"t","f",""}
                              # ""==="f", default "f"
    local SB_DISPLAY_NONERROR_FEEDBACK="$3" # domain: {"t","f",""}
                                            # "" --> "f", default "f"
    #----------------------------------------------------------------------
    if [ "$S_GUID_CANDIDATE" == "" ]; then
        echo ""
        echo -e "\e[31mThe Bash code that calls this function is flawed \e[39m."
        echo ""
        echo "    S_GUID_CANDIDATE==\"\""
        echo ""
        echo "but it is expected to be a GUID."
        echo "Aborting script."
        echo "GUID=='e0104614-1187-4f7b-a53a-d1c0004128e7'"
        echo ""
        #--------
        cd "$S_FP_ORIG"
        exit 1
    fi
    #----------------------------------------------------------------------
    if [ "$SB_OK_TO_CACHE" == "" ]; then
        SB_OK_TO_CACHE="f"
    else
        func_mmmv_assert_sbvar_domain_t_f_t1 \
            "$SB_OK_TO_CACHE" "SB_OK_TO_CACHE" \
            "97123924-8445-40d2-92db-d1c0004128e7"
    fi
    #----------------------------------------------------------------------
    if [ "$SB_DISPLAY_NONERROR_FEEDBACK" == "" ]; then
        SB_DISPLAY_NONERROR_FEEDBACK="f"
    else
        func_mmmv_assert_sbvar_domain_t_f_t1 \
            "$SB_DISPLAY_NONERROR_FEEDBACK" "SB_DISPLAY_NONERROR_FEEDBACK" \
            "7dc89950-121d-44bf-84cb-d1c0004128e7" 
    fi
    #----------------------------------------------------------------------
    func_mmmv_assert_sbvar_domain_t_f_t1 \
        "$SB_FUNC_MMMV_ASSERT_GUI_APPLICATIONS_CAN_BE_LAUNCHED_T1_RESULT_CACHED" \
        "SB_FUNC_MMMV_ASSERT_GUI_APPLICATIONS_CAN_BE_LAUNCHED_T1_RESULT_CACHED" \
        "d3f5404d-380d-4872-91cb-d1c0004128e7"
    func_mmmv_assert_sbvar_domain_t_f_t1 \
        "$SB_FUNC_MMMV_ASSERT_GUI_APPLICATIONS_CAN_BE_LAUNCHED_T1_GUI_IS_LAUNCHABLE" \
        "SB_FUNC_MMMV_ASSERT_GUI_APPLICATIONS_CAN_BE_LAUNCHED_T1_GUI_IS_LAUNCHABLE" \
        "fe458627-182a-4946-b5bb-d1c0004128e7"
    #----------------------------------------------------------------------
    local SB_RUN_TEST="t"
    if [ "$SB_OK_TO_CACHE" == "t" ]; then
        if [ "$SB_FUNC_MMMV_ASSERT_GUI_APPLICATIONS_CAN_BE_LAUNCHED_T1_RESULT_CACHED" == "t" ]; then
            SB_RUN_TEST="f"
            if [ "$SB_FUNC_MMMV_ASSERT_GUI_APPLICATIONS_CAN_BE_LAUNCHED_T1_GUI_IS_LAUNCHABLE" == "f" ]; then
                echo ""
                echo -e "\e[31mThis Bash function is flawed \e[39m."
                echo "The control flow should have never reached this if-statement, because"
                echo "the Bash program should have terminated at the "
                echo "previous run of this function, when it was discovered that "
                echo "GUI applications can not be launched."
                echo "Aborting script."
                echo "GUID=='09873838-e46f-469c-853a-d1c0004128e7'"
                echo "S_GUID_CANDIDATE==\"$S_GUID_CANDIDATE\""
                echo ""
                #--------
                cd "$S_FP_ORIG"
                exit 1
            fi
        fi
    fi
    #----------------------------------------------------------------------
    if [ "$SB_RUN_TEST" == "t" ]; then
        #------------------------------------------------------------------
        func_mmmv_assert_exists_on_path_t1 "timeout"
        func_mmmv_assert_exists_on_path_t1 "xeyes" # needed for fast testing
        #------------------------------------------------------------------
        if [ "$SB_DISPLAY_NONERROR_FEEDBACK" == "t" ]; then
            echo "Launching the xeyes application for about 2 seconds to test, "
            echo "whether it is possible to launch GUI applications..."
        fi
        nice -n 5 timeout 2s xeyes
        local S_TMP_0="$?"
        if [ "$S_TMP_0" != "124" ]; then
            #--------
            SB_FUNC_MMMV_ASSERT_GUI_APPLICATIONS_CAN_BE_LAUNCHED_T1_GUI_IS_LAUNCHABLE="f"
            SB_FUNC_MMMV_ASSERT_GUI_APPLICATIONS_CAN_BE_LAUNCHED_T1_RESULT_CACHED="t"
            #--------
            echo ""
            echo -e "It seems that it is\e[31m NOT possible to launch GUI applications\e[39m."
            echo "Aborting script."
            echo "GUID=='5cda824a-83eb-4295-a53a-d1c0004128e7'"
            echo "S_GUID_CANDIDATE==\"$S_GUID_CANDIDATE\""
            echo ""
            #--------
            cd "$S_FP_ORIG"
            exit 1
        fi
        wait ;
        if [ "$SB_DISPLAY_NONERROR_FEEDBACK" == "t" ]; then
            echo -e "\e[32mTest passed\e[39m. The xeyes could be launched successfully."
        fi
        SB_FUNC_MMMV_ASSERT_GUI_APPLICATIONS_CAN_BE_LAUNCHED_T1_GUI_IS_LAUNCHABLE="t"
        SB_FUNC_MMMV_ASSERT_GUI_APPLICATIONS_CAN_BE_LAUNCHED_T1_RESULT_CACHED="t"
        wait ;
        #------------------------------------------------------------------
    fi
    #----------------------------------------------------------------------
} # func_mmmv_assert_GUI_applications_can_be_launched_t1

#--------------------------------------------------------------------------

func_mmmv_exc_initialize_wine_C_drive_if_needed_t1(){
    #----------------------------------------------------------------------
    local SB_DISPLAY_NONERROR_FEEDBACK="$1" # domain: {"t","f",""}
                                            # ""==="f", default "f"
    #----------------------------------------------------------------------
    if [ "$SB_DISPLAY_NONERROR_FEEDBACK" == "" ]; then
        SB_DISPLAY_NONERROR_FEEDBACK="f"
    else
        func_mmmv_assert_sbvar_domain_t_f_t1 \
            "$SB_DISPLAY_NONERROR_FEEDBACK" "SB_DISPLAY_NONERROR_FEEDBACK" \
            "96a99921-1bd1-4eda-93bb-d1c0004128e7" 
    fi
    #----------------------------------------------------------------------
    local S_FP_WINE_HOME="$HOME/.wine"
    local S_FP_C="$S_FP_WINE_HOME/drive_c"
    local SB_OPTIONAL_BAN_SYMLINKS="f"
    local SB_OK_TO_CACHE="t"
    #----------------------------------------------------------------------
    if [ ! -d "$S_FP_C" ]; then # for speed optimisation
        if [ ! -e "$S_FP_C" ]; then
            #--------------------------------------------------------------
            if [ ! -e "$S_FP_WINE_HOME" ]; then
                # The if-clause at the next line is to improve error messages.
                if [ -h "$S_FP_WINE_HOME" ]; then # a broken symlink
                    func_mmmv_assert_folder_exists_t1 "$S_FP_WINE_HOME" \
                        "fa99a817-d0c1-4df7-93bb-d1c0004128e7" \
                        "$SB_OPTIONAL_BAN_SYMLINKS"
                fi
            fi
            if [ -h "$S_FP_C" ]; then # a broken symlink
                func_mmmv_assert_folder_exists_t1 "$S_FP_C" \
                    "15209d43-1636-4013-a3ab-d1c0004128e7" \
                    "$SB_OPTIONAL_BAN_SYMLINKS"
            fi
            #--------------------------------------------------------------
            if [ "$SB_DISPLAY_NONERROR_FEEDBACK" == "t" ]; then
                echo -e "Starting to create \"\e[33m$S_FP_C\e[39m\" by using wine ..."
            fi
            func_mmmv_assert_exists_on_path_t1 "wine"
            if [ "$SB_DISPLAY_NONERROR_FEEDBACK" == "t" ]; then
                echo "Wine dialogs use GUI."
            fi
            SB_OK_TO_CACHE="t" # domain: {"t","f",""}; default: "" -> "f"
            func_mmmv_assert_GUI_applications_can_be_launched_t1 \
                "235c3c7a-5337-474d-a5ab-d1c0004128e7" \
                "$SB_OK_TO_CACHE" "$SB_DISPLAY_NONERROR_FEEDBACK"
            if [ "$SB_DISPLAY_NONERROR_FEEDBACK" == "t" ]; then
                echo -e "Creating the \"\e[33m$S_FP_C\e[39m\" and executing the "
                echo -e "Wine version of \"\e[33mC:\\windows\\system32\\hostname.exe\e[39m\" ..."
            fi
            if [ "$SB_DISPLAY_NONERROR_FEEDBACK" == "t" ]; then
                nice -n 5 wine 'hostname' # creates ~/.wine/drive_c and
                                          # executes C:\windows\system32\hostname.exe
            else
                # The redirection part of the 
                nice -n 5 wine 'hostname' 2> /dev/null 1> /dev/null 
                # has been tested to work on both, Linux and FreeBSD. 
            fi
            func_mmmv_assert_error_code_zero_t1 "$?" \
                "5aef60f2-2ab2-44bf-a39b-d1c0004128e7"
            func_mmmv_wait_and_sync_t1
            func_mmmv_assert_folder_exists_t1 "$S_FP_C" \
                "b79b9d4b-ff45-49c5-a49b-d1c0004128e7" \
                "$SB_OPTIONAL_BAN_SYMLINKS"
            if [ "$SB_DISPLAY_NONERROR_FEEDBACK" == "t" ]; then
                echo -e "Creation of \"$S_FP_C\"\e[32m complete\e[39m." ; wait;
            fi
            #--------------------------------------------------------------
        else
            #--------------------------------------------------------------
            func_mmmv_assert_folder_exists_t1 "$S_FP_C" \
                "5e545901-b155-4d36-ae9b-d1c0004128e7" \
                "$SB_OPTIONAL_BAN_SYMLINKS"
            #--------------------------------------------------------------
        fi
    fi
    #----------------------------------------------------------------------
} # func_mmmv_exc_initialize_wine_C_drive_if_needed_t1

#--------------------------------------------------------------------------

S_FP_PARENT_FOLDER="$S_FP_DIR"  # will be overwritten by the 
func_mmmv_uncompress_tar_dot_foo_and_enter_t1(){
    #----------------------------------------
    local S_FN_FOLDER_NAME="$1"
    local S_FILE_EXTENTION_OF_A_COMPRESSED_FILE="$2"
    #----------------------------------------
    local SB_COMPRESSION_TYPE_RECOGNIZED="f"
    local S_CMD_NICE_PREFIX="nice -n 5 "
    local S_CMD_UNCOMPRESS="not_set"
    local S_CMD_UNCOMPRESS_CANDIDATE="not_set"
    local SB_COMPRESSIONLESS_TAR="f"
    #----------------------------------------
    #if [ "$SB_COMPRESSION_TYPE_RECOGNIZED" == "f" ]; then
        if [ "$S_FILE_EXTENTION_OF_A_COMPRESSED_FILE" == "tar" ]; then
            SB_COMPRESSIONLESS_TAR="t"
            SB_COMPRESSION_TYPE_RECOGNIZED="t"
        else
            if [ "$S_FILE_EXTENTION_OF_A_COMPRESSED_FILE" == "TAR" ]; then
                SB_COMPRESSIONLESS_TAR="t"
                SB_COMPRESSION_TYPE_RECOGNIZED="t"
            fi
        fi
    #fi
    #----------------------------------------
    if [ "$SB_COMPRESSION_TYPE_RECOGNIZED" == "f" ]; then
        #------------------------------
        S_CMD_UNCOMPRESS_CANDIDATE="$S_CMD_NICE_PREFIX plzip --decompress "
        if [ "$MMMV_USERSPACE_DISTRO_T1_SI_N_OF_COMPILATION_THREADS_T1" != "" ]; then
            S_CMD_UNCOMPRESS_CANDIDATE="$S_CMD_UNCOMPRESS_CANDIDATE --threads=$MMMV_USERSPACE_DISTRO_T1_SI_N_OF_COMPILATION_THREADS_T1 "
        fi
        #------------------------------
        if [ "$S_FILE_EXTENTION_OF_A_COMPRESSED_FILE" == "lz" ]; then
            S_CMD_UNCOMPRESS="$S_CMD_UNCOMPRESS_CANDIDATE "
            SB_COMPRESSION_TYPE_RECOGNIZED="t"
        else
            if [ "$S_FILE_EXTENTION_OF_A_COMPRESSED_FILE" == "LZ" ]; then
                S_CMD_UNCOMPRESS="$S_CMD_UNCOMPRESS_CANDIDATE  "
                SB_COMPRESSION_TYPE_RECOGNIZED="t"
            fi
            if [ "$S_FILE_EXTENTION_OF_A_COMPRESSED_FILE" == "tlz" ]; then
                S_CMD_UNCOMPRESS="$S_CMD_UNCOMPRESS_CANDIDATE   "
                SB_COMPRESSION_TYPE_RECOGNIZED="t"
            fi
            if [ "$S_FILE_EXTENTION_OF_A_COMPRESSED_FILE" == "TLZ" ]; then
                S_CMD_UNCOMPRESS="$S_CMD_UNCOMPRESS_CANDIDATE    "
                SB_COMPRESSION_TYPE_RECOGNIZED="t"
            fi
        fi
    fi
    #----------------------------------------
    if [ "$SB_COMPRESSION_TYPE_RECOGNIZED" == "f" ]; then
        if [ "$S_FILE_EXTENTION_OF_A_COMPRESSED_FILE" == "7z" ]; then
            S_CMD_UNCOMPRESS="$S_CMD_NICE_PREFIX 7z x " # The "x" is not a typo.
            SB_COMPRESSION_TYPE_RECOGNIZED="t"
        else
            if [ "$S_FILE_EXTENTION_OF_A_COMPRESSED_FILE" == "7Z" ]; then
                S_CMD_UNCOMPRESS="$S_CMD_NICE_PREFIX 7z x " # The "x" is not a typo.
                SB_COMPRESSION_TYPE_RECOGNIZED="t"
            fi
            if [ "$S_FILE_EXTENTION_OF_A_COMPRESSED_FILE" == "t7z" ]; then
                S_CMD_UNCOMPRESS="$S_CMD_NICE_PREFIX 7z x " # The "x" is not a typo.
                SB_COMPRESSION_TYPE_RECOGNIZED="t"
            fi
            if [ "$S_FILE_EXTENTION_OF_A_COMPRESSED_FILE" == "T7Z" ]; then
                S_CMD_UNCOMPRESS="$S_CMD_NICE_PREFIX 7z x " # The "x" is not a typo.
                SB_COMPRESSION_TYPE_RECOGNIZED="t"
            fi
        fi
    fi
    #----------------------------------------
    if [ "$SB_COMPRESSION_TYPE_RECOGNIZED" == "f" ]; then
        if [ "$S_FILE_EXTENTION_OF_A_COMPRESSED_FILE" == "xz" ]; then
            S_CMD_UNCOMPRESS="$S_CMD_NICE_PREFIX unxz "
            SB_COMPRESSION_TYPE_RECOGNIZED="t"
        else
            if [ "$S_FILE_EXTENTION_OF_A_COMPRESSED_FILE" == "XZ" ]; then
                S_CMD_UNCOMPRESS="$S_CMD_NICE_PREFIX unxz "
                SB_COMPRESSION_TYPE_RECOGNIZED="t"
            fi
            if [ "$S_FILE_EXTENTION_OF_A_COMPRESSED_FILE" == "txz" ]; then
                S_CMD_UNCOMPRESS="$S_CMD_NICE_PREFIX unxz "
                SB_COMPRESSION_TYPE_RECOGNIZED="t"
            fi
            if [ "$S_FILE_EXTENTION_OF_A_COMPRESSED_FILE" == "TXZ" ]; then
                S_CMD_UNCOMPRESS="$S_CMD_NICE_PREFIX unxz "
                SB_COMPRESSION_TYPE_RECOGNIZED="t"
            fi
        fi
    fi
    #----------------------------------------
    if [ "$SB_COMPRESSION_TYPE_RECOGNIZED" == "f" ]; then
        if [ "$S_FILE_EXTENTION_OF_A_COMPRESSED_FILE" == "gz" ]; then
            S_CMD_UNCOMPRESS="$S_CMD_NICE_PREFIX gunzip "
            SB_COMPRESSION_TYPE_RECOGNIZED="t"
        else
            if [ "$S_FILE_EXTENTION_OF_A_COMPRESSED_FILE" == "GZ" ]; then
                S_CMD_UNCOMPRESS="$S_CMD_NICE_PREFIX gunzip "
                SB_COMPRESSION_TYPE_RECOGNIZED="t"
            fi
            if [ "$S_FILE_EXTENTION_OF_A_COMPRESSED_FILE" == "tgz" ]; then
                S_CMD_UNCOMPRESS="$S_CMD_NICE_PREFIX gunzip "
                SB_COMPRESSION_TYPE_RECOGNIZED="t"
            fi
            if [ "$S_FILE_EXTENTION_OF_A_COMPRESSED_FILE" == "TGZ" ]; then
                S_CMD_UNCOMPRESS="$S_CMD_NICE_PREFIX gunzip "
                SB_COMPRESSION_TYPE_RECOGNIZED="t"
            fi
        fi
    fi
    #----------------------------------------
    if [ "$SB_COMPRESSION_TYPE_RECOGNIZED" == "f" ]; then
        if [ "$S_FILE_EXTENTION_OF_A_COMPRESSED_FILE" == "bz2" ]; then
            S_CMD_UNCOMPRESS="$S_CMD_NICE_PREFIX bunzip2 "
            SB_COMPRESSION_TYPE_RECOGNIZED="t"
        else
            if [ "$S_FILE_EXTENTION_OF_A_COMPRESSED_FILE" == "BZ2" ]; then
                S_CMD_UNCOMPRESS="$S_CMD_NICE_PREFIX bunzip2 "
                SB_COMPRESSION_TYPE_RECOGNIZED="t"
            fi
            if [ "$S_FILE_EXTENTION_OF_A_COMPRESSED_FILE" == "tbz2" ]; then
                S_CMD_UNCOMPRESS="$S_CMD_NICE_PREFIX bunzip2 "
                SB_COMPRESSION_TYPE_RECOGNIZED="t"
            fi
            if [ "$S_FILE_EXTENTION_OF_A_COMPRESSED_FILE" == "TBZ2" ]; then
                S_CMD_UNCOMPRESS="$S_CMD_NICE_PREFIX bunzip2 "
                SB_COMPRESSION_TYPE_RECOGNIZED="t"
            fi
        fi
    fi
    #----------------------------------------
    if [ "$SB_COMPRESSION_TYPE_RECOGNIZED" == "f" ]; then
        if [ "$S_FILE_EXTENTION_OF_A_COMPRESSED_FILE" == "zip" ]; then
            S_CMD_UNCOMPRESS="$S_CMD_NICE_PREFIX unzip "
            SB_COMPRESSION_TYPE_RECOGNIZED="t"
        else
            if [ "$S_FILE_EXTENTION_OF_A_COMPRESSED_FILE" == "ZIP" ]; then
                S_CMD_UNCOMPRESS="$S_CMD_NICE_PREFIX unzip "
                SB_COMPRESSION_TYPE_RECOGNIZED="t"
            fi
            if [ "$S_FILE_EXTENTION_OF_A_COMPRESSED_FILE" == "tzip" ]; then
                S_CMD_UNCOMPRESS="$S_CMD_NICE_PREFIX unzip "
                SB_COMPRESSION_TYPE_RECOGNIZED="t"
            fi
            if [ "$S_FILE_EXTENTION_OF_A_COMPRESSED_FILE" == "TZIP" ]; then
                S_CMD_UNCOMPRESS="$S_CMD_NICE_PREFIX unzip "
                SB_COMPRESSION_TYPE_RECOGNIZED="t"
            fi
        fi
    fi
    #----------------------------------------
    if [ "$SB_COMPRESSION_TYPE_RECOGNIZED" == "f" ]; then
        if [ "$S_FILE_EXTENTION_OF_A_COMPRESSED_FILE" == "rar" ]; then
            S_CMD_UNCOMPRESS="$S_CMD_NICE_PREFIX unrar x " # The "x" is not a typo
            SB_COMPRESSION_TYPE_RECOGNIZED="t"
        else
            if [ "$S_FILE_EXTENTION_OF_A_COMPRESSED_FILE" == "RAR" ]; then
                S_CMD_UNCOMPRESS="$S_CMD_NICE_PREFIX unrar x " # The "x" is not a typo
                SB_COMPRESSION_TYPE_RECOGNIZED="t"
            fi
            if [ "$S_FILE_EXTENTION_OF_A_COMPRESSED_FILE" == "trar" ]; then
                S_CMD_UNCOMPRESS="$S_CMD_NICE_PREFIX unrar x " # The "x" is not a typo
                SB_COMPRESSION_TYPE_RECOGNIZED="t"
            fi
            if [ "$S_FILE_EXTENTION_OF_A_COMPRESSED_FILE" == "TRAR" ]; then
                S_CMD_UNCOMPRESS="$S_CMD_NICE_PREFIX unrar x " # The "x" is not a typo
                SB_COMPRESSION_TYPE_RECOGNIZED="t"
            fi
        fi
    fi
    #----------------------------------------
    if [ "$SB_COMPRESSION_TYPE_RECOGNIZED" == "f" ]; then
        if [ "$S_FILE_EXTENTION_OF_A_COMPRESSED_FILE" == "xar" ]; then
            S_CMD_UNCOMPRESS="$S_CMD_NICE_PREFIX xar -xf "
            SB_COMPRESSION_TYPE_RECOGNIZED="t"
        else
            if [ "$S_FILE_EXTENTION_OF_A_COMPRESSED_FILE" == "XAR" ]; then
                S_CMD_UNCOMPRESS="$S_CMD_NICE_PREFIX xar -xf "
                SB_COMPRESSION_TYPE_RECOGNIZED="t"
            fi
            if [ "$S_FILE_EXTENTION_OF_A_COMPRESSED_FILE" == "txar" ]; then
                S_CMD_UNCOMPRESS="$S_CMD_NICE_PREFIX xar -xf "
                SB_COMPRESSION_TYPE_RECOGNIZED="t"
            fi
            if [ "$S_FILE_EXTENTION_OF_A_COMPRESSED_FILE" == "TXAR" ]; then
                S_CMD_UNCOMPRESS="$S_CMD_NICE_PREFIX xar -xf "
                SB_COMPRESSION_TYPE_RECOGNIZED="t"
            fi
        fi
    fi
    #----------------------------------------
    if [ "$SB_COMPRESSION_TYPE_RECOGNIZED" != "t" ]; then
        echo ""
        echo "Failed to recognize compression type."
        echo "Aborting script."
        echo "GUID=='8287ee4e-9ab9-4ab1-922a-d1c0004128e7'"
        echo ""
        #--------
        cd "$S_FP_ORIG"
        exit 1 # exiting with an error
    fi
    #----------------------------------------
    func_mmmv_assert_folder_exists_t1 "$S_FP_PARENT_FOLDER" \
        "4d590530-24d7-473c-b48b-d1c0004128e7"
    cd $S_FP_PARENT_FOLDER
    func_mmmv_assert_error_code_zero_t1 "$?" \
        "dec36b28-1100-42e3-838b-d1c0004128e7"
    #----------------------------------------
    local S_FP_NEXT_PARENT_FOLDER="$S_FP_PARENT_FOLDER/$S_FN_FOLDER_NAME"
    local S_TMP_0=".tar"
    local S_FP_TAR="$S_FP_NEXT_PARENT_FOLDER$S_TMP_0"
    S_TMP_0=".$S_FILE_EXTENTION_OF_A_COMPRESSED_FILE"
    local S_FP_COMPRESSED="$S_FP_TAR$S_TMP_0"
    #----------------------------------------
    if [ "$SB_COMPRESSIONLESS_TAR" == "f" ]; then
        func_mmmv_assert_file_exists_t1 "$S_FP_COMPRESSED" \
            "c6b57734-4cf9-4f1f-a18b-d1c0004128e7"
        $S_CMD_UNCOMPRESS $S_FP_COMPRESSED
        func_mmmv_assert_error_code_zero_t1 "$?" \
            "a87a0750-ff0e-4642-837b-d1c0004128e7"
        func_mmmv_wait_and_sync_t1
    fi
    #----------------------------------------
    func_mmmv_assert_file_exists_t1 "$S_FP_TAR" \
        "5bfb2d33-7667-4ac7-9a7b-d1c0004128e7"
    $S_CMD_NICE_PREFIX tar -xf $S_FP_TAR
    func_mmmv_assert_error_code_zero_t1 "$?" \
        "d54b788e-5ac7-4f64-826b-d1c0004128e7"
    func_mmmv_wait_and_sync_t1
    #----------------------------------------
    func_mmmv_assert_folder_exists_t1 "$S_FP_NEXT_PARENT_FOLDER" \
        "e1844d2f-3ce9-452e-816b-d1c0004128e7"
    S_FP_PARENT_FOLDER="$S_FP_NEXT_PARENT_FOLDER"
    #----------------------------------------
} # func_mmmv_uncompress_tar_dot_foo_and_enter_t1

#--------------------------------------------------------------------------

S_OWNER="to_be_determined"
func_mmmv_s_owner_of_a_file_or_folder_t1(){
    local S_FP_IN="$1" # file or directory
    #----------------------------------------------------------------------
    # According to the 
    #     https://unix.stackexchange.com/questions/7730/find-the-owner-of-a-directory-or-file-but-only-return-that-and-nothing-else
    #     archival copy: https://archive.ph/QqssI
    # the solutions are:
    #     Linux, GNU coreutils (tested to work also on WSL):
    #         stat -c '%U' /path/of/file/or/directory
    #     FreeBSD:
    #         stat -f '%Su' /path/of/file/or/directory
    #     General solution that works on Linux and FreeBSD:
    #         ls -ld /path/of/file/or/directory | awk '{print $3}'
    #----------------------------------------------------------------------
    S_OWNER=""
    #----------------------------------------------------------------------
    if [ ! -e "$S_FP_IN" ]; then
        if [ -h "$S_FP_IN" ]; then
            func_mmmv_exc_exit_with_an_error_t2 \
                "d40b8914-e617-4123-bd6b-d1c0004128e7" \
                "The $S_FP_IN is a broken symlink."
        else
            func_mmmv_exc_exit_with_an_error_t2 \
                "598a1b65-298d-421a-855b-d1c0004128e7" \
                "The file or folder(==$S_FP_IN ) does not exist."
        fi
    fi
    #----------------------------------------------------------------------
    if [ "$SB_STAT_EXISTS_ON_PATH" == "t" ]; then
        # This is a speedhack branch that 
        # takes advantage of the mmmv_userspace_distro_t1
        #     https://github.com/martinvahi/mmmv_userspace_distro_t1
        #     https://sourceforge.net/projects/mmmv-userspace-distro-t1/
        if [ "$SB_OPERATINGSYSTEM_LINUX" == "t" ]; then
            S_OWNER="`stat -c '%U' \"$S_FP_IN\" `"
        else
            if [ "$SB_OPERATINGSYSTEM_BSD_FREEBSD" == "t" ]; then
                S_OWNER="`stat -f '%Su' \"$S_FP_IN\" `"
            fi
        fi
    fi
    #--------
    if [ "$S_OWNER" == "" ]; then
        func_mmmv_exc_determine_Awk_command_t1 # sets the value of S_AWK_CMD
        if [ "$SB_AWK_EXISTS_ON_PATH" != "t" ]; then
            func_mmmv_exit_if_not_on_path_t2 "$S_AWK_CMD"
        fi
        #--------
        # The next line, if uncommented, 
        #     S_OWNER="`ls -ld \"$S_FP_IN\" | awk '{print $3}' `"
        # has been tested to work on both, Linux and FreeBSD.
        #--------
        S_OWNER="`ls -ld \"$S_FP_IN\" | $S_AWK_CMD '{print $3}' `"
    fi
    #----------------------------------------------------------------------
} # func_mmmv_s_owner_of_a_file_or_folder_t1

#--------------------------------------------------------------------------

S_FP_DEVICE_FILE="not_yet_initialised"
# Throws if if a block device with the given block device ID candidate
# does not exist. Otherwise sets the S_FP_DEVICE_FILE.
func_mmmv_exc_block_device_ID_to_device_file_name_t1(){ # 
    local S_BLOCK_DEVICE_ID_SUBPART_CANDIDATE="$1"
    local S_GUID_CANDIDATE="$2"
    #----------------------------------------------------------------------
    func_mmmv_exc_verify_S_FP_ORIG_t1
    #----------------------------------------------------------------------
    if [ "$S_GUID_CANDIDATE" == "" ]; then
        echo ""
        echo -e "\e[31mThe Bash code that calls this function is flawed \e[39m."
        echo ""
        echo "    S_GUID_CANDIDATE==\"\""
        echo ""
        echo "but it is expected to be a GUID."
        echo "Aborting script."
        echo "GUID=='95f59e24-8859-42e1-912a-d1c0004128e7'"
        echo ""
        #--------
        cd "$S_FP_ORIG"
        exit 1
    fi
    #----------------------------------------------------------------------
    if [ "$S_BLOCK_DEVICE_ID_SUBPART_CANDIDATE" == "" ]; then
        echo ""
        echo -e "\e[31mThe Bash code that calls this function is flawed \e[39m."
        echo ""
        echo "    S_BLOCK_DEVICE_ID_SUBPART_CANDIDATE==\"\""
        echo ""
        echo "but it is expected to be non-empty string "
        echo "that is a  subpart of a GUID."
        echo "Aborting script."
        echo "GUID=='88f2c634-33cf-4d4c-822a-d1c0004128e7'"
        echo "S_GUID_CANDIDATE==\"$S_GUID_CANDIDATE\""
        echo ""
        #--------
        cd "$S_FP_ORIG"
        exit 1
    fi
    #----------------------------------------------------------------------
    func_mmmv_operatingsystem_is_Linux "S_TMP_0"
    if [ "$S_TMP_0" != "t" ]; then
        echo ""
        echo -e "\e[31mThis function is meant to be used only on Linux\e[39m,"
        echo "because the program \"blkid\" is Linux specific."
        echo "Aborting script."
        echo "GUID=='d8ba5114-a530-4044-912a-d1c0004128e7'"
        echo "S_GUID_CANDIDATE==\"$S_GUID_CANDIDATE\""
        echo ""
        #--------
        cd "$S_FP_ORIG"
        exit 1
        # TODO: Upgrade this function to work with BSD.
        #       However, it might not be as trivial as it is with Linux. 
        #       https://unix.stackexchange.com/questions/175814/list-connected-storage-devices-in-freebsd
        #       archival copy: https://archive.is/bfXke
    fi
    #----------------------------------------------------------------------
    # The core of this function:
    #     blkid | grep '6dd2a4' | grep -E '^[/]dev[/]' | gsed -e 's/:.\+$//g'
    #----------------------------------------------------------------------
    # The 
    func_mmmv_exit_if_not_on_path_t2 "blkid" 
    # will not throw on Windows Subsystem for Linux version 2 (WSL2),
    # because the WSL has the "blkid" on the PATH. It just
    # shows an empty list on the WSL2, which 
    # is not necessarily a flaw in the current context.
    #----------------------------------------
    func_mmmv_exit_if_not_on_path_t2 "grep"
    func_mmmv_exc_determine_sed_command_t1
    #----------------------------------------------------------------------
    S_FP_DEVICE_FILE="`blkid | grep \"$S_BLOCK_DEVICE_ID_SUBPART_CANDIDATE\" | grep -E '^[/]dev[/]' | $S_SED_CMD -e 's/:.\\+\$//g' `"
    if [ "$S_FP_DEVICE_FILE" == "" ]; then
        echo ""
        echo "A block device with an ID of "
        echo ""
        echo -e "    S_BLOCK_DEVICE_ID_SUBPART_CANDIDATE=\"\e[31m$S_BLOCK_DEVICE_ID_SUBPART_CANDIDATE\e[39m\" "
        echo ""
        echo -e "\e[31mcould not be found\e[39m."
        echo "Aborting script."
        echo "GUID=='c70e8e46-0fa6-43fb-821a-d1c0004128e7'"
        echo "S_GUID_CANDIDATE==\"$S_GUID_CANDIDATE\""
        echo ""
        #--------
        cd "$S_FP_ORIG"
        exit 1
    fi
    #----------------------------------------------------------------------
} # func_mmmv_exc_block_device_ID_to_device_file_name_t1

#--------------------------------------------------------------------------

func_first_use_message(){
    echo ""
    echo -e "\e[33mPlease customise this script to Your needs.\e[39m"
    echo "GUID=='b42fec51-5fc0-41c6-831a-d1c0004128e7'"
    echo ""
    #------------------------------
    cd "$S_FP_ORIG"
    exit 1
    #------------------------------
} # func_first_use_message

#--------------------------------------------------------------------------

func_display_help_message(){
    echo ""
    echo "This script does not take any configuration command line arguments."
    echo "It's current parameters, which are meant to be manually updated at "
    echo ""
    echo "    func_initialize_configuration_by_initializing_global_variables()"
    echo ""
    echo "are:"
    echo ""
    echo -e "    S_FP_BUILD_FOLDER=\"\e[96m$S_FP_BUILD_FOLDER\e[39m\""
    echo ""
    echo -e "    S_FP_INSTALLATION_FOLDER=\"\e[96m$S_FP_INSTALLATION_FOLDER\e[39m\""
    echo ""
    echo -e "    S_FP_SRC=\"\e[96m$S_FP_SRC\e[39m\""
    echo ""
    echo "Thank You for trying out this script. "
    echo ""
} # func_display_help_message

#--------------------------------------------------------------------------

S_CMD_GNU_AWK="awk"
S_CMD_GNU_MAKE="make"
S_CMD_GNU_SED="sed"
func_check_for_some_dependencies(){
    #----------------------------------------------------------------------
    #func_mmmv_assert_exists_on_path_t1 "ar"
    #func_mmmv_assert_exists_on_path_t1 "bc" # different programs on BSD and Linux
    func_mmmv_assert_exists_on_path_t1 "cat"
    func_mmmv_assert_exists_on_path_t1 "grep"
    #func_mmmv_assert_exists_on_path_t1 "huniq"
    #func_mmmv_assert_exists_on_path_t1 "flex"
    #func_mmmv_assert_exists_on_path_t1 "ranlib"
    #func_mmmv_assert_exists_on_path_t1 "sort"
    #func_mmmv_assert_exists_on_path_t1 "tee"
    #func_mmmv_assert_exists_on_path_t1 "tr" # different programs on BSD and Linux
    #func_mmmv_assert_exists_on_path_t1 "uniq"
    #func_mmmv_assert_exists_on_path_t1 "xargs"
    #------------------------------
    #func_mmmv_assert_exists_on_path_t1 "7z"      # .7z
    #func_mmmv_assert_exists_on_path_t1 "arj"     # .arj
    #func_mmmv_assert_exists_on_path_t1 "bunzip2" # .bz2
    func_mmmv_assert_exists_on_path_t1 "gunzip"   # .gz
    #func_mmmv_assert_exists_on_path_t1 "plzip"   # .lz .tlz
    func_mmmv_assert_exists_on_path_t1 "tar"      # .tar
    #func_mmmv_assert_exists_on_path_t1 "unxz"    # .xz
    #func_mmmv_assert_exists_on_path_t1 "unzip"   # .zip
    #func_mmmv_assert_exists_on_path_t1 "unrar"   # .rar
    #func_mmmv_assert_exists_on_path_t1 "xar"     # .xar
    #------------------------------
    #func_mmmv_assert_exists_on_path_t1 "cargo"
    #func_mmmv_assert_exists_on_path_t1 "gem"
    #func_mmmv_assert_exists_on_path_t1 "java"
    #func_mmmv_assert_exists_on_path_t1 "javac"
    #func_mmmv_assert_exists_on_path_t1 "perl"
    #func_mmmv_assert_exists_on_path_t1 "python3"
    #func_mmmv_assert_exists_on_path_t1 "ruby"
    #func_mmmv_assert_exists_on_path_t1 "rustc"
    #----------------------------------------------------------------------
    # The test for the availability of grep is 
    # expected to be somewhere above this line.
    if [ "`uname -a | grep -i 'BSD' `" != '' ]; then 
        S_CMD_GNU_AWK="gawk"
        S_CMD_GNU_MAKE="gmake"
        S_CMD_GNU_SED="gsed" 
    fi 
    #func_mmmv_assert_exists_on_path_t1 "$S_CMD_GNU_AWK"
    func_mmmv_assert_exists_on_path_t1 "$S_CMD_GNU_MAKE"
    func_mmmv_assert_exists_on_path_t1 "$S_CMD_GNU_SED"
    #----------------------------------------------------------------------
    if [ "$CC" == "" ]; then
        export CC="gcc"
    fi
    if [ "$CXX" == "" ]; then
        export CXX="g++"
    fi
    #------------------------------
    # if [ "Foo" == "Foo" ]; then # to make it easier to switch
    #     CC="gcc"
    #     CXX="g++"
    # else
    #     CC="clang"
    #     CXX="clang++"
    # fi
    #------------------------------
    func_mmmv_assert_exists_on_path_t1 "$CC"
    func_mmmv_assert_exists_on_path_t1 "$CXX"
    #----------------------------------------------------------------------
} # func_check_for_some_dependencies

#--------------------------------------------------------------------------
S_ARGV_0="$1" # Bash style command line argument indices versus 
              # Ruby style command line argument indices. 

func_display_help_message_and_exit_if_needed(){
    #----------------------------------------------------------------------
    func_mmmv_assert_exists_on_path_t1 "grep" 
    #------------------------------
    local SB_0="f"
    if [ "$S_ARGV_0" != "" ]; then
        if [ "`echo \"$S_ARGV_0\" | grep -E '^((([-][-]?)?[hH][eE][lL][pP])|([-]?[hH?]))$' `" == "" ]; then
            echo ""
            echo -e "\e[31mUnsupported \e[39mcommand line argument: \"\e[31m$S_ARGV_0\e[39m\""
            echo "GUID=='43230d44-ba3a-401b-bc1a-d1c0004128e7'"
            echo "The only command line argument that is supported is \"help\", which"
            echo "does nothing other than display the following message:"
            func_display_help_message
            #--------
            cd "$S_FP_ORIG"
            exit 1
        else
            SB_0="t"
        fi
    fi
    if [ "$SB_0" == "t" ]; then
        func_display_help_message
        #--------
        cd "$S_FP_ORIG"
        exit 0
    fi
    #----------------------------------------------------------------------
} # func_display_help_message_and_exit_if_needed

#--------------------------------------------------------------------------

func_initialize_configuration_by_initializing_global_variables(){
    #func_first_use_message # Please outcomment this line during the customisation.
    #----------------------------------------------------------------------
    func_mmmv_init_s_timestamp_if_not_inited_t1
    #----------------------------------------------------------------------
    S_FP_BUILD_FOLDER="$S_FP_DIR/temporary_build_folder/tmp_$S_TIMESTAMP"
    S_FP_INSTALLATION_FOLDER="`cd $S_FP_DIR/../../; pwd `/v_2_17"
    S_FN_BASENAME="fossil-src-2.17"
    S_COMPRESSION_FILE_EXTENTION="gz"
    S_FP_SRC="$S_FP_DIR/$S_FN_BASENAME.tar.$S_COMPRESSION_FILE_EXTENTION"
    S_CMD_PREFIX_NICE="nice -n 4 "
    #----------------------------------------------------------------------
} # func_initialize_configuration_by_initializing_global_variables

#--------------------------------------------------------------------------

func_main(){
    #------------------------------
    func_check_for_some_dependencies
    func_initialize_configuration_by_initializing_global_variables
    func_display_help_message_and_exit_if_needed
    #------------------------------
    func_mmmv_assert_folder_exists_t1 "$S_FP_DIR" \
        "2209c8f1-bac9-4bd1-855b-d1c0004128e7"
    cd $S_FP_DIR
    func_mmmv_assert_error_code_zero_t1 "$?" \
        "2d426914-2e29-4202-b34b-d1c0004128e7"
    #------------------------------
    func_mmmv_create_folder_t1 "$S_FP_BUILD_FOLDER"
    cd $S_FP_BUILD_FOLDER
    func_mmmv_assert_error_code_zero_t1 "$?" \
        "8400c716-87bd-4c29-944b-d1c0004128e7"
    #------------------------------
    func_mmmv_assert_file_exists_t1 "$S_FP_SRC" \
        "57ec9a30-5181-4990-b44b-d1c0004128e7"
    $S_CMD_PREFIX_NICE cp -f $S_FP_SRC $S_FP_BUILD_FOLDER/
    func_mmmv_assert_error_code_zero_t1 "$?" \
        "4ea1794e-de41-4e96-923b-d1c0004128e7"
    func_mmmv_wait_and_sync_t1
    #------------------------------
    S_FP_PARENT_FOLDER="$S_FP_BUILD_FOLDER"
    func_mmmv_uncompress_tar_dot_foo_and_enter_t1 \
        "$S_FN_BASENAME" "$S_COMPRESSION_FILE_EXTENTION"
    #------------------------------
    cd $S_FP_PARENT_FOLDER
    func_mmmv_assert_error_code_zero_t1 "$?" \
        "92d30e43-98e9-472f-b53b-d1c0004128e7"
    $S_CMD_PREFIX_NICE ./configure --prefix=$S_FP_INSTALLATION_FOLDER  --with-th1-docs  --with-th1-hooks --json
    func_mmmv_assert_error_code_zero_t1 "$?" \
        "4899a4ce-ca74-4aba-a42b-d1c0004128e7"
    func_mmmv_wait_and_sync_t1
    #------------------------------
    if [ "$MMMV_USERSPACE_DISTRO_T1_SI_N_OF_COMPILATION_THREADS_T1" != "" ]; then
        $S_CMD_PREFIX_NICE $S_CMD_GNU_MAKE -j $MMMV_USERSPACE_DISTRO_T1_SI_N_OF_COMPILATION_THREADS_T1
        func_mmmv_assert_error_code_zero_t1 "$?" \
            "aaa76941-674f-4bf3-852b-d1c0004128e7"
    else
        $S_CMD_PREFIX_NICE $S_CMD_GNU_MAKE 
        func_mmmv_assert_error_code_zero_t1 "$?" \
            "4c5d3636-2b05-4fb4-a32b-d1c0004128e7"
    fi
    func_mmmv_wait_and_sync_t1
    #------------------------------
    local S_TMP_0=""
    local SB_OPTIONAL_BAN_SYMLINKS="t"
    if [ -e "$S_FP_INSTALLATION_FOLDER" ]; then
        S_TMP_0="`echo \"$S_FP_INSTALLATION_FOLDER\" | grep -E '/v_2_17$' `"
        if [ "$S_TMP_0" != "" ]; then # for safety
            func_mmmv_assert_folder_exists_t1 "$S_FP_INSTALLATION_FOLDER" \
                "6f7e281d-aa64-463d-811b-d1c0004128e7" \
                "$SB_OPTIONAL_BAN_SYMLINKS"
            rm -fr "$S_FP_INSTALLATION_FOLDER"
        else
            echo ""
            echo -e "\e[31mThis Bash script is flawed \e[39m."
            echo ""
            echo "    S_FP_INSTALLATION_FOLDER==\"$S_FP_INSTALLATION_FOLDER\""
            echo ""
            echo "GUID=='162b8b11-bdbb-4e78-921a-d1c0004128e7'"
            echo ""
            #------------------------------
            cd "$S_FP_ORIG"
            exit 1
        fi
    fi
    func_mmmv_create_folder_t1 "$S_FP_INSTALLATION_FOLDER"
    #------------------------------
    $S_CMD_PREFIX_NICE $S_CMD_GNU_MAKE install
    func_mmmv_assert_error_code_zero_t1 "$?" \
        "8b5f4453-3582-4136-811b-d1c0004128e7"
    func_mmmv_wait_and_sync_t1
    #--------
    func_mmmv_assert_folder_exists_t1 "$S_FP_INSTALLATION_FOLDER/bin" \
        "80c75036-0990-49cc-b41b-d1c0004128e7" \
        "$SB_OPTIONAL_BAN_SYMLINKS"
    func_mmmv_assert_file_exists_t1 "$S_FP_INSTALLATION_FOLDER/bin/fossil" \
        "b29cc81d-487f-4bdf-970b-d1c0004128e7" \
        "$SB_OPTIONAL_BAN_SYMLINKS"
    #------------------------------
    echo ""
    echo "The location of the compiled binaries is:"
    echo -e "\e[92m    $S_FP_INSTALLATION_FOLDER \e[39m"
    echo ""
    echo "Thank You for trying out this script. "
    echo "GUID=='c37c6518-32e5-48ac-831a-d1c0004128e7'"
    echo ""
    #------------------------------
} # func_main
func_main

#--------------------------------------------------------------------------
cd "$S_FP_ORIG"
exit 0
#==========================================================================
# S_VERSION_OF_THIS_FILE="181d2d82-c913-4d38-840b-d1c0004128e7"
#==========================================================================
