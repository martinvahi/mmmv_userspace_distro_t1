<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"  
  "http://www.w3.org/TR/html4/loose.dtd">  
<html > 
<head><title>Calling symbolic routines from algebraic mode</title> 
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1"> 
<meta name="generator" content="TeX4ht (http://www.cse.ohio-state.edu/~gurari/TeX4ht/)"> 
<meta name="originator" content="TeX4ht (http://www.cse.ohio-state.edu/~gurari/TeX4ht/)"> 
<!-- 3,html --> 
<meta name="src" content="primer.tex"> 
<meta name="date" content="2014-05-02 18:12:00"> 
<link rel="stylesheet" type="text/css" href="primer.css"> 
</head><body 
>
   <table cellspacing="5"><tr><td class="clinks"><a 
href="primerse5.html#primersu29.html" >Up</a></td><td class="clinks"><a 
href="primersu30.html" >Next</a></td><td class="clinks"><a 
href="primersu28.html" >Prev</a></td><td class="clinks"><a 
href="primersu28.html#tailprimersu28.html" >PrevTail</a></td><td class="clinks"><a 
href="primersu29.html#tailprimersu29.html">Tail</a></td></tr></table><h4 class="subsectionHead"><span class="titlemark">5.2   </span> <a 
 id="x49-400005.2"></a>Calling symbolic routines from algebraic
mode</h4>
<!--l. 1764--><p class="noindent" ><span 
class="cmr-10">REDUCE </span>offers various ways to use symbolic routines in algebraic mode such that
they appear on the algebraic level as genuine parts of <span 
class="cmr-10">REDUCE</span>. These mainly
differ in their strategy of evaluating parameters (and results).
<!--l. 1770--><p class="noindent" >
   <h5 class="subsubsectionHead"><span class="titlemark">5.2.1   </span> <a 
 id="x49-410005.2.1"></a>Common protocol</h5>
<!--l. 1772--><p class="noindent" >Some general protocol rules apply for <span 
class="cmr-10">REDUCE </span>symbolic mode routines:
     <ul class="itemize1">
     <li class="itemize">A routine should check its parameters carefully; in the case of illegal
     parameters the <span 
class="cmr-10">REDUCE </span>error handlers should be invoked (see below).
     </li>
     <li class="itemize">If a routine cannot process its parameters for mathematical reasons it
     best returns the expression which had caused the call unchanged.
     </li>
     <li class="itemize">Evaluators should operate silently; events such as messages needed for
     testing and program development should be carried out in dependency
     of a switch.
     </li>
     <li class="itemize">A routine should return its result as a value rather than printing it; for
     an isolated call in interactive mode a printed result would be sufficient,
     but for following evaluation steps the availability of an algebraic value
     is essential.</li></ul>
<!--l. 1790--><p class="noindent" >
   <h5 class="subsubsectionHead"><span class="titlemark">5.2.2   </span> <a 
 id="x49-420005.2.2"></a>Symbolic operator</h5>
<!--l. 1792--><p class="noindent" >The simplest way to link a symbolic procedure to algebraic mode is the <span 
class="cmtt-10x-x-109">symbolic</span>
<span 
class="cmtt-10x-x-109">operator</span><a 
 id="dx49-42001"></a> declaration. In that case the routine can be called by its proper name
in algebraic mode with <span 
class="cmr-10">REDUCE </span>first evaluating its parameters to fully simplified
                                                                     

                                                                     
algebraic forms. Upon return the result should also be an algebraic form (or
NIL). Example:
                                                                     

                                                                     
   <div class="verbatim" id="verbatim-49">
&#x00A0;&#x00A0;&#x00A0;symbolic&#x00A0;procedure&#x00A0;my_plus(a,b);
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;begin&#x00A0;scalar&#x00A0;r;
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;print&#x00A0;a;&#x00A0;print&#x00A0;b;
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;r&#x00A0;:=&#x00A0;reval{&#8217;plus,a,b};
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;print&#x00A0;r;
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;return&#x00A0;r;
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;end;
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;symbolic&#x00A0;operator&#x00A0;my_plus;
</div>
<!--l. 1808--><p class="nopar" >
<!--l. 1810--><p class="indent" >   This routine receives two algebraic expressions and computes their sum by
calling the algebraic evaluator. The calls the the LISP function <span 
class="cmtt-10x-x-109">print </span>have been
inserted here and in the following examples to show you the forms passed to the
routine.
<!--l. 1815--><p class="noindent" >
   <h5 class="subsubsectionHead"><span class="titlemark">5.2.3   </span> <a 
 id="x49-430005.2.3"></a>Polyfn</h5>
<!--l. 1817--><p class="noindent" >If the symbolic routine is specialized for computations with pure polynomials it
can be declared <span 
class="cmtt-10x-x-109">polyfn</span><a 
 id="dx49-43001"></a>. <span 
class="cmr-10">REDUCE </span>will evaluate the arguments for such a routine
to <span 
class="cmtt-10x-x-109">standard forms</span><a 
 id="dx49-43002"></a> and expects that the result also will have that form.
Example:
                                                                     

                                                                     
   <div class="verbatim" id="verbatim-50">
&#x00A0;&#x00A0;&#x00A0;symbolic&#x00A0;procedure&#x00A0;poly_plus(a,b);
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;begin&#x00A0;scalar&#x00A0;r;
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;print&#x00A0;a;&#x00A0;print&#x00A0;b;
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;r&#x00A0;:=&#x00A0;addf(a,b);
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;print&#x00A0;r;
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;return&#x00A0;r;
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;end;
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;put(&#8217;poly_plus,&#8217;polyfn,&#8217;poly_plus);
</div>
<!--l. 1833--><p class="nopar" >
<!--l. 1835--><p class="indent" >   This routine also adds its arguments but it is specialized for polynomials. If
called with a non-polynomial form an error message will be generated. In the <span 
class="cmtt-10x-x-109">put</span>
statement the first argument is the algebraic operator name and the
third one is the name of the associated evaluator function. These may
differ.
<!--l. 1842--><p class="noindent" >
   <h5 class="subsubsectionHead"><span class="titlemark">5.2.4   </span> <a 
 id="x49-440005.2.4"></a>Psopfn</h5>
<!--l. 1844--><p class="noindent" >The most general type of function is that of a <span 
class="cmtt-10x-x-109">psopfn</span><a 
 id="dx49-44001"></a>. <span 
class="cmr-10">REDUCE </span>will not evaluate
the parameters for such a routine, instead it passes the unevaluated list of
parameters to the function. The routine has to evaluate its parameters itself (of
course using the services of <span 
class="cmmi-10x-x-109">reval </span>and friends). So a <span 
class="cmtt-10x-x-109">psopfn </span>can handle variable
numbers of parameters. The result must be an algebraic expression or <span 
class="cmmi-10x-x-109">nil</span>.
Example:
                                                                     

                                                                     
   <div class="verbatim" id="verbatim-51">
&#x00A0;&#x00A0;&#x00A0;symbolic&#x00A0;procedure&#x00A0;multi_plus0&#x00A0;u;
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;begin&#x00A0;scalar&#x00A0;r;
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;r:=0;
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;for&#x00A0;each&#x00A0;x&#x00A0;in&#x00A0;u&#x00A0;do
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x003C;&#x003C;x:=reval&#x00A0;x;&#x00A0;print&#x00A0;x;
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;r:=reval{&#8217;plus,r,x}
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x003E;&#x003E;;
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;print&#x00A0;r;
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;return&#x00A0;r;
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;end;
&#x00A0;<br />
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;put(&#8217;multi_plus,&#8217;psopfn,&#8217;multi_plus0);
</div>
<!--l. 1865--><p class="nopar" >
<!--l. 1867--><p class="indent" >   This routine can be called with an arbitrary number of parameters; it
will evaluate them one after the other, add them by calling <span 
class="cmmi-10x-x-109">reval </span>and
return the sum as result. Note that the name used in algebraic mode is
<span 
class="cmmi-10x-x-109">multi</span>_<span 
class="cmmi-10x-x-109">plus </span>which is different from the name of the symbolic routine doing the
work. This is necessary because otherwise the argument count check of
<span 
class="cmr-10">REDUCE </span>would complain as soon as the routine is called with more than one
argument.
<!--l. 1876--><p class="indent" >   In the next example a <span 
class="cmtt-10x-x-109">psopfn </span>implements an operator with a fixed number of
arguments; it expects two numbers as arguments and performs an extensive
checking as any such routine should do; again the name of the routine and the
algebraic mode operator are different:
                                                                     

                                                                     
   <div class="verbatim" id="verbatim-52">
&#x00A0;&#x00A0;&#x00A0;symbolic&#x00A0;procedure&#x00A0;bin_plus0&#x00A0;u;
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;begin&#x00A0;scalar&#x00A0;p1,p2,r;
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;if&#x00A0;length&#x00A0;u&#x00A0;neq&#x00A0;2&#x00A0;then&#x00A0;rederr&#x00A0;"illegal&#x00A0;number&#x00A0;of&#x00A0;arguments";
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;p1:=reval&#x00A0;car&#x00A0;u;&#x00A0;p2:=reval&#x00A0;cadr&#x00A0;u;
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;if&#x00A0;not&#x00A0;numberp&#x00A0;p1&#x00A0;then&#x00A0;typerr(p1,"number");
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;if&#x00A0;not&#x00A0;numberp&#x00A0;p2&#x00A0;then&#x00A0;typerr(p2,"number");
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;r:=p1+p2;
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;return&#x00A0;r;
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;end;
&#x00A0;<br />
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;put(&#8217;bin_plus,&#8217;psopfn,&#8217;bin_plus0);
</div>
<!--l. 1893--><p class="nopar" > The functions <span 
class="cmtt-10x-x-109">typerr</span><a 
 id="dx49-44002"></a> and <span 
class="cmtt-10x-x-109">rederr</span><a 
 id="dx49-44003"></a> are explained in the section <span 
class="cmti-10x-x-109">error</span>
<span 
class="cmti-10x-x-109">management</span>.
<!--l. 1897--><p class="noindent" >
   <h5 class="subsubsectionHead"><span class="titlemark">5.2.5   </span> <a 
 id="x49-450005.2.5"></a>Simpfn</h5>
<!--l. 1899--><p class="noindent" >When you declare a new algebraic operator and want to assign a special
evaluation mode for it which cannot be written in algebraic mode (e.g.&#x00A0;as a rule
set) you can create a simplifier which has the task to convert each operator
expression to a <span 
class="cmtt-10x-x-109">standard quotient</span><a 
 id="dx49-45001"></a>. A simplifier function is linked to the
operator by the property <span 
class="cmtt-10x-x-109">simpfn</span><a 
 id="dx49-45002"></a> and has one argument which is the unevaluated
parameter list of the operator expression. It will be called every time the
operator appears in an expression. It must return a standard quotient.
Example:
                                                                     

                                                                     
   <div class="verbatim" id="verbatim-53">
&#x00A0;&#x00A0;&#x00A0;algebraic&#x00A0;operator&#x00A0;op_plus;
&#x00A0;<br />
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;symbolic&#x00A0;procedure&#x00A0;simp_op_plus&#x00A0;u;
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;begin&#x00A0;scalar&#x00A0;r;
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;r:=simp&#x00A0;0;
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;for&#x00A0;each&#x00A0;x&#x00A0;in&#x00A0;u&#x00A0;do
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x003C;&#x003C;x:=simp&#x00A0;x;&#x00A0;print&#x00A0;x;
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;r:=addsq(r,x)
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x003E;&#x003E;;
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;return&#x00A0;print&#x00A0;r;
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;end;
&#x00A0;<br />
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;put(&#8217;op_plus,&#8217;simpfn,&#8217;simp_op_plus);
</div>
<!--l. 1925--><p class="nopar" >
<!--l. 1927--><p class="indent" >   In many cases the simpfn is the method of choice as it is best integrated into
the <span 
class="cmr-10">REDUCE </span>evaluation process: its results can immediately be used for
subsequent calculations while algebraic form results need to be converted to
standard quotients before combining them with other formulae.
<!--l. 1934--><p class="indent" >   Note that a simpfn which cannot simplify its argument must nevertheless
return a <span 
class="cmtt-10x-x-109">standard quotient</span>, then with the unevaluable form as kernel.
E.g.&#x00A0;a function for supporting the algebraic evaluation of the operator
&#8220;<span 
class="cmmi-10x-x-109">&#x003C;</span>&#8221;:
                                                                     

                                                                     
   <div class="verbatim" id="verbatim-54">
&#x00A0;&#x00A0;&#x00A0;algebraic&#x00A0;operator&#x00A0;&#x003C;;
&#x00A0;<br />
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;symbolic&#x00A0;procedure&#x00A0;simp_lessp&#x00A0;u;
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;begin&#x00A0;scalar&#x00A0;a1,a2,d;
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;a1:=simp&#x00A0;car&#x00A0;u;&#x00A0;a2:=simp&#x00A0;cadr&#x00A0;u;
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;d:=subtrsq(a1,a2);
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;if&#x00A0;domainp&#x00A0;denr&#x00A0;d&#x00A0;and&#x00A0;domainp&#x00A0;numr&#x00A0;d&#x00A0;then
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;return&#x00A0;if&#x00A0;!:minusp&#x00A0;numr&#x00A0;d&#x00A0;then&#x00A0;simp&#x00A0;1&#x00A0;else&#x00A0;simp&#x00A0;0;
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;return&#x00A0;mksq({&#8217;lessp,prepsq&#x00A0;a1,prepsq&#x00A0;a2},1);
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;end;
&#x00A0;<br />
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;put(&#8217;lessp,&#8217;simpfn,&#8217;simp_lessp);
</div>
<!--l. 1952--><p class="nopar" >
<!--l. 1954--><p class="indent" >   Here all comparisons with numeric items are reduced to zero or one because
of the equivalence of zero and &#8220;false&#8221; in algebraic mode, while in all other
cases the non-evaluable expression is returned mapped by the function
<span 
class="cmtt-10x-x-109">mksq</span><a 
 id="dx49-45003"></a> which converts an algebraic expression into a standard quotient,
ensuring the identity of composite kernels (see the section <span 
class="cmtt-10x-x-109">standard forms</span>)
<a 
 id="dx49-45004"></a><a 
 id="dx49-45005"></a>.
                                                                     

                                                                     
<!--l. 1962--><p class="indent" >   <table cellspacing="5"><tr><td class="clinks"><a 
href="primerse5.html#primersu29.html" >Up</a></td><td class="clinks"><a 
href="primersu30.html" >Next</a></td><td class="clinks"><a 
href="primersu28.html" >Prev</a></td><td class="clinks"><a 
href="primersu28.html#tailprimersu28.html" >PrevTail</a></td><td class="clinks"><a 
href="primersu29.html" >Front</a></td></tr></table><a 
 id="tailprimersu29.html"></a>   
</body></html> 
