<!DOCTYPE html> 
<html lang="en-US" xml:lang="en-US" > 
<head><title>APPLYSYM: Inﬁnitesimal Symmetries of Diﬀerential Equations</title> 
<meta  charset="utf-8" /> 
<meta name="generator" content="TeX4ht (https://tug.org/tex4ht/)" /> 
<meta name="viewport" content="width=device-width,initial-scale=1" /> 
<link rel="stylesheet" type="text/css" href="manual.css" /> 
<meta name="src" content="manual.tex" /> 
<script>window.MathJax = { tex: { tags: "ams", }, }; </script> 
 <script type="text/javascript" async="async" id="MathJax-script" src="../../cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js"></script>  
<meta name="description" content="The REDUCE Computer Algebra System User's Manual" /> 
</head><body 
>
<header>REDUCE</header><table cellspacing="5"><tr><td class="clinks"><a 
href="../manual-lookup.php%3FUser&#32;Contributed&#32;Packages.html#manualse124.html" >Up</a></td><td class="clinks"><a 
href="manualse125.html" >Next</a></td><td class="clinks"><a 
href="manualse124.html#tailmanualse124.html">Tail</a></td></tr></table><h3 class="sectionHead"><span class="titlemark">20.1    </span> <a 
 id="x164-30700020.1"></a>APPLYSYM: Inﬁnitesimal Symmetries of Diﬀerential Equations</h3>
<a 
 id="dx164-307001"></a>
<a 
 id="dx164-307002"></a>
<!--l. 58--><p class="noindent" >This package provides programs APPLYSYM, QUASILINPDE and DETRAFO for
applying inﬁnitesimal symmetries of diﬀerential equations, the generalization of special
solutions and the calculation of symmetry and similarity variables.
</p><!--l. 63--><p class="noindent" >Author: Thomas Wolf.
<a 
 id="dx164-307003"></a>
<a 
 id="dx164-307004"></a>
</p><!--l. 4--><p class="noindent" >In this paper the programs <span 
class="pcrr8t-x-x-109">APPLYSYM</span>, <span 
class="pcrr8t-x-x-109">QUASILINPDE </span>and <span 
class="pcrr8t-x-x-109">DETRAFO </span>are described
which aim at the utilization of inﬁnitesimal symmetries of diﬀerential equations. The
purpose of <span 
class="pcrr8t-x-x-109">QUASILINPDE </span>is the general solution of quasilinear PDEs. This
procedure is used by <span 
class="pcrr8t-x-x-109">APPLYSYM </span>for the application of point symmetries for either
</p>
     <ul class="itemize1">
     <li class="itemize">
     <!--l. 11--><p class="noindent" >calculating  similarity  variables  to  perform  a  point  transformation  which
     lowers the order of an ODE or eﬀectively reduces the number of explicitly
     occuring independent variables in a PDE(-system) or for
     </p></li>
     <li class="itemize">
     <!--l. 14--><p class="noindent" >generalizing  given  special  solutions  of  ODEs  /  PDEs  with  new  constant
                                                                     

                                                                     
     parameters.</p></li></ul>
<!--l. 18--><p class="noindent" >The program <span 
class="pcrr8t-x-x-109">DETRAFO </span>performs arbitrary point- and contact transformations of ODEs /
PDEs and is applied if similarity and symmetry variables have been found.
The program <span 
class="pcrr8t-x-x-109">APPLYSYM </span>is used in connection with the program <span 
class="pcrr8t-x-x-109">LIEPDE</span>
for formulating and solving the conditions for point- and contact symmetries
which is described in <span class="cite">[<a 
href="manualap2.html#XWolf:93">Wol93</a>]</span>. The actual problem solving is done in all these
programs through a call to the package <span 
class="pcrr8t-x-x-109">CRACK </span>for solving overdetermined
PDE-systems.
</p><!--l. 28--><p class="noindent" >
</p>
<h4 class="subsectionHead"><span class="titlemark">20.1.1    </span> <a 
 id="x164-30800020.1.1"></a>Introduction and overview of the symmetry method</h4>
<!--l. 29--><p class="noindent" >The investigation of inﬁnitesimal symmetries of diﬀerential equations (DEs) with
computer algebra programs attrackted considerable attention over the last years.
Corresponding programs are available in all major computer algebra systems. In a review
article by W. Hereman <span class="cite">[<a 
href="manualap2.html#XHereman:95">Her95</a>]</span> about 200 references are given, many of them describing
related software.
</p><!--l. 36--><p class="noindent" >One reason for the popularity of the symmetry method is the fact that Sophus
Lie’s method <span class="cite">[<a 
href="manualap2.html#XLie:1880">Lie75</a>, <a 
href="manualap2.html#XLie:1967">Lie67</a>]</span> is the most widely used method for computing
exact solutions of non-linear DEs. Another reason is that the ﬁrst step in this
method, the formulation of the determining equation for the generators of the
symmetries, can already be very cumbersome, especially in the case of PDEs
of higher order and/or in case of many dependent and independent variables.
Also, the formulation of the conditions is a straight forward task involving only
diﬀerentiations and basic algebra - an ideal task for computer algebra systems. Less
straight forward is the automatic solution of the symmetry conditions which is the
strength of the program <span 
class="pcrr8t-x-x-109">LIEPDE </span>(for a comparison with another program see
<span class="cite">[<a 
href="manualap2.html#XWolf:93">Wol93</a>]</span>).
</p><!--l. 50--><p class="noindent" >The novelty described in this paper are programs aiming at the ﬁnal third step: Applying
symmetries for </p>
     <ul class="itemize1">
     <li class="itemize">
     <!--l. 53--><p class="noindent" >calculating  similarity  variables  to  perform  a  point  transformation  which
     lowers the order of an ODE or eﬀectively reduces the number of explicitly
     occuring independent variables of a PDE(-system) or for
     </p></li>
     <li class="itemize">
                                                                     

                                                                     
     <!--l. 56--><p class="noindent" >generalizing  given  special  solutions  of  ODEs/PDEs  with  new  constant
     parameters.</p></li></ul>
<!--l. 59--><p class="noindent" >Programs which run on their own but also allow interactive user control are indispensible
for these calculations. On one hand the calculations can become quite lengthy, like
variable transformations of PDEs (of higher order, with many variables). On the other
hand the freedom of choosing the right linear combination of symmetries and choosing
the optimal new symmetry- and similarity variables makes it necessary to ‘play’ with the
problem interactively.
</p><!--l. 67--><p class="noindent" >The focus in this paper is directed on questions of implementation and eﬃciency, no
principally new mathematics is presented.
</p><!--l. 70--><p class="noindent" >In the following subsections a review of the ﬁrst two steps of the symmetry method is
given as well as the third, i.e. the application step is outlined. Each of the remaining
sections is devoted to one procedure.
</p>
<h5 class="subsubsectionHead"><a 
 id="x164-30900020.1.1"></a>The ﬁrst step: Formulating the symmetry conditions</h5>
<!--l. 76--><p class="noindent" >To obey classical Lie-symmetries, diﬀerential equations \begin {equation}  H_A = 0 \label {PDEs}  \end {equation}
for unknown functions \(y^\alpha ,\;\;1\leq \alpha \leq p\) of independent variables \(x^i,\;\;1\leq i \leq q\) must be forminvariant against
inﬁnitesimal transformations \begin {equation}  \tilde {x}^i = x^i + \varepsilon \xi ^i, \;\; \;\;\; \tilde {y}^\alpha = y^\alpha + \varepsilon \eta ^\alpha \label {tran}  \end {equation}
in ﬁrst order of \(\varepsilon .\) To transform the equations (\ref {PDEs}) by (\ref {tran}), derivatives of \(y^\alpha \) must be transformed,
i.e. the part linear in \(\varepsilon \) must be determined. The corresponding formulas are (see e.g.
<span class="cite">[<a 
href="manualap2.html#XOlver:89">Olv86</a>, <a 
href="manualap2.html#XStephani:89">Ste89</a>]</span>) \begin {align}  \tilde {y}^\alpha _{j_1\ldots j_k} &amp;= y^\alpha _{j_1\ldots j_k} + \varepsilon \eta ^\alpha _{j_1\ldots j_k} + O(\varepsilon ^2) \nonumber \\[3mm] \eta ^\alpha _{j_1\ldots j_{k-1}j_k} &amp;= \frac {D \eta ^\alpha _{j_1\ldots j_{k-1}}}{D x^k} - y^\alpha _{ij_1\ldots j_{k-1}}\frac {D \xi ^i}{D x^k} \label {recur}  \end {align}
</p><!--l. 99--><p class="noindent" >where \(D/Dx^k\) means total diﬀerentiation w.r.t. \(x^k\) and from now on lower latin indices
of functions \(y^\alpha ,\) (and later \(u^\alpha \)) denote partial diﬀerentiation w.r.t. the independent
variables \(x^i,\) (and later \(v^i\)). The complete symmetry condition then takes the form \begin {align}  X H_A &amp;= 0 \bmod H_A = 0\ \label {sbed1} \\ X &amp;= \xi ^i \frac {\partial }{\partial x^i} + \eta ^\alpha \frac {\partial }{\partial y^\alpha } + \eta ^\alpha _m \frac {\partial }{\partial y^\alpha _m} + \eta ^\alpha _{mn} \frac {\partial }{\partial y^\alpha _{mn}} + \ldots + \eta ^\alpha _{mn\ldots p} \frac {\partial }{\partial y^\alpha _{mn\ldots p}}. \label {sbed2}  \end {align}
</p><!--l. 114--><p class="noindent" >where mod \(H_A = 0\) means that the original PDE-system is used to replace some partial
derivatives of \(y^\alpha \) to reduce the number of independent variables, because the symmetry
condition (\ref {sbed1}) must be fulﬁlled identically in \(x^i, y^\alpha \) and all partial derivatives of \(y^\alpha .\)
</p><!--l. 120--><p class="noindent" >For point symmetries, \(\xi ^i, \eta ^\alpha \) are functions of \(x^j, y^\beta \) and for contact symmetries they depend on \(x^j, y^\beta \) and \(y^\beta _k.\)
We restrict ourself to point symmetries as those are the only ones that can be applied by
the current version of the program <span 
class="pcrr8t-x-x-109">APPLYSYM </span>(see below). For literature about
generalized symmetries see <span class="cite">[<a 
href="manualap2.html#XHereman:95">Her95</a>]</span>.
</p><!--l. 126--><p class="noindent" >Though the formulation of the symmetry conditions (\ref {sbed1}), (\ref {sbed2}), (\ref {recur}) is straightforward and
handled in principle by all related programs <span class="cite">[<a 
href="manualap2.html#XHereman:95">Her95</a>]</span>, the computational eﬀort to
formulate the conditions (\ref {sbed1}) may cause problems if the number of \(x^i\) and \(y^\alpha \) is high. This can
                                                                     

                                                                     
partially be avoided if at ﬁrst only a few conditions are formulated and solved such that
the remaining ones are much shorter and quicker to formulate.
</p><!--l. 136--><p class="noindent" >A ﬁrst step in this direction is to investigate one PDE \(H_A = 0\) after another, as done in
<span class="cite">[<a 
href="manualap2.html#XChampagne:91">CHW91</a>]</span>. Two methods to partition the conditions for a single PDE are described by
Bocharov/Bronstein <span class="cite">[<a 
href="manualap2.html#XBocharov:89">BB89</a>]</span> and Stephani <span class="cite">[<a 
href="manualap2.html#XStephani:89">Ste89</a>]</span>.
</p><!--l. 141--><p class="noindent" >In the ﬁrst method only those terms of the symmetry condition \(X H_A = 0\) are calculated which
contain at least a derivative of \(y^\alpha \) of a minimal order \(m.\) Setting coeﬃcients of these
\(u\)-derivatives to zero provides symmetry conditions. Lowering the minimal order \(m\)
successively then gradually provides all symmetry conditions.
</p><!--l. 148--><p class="noindent" >The second method is even more selective. If \(H_A\) is of order \(n\) then only terms of the
symmetry condition \(X H_A = 0\) are generated which contain \(n'\)th order derivatives of \(y^\alpha .\) Furthermore
these derivatives must not occur in \(H_A\) itself. They can therefore occur in the symmetry
condition (\ref {sbed1}) only in \(\eta ^\alpha _{j_1\ldots j_n},\) i.e. in the terms \[\eta ^\alpha _{j_1\ldots j_n} \frac {\partial H_A}{\partial y^\alpha _{j_1\ldots j_n}}. \] If only coeﬃcients of \(n'\)th order derivatives of \(y^\alpha \) need
to be accurate to formulate preliminary conditions then from the total derivatives to be
taken in (\ref {recur}) only that part is performed which diﬀerentiates w.r.t. the highest
\(y^\alpha \)-derivatives. This means, for example, to form only \(y^\alpha _{mnk} \partial /\partial y^\alpha _{mn} \) if the expression, which is to
be diﬀerentiated totally w.r.t. \(x^k\), contains at most second order derivatives of
\(y^\alpha .\)
</p><!--l. 167--><p class="noindent" >The second method is applied in <span 
class="pcrr8t-x-x-109">LIEPDE</span>. Already the formulation of the remaining
conditions is speeded up considerably through this iteration process. These methods can
be applied if systems of DEs or single PDEs of at least second order are investigated
concerning symmetries.
</p>
<h5 class="subsubsectionHead"><a 
 id="x164-31000020.1.1"></a>The second step: Solving the symmetry conditions</h5>
<!--l. 174--><p class="noindent" >The second step in applying the whole method consists in solving the determining
conditions (\ref {sbed1}), (\ref {sbed2}), (\ref {recur}) which are linear homogeneous PDEs for \(\xi ^i, \eta ^\alpha \). The complete solution of
this system is not algorithmic any more because the solution of a general linear
PDE-system is as diﬃcult as the solution of its non-linear characteristic ODE-system
which is not covered by algorithms so far.
</p><!--l. 182--><p class="noindent" >Still algorithms are used successfully to simplify the PDE-system by calculating its
standard normal form and by integrating exact PDEs if they turn up in this simpliﬁcation
process <span class="cite">[<a 
href="manualap2.html#XWolf:93">Wol93</a>]</span>. One problem in this respect, for example, concerns the optimization of
the symbiosis of both algorithms. By that we mean the ranking of priorities between
integrating, adding integrability conditions and doing simpliﬁcations by substitutions -
all depending on the length of expressions and the overall structure of the PDE-system.
Also the extension of the class of PDEs which can be integrated exactly is a problem to
be pursuit further.
                                                                     

                                                                     
</p><!--l. 194--><p class="noindent" >The program <span 
class="pcrr8t-x-x-109">LIEPDE</span><a 
 id="dx164-310001"></a> which formulates the symmetry conditions calls the
program <span 
class="pcrr8t-x-x-109">CRACK </span>to solve them. This is done in a number of successive calls
in order to formulate and solve some ﬁrst order PDEs of the overdetermined
system ﬁrst and use their solution to formulate and solve the next subset of
conditions as described in the previous subsection. Also, <span 
class="pcrr8t-x-x-109">LIEPDE </span>can work on
DEs that contain parametric constants and parametric functions. An ansatz for
the symmetry generators can be formulated. For more details see <span class="cite">[<a 
href="manualap2.html#XWolf:93">Wol93</a>]</span> or
<span class="cite">[<a 
href="manualap2.html#XBrand:92">BW92</a>]</span>.
</p><!--l. 204--><p class="noindent" >The procedure <span 
class="pcrr8t-x-x-109">LIEPDE </span>is called through <br 
class="newline" /><span 
class="pcrr8t-x-x-109">LIEPDE(</span><span 
class="pcrro8t-x-x-109">problem,symtype,flist,inequ</span><span 
class="pcrr8t-x-x-109">); </span><br 
class="newline" />All parameters are lists.<br 
class="newline" /> The ﬁrst parameter speciﬁes the DEs to be investigated: <br 
class="newline" /><span 
class="ptmri8t-x-x-109">problem </span>has the form {<span 
class="ptmri8t-x-x-109">equations, ulist, xlist</span>} where
     </p><dl class="description"><dt class="description">
     <!--l. 210--><p class="noindent" >
<span 
class="ptmbi8t-x-x-109">equations</span> </p></dt><dd 
class="description">
     <!--l. 210--><p class="noindent" >is a list of equations, each has the form <span 
class="pcrr8t-x-x-109">df(ui,..)=... </span>where the LHS (left
     hand side) <span 
class="pcrr8t-x-x-109">df(ui,..) </span>is selected such that </p>
          <ul class="itemize1">
          <li class="itemize">
          <!--l. 214--><p class="noindent" >The RHS (right h.s.) of an equations must not include the derivative on
          the LHS nor a derivative of it.
          </p></li>
          <li class="itemize">
          <!--l. 216--><p class="noindent" >Neither the LHS nor any derivative of it of any equation may occur in
          any other equation.
          </p></li>
          <li class="itemize">
          <!--l. 218--><p class="noindent" >Each  of  the  unknown  functions  occurs  on  the  LHS  of  exactly  one
          equation.</p></li></ul>
     </dd><dt class="description">
     <!--l. 221--><p class="noindent" >
<span 
class="ptmbi8t-x-x-109">ulist</span> </p></dt><dd 
class="description">
     <!--l. 221--><p class="noindent" >is a list of function names, which can be chosen freely.
     </p></dd><dt class="description">
     <!--l. 222--><p class="noindent" >
<span 
class="ptmbi8t-x-x-109">xlist</span> </p></dt><dd 
class="description">
                                                                     

                                                                     
     <!--l. 222--><p class="noindent" >is a list of variable names, which can be chosen freely.</p></dd></dl>
<!--l. 224--><p class="noindent" >Equations can be given as a list of single diﬀerential expressions and then the program
will try to bring them into the ‘solved form’ <span 
class="pcrr8t-x-x-109">df(ui,..)=... </span>automatically. If
equations are given in the solved form then the above conditions are checked and
execution is stopped it they are not satisﬁed. An easy way to get the equations in the
desired form is to use <br 
class="newline" /><span class="obeylines-h"><span class="verb"><span 
class="pcrr8t-x-x-109"> </span><span 
class="pcrr8t-x-x-109"> </span><span 
class="pcrr8t-x-x-109"> </span><span 
class="pcrr8t-x-x-109"> FIRST</span><span 
class="pcrr8t-x-x-109"> SOLVE({</span></span></span><span 
class="ptmri8t-x-x-109">eq1,eq2,</span>...<span class="obeylines-h"><span class="verb"><span 
class="pcrr8t-x-x-109">},{</span></span></span><span 
class="ptmri8t-x-x-109">one highest derivative for each function u</span><span class="obeylines-h"><span class="verb"><span 
class="pcrr8t-x-x-109">})</span></span></span>
<br 
class="newline" />(see the example of the Karpman equations in <span 
class="pcrr8t-x-x-109">LIEPDE.TST</span>). The example of the
Burgers equation in <span 
class="pcrr8t-x-x-109">LIEPDE.TST </span>demonstrates that the number of symmetries for a
given maximal order of the inﬁnitesimal generators depends on the derivative chosen for
the LHS.
</p><!--l. 236--><p class="noindent" >The second parameter <span 
class="ptmri8t-x-x-109">symtype </span>of <span 
class="pcrr8t-x-x-109">LIEPDE </span>is a list \(\{\;\}\) that speciﬁes the symmetry to be
calculated. <span 
class="ptmri8t-x-x-109">symtype </span>can have the following values and meanings:
     </p><dl class="description"><dt class="description">
     <!--l. 240--><p class="noindent" >
<span 
class="pcrb8t-x-x-109">{"point"}</span> </p></dt><dd 
class="description">
     <!--l. 240--><p class="noindent" >Point symmetries with \(\xi ^i=\xi ^i(x^j,u^{\beta }),\; \eta ^{\alpha }=\eta ^{\alpha }(x^j,u^{\beta })\) are determined.
     </p></dd><dt class="description">
     <!--l. 243--><p class="noindent" >
<span 
class="pcrb8t-x-x-109">{"contact"}</span> </p></dt><dd 
class="description">
     <!--l. 243--><p class="noindent" >Contact  symmetries  with  \(\xi ^i=0,\;\eta =\eta (x^j,u,u_k)\)  are  determined  \((u_k = \partial u/\partial x^k)\),  which  is  only  applicable  if  a
     single equation (\ref {PDEs}) with an order \(&gt;1\) for a single function \(u\) is to be investigated.
     (The  <span 
class="ptmri8t-x-x-109">symtype  </span><span class="obeylines-h"><span class="verb"><span 
class="pcrr8t-x-x-109">{&#x0022;contact&#x0022;}</span></span></span> is  equivalent  to  <span class="obeylines-h"><span class="verb"><span 
class="pcrr8t-x-x-109">{&#x0022;general&#x0022;,</span><span 
class="pcrr8t-x-x-109"> 1}</span></span></span> (see
     below) apart from the additional checks done for <span class="obeylines-h"><span class="verb"><span 
class="pcrr8t-x-x-109">{&#x0022;contact&#x0022;}</span></span></span>.)
     </p></dd><dt class="description">
     <!--l. 250--><p class="noindent" >
<span 
class="pcrb8t-x-x-109">{"general"</span><span 
class="ptmb8t-x-x-109">, </span><span 
class="ptmbi8t-x-x-109">order</span><span 
class="pcrb8t-x-x-109">}</span> </p></dt><dd 
class="description">
     <!--l. 250--><p class="noindent" >where <span 
class="ptmri8t-x-x-109">order </span>is an integer \(&gt;0\). Generalized symmetries \(\xi ^i=0,\) \(\eta ^{\alpha }=\eta ^{\alpha }(x^j,u^{\beta },\ldots ,u^{\beta }_K)\) of a speciﬁed order are
     determined (where \(_K\) is a multiple index representing <span 
class="ptmri8t-x-x-109">order </span>many indices.)
     <br 
class="newline" />NOTE: Characteristic functions of generalized symmetries (\(= \eta ^{\alpha }\) if \(\xi ^i=0\)) are equivalent if
     they are equal on the solution manifold. Therefore, all dependences of
     characteristic functions on the substituted derivatives and their derivatives are
     dropped. For example, if the heat equation is given as \(u_t=u_{xx}\) (i.e. \(u_t\) is substituted by \(u_{xx}\)) then
     <span class="obeylines-h"><span class="verb"><span 
class="pcrr8t-x-x-109">{&#x0022;general&#x0022;,</span><span 
class="pcrr8t-x-x-109"> 2}</span></span></span> would not include characteristic functions depending on \(u_{tx}\) or \(u_{xxx}\).
     <br 
class="newline" />THEREFORE: <br 
class="newline" />If you want to ﬁnd <span 
class="ptmri8t-x-x-109">all </span>symmetries up to a given order then either </p>
                                                                     

                                                                     
          <ul class="itemize1">
          <li class="itemize">
          <!--l. 267--><p class="noindent" >avoid  using  \(H_A=0\)  to  substitute  lower  order  derivatives  by  expressions
          involving higher derivatives, or
          </p></li>
          <li class="itemize">
          <!--l. 269--><p class="noindent" >increase the order speciﬁed in <span 
class="ptmri8t-x-x-109">symtype</span>.</p></li></ul>
     <!--l. 271--><p class="noindent" >For an illustration of this eﬀect see the two symmetry determinations of the
     Burgers equation in the ﬁle <span 
class="pcrr8t-x-x-109">LIEPDE.TST</span>.
     </p></dd><dt class="description">
     <!--l. 274--><p class="noindent" >
<span 
class="pcrb8t-x-x-109">{xi!_</span><span 
class="ptmbi8t-x-x-109">x1  </span><span 
class="pcrb8t-x-x-109">=...,..., eta!_</span><span 
class="ptmbi8t-x-x-109">u1  </span><span 
class="pcrb8t-x-x-109">=...,...}</span> </p></dt><dd 
class="description">
     <!--l. 274--><p class="noindent" >It is possible to specify an ansatz for the symmetry. Such an ansatz must specify all
     \(\xi ^i\) for all independent variables and all \(\eta ^{\alpha }\) for all dependent variables in terms of
     diﬀerential expressions which may involve unknown functions/constants. The
     dependences of the unknown functions have to be declared in advance by using the
     <span 
class="pcrr8t-x-x-109">DEPEND </span>command. For example, <br 
class="newline" /><span class="obeylines-h"><span class="verb"><span 
class="pcrr8t-x-x-109"> </span><span 
class="pcrr8t-x-x-109"> </span><span 
class="pcrr8t-x-x-109"> </span><span 
class="pcrr8t-x-x-109"> DEPEND</span><span 
class="pcrr8t-x-x-109"> f,</span><span 
class="pcrr8t-x-x-109"> t,</span><span 
class="pcrr8t-x-x-109"> x,</span><span 
class="pcrr8t-x-x-109"> u$</span></span></span><br 
class="newline" />speciﬁes \(f\) to be a function of \(t,x,u\). If one wants to have \(f\) as a function of derivatives of \(u(t,x)\),
     say \(f\) depending on \(u_{txx}\), then one <span class="underline"><span 
class="ptmri8t-x-x-109">cannot</span></span> write <br 
class="newline" /><span class="obeylines-h"><span class="verb"><span 
class="pcrr8t-x-x-109"> </span><span 
class="pcrr8t-x-x-109"> </span><span 
class="pcrr8t-x-x-109"> </span><span 
class="pcrr8t-x-x-109"> DEPEND</span><span 
class="pcrr8t-x-x-109"> f,</span><span 
class="pcrr8t-x-x-109"> df(u,t,x,2)$</span></span></span><br 
class="newline" />but instead must write <br 
class="newline" /><span class="obeylines-h"><span class="verb"><span 
class="pcrr8t-x-x-109"> </span><span 
class="pcrr8t-x-x-109"> </span><span 
class="pcrr8t-x-x-109"> </span><span 
class="pcrr8t-x-x-109"> DEPEND</span><span 
class="pcrr8t-x-x-109"> f,</span><span 
class="pcrr8t-x-x-109"> u!‘1!‘2!‘2$</span></span></span><br 
class="newline" />assuming <span 
class="ptmri8t-x-x-109">xlist </span>has been speciﬁed as <span class="obeylines-h"><span class="verb"><span 
class="pcrr8t-x-x-109"> {t,x}</span></span></span>. Because \(t\) is the ﬁrst variable and \(x\) is
     the second variable in <span 
class="ptmri8t-x-x-109">xlist </span>and \(u\) is diﬀerentiated oncs wrt. \(t\) and twice wrt. \(x\) we
     therefore use <span class="obeylines-h"><span class="verb"><span 
class="pcrr8t-x-x-109"> u!‘1!‘2!‘2</span></span></span>. The character <span 
class="pcrr8t-x-x-109">! </span>is the escape character to allow
     special characters like ‘ to occur in an identiﬁer.
     </p><!--l. 295--><p class="noindent" >For generalized symmetries one usually sets all \(\xi ^i=0\). Then the \(\eta ^{\alpha }\) are equal to the
     characteristic functions.</p></dd></dl>
<!--l. 298--><p class="noindent" >The third parameter <span 
class="ptmri8t-x-x-109">ﬂist </span>of <span 
class="pcrr8t-x-x-109">LIEPDE </span>is a list \(\{\;\}\) that includes </p>
     <ul class="itemize1">
     <li class="itemize">
     <!--l. 301--><p class="noindent" >all parameters and functions in the equations which are to be determined
     such that symmetries exist (if any such parameters/functions are speciﬁed in
     <span 
class="ptmri8t-x-x-109">ﬂist </span>then the symmetry conditions formulated in <span 
class="pcrr8t-x-x-109">LIEPDE </span>become non-linear
     conditions which may be much harder for <span 
class="pcrr8t-x-x-109">CRACK </span>to solve with many cases
     and subcases to be considered.)
                                                                     

                                                                     
     </p></li>
     <li class="itemize">
     <!--l. 308--><p class="noindent" >all unknown functions and constants in the ansatz <span class="obeylines-h"><span class="verb"><span 
class="pcrr8t-x-x-109">xi!_..</span></span></span> and <span class="obeylines-h"><span class="verb"><span 
class="pcrr8t-x-x-109">eta!_..</span></span></span>
     if that has been speciﬁed in <span 
class="ptmri8t-x-x-109">symtype</span>.</p></li></ul>
<!--l. 312--><p class="noindent" >The fourth parameter <span 
class="ptmri8t-x-x-109">inequ </span>of <span 
class="pcrr8t-x-x-109">LIEPDE </span>is a list \(\{\;\}\) that includes all non-vanishing
expressions which represent inequalities for the functions in ﬂist.
</p><!--l. 316--><p class="noindent" >The result of <span 
class="pcrr8t-x-x-109">LIEPDE </span>is a list with 3 elements, each of which is a list: \[ \{\{\textit {con}_1,\textit {con}_2,\ldots \}, \{\texttt {xi}\__{\ldots }=\ldots , \ldots , \texttt {eta}\__{\ldots }=\ldots , \ldots \}, \{\textit {flist}\}\}. \] The ﬁrst list
contains remaining unsolved symmetry conditions <span 
class="ptmri8t-x-x-109">con</span>\(_i\). It is the empty list {} if all
conditions have been solved. The second list gives the symmetry generators,
i.e. expressions for \(\xi _i\) and \(\eta _j\). The last list contains all free constants and functions occuring
in the ﬁrst and second list.
</p><!--l. 348--><p class="noindent" >
</p>
<h5 class="subsubsectionHead"><a 
 id="x164-31100020.1.1"></a>The third step: Application of inﬁnitesimal symmetries</h5>
<!--l. 349--><p class="noindent" >If inﬁnitesimal symmetries have been found then the program <span 
class="pcrr8t-x-x-109">APPLYSYM </span>can use them
for the following purposes:
     </p><ol  class="enumerate1" >
<li 
  class="enumerate" id="x164-311002x1">
     <!--l. 352--><p class="noindent" >Calculation of one symmetry variable and further similarity variables. After
     transforming the DE(-system) to these variables, the symmetry variable will
     not occur explicitly any more. For ODEs this has the consequence that their
     order has eﬀectively been reduced.
     </p></li>
<li 
  class="enumerate" id="x164-311004x2">
     <!--l. 357--><p class="noindent" >Generalization of a special solution by one or more constants of integration.</p></li></ol>
<!--l. 360--><p class="noindent" >Both methods are described in the following section.
</p>
<h4 class="subsectionHead"><span class="titlemark">20.1.2    </span> <a 
 id="x164-31200020.1.2"></a>Applying symmetries with <span 
class="pcrr8t-x-x-109">APPLYSYM</span></h4>
                                                                     

                                                                     
<!--l. 364--><p class="noindent" >
</p>
<h5 class="subsubsectionHead"><a 
 id="x164-31300020.1.2"></a>The ﬁrst mode: Calculation of similarity and symmetry variables</h5>
<!--l. 365--><p class="noindent" >In the following we assume that a symmetry generator \(X\), given in (\ref {sbed2}), is known such that
ODE(s)/PDE(s) \(H_A=0\) satisfy the symmetry condition (\ref {sbed1}). The aim is to ﬁnd new dependent
functions \(u^\alpha = u^\alpha (x^j,y^\beta )\) and new independent variables \(v^i = v^i(x^j,y^\beta ),\;\; 1\leq \alpha ,\beta \leq p,\;1\leq i,j \leq q\) such that the symmetry generator \(X = \xi ^i(x^j,y^\beta )\partial _{x^i} + \eta ^\alpha (x^j,y^\beta )\partial _{y^\alpha }\) transforms
to \begin {equation}  X = \partial _{v^1}. \label {sbed3}  \end {equation}
</p><!--l. 379--><p class="noindent" >Inverting the above transformation to \(x^i=x^i(v^j,u^\beta ), y^\alpha =y^\alpha (v^j,u^\beta )\) and setting <br 
class="newline" />\(H_A(x^i(v^j,u^\beta ), y^\alpha (v^j,u^\beta ),\ldots ) = h_A(v^j, u^\beta ,\ldots )\) this means that \begin {align*}  0 &amp;= X H_A(x^i,y^\alpha ,y^\beta _j,\ldots )\;\;\; \bmod \;\;\; H_A=0 \\ &amp;= X h_A(v^i,u^\alpha ,u^\beta _j,\ldots )\;\;\; \bmod \;\;\; h_A=0 \\ &amp;= \partial _{v^1}h_A(v^i,u^\alpha ,u^\beta _j,\ldots )\;\;\; \bmod \;\;\; h_A=0.  \end {align*}
</p><!--l. 390--><p class="noindent" >Consequently, the variable \(v^1\) does not occur explicitly in \(h_A\). In the case of an ODE(-system) \((v^1=v)\)
the new equations \(0=h_A(v,u^\alpha ,du^\beta /dv,\ldots )\) are then of lower total order after the transformation \(z = z(u^1) = du^1/dv\) with now \(z, u^2,\ldots u^p\) as
unknown functions and \(u^1\) as independent variable.
</p><!--l. 397--><p class="noindent" >The new form (\ref {sbed3}) of \(X\) leads directly to conditions for the symmetry variable \(v^1\) and the
similarity variables \(v^i|_{i\neq 1}, u^\alpha \) (all functions of \(x^k,y^\gamma \)): \begin {align}  X v^1 = 1 &amp;= \xi ^i(x^k,y^\gamma )\partial _{x^i}v^1 + \eta ^\alpha (x^k,y^\gamma )\partial _{y^\alpha }v^1 \label {ql1} \\ X v^j|_{j\neq 1} = X u^\beta = 0 &amp;= \xi ^i(x^k,y^\gamma )\partial _{x^i}u^\beta + \eta ^\alpha (x^k,y^\gamma )\partial _{y^\alpha }u^\beta \label {ql2}  \end {align}
</p><!--l. 407--><p class="noindent" >The general solutions of (\ref {ql1}), (\ref {ql2}) involve free functions of \(p+q-1\) arguments. From the general
solution of equation (\ref {ql2}), \(p+q-1\) functionally independent special solutions have to be selected (\(v^2,\ldots ,v^p\)
and \(u^1,\ldots ,u^q\)), whereas from (\ref {ql1}) only one solution \(v^1\) is needed. Together, the expressions for the
symmetry and similarity variables must deﬁne a non-singular transformation
\(x,y \rightarrow u,v\).
</p><!--l. 415--><p class="noindent" >Diﬀerent special solutions selected at this stage will result in diﬀerent resulting DEs
which are equivalent under point transformations but may look quite diﬀerently. A
transformation that is more diﬃcult than another one will in general only complicate the
new DE(s) compared with the simpler transformation. We therefore seek the simplest
possible special solutions of (\ref {ql1}), (\ref {ql2}). They also have to be simple because the
transformation has to be inverted to solve for the old variables in order to do the
transformations.
</p><!--l. 426--><p class="noindent" >The following steps are performed in the corresponding mode of the program
<span 
class="pcrr8t-x-x-109">APPLYSYM</span>: </p>
     <ul class="itemize1">
     <li class="itemize">
     <!--l. 429--><p class="noindent" >The user is asked to specify a symmetry by selecting one symmetry from all
     the known symmetries or by specifying a linear combination of them.
     </p></li>
     <li class="itemize">
     <!--l. 431--><p class="noindent" >Through  a  call  of  the  procedure  <span 
class="pcrr8t-x-x-109">QUASILINPDE </span>(described  in  a  later
                                                                     

                                                                     
     section) the two linear ﬁrst order PDEs (\ref {ql1}), (\ref {ql2}) are investigated and, if possible,
     solved.
     </p></li>
     <li class="itemize">
     <!--l. 434--><p class="noindent" >From the general solution of (\ref {ql1}) 1 special solution is selected and from (\ref {ql2}) \(p+q-1\)
     special solutions are selected which should be as simple as possible.
     </p></li>
     <li class="itemize">
     <!--l. 437--><p class="noindent" >The  user  is  asked  whether  the  symmetry  variable  should  be  one  of  the
     independent  variables  (as  it  has  been  assumed  so  far)  or  one  of  the  new
     functions (then only derivatives of this function and not the function itself
     turn up in the new DE(s)).
     </p></li>
     <li class="itemize">
     <!--l. 441--><p class="noindent" >Through a call of the procedure <span 
class="pcrr8t-x-x-109">DETRAFO </span>the transformation \(x^i,y^\alpha \rightarrow v^j,u^\beta \) of the DE(s) \(H_A=0\)
     is ﬁnally done.
     </p></li>
     <li class="itemize">
     <!--l. 443--><p class="noindent" >The program returns to the starting menu.</p></li></ul>
<!--l. 446--><p class="noindent" >
</p>
<h5 class="subsubsectionHead"><a 
 id="x164-31400020.1.2"></a>The second mode: Generalization of special solutions</h5>
<!--l. 447--><p class="noindent" >A second application of inﬁnitesimal symmetries is the generalization of a known special
solution given in implicit form through \(0 = F(x^i,y^\alpha )\). If one knows a symmetry variable \(v^1\) and
similarity variables \(v^r, u^\alpha ,\;\;2\leq r\leq p\) then \(v^1\) can be shifted by a constant \(c\) because of \(\partial _{v^1}H_A = 0\) and therefore the DEs \(0 = H_A(v^r,u^\alpha ,u^\beta _j,\ldots )\)
are unaﬀected by the shift. Hence from \[0 = F(x^i, y^\alpha ) = F(x^i(v^j,u^\beta ), y^\alpha (v^j,u^\beta )) = \bar {F}(v^j,u^\beta )\] follows that \[ 0 = \bar {F}(v^1+c,v^r,u^\beta ) = \bar {F}(v^1(x^i,y^\alpha )+c, v^r(x^i,y^\alpha ), u^\beta (x^i,y^\alpha ))\] deﬁnes implicitly a generalized
solution \(y^\alpha =y^\alpha (x^i,c)\).
</p><!--l. 461--><p class="noindent" >This generalization works only if \(\partial _{v^1}\bar {F} \neq 0\) and if \(\bar {F}\) does not already have a constant additive to
\(v^1\).
</p><!--l. 465--><p class="noindent" >The method above needs to know \(x^i=x^i(u^\beta ,v^j),\; y^\alpha =y^\alpha (u^\beta ,v^j)\) <span class="underline">and</span> \(u^\alpha = u^\alpha (x^j,y^\beta ), v^\alpha = v^\alpha (x^j,y^\beta )\) which may be practically impossible. Better is, to
integrate \(x^i,y^\alpha \) along \(X\): \begin {equation}  \frac {d\bar {x}^i}{d\varepsilon } = \xi ^i(\bar {x}^j(\varepsilon ), \bar {y}^\beta (\varepsilon )), \;\;\;\;\; \frac {d\bar {y}^\alpha }{d\varepsilon } = \eta ^\alpha (\bar {x}^j(\varepsilon ), \bar {y}^\beta (\varepsilon )) \label {ODEsys}  \end {equation}
with initial values \(\bar {x}^i = x^i, \bar {y}^\alpha = y^\alpha \) for \(\varepsilon = 0.\) (This ODE-system is the characteristic system of (\ref {ql2}).)
</p><!--l. 481--><p class="noindent" >Knowing only the ﬁnite transformations \begin {equation}  \bar {x}^i = \bar {x}^i(x^j,y^\beta ,\varepsilon ),\;\; \bar {y}^\alpha = \bar {y}^\alpha (x^j,y^\beta ,\varepsilon ) \label {ODEsol}  \end {equation}
gives immediately the inverse transformation \(\bar {x}^i = \bar {x}^i(x^j,y^\beta ,\varepsilon ),\;\; \bar {y}^\alpha = \bar {y}^\alpha (x^j,y^\beta ,\varepsilon )\) just by \(\varepsilon \rightarrow -\varepsilon \) and renaming \(x^i,y^\alpha \leftrightarrow \bar {x}^i,\bar {y}^\alpha .\)
                                                                     

                                                                     
</p><!--l. 492--><p class="noindent" >The special solution \(0 = F(x^i,y^\alpha )\) is generalized by the new constant \(\varepsilon \) through \[ 0 = F(x^i,y^\alpha ) = F(x^i(\bar {x}^j,\bar {y}^\beta ,\varepsilon ), y^\alpha (\bar {x}^j,\bar {y}^\beta ,\varepsilon )) \] after dropping the
\(\bar {~}\).
</p><!--l. 499--><p class="noindent" >The steps performed in the corresponding mode of the program <span 
class="pcrr8t-x-x-109">APPLYSYM </span>show
features of both techniques: </p>
     <ul class="itemize1">
     <li class="itemize">
     <!--l. 502--><p class="noindent" >The user is asked to specify a symmetry by selecting one symmetry from all
     the known symmetries or by specifying a linear combination of them.
     </p></li>
     <li class="itemize">
     <!--l. 504--><p class="noindent" >The special solution to be generalized and the name of the new constant have
     to be put in.
     </p></li>
     <li class="itemize">
     <!--l. 506--><p class="noindent" >Through a call of the procedure <span 
class="pcrr8t-x-x-109">QUASILINPDE</span>, the PDE (\ref {ql1}) is solved which
     amounts to a solution of its characteristic ODE system (\ref {ODEsys}) where \(v^1=\varepsilon \).
     </p></li>
     <li class="itemize">
     <!--l. 509--><p class="noindent" ><span 
class="pcrr8t-x-x-109">QUASILINPDE </span>returns a list of constant expressions \begin {equation}  c_i = c_i(x^k, y^\beta , \varepsilon ),\;\;1\leq i\leq p+q  \end {equation}
     which are solved for \(x^j=x^j(c_i,\varepsilon ),\;\; y^\alpha =y^\alpha (c_i,\varepsilon )\) to obtain the generalized solution through \[ 0 = F(x^j, y^\alpha ) = F( x^j(c_i(x^k, y^\beta , 0), \varepsilon ), y^\alpha (c_i(x^k, y^\beta , 0), \varepsilon )). \]
     </p></li>
     <li class="itemize">
     <!--l. 519--><p class="noindent" >The new solution is availabe for further generalizations w.r.t. other symmetries.</p></li></ul>
<!--l. 522--><p class="noindent" >If one would like to generalize a given special solution with \(m\) new constants because \(m\)
symmetries are known, then one could run the whole program \(m\) times, each time with a
diﬀerent symmetry or one could run the program once with a linear combination
of \(m\) symmetry generators which again is a symmetry generator. Running the
program once adds one constant but we have in addition \(m-1\) arbitrary constants in the
linear combination of the symmetries, so \(m\) new constants are added. Usually
one will generalize the solution gradually to make solving (\ref {ODEsys}) gradually more
diﬃcult.
</p>
<h5 class="subsubsectionHead"><a 
 id="x164-31500020.1.2"></a>Syntax</h5>
<!--l. 533--><p class="noindent" >The call of <span 
class="pcrr8t-x-x-109">APPLYSYM</span><a 
 id="dx164-315001"></a> is <span 
class="pcrr8t-x-x-109">APPLYSYM</span>({<span 
class="ptmri8t-x-x-109">de</span>, <span 
class="ptmri8t-x-x-109">fun</span>, <span 
class="ptmri8t-x-x-109">var</span>}, {<span 
class="ptmri8t-x-x-109">sym</span>, <span 
class="ptmri8t-x-x-109">cons</span>}); </p>
                                                                     

                                                                     
     <ul class="itemize1">
     <li class="itemize">
     <!--l. 536--><p class="noindent" ><span 
class="ptmri8t-x-x-109">de </span>is a single DE or a list of DEs in the form of a vanishing expression or in
     the form \(\ldots =\ldots \;\;\).
     </p></li>
     <li class="itemize">
     <!--l. 538--><p class="noindent" ><span 
class="ptmri8t-x-x-109">fun </span>is the single function or the list of functions occuring in <span 
class="ptmri8t-x-x-109">de</span>.
     </p></li>
     <li class="itemize">
     <!--l. 540--><p class="noindent" ><span 
class="ptmri8t-x-x-109">var </span>is the single variable or the list of variables in <span 
class="ptmri8t-x-x-109">de</span>.
     </p></li>
     <li class="itemize">
     <!--l. 541--><p class="noindent" ><span 
class="ptmri8t-x-x-109">sym </span>is a linear combination of all symmetries, each with a diﬀerent constant
     coeﬃcient, in form of a list of the \(\xi ^i\) and \(\eta ^\alpha \): {xi_…=…,…,eta_…=…,…}, where the
     indices after ‘xi_’ are the variable names and after ‘eta_’ the function names.
     </p></li>
     <li class="itemize">
     <!--l. 546--><p class="noindent" ><span 
class="ptmri8t-x-x-109">cons </span>is the list of constants in <span 
class="ptmri8t-x-x-109">sym</span>, one constant for each symmetry.</p></li></ul>
<!--l. 549--><p class="noindent" >The list that is the ﬁrst argument of <span 
class="pcrr8t-x-x-109">APPLYSYM </span>is the same as the ﬁrst argument of
<span 
class="pcrr8t-x-x-109">LIEPDE </span>and the second argument is the list that <span 
class="pcrr8t-x-x-109">LIEPDE </span>returns without its ﬁrst
element (the unsolved conditions). An example is given below.
</p><!--l. 554--><p class="noindent" >What <span 
class="pcrr8t-x-x-109">APPLYSYM </span>returns depends on the last performed modus. After modus 1 the
return is <br 
class="newline" />{{<span 
class="ptmri8t-x-x-109">newde</span>, <span 
class="ptmri8t-x-x-109">newfun</span>, <span 
class="ptmri8t-x-x-109">newvar</span>}, <span 
class="ptmri8t-x-x-109">trafo</span>} <br 
class="newline" />where </p>
     <ul class="itemize1">
     <li class="itemize">
     <!--l. 559--><p class="noindent" ><span 
class="ptmri8t-x-x-109">newde </span>lists the transformed equation(s)
     </p></li>
     <li class="itemize">
     <!--l. 560--><p class="noindent" ><span 
class="ptmri8t-x-x-109">newfun </span>lists the new function name(s)
     </p></li>
     <li class="itemize">
     <!--l. 561--><p class="noindent" ><span 
class="ptmri8t-x-x-109">newvar </span>lists the new variable name(s)
                                                                     

                                                                     
     </p></li>
     <li class="itemize">
     <!--l. 562--><p class="noindent" ><span 
class="ptmri8t-x-x-109">trafo </span>lists the transformations \(x^i=x^i(v^j,u^\beta ), y^\alpha =y^\alpha (v^j,u^\beta )\)</p></li></ul>
<!--l. 565--><p class="noindent" >After modus 2, <span 
class="pcrr8t-x-x-109">APPLYSYM </span>returns the generalized special solution.
</p>
<h5 class="subsubsectionHead"><a 
 id="x164-31600020.1.2"></a>Example: A second order ODE</h5>
<a 
 id="dx164-316001"></a>
<!--l. 569--><p class="noindent" >Weyl’s class of solutions of Einsteins ﬁeld equations consists of axialsymmetric time
independent metrics of the form \begin {equation}  {\mathrm {d}} s^2 = e^{-2 U} \left [ e^{2 k} \left ( \mathrm {d} \rho ^2 + \mathrm {d} z^2 \right )+\rho ^2 \mathrm {d} \varphi ^2 \right ] - e^{2 U} \mathrm {d} t^2,  \end {equation}
where \(U\) and \(k\) are functions of \(\rho \) and \(z\). If one is interested in generalizing these solutions to
have a time dependence then the resulting DEs can be transformed such that one longer
third order ODE for \(U\) results which contains only \(\rho \) derivatives <span class="cite">[<a 
href="manualap2.html#XMarkus">Kub</a>]</span>. Because \(U\) appears not
alone but only as derivative, a substitution \begin {equation}  g = dU/d\rho \label {g1dgl}  \end {equation}
lowers the order and the introduction of a function \begin {equation}  h = \rho g - 1 \label {g2dgl}  \end {equation}
simpliﬁes the ODE to \begin {equation}  0 = 3\rho ^2h\,h'' -5\rho ^2\,h'^2+5\rho \,h\,h'-20\rho \,h^3h'-20\,h^4+16\,h^6+4\,h^2. \label {hdgl}  \end {equation}
where \('= d/d\rho \). Calling <span 
class="pcrr8t-x-x-109">LIEPDE </span>through
                                                                     

                                                                     
</p>
<pre class="verbatim" id="verbatim-575">
depend h,r;
prob:={{-20*h**4+16*h**6+3*r**2*h*df(h,r,2)+5*r*h*df(h,r)
        -20*h**3*r*df(h,r)+4*h**2-5*r**2*df(h,r)**2},
       {h}, {r}};
sym:=liepde(prob, {&#x0022;point&#x0022;},{},{});
end; 
</pre>
<!--l. 600--><p class="nopar" > gives
                                                                     

                                                                     
</p>
<pre class="verbatim" id="verbatim-576">
                          3                       2
sym := {{}, {xi_r= - c10*r  - c11*r, eta_h=c10*h*r }, {c10,c11}}.
</pre>
<!--l. 604--><p class="nopar" > All conditions have been solved because the ﬁrst element of <span 
class="pcrr8t-x-x-109">sym </span>is \(\{\}\). The two existing
symmetries are therefore \begin {equation}  - \rho ^3 \partial _{\rho } + h \rho ^2 \,\partial _{h} \;\;\;\;\;\;\mbox {and} \;\;\;\;\;\;\rho \partial _{\rho }.  \end {equation}
Corresponding ﬁnite transformations can be calculated with <span 
class="pcrr8t-x-x-109">APPLYSYM </span>through
                                                                     

                                                                     
</p>
<pre class="verbatim" id="verbatim-577">
newde:=applysym(prob,rest sym);
</pre>
<!--l. 615--><p class="nopar" > The interactive session is given below with the user input following the prompt
‘<span 
class="pcrr8t-x-x-109">Input:3:</span>’ or following ‘?’. (Empty lines have been deleted.)
                                                                     

                                                                     
</p>
<pre class="verbatim" id="verbatim-578">
Do you want to find similarity and symmetry variables (enter ‘1;’)
or generalize a special solution with new parameters  (enter ‘2;’)
or exit the program                                   (enter  ‘;’)
Input:3: 1;
</pre>
<!--l. 623--><p class="nopar" > We enter ‘1;’ because we want to reduce dependencies by ﬁnding similarity variables
and one symmetry variable and then doing the transformation such that the symmetry
variable does not explicitly occur in the DE.
                                                                     

                                                                     
</p>
<pre class="verbatim" id="verbatim-579">
----------------------   The 1.  symmetry is:
         3
xi_r= - r
         2
eta_h=h*r
----------------------   The 2.  symmetry is:
xi_r= - r
----------------------
Which single symmetry or linear combination of symmetries
do you want to apply?
Enter an expression with ‘sy_(i)’ for the i’th symmetry.
sy_(1);
</pre>
<!--l. 640--><p class="nopar" > We could have entered ‘sy_(2);’ or a combination of both as well with the calculation
running then diﬀerently.
                                                                     

                                                                     
</p>
<pre class="verbatim" id="verbatim-580">
The symmetry to be applied in the following is
          3          2
{xi_r= - r ,eta_h=h*r }
Enter the name of the new dependent variables:
Input:3: u;
Enter the name of the new independent variables:
Input:3: v;
</pre>
<!--l. 652--><p class="nopar" > This was the input part, now the real calculation starts.
                                                                     

                                                                     
</p>
<pre class="verbatim" id="verbatim-581">
The ODE/PDE (-system) under investigation is :
                   2            2  2               3
0 = 3*df(h,r,2)*h*r  - 5*df(h,r) *r  - 20*df(h,r)*h *r
                           6       4      2
     + 5*df(h,r)*h*r + 16*h  - 20*h  + 4*h
for the function(s) : h.
It will be looked for a new dependent variable u
and an independent variable v such that the transformed
de(-system) does not depend on u or v.
1. Determination of the similarity variable
                           2
The quasilinear PDE:  0 = r *(df(u_,h)*h - df(u_,r)*r).
The equivalent characteristic system:
               3
0= - df(u_,r)*r
      2
0= - r *(df(h,r)*r + h)
for the functions: h(r)  u_(r).
</pre>
<!--l. 673--><p class="nopar" > The PDE is equation (\ref {ql2}).
                                                                     

                                                                     
</p>
<pre class="verbatim" id="verbatim-582">
The general solution of the PDE is given through
0 = ff(u_,h*r)
with arbitrary function ff(..).
A suggestion for this function ff provides:
0 =  - h*r + u_
Do you like this choice? (Y or N)
?y
</pre>
<!--l. 684--><p class="nopar" >
For the following calculation only a single special solution of the PDE is necessary and
this has to be speciﬁed from the general solution by choosing a special function <span 
class="pcrr8t-x-x-109">ff</span>.
(This function is called <span 
class="pcrr8t-x-x-109">ff </span>to prevent a clash with names of user variables/functions.) In
principle any choice of <span 
class="pcrr8t-x-x-109">ff </span>would work, if it deﬁnes a non-singular coordinate
transformation, i.e. here \(r\) must be a function of \(u\_\). If we have \(q\) independent variables and \(p\)
functions of them then <span 
class="pcrr8t-x-x-109">ff </span>has \(p+q\) arguments. Because of the condition \(0 = \)<span 
class="pcrr8t-x-x-109">ff </span>one has
essentially the freedom of choosing a function of \(p+q-1\) arguments freely. This freedom is also
necessary to select \(p+q-1\) diﬀerent functions <span 
class="pcrr8t-x-x-109">ff </span>and to ﬁnd as many functionally
independent solutions \(u\_\) which all become the new similarity variables. \(q\) of them become
the new functions \(u^\alpha \) and \(p-1\) of them the new variables \(v^2,\ldots ,v^p\). Here we have \(p=q=1\) (one single
ODE).
</p><!--l. 701--><p class="noindent" >Though the program could have done that alone, once the general solution <span 
class="pcrr8t-x-x-109">ff(..) </span>is
known, the user can interfere here to enter a simpler solution, if possible.
                                                                     

                                                                     
</p>
<pre class="verbatim" id="verbatim-583">
2. Determination of the symmetry variable
                                      2             3
The quasilinear PDE:  0 = df(u_,h)*h*r  - df(u_,r)*r  - 1.
The equivalent characteristic system:
              3
0=df(r,u_) + r
                2
0=df(h,u_) - h*r
for the functions: r(u_)  h(u_)  .
New attempt with a different independent variable
The equivalent characteristic system:
              2
0=df(u_,h)*h*r  - 1
   2
0=r *(df(r,h)*h + r)
for the functions: r(h)  u_(h)  .
The general solution of the PDE is given through
                  2  2       2
             - 2*h *r *u_ + h
0 = ff(h*r,--------------------)
                    2
with arbitrary function ff(..).
A suggestion for this function ff(..) yields:
      2        2
     h *( - 2*r *u_ + 1)
0 = ---------------------
              2
Do you like this choice? (Y or N)
?y
</pre>
<!--l. 734--><p class="nopar" > Similar to above.
                                                                     

                                                                     
</p>
<pre class="verbatim" id="verbatim-584">
The suggested solution of the algebraic system which will
do the transformation is:
                        sqrt(v)*sqrt(2)
{h=sqrt(v)*sqrt(2)*u,r=-----------------}
                              2*v
Is the solution ok? (Y or N)
?y
In the intended transformation shown above the dependent
variable is u and the independent variable is v.
The symmetry variable is v, i.e. the transformed expression
will be free of v.
Is this selection of dependent and independent variables ok? (Y or N)
?n
</pre>
<!--l. 750--><p class="nopar" > We so far assumed that the symmetry variable is one of the new variables, but, of
course we also could choose it to be one of the new functions. If it is one of
the functions then only derivatives of this function occur in the new DE, not
the function itself. If it is one of the variables then this variable will not occur
explicitly.
</p><!--l. 757--><p class="noindent" >In our case we prefer (without strong reason) to have the function as symmetry variable.
We therefore answered with ‘no’. As a consequence, \(u\) and \(v\) will exchange names such
that still all new functions have the name \(u\) and the new variables have name
\(v\):
                                                                     

                                                                     
</p>
<pre class="verbatim" id="verbatim-585">
Please enter a list of substitutions. For example, to
make the variable, which is so far call u1, to an
independent variable v2 and the variable, which is
so far called v2, to an dependent variable u1,
enter: ‘{u1=v2, v2=u1};’
Input:3: {u=v,v=u};

The transformed equation which should be free of u:
                            3  6             2  3
0=3*df(u,v,2)*v - 16*df(u,v) *v  - 20*df(u,v) *v  + 5*df(u,v)
Do you want to find similarity and symmetry variables (enter ‘1;’)
or generalize a special solution with new parameters  (enter ‘2;’)
or exit the program                                   (enter  ‘;’)
Input:3: ;
</pre>
<!--l. 776--><p class="nopar" > We stop here. The following is returned from our <span 
class="pcrr8t-x-x-109">APPLYSYM </span>call:
                                                                     

                                                                     
</p>
<pre class="verbatim" id="verbatim-586">
                             3  6             2  3
{{{3*df(u,v,2)*v - 16*df(u,v) *v  - 20*df(u,v) *v + 5*df(u,v)},
  {u},
  {v}},
     sqrt(u)*sqrt(2)
 {r=-----------------, h=sqrt(u)*sqrt(2)*v }}
           2*u
</pre>
<!--l. 787--><p class="nopar" >
The use of <span 
class="pcrr8t-x-x-109">APPLYSYM </span>eﬀectively provided us the ﬁnite transformation \begin {equation}  \rho =(2\,u)^{-1/2},\;\;\;\;\;h=(2\,u)^{1/2}\,v \label {trafo1}.  \end {equation}
and the new ODE \begin {equation}  0 = 3u''v - 16u'^3v^6 - 20u'^2v^3 + 5u' \label {udgl}  \end {equation}
where \(u=u(v)\) and \('=d/dv.\) Using one symmetry we reduced the 2. order ODE (\ref {hdgl}) to a ﬁrst order ODE
(\ref {udgl}) for \(u'\) plus one integration. The second symmetry can be used to reduce the
remaining ODE to an integration too by introducing a variable \(w\) through \(v^3d/dv = d/dw\), i.e. \(w = -1/(2v^2)\). With
\begin {equation}  p=du/dw \label {udot}  \end {equation}
the remaining ODE is \[0 = 3\,w\,\frac {dp}{dw} + 2\,p\,(p+1)(4\,p+1) \] with solution \[ \tilde {c}w^{-2}/4 = \tilde {c}v^4 = \frac {p^3(p+1)}{(4\,p+1)^4},\;\;\; \tilde {c}=const. \] Writing (\ref {udot}) as \(p = v^3(du/dp)/(dv/dp)\) we get \(u\) by integration and with (\ref {trafo1})
further a parametric solution for \(\rho ,h\): \begin {align}  \rho &amp; = \left (\frac {3c_1^2(2p-1)}{p^{1/2}(p+1)^{1/2}}+c_2\right )^{-1/2} \\ h &amp; = \frac {(c_2p^{1/2}(p+1)^{1/2}+6c_1^2p-3c_1^2)^{1/2}p^{1/2}}{c_1(4p+1)}  \end {align}
</p><!--l. 818--><p class="noindent" >where \(c_1, c_2 = const.\) and \(c_1=\tilde {c}^{1/4}.\) Finally, the metric function \(U(p)\) is obtained as an integral from (\ref {g1dgl}),(\ref {g2dgl}).
</p>
<h5 class="subsubsectionHead"><a 
 id="x164-31700020.1.2"></a>Limitations of <span 
class="pcrr8t-x-x-109">APPLYSYM</span></h5>
<!--l. 822--><p class="noindent" >Restrictions of the applicability of the program <span 
class="pcrr8t-x-x-109">APPLYSYM </span>result from limitations of the
program <span 
class="pcrr8t-x-x-109">QUASILINPDE </span>described in a section below. Essentially this means that
symmetry generators may only be polynomially non-linear in \(x^i, y^\alpha \). Though even then the
solvability can not be guaranteed, the generators of Lie-symmetries are mostly very
simple such that the resulting PDE (\ref {PDE}) and the corresponding characteristic ODE-system
have good chances to be solvable.
</p><!--l. 831--><p class="noindent" >Apart from these limitations implied through the solution of diﬀerential equations with
<span 
class="pcrr8t-x-x-109">CRACK </span>and algebraic equations with <span 
class="pcrr8t-x-x-109">SOLVE </span>the program <span 
class="pcrr8t-x-x-109">APPLYSYM </span>itself is free of
restrictions, i.e. if once new versions of <span 
class="pcrr8t-x-x-109">CRACK, SOLVE </span>would be available then
<span 
class="pcrr8t-x-x-109">APPLYSYM </span>would not have to be changed.
</p><!--l. 837--><p class="noindent" >Currently, whenever a computational step could not be performed the user is informed
and has the possibility of entering interactively the solution of the unsolved algebraic
system or the unsolved linear PDE.
                                                                     

                                                                     
</p>
<h4 class="subsectionHead"><span class="titlemark">20.1.3    </span> <a 
 id="x164-31800020.1.3"></a>Solving quasilinear PDEs</h4>
<!--l. 843--><p class="noindent" >
</p>
<h5 class="subsubsectionHead"><a 
 id="x164-31900020.1.3"></a>The content of <span 
class="pcrr8t-x-x-109">QUASILINPDE</span></h5>
<a 
 id="dx164-319001"></a>
<!--l. 845--><p class="noindent" >The generalization of special solutions of DEs as well as the computation of similarity
and symmetry variables involve the general solution of single ﬁrst order linear PDEs.
The procedure <span 
class="pcrr8t-x-x-109">QUASILINPDE </span>is a general procedure aiming at the general solution of
PDEs \begin {equation}  a_1(w_i,\phi )\phi _{w_1} + a_2(w_i,\phi )\phi _{w_2} + \ldots + a_n(w_i,\phi )\phi _{w_n} = b(w_i,\phi ) \label {PDE}  \end {equation}
in \(n\) independent variables \(w_i, i=1\ldots n\) for one unknown function \(\phi =\phi (w_i)\).
     </p><ol  class="enumerate1" >
<li 
  class="enumerate" id="x164-319003x1">
     <!--l. 859--><p class="noindent" >The ﬁrst step in solving a quasilinear PDE (\ref {PDE}) is the formulation of the
     corresponding characteristic ODE-system \begin {align}  \frac {dw_i}{d\varepsilon } &amp; = a_i(w_j,\phi ) \label {char1} \\ \frac {d\phi }{d\varepsilon } &amp; = b(w_j,\phi ) \label {char2}  \end {align}
     </p><!--l. 865--><p class="noindent" >for \(\phi , w_i\) regarded now as functions of one variable \(\varepsilon \).
     </p><!--l. 867--><p class="noindent" >Because the \(a_i\) and \(b\) do not depend explicitly on \(\varepsilon \), one of the equations (\ref {char1}),(\ref {char2}) with
     non-vanishing right hand side can be used to divide all others through it and by
     that having a system with one less ODE to solve. If the equation to divide through
     is one of (\ref {char1}) then the remaining system would be \begin {align}  \frac {dw_i}{dw_k} &amp; = \frac {a_i}{a_k} , \;\;\;i=1,2,\ldots k-1,k+1,\ldots n \label {char3} \\ \frac {d\phi }{dw_k} &amp; = \frac {b}{a_k} \label {char4}  \end {align}
     </p><!--l. 878--><p class="noindent" >with the independent variable \(w_k\) instead of \(\varepsilon \). If instead we divide through equation (\ref {char2})
     then the remaining system would be \[ \frac {dw_i}{d\phi } = \frac {a_i}{b} , \;\;\;i=1,2,\ldots n \label {char3a} \] with the independent variable \(\phi \) instead of
     \(\varepsilon \).
     </p><!--l. 887--><p class="noindent" >The equation to divide through is chosen by a subroutine with a heuristic to ﬁnd
     the “simplest” non-zero right hand side (\(a_k\) or \(b\)), i.e. one which </p>
          <ul class="itemize1">
          <li class="itemize">
          <!--l. 891--><p class="noindent" >is constant or
          </p></li>
          <li class="itemize">
          <!--l. 892--><p class="noindent" >depends only on one variable or
                                                                     

                                                                     
          </p></li>
          <li class="itemize">
          <!--l. 893--><p class="noindent" >is a product of factors, each of which depends only on one variable.</p></li></ul>
     <!--l. 897--><p class="noindent" >One purpose of this division is to reduce the number of ODEs by one. Secondly,
     the general solution of (\ref {char1}), (\ref {char2}) involves an additive constant to \(\varepsilon \) which is not relevant
     and would have to be set to zero. By dividing through one ODE we eliminate \(\varepsilon \) and
     lose the problem of identifying this constant in the general solution before we
     would have to set it to zero.
     </p></li>
<li 
  class="enumerate" id="x164-319005x2">
     <!--l. 905--><p class="noindent" >To solve the system (\ref {char3}), (\ref {char4}) or (\ref {char3a}), the procedure <span 
class="pcrr8t-x-x-109">CRACK </span>is called. Although being
     designed primarily for the solution of overdetermined PDE-systems, <span 
class="pcrr8t-x-x-109">CRACK</span>
     can also be used to solve simple not overdetermined ODE-systems. This
     solution process is not completely algorithmic. Improved versions of
     <span 
class="pcrr8t-x-x-109">CRACK </span>could be used, without making any changes of <span 
class="pcrr8t-x-x-109">QUASILINPDE</span>
     necessary.
     </p><!--l. 914--><p class="noindent" >If the characteristic ODE-system can not be solved in the form (\ref {char3}), (\ref {char4}) or
     (\ref {char3a}) then successively all other ODEs of (\ref {char1}), (\ref {char2}) with non-vanishing right
     hand side are used for division until one is found such that the resulting
     ODE-system can be solved completely. Otherwise the PDE can not be solved by
     <span 
class="pcrr8t-x-x-109">QUASILINPDE</span>.
     </p></li>
<li 
  class="enumerate" id="x164-319007x3">
     <!--l. 923--><p class="noindent" >If the characteristic ODE-system (\ref {char1}), (\ref {char2}) has been integrated completely and in full
     generality to the implicit solution \begin {equation}  0 = G_i(\phi , w_j, c_k, \varepsilon ),\;\; i,k=1,\ldots ,n+1,\;\;j=1,\ldots ,n \label {charsol1}  \end {equation}
     then according to the general theory for solving ﬁrst order PDEs, \(\varepsilon \) has to be
     eliminated from one of the equations and to be substituted in the others to have left
     \(n\) equations. Also the constant that turns up additively to \(\varepsilon \) is to be set to zero.
     Both tasks are automatically fulﬁlled, if, as described above, \(\varepsilon \) is already
     eliminated from the beginning by dividing all equations of (\ref {char1}), (\ref {char2}) through one of
     them.
     </p><!--l. 940--><p class="noindent" >On either way one ends up with \(n\) equations \begin {equation}  0=g_i(\phi ,w_j,c_k),\;\;i,j,k=1\ldots n \label {charsol2}  \end {equation}
     involving \(n\) constants \(c_k\).
     </p><!--l. 946--><p class="noindent" >The ﬁnal step is to solve (\ref {charsol2}) for the \(c_i\) to obtain \begin {equation}  c_i = c_i(\phi , w_1,\ldots ,w_n) \;\;\;\;\;i=1,\ldots n . \label {cons}  \end {equation}
     The ﬁnal solution \(\phi = \phi (w_i)\) of the PDE (\ref {PDE}) is then given implicitly through \[ 0 = F(c_1(\phi ,w_i),c_2(\phi ,w_i),\ldots ,c_n(\phi ,w_i)) \] where \(F\) is an
     arbitrary function with \(n\) arguments.</p></li></ol>
                                                                     

                                                                     
<!--l. 956--><p class="noindent" >
</p>
<h5 class="subsubsectionHead"><a 
 id="x164-32000020.1.3"></a>Syntax</h5>
<!--l. 957--><p class="noindent" >The call of <span 
class="pcrr8t-x-x-109">QUASILINPDE </span>is <br 
class="newline" /><span 
class="pcrr8t-x-x-109">QUASILINPDE</span>(<span 
class="ptmri8t-x-x-109">de</span>, <span 
class="ptmri8t-x-x-109">fun</span>, <span 
class="ptmri8t-x-x-109">varlist</span>); </p>
     <ul class="itemize1">
     <li class="itemize">
     <!--l. 961--><p class="noindent" ><span 
class="ptmri8t-x-x-109">de </span>is the diﬀerential expression which vanishes due to the PDE <span 
class="ptmri8t-x-x-109">de</span>\(\; = 0\) or, <span 
class="ptmri8t-x-x-109">de </span>may
     be the diﬀerential equation itself in the form \(\;\;\ldots = \ldots \;\;\).
     </p></li>
     <li class="itemize">
     <!--l. 965--><p class="noindent" ><span 
class="ptmri8t-x-x-109">fun </span>is the unknown function.
     </p></li>
     <li class="itemize">
     <!--l. 967--><p class="noindent" ><span 
class="ptmri8t-x-x-109">varlist </span>is the list of variables of <span 
class="ptmri8t-x-x-109">fun</span>.</p></li></ul>
<!--l. 969--><p class="noindent" >The result of <span 
class="pcrr8t-x-x-109">QUASILINPDE </span>is a list of general solutions \[ \{\textit {sol}_1, \textit {sol}_2, \ldots \}. \] If <span 
class="pcrr8t-x-x-109">QUASILINPDE </span>can not
solve the PDE then it returns \(\{\}\). Each solution \(\textit {sol}_i\) is a list of expressions \[ \{\textit {ex}_1, \textit {ex}_2, \ldots \} \] such that the
dependent function (\(\phi \) in (\ref {PDE})) is determined implicitly through an arbitrary function \(F\) and the
algebraic equation \[ 0 = F(\textit {ex}_1, \textit {ex}_2, \ldots ). \]
</p>
<h5 class="subsubsectionHead"><a 
 id="x164-32100020.1.3"></a>Examples</h5>
<!--l. 979--><p class="noindent" ><span 
class="ptmri8t-x-x-109">Example 1:</span><br 
class="newline" />To solve the quasilinear ﬁrst order PDE \[1 = xu,_x + uu,_y - zu,_z\] for the function \(u = u(x,y,z),\) the input would be
                                                                     

                                                                     
</p>
<pre class="verbatim" id="verbatim-587">
depend u,x,y,z;
de:=x*df(u,x)+u*df(u,y)-z*df(u,z) - 1;
varlist:={x,y,z};
QUASILINPDE(de,u,varlist);
</pre>
<!--l. 988--><p class="nopar" >
In this example the procedure returns \[\{ \{ x/e^u, ze^u, u^2 - 2y \} \},\] i.e. there is one general solution (because the outer
list has only one element which itself is a list) and \(u\) is given implicitly through the
algebraic equation \[ 0 = F(x/e^u, ze^u, u^2 - 2y)\] with arbitrary function \(F.\) <br 
class="newline" /><span 
class="ptmri8t-x-x-109">Example 2:</span><br 
class="newline" />For the linear inhomogeneous PDE \[ 0 = y z,_x + x z,_y - 1, \;\;\;\;\mbox {for}\;\;\;\;z=z(x,y)\] <span 
class="pcrr8t-x-x-109">QUASILINPDE </span>returns the result that for an
arbitrary function \(F,\) the equation \[ 0 = F\left (\frac {x+y}{e^z},e^z(x-y)\right ) \] deﬁnes the general solution for \(z\). <br 
class="newline" /><span 
class="ptmri8t-x-x-109">Example 3:</span><br 
class="newline" />For the linear inhomogeneous PDE (3.8) from <span class="cite">[<a 
href="manualap2.html#XKamke:Vol2">Kam59</a>]</span> \[ 0 = x w,_x + (y+z)(w,_y - w,_z), \;\;\;\;\mbox {for}\;\;\;\;w=w(x,y,z)\] <span 
class="pcrr8t-x-x-109">QUASILINPDE </span>returns the
result that for an arbitrary function \(F,\) the equation \[ 0 = F\left (w, \;y+z, \;\ln (x)(y+z)-y\right ) \] deﬁnes the general solution for \(w\), i.e. for
any function \(f\) \[ w = f\left (y+z, \;\ln (x)(y+z)-y\right ) \] solves the PDE.
</p>
<h5 class="subsubsectionHead"><a 
 id="x164-32200020.1.3"></a>Limitations of <span 
class="pcrr8t-x-x-109">QUASILINPDE</span></h5>
<!--l. 1015--><p class="noindent" >One restriction on the applicability of <span 
class="pcrr8t-x-x-109">QUASILINPDE </span>results from the program <span 
class="pcrr8t-x-x-109">CRACK</span>
which tries to solve the characteristic ODE-system of the PDE. So far <span 
class="pcrr8t-x-x-109">CRACK </span>can be
applied only to polynomially non-linear DE’s, i.e. the characteristic ODE-system (\ref {char3}),(\ref {char4}) or
(\ref {char3a}) may only be polynomially non-linear, i.e. in the PDE (\ref {PDE}) the expressions \(a_i\) and \(b\) may only
be rational in \(w_j,\phi \).
</p><!--l. 1023--><p class="noindent" >The task of <span 
class="pcrr8t-x-x-109">CRACK </span>is simpliﬁed as (\ref {charsol1}) does not have to be solved for \(w_j, \phi \). On the other hand
(\ref {charsol1}) has to be solved for the \(c_i\). This gives a second restriction coming from the REDUCE
function <span 
class="pcrr8t-x-x-109">SOLVE</span>. Though <span 
class="pcrr8t-x-x-109">SOLVE </span>can be applied to polynomial and transzendential
equations, again no guarantee for solvability can be given.
</p>
<h4 class="subsectionHead"><span class="titlemark">20.1.4    </span> <a 
 id="x164-32300020.1.4"></a>Transformation of DEs</h4>
                                                                     

                                                                     
<!--l. 1033--><p class="noindent" >
</p>
<h5 class="subsubsectionHead"><a 
 id="x164-32400020.1.4"></a>The content of <span 
class="pcrr8t-x-x-109">DETRAFO</span></h5>
<a 
 id="dx164-324001"></a>
<!--l. 1035--><p class="noindent" >Finally, after having found the ﬁnite transformations, the program <span 
class="pcrr8t-x-x-109">APPLYSYM</span>
calls the procedure <span 
class="pcrr8t-x-x-109">DETRAFO </span>to perform the transformations. <span 
class="pcrr8t-x-x-109">DETRAFO </span>can
also be used alone to do point- or higher order transformations which involve a
considerable computational eﬀort if the diﬀerential order of the expression to
be transformed is high and if many dependent and independent variables are
involved. This might be especially useful if one wants to experiment and try out
diﬀerent coordinate transformations interactively, using <span 
class="pcrr8t-x-x-109">DETRAFO </span>as standalone
procedure.
</p><!--l. 1046--><p class="noindent" >To run <span 
class="pcrr8t-x-x-109">DETRAFO</span>, the old functions \(y^{\alpha }\) and old variables \(x^i\) must be known explicitly in terms
of algebraic or diﬀerential expressions of the new functions \(u^{\beta }\) and new variables \(v^j\). Then for
point transformations the identity \begin {align}  dy^{\alpha } &amp; = \left (y^{\alpha },_{v^i} + y^{\alpha },_{u^{\beta }}u^{\beta },_{v^i}\right ) dv^i \\ &amp; = y^{\alpha },_{x^j}dx^j \\ &amp; = y^{\alpha },_{x^j}\left (x^j,_{v^i} + x^j,_{u^{\beta }}u^{\beta },_{v^i}\right ) dv^i  \end {align}
</p><!--l. 1058--><p class="noindent" >provides the transformation \begin {equation}  y^{\alpha },_{x^j} = \frac {dy^\alpha }{dv^i}\cdot \left (\frac {dx^j}{dv^i}\right )^{-1} \label {trafo}  \end {equation}
with <span 
class="ptmri8t-x-x-109">det</span>\(\left (dx^j/dv^i\right ) \neq 0\) because of the regularity of the transformation which is checked by <span 
class="pcrr8t-x-x-109">DETRAFO</span>.
Non-regular transformations are not performed.
</p><!--l. 1067--><p class="noindent" ><span 
class="pcrr8t-x-x-109">DETRAFO </span>is not restricted to point transformations. In the case of contact- or higher
order transformations, the total derivatives \(dy^{\alpha }/dv^i\) and \(dx^j/dv^i\) then only include all \(v^i-\) derivatives of \(u^{\beta }\)
which occur in \begin {align*}  y^{\alpha } &amp;= y^{\alpha }(v^i,u^{\beta },u^{\beta },_{v^j},\ldots ) \\ x^k &amp;= x^k(v^i,u^{\beta },u^{\beta },_{v^j},\ldots ).  \end {align*}
</p><!--l. 1077--><p class="noindent" >
</p>
<h5 class="subsubsectionHead"><a 
 id="x164-32500020.1.4"></a>Syntax</h5>
<!--l. 1078--><p class="noindent" >The call of <span 
class="pcrr8t-x-x-109">DETRAFO </span>is
</p>
<div class="flushleft" 
>
<!--l. 1080--><p class="noindent" >
 <span 
class="pcrr8t-x-x-109">DETRAFO</span>({<span 
class="ptmri8t-x-x-109">ex</span>\(_1\), <span 
class="ptmri8t-x-x-109">ex</span>\(_2\), …, <span 
class="ptmri8t-x-x-109">ex</span>\(_m\)},<br />
                  {<span 
class="ptmri8t-x-x-109">ofun</span>\(_1=\)<span 
class="ptmri8t-x-x-109">fex</span>\(_1\), <span 
class="ptmri8t-x-x-109">ofun</span>\(_2=\)<span 
class="ptmri8t-x-x-109">fex</span>\(_2\), …,<span 
class="ptmri8t-x-x-109">ofun</span>\(_p=\)<span 
class="ptmri8t-x-x-109">fex</span>\(_p\)},<br />
                  {<span 
class="ptmri8t-x-x-109">ovar</span>\(_1=\)<span 
class="ptmri8t-x-x-109">vex</span>\(_1\), <span 
class="ptmri8t-x-x-109">ovar</span>\(_2=\)<span 
class="ptmri8t-x-x-109">vex</span>\(_2\), …, <span 
class="ptmri8t-x-x-109">ovar</span>\(_q=\)<span 
class="ptmri8t-x-x-109">vex</span>\(_q\)},<br />
                  {<span 
class="ptmri8t-x-x-109">nfun</span>\(_1\), <span 
class="ptmri8t-x-x-109">nfun</span>\(_2\), …, <span 
class="ptmri8t-x-x-109">nfun</span>\(_p\)},<br />
                  {<span 
class="ptmri8t-x-x-109">nvar</span>\(_1\), <span 
class="ptmri8t-x-x-109">nvar</span>\(_2\), …, <span 
class="ptmri8t-x-x-109">nvar</span>\(_q\)});</p></div>
                                                                     

                                                                     
<!--l. 1090--><p class="noindent" >where \(m,p,q\) are arbitrary. </p>
     <ul class="itemize1">
     <li class="itemize">
     <!--l. 1093--><p class="noindent" >The <span 
class="ptmri8t-x-x-109">ex</span>\(_i\) are diﬀerential expressions to be transformed.
     </p></li>
     <li class="itemize">
     <!--l. 1095--><p class="noindent" >The second list is the list of old functions <span 
class="ptmri8t-x-x-109">ofun </span>expressed as expressions <span 
class="ptmri8t-x-x-109">fex</span>
     in terms of new functions <span 
class="ptmri8t-x-x-109">nfun </span>and new independent variables <span 
class="ptmri8t-x-x-109">nvar</span>.
     </p></li>
     <li class="itemize">
     <!--l. 1099--><p class="noindent" >Similarly  the  third  list  expresses  the  old  independent  variables  <span 
class="ptmri8t-x-x-109">ovar  </span>as
     expressions  <span 
class="ptmri8t-x-x-109">vex  </span>in  terms  of  new  functions  <span 
class="ptmri8t-x-x-109">nfun  </span>and  new  independent
     variables <span 
class="ptmri8t-x-x-109">nvar</span>.
     </p></li>
     <li class="itemize">
     <!--l. 1103--><p class="noindent" >The  last  two  lists  include  the  new  functions  <span 
class="ptmri8t-x-x-109">nfun  </span>and  new  independent
     variables <span 
class="ptmri8t-x-x-109">nvar</span>.</p></li></ul>
<!--l. 1106--><p class="noindent" >Names for <span 
class="ptmri8t-x-x-109">ofun, ovar, nfun </span>and <span 
class="ptmri8t-x-x-109">nvar </span>can be arbitrarily chosen.
</p><!--l. 1109--><p class="noindent" >As the result <span 
class="pcrr8t-x-x-109">DETRAFO </span>returns the ﬁrst argument of its input, i.e. the list \[\{\textit {ex}_1, \textit {ex}_2, \ldots , \textit {ex}_m\}\] where all \(\textit {ex}_i\) are
transformed.
</p>
<h5 class="subsubsectionHead"><a 
 id="x164-32600020.1.4"></a>Limitations of <span 
class="pcrr8t-x-x-109">DETRAFO</span></h5>
<!--l. 1115--><p class="noindent" >The only requirement is that the old independent variables \(x^i\) and old functions \(y^\alpha \) must be
given explicitly in terms of new variables \(v^j\) and new functions \(u^\beta \) as indicated in the syntax.
Then all calculations involve only diﬀerentiations and basic algebra.
</p><!--l. 104--><p class="noindent" >
                                                                     

                                                                     
                                                                     

                                                                     
</p><!--l. 106--><p class="noindent" ><table cellspacing="5"><tr><td class="clinks"><a 
href="../manual-lookup.php%3FUser&#32;Contributed&#32;Packages.html#manualse124.html" >Up</a></td><td class="clinks"><a 
href="manualse125.html" >Next</a></td><td class="clinks"><a 
href="manualse124.html" >Front</a></td></tr></table><a 
 id="tailmanualse124.html"></a>   <hr> <p style="font-family:sans-serif">Hosted by <a href="https://sourceforge.net/p/reduce-algebra/"> <img title="Download REDUCE" alt="Download REDUCE" style="vertical-align:middle" src="https://sourceforge.net/sflogo.php?type=16&amp;group_id=248416"/></a> <a href="https://www.mathjax.org"> <img title="Powered by MathJax" alt="Powered by MathJax" style="float:right" src="https://www.mathjax.org/badge/badge.gif"/></a></p></p> 
</body> 
</html>