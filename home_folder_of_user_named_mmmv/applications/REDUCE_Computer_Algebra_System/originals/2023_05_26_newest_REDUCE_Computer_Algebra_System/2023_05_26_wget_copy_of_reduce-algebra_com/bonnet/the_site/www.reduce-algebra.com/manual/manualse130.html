<!DOCTYPE html> 
<html lang="en-US" xml:lang="en-US" > 
<head><title>CALI: A Package for Computational Commutative Algebra</title> 
<meta  charset="utf-8" /> 
<meta name="generator" content="TeX4ht (https://tug.org/tex4ht/)" /> 
<meta name="viewport" content="width=device-width,initial-scale=1" /> 
<link rel="stylesheet" type="text/css" href="manual.css" /> 
<meta name="src" content="manual.tex" /> 
<script>window.MathJax = { tex: { tags: "ams", }, }; </script> 
 <script type="text/javascript" async="async" id="MathJax-script" src="../../cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js"></script>  
<meta name="description" content="The REDUCE Computer Algebra System User's Manual" /> 
</head><body 
>
<header>REDUCE</header><table cellspacing="5"><tr><td class="clinks"><a 
href="../manual-lookup.php%3FUser&#32;Contributed&#32;Packages.html#manualse130.html" >Up</a></td><td class="clinks"><a 
href="manualse131.html" >Next</a></td><td class="clinks"><a 
href="manualse129.html" >Prev</a></td><td class="clinks"><a 
href="manualse129.html#tailmanualse129.html" >PrevTail</a></td><td class="clinks"><a 
href="manualse130.html#tailmanualse130.html">Tail</a></td></tr></table><h3 class="sectionHead"><span class="titlemark">20.7    </span> <a 
 id="x170-36200020.7"></a>CALI: A Package for Computational Commutative
Algebra</h3>
<a 
 id="dx170-362001"></a>
<a 
 id="dx170-362002"></a>
<!--l. 191--><p class="noindent" >Author: Hans-Gert Gräbe.
<a 
 id="dx170-362003"></a>
<a 
 id="dx170-362004"></a>
</p><!--l. 10--><p class="noindent" >Key words: aﬃne and projective monomial curves, aﬃne and projective sets of points,
analytic spread, associated graded ring, blowup, border bases, constructive commutative
algebra, dual bases, elimination, equidimensional part, extended Gröbner factorizer,
free resolution, Gröbner algorithms for ideals and module, Gröbner factorizer, ideal
and module operations, independent sets, intersections, lazy standard bases, local free
resolutions, local standard bases, minimal generators, minors, normal forms, pfaﬃans,
polynomial maps, primary decomposition, quotients, symbolic powers, symmetric
algebra, triangular systems, weighted Hilbert series, primality test, radical, unmixed
radical.
</p><!--l. 47--><p class="noindent" >
</p>
<h4 class="subsectionHead"><span class="titlemark">20.7.1    </span> <a 
 id="x170-36300020.7.1"></a>Introduction</h4>
<!--l. 49--><p class="noindent" >This package contains algorithms for computations in commutative algebra closely related to the
Gröbner algorithm for ideals and modules. Its heart is a new implementation of the Gröbner
algorithm<span class="footnote-mark"><a 
href="manual171.html#fn1x20"><sup class="textsuperscript">1</sup></a></span><a 
 id="x170-363001f1"></a> 
that allows the computation of syzygies, too. This implementation is also applicable to
submodules of free modules with generators represented as rows of a matrix.
</p><!--l. 58--><p class="noindent" >Moreover <span 
class="ptmrc8t-x-x-109">C<span 
class="small-caps">A</span><span 
class="small-caps">L</span><span 
class="small-caps">I</span> </span>contains facilities for local computations, using a modern implementation
of Mora’s standard basis algorithm, see <span class="cite">[<a 
href="manualap2.html#XMoraPfisterTraverso:92">MPT92</a>]</span> and <span class="cite">[<a 
href="manualap2.html#XGraebe:94">Grä94b</a>]</span>, that works for
arbitrary term orders. The full analogy between modules over the local ring
\(k[x_v:v\in H]_{\mathbf {m}}\) and homogeneous (in fact H-local) modules over \(k[x_v:v\in H]\) is reﬂected through the switch <a 
 id="dx170-363002"></a><a 
 id="dx170-363003"></a><a 
 id="dx170-363004"></a>. Turn it
                                                                     

                                                                     
on (Gröbner basis, the default) or oﬀ (local standard basis) to choose appropriate
algorithms automatically. In v. 2.2 we present an uniﬁed approach to both cases, using
reduction with bounded ecart for non Noetherian term orders, see <span class="cite">[<a 
href="manualap2.html#XGraebe:95a">Grä95a</a>]</span> for
details. This allows to have a common driver for the Gröbner algorithm in both
cases.
</p><!--l. 72--><p class="noindent" ><span 
class="ptmrc8t-x-x-109">C<span 
class="small-caps">A</span><span 
class="small-caps">L</span><span 
class="small-caps">I</span> </span>extends also the restricted term order facilities of the <span 
class="ptmrc8t-x-x-109">G<span 
class="small-caps">R</span><span 
class="small-caps">O</span><span 
class="small-caps">E</span><span 
class="small-caps">B</span><span 
class="small-caps">N</span><span 
class="small-caps">E</span><span 
class="small-caps">R</span> </span>package,
deﬁning term orders by degree vector lists, and the rigid implementation of the sugar
idea, by a more ﬂexible <span 
class="ptmri8t-x-x-109">ecart</span><a 
 id="dx170-363005"></a> vector, in particular useful for local computations, see
<span class="cite">[<a 
href="manualap2.html#XGraebe:94">Grä94b</a>]</span>.
</p><!--l. 79--><p class="noindent" >The package was designed mainly as a symbolic mode programming environment
extending the build-in facilities of REDUCE for the computational approach to problems
arising naturally in commutative algebra. An algebraic mode interface accesses (in a
more rigid frame) all important features implemented symbolically and thus should be
favored for short sample computations.
</p><!--l. 86--><p class="noindent" >On the other hand, tedious computations are strongly recommended to be done
symbolically since this allows considerably more ﬂexibility and avoids unnecessary
translations of intermediate results from <span 
class="ptmrc8t-x-x-109">C<span 
class="small-caps">A</span><span 
class="small-caps">L</span><span 
class="small-caps">I</span></span>’s internal data representation to the
algebraic mode and vice versa. Moreover, one can easily extend the package with new
symbolic mode scripts, or do more diﬃcult interactive computations. For all these
purposes the symbolic mode interface oﬀers substantially more facilities than the
algebraic one.
</p><!--l. 96--><p class="noindent" >For a detailed description of special symbolic mode procedures one should consult the
source code and the comments therein. In this manual we can give only a brief
description of the main ideas incorporated into the package <span 
class="ptmrc8t-x-x-109">C<span 
class="small-caps">A</span><span 
class="small-caps">L</span><span 
class="small-caps">I</span></span>. We concentrate on the
data structure design and the description of the more advanced algorithms. For sample
computations from several ﬁelds of commutative algebra the reader may consult also the
<span 
class="ptmri8t-x-x-109">cali.tst </span>ﬁle.
</p><!--l. 105--><p class="noindent" >As main topics <span 
class="ptmrc8t-x-x-109">C<span 
class="small-caps">A</span><span 
class="small-caps">L</span><span 
class="small-caps">I</span> </span>contains facilities for </p>
     <ul class="itemize1">
     <li class="itemize">
     <!--l. 107--><p class="noindent" >deﬁning rings, ideals and modules,
     </p></li>
     <li class="itemize">
     <!--l. 109--><p class="noindent" >computing Gröbner bases and local standard bases,
     </p></li>
     <li class="itemize">
     <!--l. 111--><p class="noindent" >computing syzygies, resolutions and (graded) Betti numbers,
                                                                     

                                                                     
     </p></li>
     <li class="itemize">
     <!--l. 113--><p class="noindent" >computing  (now  also  weighted)  Hilbert  series,  multiplicities,  independent
     sets, and dimensions,
     </p></li>
     <li class="itemize">
     <!--l. 116--><p class="noindent" >computing normal forms and representations,
     </p></li>
     <li class="itemize">
     <!--l. 118--><p class="noindent" >computing   sums,   products,   intersections,   quotients,   stable   quotients,
     elimination ideals etc.,
     </p></li>
     <li class="itemize">
     <!--l. 121--><p class="noindent" >primality tests, computation of radicals, unmixed radicals, equidimensional
     parts, primary decompositions etc. of ideals and modules,
     </p></li>
     <li class="itemize">
     <!--l. 125--><p class="noindent" >advanced applications of Gröbner bases (blowup, associated graded ring,
     analytic spread, symmetric algebra, monomial curves etc.),
     </p></li>
     <li class="itemize">
     <!--l. 128--><p class="noindent" >applications  of  linear  algebra  techniques  to  zero  dimensional  ideals,  as
     e.g. the FGLM change of term orders, border bases and aﬃne and projective
     ideals of sets of points,
     </p></li>
     <li class="itemize">
     <!--l. 132--><p class="noindent" >splitting  polynomial  systems  of  equations  mixing  factorization  and  the
     Gröbner  algorithm,  triangular  systems,  and  diﬀerent  versions  of  the
     extended Gröbner factorizer.
</p>
     </li></ul>
<!--l. 138--><p class="noindent" >Below we will use freely without further explanation the notions common for text books
and papers about constructive commutative algebra, assuming the reader to be familiar
with the corresponding ideas and concepts. For further references see e.g. the text books
<span class="cite">[<a 
href="manualap2.html#XBecker:93">BWK93</a>]</span>, <span class="cite">[<a 
href="manualap2.html#XCox:92">CLO92</a>]</span> and <span class="cite">[<a 
href="manualap2.html#XMishra:93">Mis93</a>]</span> or the survey papers <span class="cite">[<a 
href="manualap2.html#XBuchberger:85">Buc85</a>]</span>, <span class="cite">[<a 
href="manualap2.html#XBuchberger:88">Buc88</a>]</span> and
<span class="cite">[<a 
href="manualap2.html#XRobbiano:89">Rob89</a>]</span>.
                                                                     

                                                                     
</p>
<h5 class="subsubsectionHead"><a 
 id="x170-36400020.7.1"></a>Description of the Documents Distributed with <span 
class="ptmrc8t-x-x-109">C<span 
class="small-caps">A</span><span 
class="small-caps">L</span><span 
class="small-caps">I</span></span></h5>
<!--l. 147--><p class="noindent" >The <span 
class="ptmrc8t-x-x-109">C<span 
class="small-caps">A</span><span 
class="small-caps">L</span><span 
class="small-caps">I</span> </span>package contains the following ﬁles:
     </p><blockquote class="quote">
     <!--l. 149--><p class="noindent" >cali.chg
     </p><!--l. 151--><p class="noindent" >a detailed report of changes from v. 2.1 to v. 2.2. and 2.2.1
     </p><!--l. 153--><p class="noindent" >cali.log
     </p><!--l. 164--><p class="noindent" >the output ﬁle, that cali.tst should produce with
     </p><blockquote class="quote">
     <!--l. 164--><p class="noindent" ><span 
class="pcrr8t-x-x-109">load_package cali;</span>
     </p><!--l. 164--><p class="noindent" ><span 
class="pcrr8t-x-x-109">out &#x0022;logfile&#x0022;$</span>
     </p><!--l. 164--><p class="noindent" ><span 
class="pcrr8t-x-x-109">in &#x0022;cali.tst&#x0022;;</span>
     </p><!--l. 164--><p class="noindent" ><span 
class="pcrr8t-x-x-109">shut &#x0022;logfile&#x0022;$</span></p></blockquote>
     <!--l. 166--><p class="noindent" >cali.red
     </p><!--l. 168--><p class="noindent" >the <span 
class="ptmrc8t-x-x-109">C<span 
class="small-caps">A</span><span 
class="small-caps">L</span><span 
class="small-caps">I</span> </span>source ﬁle.
     </p><!--l. 170--><p class="noindent" >cali.tex
     </p><!--l. 172--><p class="noindent" >this manual.
     </p><!--l. 174--><p class="noindent" >cali.tst
     </p><!--l. 176--><p class="noindent" >a test ﬁle with various examples and applications of <span 
class="ptmrc8t-x-x-109">C<span 
class="small-caps">A</span><span 
class="small-caps">L</span><span 
class="small-caps">I</span></span>.
</p>
     </blockquote>
<!--l. 180--><p class="noindent" ><span 
class="ptmrc8t-x-x-109">C<span 
class="small-caps">A</span><span 
class="small-caps">L</span><span 
class="small-caps">I</span> </span>should be loaded via
                                                                     

                                                                     
</p>
<pre class="verbatim" id="verbatim-690">
    load_package cali;
</pre>
<!--l. 193--><p class="nopar" > Upon successful loading <span 
class="ptmrc8t-x-x-109">C<span 
class="small-caps">A</span><span 
class="small-caps">L</span><span 
class="small-caps">I</span> </span>responds with a message containing the version number
and the last update of the distribution.
</p>
<div class="center" 
>
<!--l. 197--><p class="noindent" >
</p>
<div class="fbox">Feel free to contact me by email if You have problems to get <span 
class="ptmrc8t-x-x-109">C<span 
class="small-caps">A</span><span 
class="small-caps">L</span><span 
class="small-caps">I</span> </span>started.
Also comments, hints, bug reports etc. are welcome.                     </div>
</div>
<!--l. 203--><p class="noindent" >
</p>
<h5 class="subsubsectionHead"><a 
 id="x170-36500020.7.1"></a>CALI’s Language Concept</h5>
<!--l. 205--><p class="noindent" >From a certain point of view one of the major disadvantage of the current RLISP (and the
underlying Lisp) language is the fact that it supports modularity and data encapsulation
only in a rudimentary way. Since all parts of code loaded into a session are visible all the
time, name conﬂicts between diﬀerent packages may occur, will occur (even not issuing
a warning message), and are hard to prevent, since packages are developed (and are
still developing) by diﬀerent research groups at diﬀerent places and diﬀerent
time.
</p><!--l. 214--><p class="noindent" >A (yet rudimentary) concept of REDUCE packages and modules indicates the direction
into what the REDUCE designers are looking for a solution for this general problem.
</p><!--l. 219--><p class="noindent" ><span 
class="ptmrc8t-x-x-109">C<span 
class="small-caps">A</span><span 
class="small-caps">L</span><span 
class="small-caps">I</span> </span>(2.0 and higher) follows a name concept for internal procedures to mimick data
encapsulation at a semantical level. We hope this way on the one hand to resolve the
conﬂicts described above at least for the internal part of <span 
class="ptmrc8t-x-x-109">C<span 
class="small-caps">A</span><span 
class="small-caps">L</span><span 
class="small-caps">I</span> </span>and on the other hand to
anticipate a desirable future and already foregoing development of REDUCE towards a
                                                                     

                                                                     
true modularity.
</p><!--l. 226--><p class="noindent" >The package <span 
class="ptmrc8t-x-x-109">C<span 
class="small-caps">A</span><span 
class="small-caps">L</span><span 
class="small-caps">I</span> </span>is divided into several modules, each of them introducing either a
single new data type together with basic facilities, constructors, and selectors or a
collection of algorithms subject to a common problem. Each module contains
<span 
class="ptmri8t-x-x-109">internal procedures</span><a 
 id="dx170-365001"></a>, conceptually hidden by this module, <span 
class="ptmri8t-x-x-109">local procedures</span><a 
 id="dx170-365002"></a>,
designed for a <span 
class="ptmrc8t-x-x-109">C<span 
class="small-caps">A</span><span 
class="small-caps">L</span><span 
class="small-caps">I</span> </span>wide use, and <span 
class="ptmri8t-x-x-109">global procedures</span><a 
 id="dx170-365003"></a>, exported by <span 
class="ptmrc8t-x-x-109">C<span 
class="small-caps">A</span><span 
class="small-caps">L</span><span 
class="small-caps">I</span> </span>into the
general (algebraic or symbolic) environment of REDUCE. A header <span 
class="ptmri8t-x-x-109">module</span>
<span 
class="ptmri8t-x-x-109">cali</span><a 
 id="dx170-365004"></a> contains all (ﬂuid) global variables and switches deﬁned by the package
<span 
class="ptmrc8t-x-x-109">C<span 
class="small-caps">A</span><span 
class="small-caps">L</span><span 
class="small-caps">I</span></span>.
</p><!--l. 237--><p class="noindent" >Along these lines the <span 
class="ptmrc8t-x-x-109">C<span 
class="small-caps">A</span><span 
class="small-caps">L</span><span 
class="small-caps">I</span> </span>procedures available in symbolic mode are divided into three
types with the following naming convention:
     </p><blockquote class="quote">
     <!--l. 240--><p class="noindent" ><span 
class="pcrr8t-x-x-109">module!=procedure</span>
     </p><!--l. 242--><p class="noindent" >internal to the given module.
     </p><!--l. 244--><p class="noindent" ><span 
class="pcrr8t-x-x-109">module\procedure</span>
     </p><!--l. 246--><p class="noindent" >exported by the given module into the local <span 
class="ptmrc8t-x-x-109">C<span 
class="small-caps">A</span><span 
class="small-caps">L</span><span 
class="small-caps">I</span> </span>environment.
     </p><!--l. 248--><p class="noindent" ><span 
class="pcrr8t-x-x-109">procedure!*</span>
     </p><!--l. 252--><p class="noindent" >a   global   procedure   usually   having   a   semantically   equivalent   procedure
(possibly  with  another  parameter  list)  without  trailing  asterisk  in  algebraic
mode.</p></blockquote>
<!--l. 254--><p class="noindent" >There are also symbolic mode equivalents without trailing asterisk, if the algebraic
procedure is not a <span 
class="ptmri8t-x-x-109">psopfn</span>, but a <span 
class="ptmri8t-x-x-109">symbolic operator</span>. They transfer data to <span 
class="ptmrc8t-x-x-109">C<span 
class="small-caps">A</span><span 
class="small-caps">L</span><span 
class="small-caps">I</span></span>’s internal
structure and call the corresponding procedure with trailing asterisk. <span 
class="ptmrc8t-x-x-109">C<span 
class="small-caps">A</span><span 
class="small-caps">L</span><span 
class="small-caps">I</span> </span>2.2
distinguishes between algebraic and symbolic calls of such a procedure. In symbolic
mode such a procedure calls the corresponding procedure with trailing asterisk directly
without data transfer.
</p><!--l. 263--><p class="noindent" ><span 
class="ptmrc8t-x-x-109">C<span 
class="small-caps">A</span><span 
class="small-caps">L</span><span 
class="small-caps">I</span> </span>2.2 follows also a more concise concept for global variables. There are three types
of them:
     </p><blockquote class="quote">
     <!--l. 266--><p class="noindent" >True <span 
class="ptmri8t-x-x-109">ﬂuid </span>global variables,
     </p><!--l. 270--><p class="noindent" >that are part of the current data structure, as e.g. the current base ring and the
degree vector. They are often locally rebound to be restored after interrupts.
                                                                     

                                                                     
     </p><!--l. 272--><p class="noindent" >Global  variables,  stored  on  the  property  list  of  the  package  name
     <span 
class="pcrr8t-x-x-109">cali</span>,
     </p><!--l. 278--><p class="noindent" >that  reﬂect  the  state  of  the  computational  model  as  e.g. the  trace  level,  the
output print level or the chosen version of the Gröbner basis algorithm. There
are several such parameters in the module <span 
class="ptmri8t-x-x-109">dualbases</span><a 
 id="dx170-365005"></a> to serve the common dual
basis driver with information for diﬀerent applications.
     </p><!--l. 280--><p class="noindent" ><span 
class="ptmri8t-x-x-109">Switches,</span>
     </p><!--l. 285--><p class="noindent" >that allow to choose diﬀerent branches of algorithms. Note that this concept
interferes  with  the  second  one.  Diﬀerent  <span 
class="ptmri8t-x-x-109">versions  </span>of  algorithms,  that  apply
diﬀerent functions in a common driver, are <span 
class="ptmri8t-x-x-109">not </span>implemented through switches.
     </p></blockquote>
<!--l. 288--><p class="noindent" >
</p>
<h5 class="subsubsectionHead"><a 
 id="x170-36600020.7.1"></a>New and Improved Facilities in v. 2.1</h5>
<!--l. 290--><p class="noindent" >The major changes in v. 2.1 reﬂect the experience we’ve got from the use of <span 
class="ptmrc8t-x-x-109">C<span 
class="small-caps">A</span><span 
class="small-caps">L</span><span 
class="small-caps">I</span> </span>2.0.
The following changes are worth mentioning explicitely:
     </p><ol  class="enumerate1" >
<li 
  class="enumerate" id="x170-366002x1">
     <!--l. 294--><p class="noindent" >The algebraic rule concept was adapted to <span 
class="ptmrc8t-x-x-109">C<span 
class="small-caps">A</span><span 
class="small-caps">L</span><span 
class="small-caps">I</span></span>. It allows to supply rule
     based coeﬃcient domains. This is a more eﬃcient way to deal with (easy)
     algebraic numbers than through the <span 
class="ptmri8t-x-x-109">arnum package</span>.
     </p></li>
<li 
  class="enumerate" id="x170-366004x2">
     <!--l. 299--><p class="noindent" ><span 
class="ptmri8t-x-x-109">listtest</span><a 
 id="dx170-366005"></a>   and   <span 
class="ptmri8t-x-x-109">listminimize</span><a 
 id="dx170-366006"></a>   provide   an   uniﬁed   concept   for   diﬀerent   list
     operations previously scattered in the source text.
     </p></li>
<li 
  class="enumerate" id="x170-366008x3">
     <!--l. 303--><p class="noindent" >There are several new quotient algorithms at the symbolic level (both the
     general  element  and  the  intersection  approaches  are  available)  and  new
     features for the computation of equidimensional hull and equidimensional
     radical.
                                                                     

                                                                     
     </p></li>
<li 
  class="enumerate" id="x170-366010x4">
     <!--l. 308--><p class="noindent" >A new <span 
class="ptmri8t-x-x-109">module scripts</span><a 
 id="dx170-366011"></a> oﬀers advanced applications of Gröbner bases.
     </p></li>
<li 
  class="enumerate" id="x170-366013x5">
     <!--l. 311--><p class="noindent" >Several advanced procedures initialize a Gröbner basis computation over
     a  certain  intermediate  base  ring  or  term  order  as  e.g. <span 
class="ptmri8t-x-x-109">eliminate</span><a 
 id="dx170-366014"></a>,  <span 
class="ptmri8t-x-x-109">resolve</span><a 
 id="dx170-366015"></a>,
     <span 
class="ptmri8t-x-x-109">matintersect</span><a 
 id="dx170-366016"></a> or all <span 
class="ptmri8t-x-x-109">primary decomposition</span><a 
 id="dx170-366017"></a> procedures. Interrupting a computation
     in  v. 2.1  now  restores  the  original  values  of  <span 
class="ptmrc8t-x-x-109">C<span 
class="small-caps">A</span><span 
class="small-caps">L</span><span 
class="small-caps">I</span></span>’s  global  variables,
     since  all  intermediate  procedures  work  with  local  copies  of  the  global
     variables.<span class="footnote-mark"><a 
href="manual172.html#fn2x20"><sup class="textsuperscript">2</sup></a></span><a 
 id="x170-366018f2"></a> 
     This doesn’t apply to advanced procedures that change the current base ring
     as e.g. <span 
class="ptmri8t-x-x-109">blowup</span><a 
 id="dx170-366020"></a>, <span 
class="ptmri8t-x-x-109">preimage</span><a 
 id="dx170-366021"></a>, <span 
class="ptmri8t-x-x-109">sym</span><a 
 id="dx170-366022"></a> etc.
</p>
     </li></ol>
<!--l. 326--><p class="noindent" >
</p>
<h5 class="subsubsectionHead"><a 
 id="x170-36700020.7.1"></a>New and Improved Facilities in v. 2.2</h5>
<!--l. 328--><p class="noindent" >Version 2.2 (beside bug ﬁxes) incorporates several new facilities of constructive non
linear algebra that we investigated the last two years, as e.g. dual bases, the Gröbner
factorizer, triangular systems, and local standard bases. Essential changes concern the
following topics:
     </p><ol  class="enumerate1" >
<li 
  class="enumerate" id="x170-367002x1">
     <!--l. 333--><p class="noindent" >The <span 
class="ptmrc8t-x-x-109">C<span 
class="small-caps">A</span><span 
class="small-caps">L</span><span 
class="small-caps">I</span> </span>modules <span 
class="ptmri8t-x-x-109">red</span><a 
 id="dx170-367003"></a> and <span 
class="ptmri8t-x-x-109">groeb</span><a 
 id="dx170-367004"></a> were rewritten and the <span 
class="ptmri8t-x-x-109">module mora</span><a 
 id="dx170-367005"></a> was
     removed. This is due to new theoretical insight into standard bases theory
     as e.g. described in <span class="cite">[<a 
href="manualap2.html#XGraebe:94">Grä94b</a>]</span> or <span class="cite">[<a 
href="manualap2.html#XGraebe:95a">Grä95a</a>]</span>. The Gröbner basis algorithm
     is  reorganized  as  a  Gröbner  driver  with  simpliﬁer  and  base  lists,  that
     involves diﬀerent versions of polynomial reduction according to the setting
     via <span 
class="ptmri8t-x-x-109">gbtestversion</span><a 
 id="dx170-367006"></a>. It applies now to both noetherian and non noetherian term
     orders in a uniﬁed way.
                                                                     

                                                                     
     </p><!--l. 342--><p class="noindent" >The switches <span 
class="pcrr8t-x-x-109">binomial </span>and <span 
class="pcrr8t-x-x-109">lazy </span>were removed.
     </p></li>
<li 
  class="enumerate" id="x170-367008x2">
     <!--l. 344--><p class="noindent" >The Gröbner factorizer was thoroughly revised, extended along the lines
     explained  in  <span class="cite">[<a 
href="manualap2.html#XGraebe:94a">Grä94a</a>]</span>,  and  collected  into  a  separate  <span 
class="ptmri8t-x-x-109">module  groebf</span> <a 
 id="dx170-367009"></a>.  It
     now  allows  a  list  of  constraints  also  in  algebraic  mode.  Two  versions
     of  an  <span 
class="ptmri8t-x-x-109">extended  Gr</span><span 
class="ptmri8t-x-x-109">ö</span><span 
class="ptmri8t-x-x-109">bner  factorizer</span><a 
 id="dx170-367010"></a>  produce  <span 
class="ptmri8t-x-x-109">triangular  systems</span><a 
 id="dx170-367011"></a>,  i.e. a
     decomposition into quasi prime components, see <span class="cite">[<a 
href="manualap2.html#XGraebe:95b">Grä95b</a>]</span>, that are well
     suited  for  further  (numerical)  evaluation.  There  is  also  a  version  of  the
     Gröbner factorizer that allows a list of problems as input. This is especially
     useful, if a system is splitted with respect to a “cheap” (e.g. degrevlex) term
     order and the pieces are recomputed with respect to a “hard” (e.g. pure lex)
     term order.
     </p><!--l. 356--><p class="noindent" >The extended Gröbner factorizer involves, after change to dimension zero,
     the  computation  of  <span 
class="ptmri8t-x-x-109">triangular  systems</span><a 
 id="dx170-367012"></a>.  The  corresponding  module  <span 
class="ptmri8t-x-x-109">triang</span><a 
 id="dx170-367013"></a>
     extends the facilities for zero dimensional ideals and modules in the <span 
class="ptmri8t-x-x-109">module</span>
     <span 
class="ptmri8t-x-x-109">odim</span><a 
 id="dx170-367014"></a>.
     </p></li>
<li 
  class="enumerate" id="x170-367016x3">
     <!--l. 361--><p class="noindent" >A  new  <span 
class="ptmri8t-x-x-109">module  lf</span> <a 
 id="dx170-367017"></a>  implements  the  <span 
class="ptmri8t-x-x-109">dual  bases</span><a 
 id="dx170-367018"></a>  approach  as  described
     in    <span class="cite">[<a 
href="manualap2.html#XMarinari:91">MMM91</a>]</span>.    On    this    basis    there    are    new    implementations    of
     <span 
class="pcrr8t-x-x-109">affine_points</span><a 
 id="dx170-367019"></a> and  <span 
class="pcrr8t-x-x-109">proj_points</span><a 
 id="dx170-367020"></a>,  that  are  signiﬁcantly  faster  than
     the  old  ones.  The  linear  algebra  <span 
class="ptmri8t-x-x-109">change  of  term  orders</span><a 
 id="dx170-367021"></a>  <span class="cite">[<a 
href="manualap2.html#XFaugere:93">FGLM93</a>]</span>  is
     available, too. There are two versions, one with precomputed <span 
class="ptmri8t-x-x-109">border basis</span><a 
 id="dx170-367022"></a>,
     the other with conventional normal forms.
     </p></li>
<li 
  class="enumerate" id="x170-367024x4">
     <!--l. 369--><p class="noindent" ><span 
class="ptmri8t-x-x-109">dpmat</span><a 
 id="dx170-367025"></a>s  now  have  a  <span 
class="ptmri8t-x-x-109">gb-tag</span><a 
 id="dx170-367026"></a>  that  indicates,  whether  the  given  ideal  or
     module  basis  is  already  a  Gröbner  basis.  This  avoids  certain  Gröbner
     basis recomputations especially during advanced algorithms as e.g. prime
     decomposition.  In  the  algebraic  interface  Gröbner  bases  are  computed
     automatically when needed rather than to issue an error message as in v. 2.1.
     So one can call <span 
class="pcrr8t-x-x-109">modequalp</span><a 
 id="dx170-367027"></a> or <span 
class="pcrr8t-x-x-109">dim</span><a 
 id="dx170-367028"></a> etc. not having computed Gröbner
     bases in advance. Note that such automatic computation can be avoided with
     <span 
class="ptmri8t-x-x-109">setgbasis</span><a 
 id="dx170-367029"></a>.
     </p></li>
                                                                     

                                                                     
<li 
  class="enumerate" id="x170-367031x5">
     <!--l. 378--><p class="noindent" >Hilbert series are now <span 
class="ptmri8t-x-x-109">weighted Hilbert series</span><a 
 id="dx170-367032"></a>, since e.g. for blow up rings
     the generating ideal is multigraded. Usual Hilbert series are computed as in
     v. 2.1 with respect to the <span 
class="ptmri8t-x-x-109">ecart vector</span><a 
 id="dx170-367033"></a>. Weighted Hilbert series accept a list
     of (integer) weight lists as second parameter.
     </p></li>
<li 
  class="enumerate" id="x170-367035x6">
     <!--l. 384--><p class="noindent" >There are some name and conceptual changes to existing procedures and variables
     to have a more concise semantic concept. This concerns
          </p><blockquote class="quote">
          <!--l. 388--><p class="noindent" ><span 
class="ptmri8t-x-x-109">Tracing</span><a 
 id="dx170-367036"></a> (the trace parameter is now stored on the property list of
          <span 
class="pcrr8t-x-x-109">cali </span>and should be set with <span 
class="ptmri8t-x-x-109">setcalitrace</span><a 
 id="dx170-367037"></a>),
          </p><!--l. 391--><p class="noindent" >choosing diﬀerent versions of the Gröbner algorithm (through
          <span 
class="ptmri8t-x-x-109">gbtestversion</span><a 
 id="dx170-367038"></a>)   and   the   Hilbert   series   computation   (through
          <span 
class="ptmri8t-x-x-109">hftestversion</span><a 
 id="dx170-367039"></a>),
          </p><!--l. 395--><p class="noindent" >some  names  (<span 
class="ptmri8t-x-x-109">mat2list</span><a 
 id="dx170-367040"></a>  replaced  <span 
class="ptmri8t-x-x-109">ﬂatten</span><a 
 id="dx170-367041"></a>,  <span 
class="ptmri8t-x-x-109">HilbertSeries</span><a 
 id="dx170-367042"></a>  replaced
          <span 
class="ptmri8t-x-x-109">hilbseries</span>) and
          </p><!--l. 398--><p class="noindent" >parameter  lists  of  some  local  and  internal  procedures  (consult
          <span 
class="ptmri8t-x-x-109">cali.chg </span>for details).</p></blockquote>
     </li>
<li 
  class="enumerate" id="x170-367044x7">
     <!--l. 401--><p class="noindent" >The <span 
class="ptmri8t-x-x-109">revlex term order</span><a 
 id="dx170-367045"></a> is now the reverse lexicographic term order on the <span 
class="ptmb8t-x-x-109">reversely </span>ordered
     variables. This is consistent with other computer algebra systems (e.g. SINGULAR or
     AXIOM)<span class="footnote-mark"><a 
href="manual173.html#fn3x20"><sup class="textsuperscript">3</sup></a></span><a 
 id="x170-367046f3"></a> 
     and implies the same order on the variables for deglex and degrevlex term orders
     (this was the main reason to change the deﬁnition).
     </p></li>
<li 
  class="enumerate" id="x170-367048x8">
     <!--l. 409--><p class="noindent" >Ideals of minors, pfaﬃans and related stuﬀ are now implemented as extension of
     the internal <span 
class="pcrr8t-x-x-109">matrix </span>package and collected into a separate <span 
class="ptmri8t-x-x-109">module calimat</span><a 
 id="dx170-367049"></a>. Thus
     they allow more general expressions, especially with variable exponents, as
     general REDUCE matrices do. So one can deﬁne generic ideals as e.g. ideals of
     minors or pfaﬃans of matrices, containing generic expressions as elements. They
                                                                     

                                                                     
     must be speciﬁed for further use in <span 
class="ptmrc8t-x-x-109">C<span 
class="small-caps">A</span><span 
class="small-caps">L</span><span 
class="small-caps">I</span> </span>substituting general exponents by
     integers.
</p>
     </li></ol>
<!--l. 420--><p class="noindent" >
</p>
<h5 class="subsubsectionHead"><a 
 id="x170-36800020.7.1"></a>New and Improved Facilities in v. 2.2.1</h5>
<!--l. 422--><p class="noindent" >The main change concerns the primary decomposition algorithm, where
I ﬁxed a serious bug for deciding, which embedded primes are really
embedded<span class="footnote-mark"><a 
href="manual174.html#fn4x20"><sup class="textsuperscript">4</sup></a></span><a 
 id="x170-368001f4"></a> .
During that remake I incorporated also the Gröbner factorizer to compute isolated
primes. Since REDUCE has no multivariate <span 
class="ptmri8t-x-x-109">modular </span>factorizer, the switch <span 
class="ptmri8t-x-x-109">factorprimes</span><a 
 id="dx170-368002"></a>
may be turned oﬀ to switch to the former algorithm.
</p><!--l. 437--><p class="noindent" >Some minor bugs are ﬁxed, too, e.g. the bug that made <span 
class="ptmri8t-x-x-109">radical</span><a 
 id="dx170-368003"></a> crashing.
</p>
<h4 class="subsectionHead"><span class="titlemark">20.7.2    </span> <a 
 id="x170-36900020.7.2"></a>The Computational Model</h4>
<!--l. 445--><p class="noindent" >This section gives a short introduction into the data type design of <span 
class="ptmrc8t-x-x-109">C<span 
class="small-caps">A</span><span 
class="small-caps">L</span><span 
class="small-caps">I</span> </span>at diﬀerent
levels. First (§1 and 2) we describe <span 
class="ptmrc8t-x-x-109">C<span 
class="small-caps">A</span><span 
class="small-caps">L</span><span 
class="small-caps">I</span></span>’s way of algorithmic translation of the abstract
algebraic objects <span 
class="ptmri8t-x-x-109">ring of polynomials, ideal </span>and (ﬁnitely generated) <span 
class="ptmri8t-x-x-109">module</span>. Then (§3
and 4) we describe the algebraic mode interface of <span 
class="ptmrc8t-x-x-109">C<span 
class="small-caps">A</span><span 
class="small-caps">L</span><span 
class="small-caps">I</span> </span>and the switches and global
variables to drive a session. In the next chapter we give a more detailed overview
of the basic (symbolic mode) data structures involved with <span 
class="ptmrc8t-x-x-109">C<span 
class="small-caps">A</span><span 
class="small-caps">L</span><span 
class="small-caps">I</span></span>. We refer
to the appendix for a short summary of the commands available in algebraic
mode.
</p><!--l. 455--><p class="noindent" >
                                                                     

                                                                     
</p>
<h5 class="subsubsectionHead"><a 
 id="x170-37000020.7.2"></a>The Base Ring</h5>
<!--l. 457--><p class="noindent" >A polynomial ring consists in <span 
class="ptmrc8t-x-x-109">C<span 
class="small-caps">A</span><span 
class="small-caps">L</span><span 
class="small-caps">I</span> </span>of the following data:
     </p><blockquote class="quote">
     <!--l. 459--><p class="noindent" >a list of variable names
     </p><!--l. 464--><p class="noindent" >All variables not occuring in the list of ring names are treated as parameters.
Computations are executed denominatorfree, but the results are valid only over
the corresponding parameter <span 
class="ptmri8t-x-x-109">ﬁeld </span>extension.
     </p><!--l. 466--><p class="noindent" >a term order and a term order tag
     </p><!--l. 469--><p class="noindent" >They describe the way in which the terms in each polynomial (and polynomial
vector) are ordered.
     </p><!--l. 471--><p class="noindent" >an ecart vector
     </p><!--l. 474--><p class="noindent" >A list of positive integers corresponding to the variable names.
     </p></blockquote>
<!--l. 477--><p class="noindent" >A <span 
class="ptmri8t-x-x-109">base ring</span><a 
 id="dx170-370001"></a> may be deﬁned (in algebraic mode) through the command
  </p><div class="syntax">
   <span 
class="pcrr8t-x-x-109">setring</span>\(\langle \)<span 
class="ptmri8t-x-x-109">ring</span>\(\rangle \)</div>
<!--l. 482--><p class="noindent" >with \(\langle \)<span 
class="ptmri8t-x-x-109">ring&#x003E;</span>\(\rangle \) ::= {  vars, tord, tag [, ecart ] } resp.
                                                                     

                                                                     
</p>
<pre class="verbatim" id="verbatim-691">
 setring(vars, tord, tag [,ecart])
</pre>
<!--l. 485--><p class="nopar" > <a 
 id="dx170-370002"></a> <a 
 id="command:SETRING"></a> This sets the global (symbolic) variable <span 
class="pcrr8t-x-x-109">cali!=basering</span><a 
 id="dx170-370003"></a>. Here <span 
class="pcrr8t-x-x-109">vars </span>is the list of
variable names, <span 
class="pcrr8t-x-x-109">tord </span>a (possibly empty) list of weight lists, the <span 
class="ptmri8t-x-x-109">degree vectors</span><a 
 id="dx170-370004"></a>, and <span 
class="pcrr8t-x-x-109">tag</span>
the tag LEX or REVLEX. Optionally one can supply <span 
class="pcrr8t-x-x-109">ecart</span>, a list of positive integers of
the same length as <span 
class="pcrr8t-x-x-109">vars</span>, to set an ecart vector diﬀerent from the default one (see
below).
</p><!--l. 496--><p class="noindent" >The degree vectors must have the same length as <span 
class="pcrr8t-x-x-109">vars</span>. If \((w_1\\ldots \ w_k)\) is the list of degree vectors
then </p>
<div class="center" 
>
<!--l. 498--><p class="noindent" >
</p>
<div class="tabular"> <table id="TBL-39" class="tabular" 
 
><colgroup id="TBL-39-1g"><col 
id="TBL-39-1" /><col 
id="TBL-39-2" /><col 
id="TBL-39-3" /><col 
id="TBL-39-4" /><col 
id="TBL-39-5" /><col 
id="TBL-39-6" /></colgroup><tr  
 style="vertical-align:baseline;" id="TBL-39-1-"><td  style="white-space:nowrap; text-align:left;" id="TBL-39-1-1"  
class="td10">\(x^a&lt;x^b\)          </td><td  style="white-space:nowrap; text-align:left;" id="TBL-39-1-2"  
class="td00">\(:\Leftrightarrow \)          </td><td  style="white-space:nowrap; text-align:left;" id="TBL-39-1-3"  
class="td00">either          </td><td  style="white-space:nowrap; text-align:left;" id="TBL-39-1-4"  
class="td00">\(w_j(x^a)=w_j(x^b)\)       </td><td  style="white-space:nowrap; text-align:left;" id="TBL-39-1-5"  
class="td00">for \(j&lt;i\)            </td><td  style="white-space:nowrap; text-align:left;" id="TBL-39-1-6"  
class="td01">and</td></tr><tr 
class="vspace" style="font-size:8.0pt"><td 
>&nbsp;</td><td 
>&nbsp;</td><td 
>&nbsp;</td><td 
>&nbsp;</td><td 
>&nbsp;</td><td 
>&nbsp;</td></tr><tr  
 style="vertical-align:baseline;" id="TBL-39-2-"><td  style="white-space:nowrap; text-align:left;" id="TBL-39-2-1"  
class="td10">    </td><td  style="white-space:nowrap; text-align:left;" id="TBL-39-2-2"  
class="td00">   </td><td  style="white-space:nowrap; text-align:left;" id="TBL-39-2-3"  
class="td00">    </td><td  style="white-space:nowrap; text-align:left;" id="TBL-39-2-4"  
class="td00">\(w_i(x^a)&lt;w_i(x^b)\)  </td>
</tr><tr 
class="vspace" style="font-size:10.0pt"><td 
>&nbsp;</td><td 
>&nbsp;</td><td 
>&nbsp;</td><td 
>&nbsp;</td><td 
>&nbsp;</td><td 
>&nbsp;</td></tr><tr  
 style="vertical-align:baseline;" id="TBL-39-3-"><td  style="white-space:nowrap; text-align:left;" id="TBL-39-3-1"  
class="td10">          </td><td  style="white-space:nowrap; text-align:left;" id="TBL-39-3-2"  
class="td00">          </td><td  style="white-space:nowrap; text-align:left;" id="TBL-39-3-3"  
class="td00">or                </td><td  style="white-space:nowrap; text-align:left;" id="TBL-39-3-4"  
class="td00">\(w_j(x^a)=w_j(x^b)\)       </td><td  style="white-space:nowrap; text-align:left;" id="TBL-39-3-5"  
class="td00">for all \(j\)       </td><td  style="white-space:nowrap; text-align:left;" id="TBL-39-3-6"  
class="td01">and</td>
</tr><tr 
class="vspace" style="font-size:8.0pt"><td 
>&nbsp;</td><td 
>&nbsp;</td><td 
>&nbsp;</td><td 
>&nbsp;</td><td 
>&nbsp;</td><td 
>&nbsp;</td></tr><tr  
 style="vertical-align:baseline;" id="TBL-39-4-"><td  style="white-space:nowrap; text-align:left;" id="TBL-39-4-1"  
class="td10">          </td><td  style="white-space:nowrap; text-align:left;" id="TBL-39-4-2"  
class="td00">          </td><td  style="white-space:nowrap; text-align:left;" id="TBL-39-4-3"  
class="td00">              </td><td colspan="3" style="white-space:nowrap; text-align:left;" id="TBL-39-4-4"  
class="td00"><div class="multicolumn"  style="white-space:nowrap; text-align:left;">\(x^a&lt;_{lex}x^b\) resp. \(x^a&lt;_{revlex}x^b\)</div>
</td></tr></table></div></div>
<!--l. 507--><p class="noindent" >Here \(&lt;_{lex}\) resp. \(&lt;_{revlex}\) denote the <span 
class="ptmri8t-x-x-109">lexicographic</span><a 
 id="dx170-370005"></a> (tag=LEX) resp. <span 
class="ptmri8t-x-x-109">reverse lexicographic</span><a 
 id="dx170-370006"></a> (tag=REVLEX)
term orders<span class="footnote-mark"><a 
href="manual175.html#fn5x20"><sup class="textsuperscript">5</sup></a></span><a 
 id="x170-370007f5"></a> 
with respect to the variable order given in <span 
class="pcrr8t-x-x-109">vars</span>, i.e. \[x^a&lt;x^b \quad :\Leftrightarrow \quad \exists \ j\ \forall \ i&lt;j\ :\ a_i=b_i\quad \mbox {and}\quad a_j&lt;b_j\\mbox {(lex.)}\] or \[x^a&lt;x^b \quad :\Leftrightarrow \quad \exists \ j\ \forall \ i&gt;j\ :\ a_i=b_i\quad \mbox {and}\quad a_j&gt;b_j\\mbox {(revlex.)}\]
</p><!--l. 520--><p class="noindent" >Every term order can be represented in such a way, see <span class="cite">[<a 
href="manualap2.html#XMora:88">MR88</a>]</span>.
</p><!--l. 522--><p class="noindent" >During the ring setting the term order will be checked to be Noetherian (i.e. to fulﬁll the
descending chain condition) provided the switch <a 
 id="dx170-370008"></a><a 
 id="dx170-370009"></a><a 
 id="dx170-370010"></a> is on (the default). The same
applies turning <span 
class="ptmri8t-x-x-109">noetherian on</span>: If the term order of the underlying base ring
isn’t Noetherian the switch can’t be turned over. Hence, starting from a non
Noetherian term order, one should deﬁne <span 
class="ptmri8t-x-x-109">ﬁrst </span>a new ring and <span 
class="ptmri8t-x-x-109">then </span>turn the switch
on.
</p><!--l. 530--><p class="noindent" >Useful term orders can be deﬁned by the procedures </p>
     <ul class="itemize1">
     <li class="itemize">
                                                                     

                                                                     
     <!--l. 532--><p class="noindent" >
       </p><div class="syntax">
        <span 
class="pcrr8t-x-x-109">degreeorder</span>\(\langle \)<span 
class="ptmri8t-x-x-109">vars</span>\(\rangle \)</div>
<a 
 id="dx170-370011"></a>
     <!--l. 537--><p class="noindent" >that returns \(tord=\{\{1,\ldots ,1\}\}\).
     </p></li>
     <li class="itemize">
     <!--l. 539--><p class="noindent" >
       </p><div class="syntax">
        <span 
class="pcrr8t-x-x-109">localorder</span>\(\langle \)<span 
class="ptmri8t-x-x-109">vars</span>\(\rangle \)</div>
<a 
 id="dx170-370012"></a>
     <!--l. 545--><p class="noindent" >that returns \(tord=\{\{-1,\ldots ,-1\}\}\) (a non Noetherian term order for computations in local rings).
     </p></li>
     <li class="itemize">
     <!--l. 547--><p class="noindent" >
       </p><div class="syntax">
        <span 
class="pcrr8t-x-x-109">eliminationorder</span>( \(\langle \)<span 
class="ptmri8t-x-x-109">vars</span>\(\rangle \),\(\langle \)<span 
class="ptmri8t-x-x-109">elimvars</span>\(\rangle \))</div>
<a 
 id="dx170-370013"></a>
     <!--l. 554--><p class="noindent" >that returns a term order for elimination of the variables in \(\langle \)<span 
class="ptmri8t-x-x-109">elimvars</span>\(\rangle \), a subset
of all \(\langle \)<span 
class="ptmri8t-x-x-109">vars</span>\(\rangle \). It’s recommended to combine it with the tag revlex.
     </p></li>
     <li class="itemize">
     <!--l. 556--><p class="noindent" >
       </p><div class="syntax">
        <span 
class="pcrr8t-x-x-109">blockorder</span>( \(\langle \)<span 
class="ptmri8t-x-x-109">vars</span>\(\rangle \),\(\langle \)<span 
class="ptmri8t-x-x-109">vars,integerlist</span>\(\rangle \))</div>
<a 
 id="dx170-370014"></a>
     <!--l. 564--><p class="noindent" >that returns the list of degree vectors for the block order with block lengths
given in the \(\langle \)<span 
class="ptmri8t-x-x-109">integerlist</span>\(\rangle \). Note that these numbers should sum up to the length
of the variable list supplied as the ﬁrst argument.
     </p></li></ul>
<!--l. 567--><p class="noindent" >Examples:
                                                                     

                                                                     
</p>
<pre class="verbatim" id="verbatim-692">
vars:={x,y,z};
tord:=degreeorder vars;   % Returns {{1,1,1}}.
setring(vars,tord,lex);   % GRADLEX in the groebner package.

% or

setring({a,b,c,d},{},lex); % LEX in the groebner package.

% or

vars:={a,b,c,x,y,z};
tord:=eliminationorder(vars,{x,y,z});
tord:=reverse blockorder(vars,{3,3});
                          % Return both {{0,0,0,1,1,1},{1,1,1,0,0,0}}.
setring(vars,tord,revlex);
</pre>
<!--l. 584--><p class="nopar" >
</p><!--l. 587--><p class="noindent" >The base ring is initialized with
                                                                     

                                                                     
</p>
<pre class="verbatim" id="verbatim-693">

   {{t,x,y,z},{{1,1,1,1}},revlex,{1,1,1,1}}
</pre>
<!--l. 591--><p class="nopar" > i.e. \(S=k[t,x,y,z]\) supplied with the degreewise reverse lexicographic term order. </p>
     <ul class="itemize1">
     <li class="itemize">
     <!--l. 595--><p class="noindent" >
       </p><div class="syntax">
        <span 
class="pcrr8t-x-x-109">getring</span>\(\langle \)<span 
class="ptmri8t-x-x-109">m</span>\(\rangle \)</div>
<a 
 id="dx170-370015"></a>
     <!--l. 600--><p class="noindent" ><a 
 id="operator:GETRING"></a> returns the ring attached to the object with the identiﬁer \(\langle \)<span 
class="ptmri8t-x-x-109">m</span>\(\rangle \). E.g. 
     </p></li>
     <li class="itemize">
     <!--l. 604--><p class="noindent" >
       </p><div class="syntax">
        <span 
class="pcrr8t-x-x-109">setringgetring</span>\(\langle \)<span 
class="ptmri8t-x-x-109">m</span>\(\rangle \)</div>
<a 
 id="dx170-370016"></a>
     <!--l. 609--><p class="noindent" ><a 
 id="operator:SETRING"></a> (re)sets the base ring to the base ring of the formerly deﬁned object (ideal or
 module) \(\langle \)<span 
class="ptmri8t-x-x-109">m</span>\(\rangle \).
     </p></li>
     <li class="itemize">
     <!--l. 613--><p class="noindent" >
       </p><div class="syntax">
        <span 
class="pcrr8t-x-x-109">getring</span>()</div>
     <!--l. 617--><p class="noindent" >returns the currently active base ring.
     </p></li></ul>
                                                                     

                                                                     
<!--l. 620--><p class="noindent" ><span 
class="ptmrc8t-x-x-109">C<span 
class="small-caps">A</span><span 
class="small-caps">L</span><span 
class="small-caps">I</span> </span>deﬁnes also an <span 
class="ptmri8t-x-x-109">ecart vector</span><a 
 id="dx170-370017"></a>, attaching to each variable a positive weight with
respect to that homogenizations and related algorithms are executed. It may be set
optionally by the user during the <span 
class="ptmri8t-x-x-109">setring</span><a 
 id="dx170-370018"></a> command. (Default: If the term order is a
(positive) degree order then the ecart is the ﬁrst degree vector, otherwise each ecart
equals 1).
</p><!--l. 627--><p class="noindent" >The ecart vector is used in several places for eﬃciency reason (Gröbner basis
computation with the sugar strategy) or for termination (local standard bases). If the
input is homogeneous the ecart vector should reﬂect this homogeneity rather than the
ﬁrst degree vector to obtain the best possible performance. For a discussion of local
computations with encoupled ecart vector see <span class="cite">[<a 
href="manualap2.html#XGraebe:94">Grä94b</a>]</span>. In general the ecart vector is
recommended to be chosen in such a way that the input examples become close
to be homogeneous. <span 
class="ptmri8t-x-x-109">Homogenizations </span>and <span 
class="ptmri8t-x-x-109">Hilbert series</span><a 
 id="dx170-370019"></a> are computed with
respect to this ecart vector. <a 
 id="operator:GETECART"></a> <span 
class="pcrr8t-x-x-109">getecart()</span><a 
 id="dx170-370020"></a> returns the ecart vector currently
set.
</p>
<h5 class="subsubsectionHead"><a 
 id="x170-37100020.7.2"></a>Ideals and Modules</h5>
<!--l. 645--><p class="noindent" >If \(S=k[x_v,\ v \in H]\) is a polynomial ring, a matrix \(M\) of size \(r\times c\) deﬁnes a map \[f\ :\ S^r \longrightarrow S^c\] by the following rule \[ f(v):=v\cdot M \qquad \mbox { for } v \in S^r.\] There are
two modules, connected with such a map, \(im\ f\), the submodule of \(S^c\) generated by the rows of \(M\),
and \(\mathop {\mathrm {coker}} f\(=S^c/im\ f)\). Conceptually we will identify \(M\) with \(im\ f\) for the basic algebra, and with \(\mathop {\mathrm {coker}} f\) for more
advanced topics of commutative algebra (Hilbert series, dimension, resolution etc.)
following widely accepted conventions.
</p><!--l. 657--><p class="noindent" >With respect to a ﬁxed basis \(\{e_1,\ldots ,e_c\}\) one can deﬁne module term orders on \(S^c\), Gröbner bases of
submodules of \(S^c\) etc. They generalize the corresponding notions for ideal bases. See
<span class="cite">[<a 
href="manualap2.html#XEisenbud:95">Eis95</a>]</span> or <span class="cite">[<a 
href="manualap2.html#XMoellerMora:86">MM86</a>]</span> for a detailed introduction to this area of computational commutative
algebra. This allows to deﬁne joint facilities for both ideals and submodules of
free modules. Moreover computing syzygies the latter come in in a natural
way.
</p><!--l. 665--><p class="noindent" ><span 
class="ptmrc8t-x-x-109">C<span 
class="small-caps">A</span><span 
class="small-caps">L</span><span 
class="small-caps">I</span> </span>handles ideal and module bases in a unique way representing them as rows
of a <span 
class="ptmri8t-x-x-109">dpmat</span><a 
 id="dx170-371001"></a> (<span 
class="ptmb8t-x-x-109">d</span>istributive <span 
class="ptmb8t-x-x-109">p</span>olynomial <span 
class="ptmb8t-x-x-109">mat</span>rix). It attaches to each unit vector \(e_i\)
a monomial \(x^{a_i}\), the \(i\)-th <span 
class="ptmri8t-x-x-109">column degree</span><a 
 id="dx170-371002"></a> and represents the rows of a dpmat \(M\) as
lists of module terms \(x^ae_i\), sorted with respect to a <span 
class="ptmri8t-x-x-109">module term order</span><a 
 id="dx170-371003"></a>, that may be
roughly<span class="footnote-mark"><a 
href="manual176.html#fn6x20"><sup class="textsuperscript">6</sup></a></span><a 
 id="x170-371004f6"></a> 
described as </p>
                                                                     

                                                                     
<div class="flushleft" 
>
<!--l. 673--><p class="noindent" >
 <!--tex4ht:inline--></p><div class="tabular"> <table id="TBL-40" class="tabular" 
 
><colgroup id="TBL-40-1g"><col 
id="TBL-40-1" /><col 
id="TBL-40-2" /><col 
id="TBL-40-3" /><col 
id="TBL-40-4" /></colgroup><tr  
 style="vertical-align:baseline;" id="TBL-40-1-"><td  style="white-space:nowrap; text-align:center;" id="TBL-40-1-1"  
class="td11">\(x^ae_i&lt;x^be_j\)</td><td  style="white-space:nowrap; text-align:center;" id="TBL-40-1-2"  
class="td11">\(:\Leftrightarrow \)</td><td  style="white-space:nowrap; text-align:center;" id="TBL-40-1-3"  
class="td10">either            </td><td  style="white-space:nowrap; text-align:center;" id="TBL-40-1-4"  
class="td01">      \(x^ax^{a_i}&lt;x^bx^{a_j}\) in \(S\)               </td></tr><tr  
 style="vertical-align:baseline;" id="TBL-40-2-"><td  style="white-space:nowrap; text-align:center;" id="TBL-40-2-1"  
class="td11"> </td>
</tr><tr  
 style="vertical-align:baseline;" id="TBL-40-3-"><td  style="white-space:nowrap; text-align:center;" id="TBL-40-3-1"  
class="td11"></td><td  style="white-space:nowrap; text-align:center;" id="TBL-40-3-2"  
class="td11"></td><td  style="white-space:nowrap; text-align:center;" id="TBL-40-3-3"  
class="td10"> or               </td><td  style="white-space:nowrap; text-align:center;" id="TBL-40-3-4"  
class="td01">       \(x^ax^{a_i}=x^bx^{a_j}\)       </td></tr><tr  
 style="vertical-align:baseline;" id="TBL-40-4-"><td  style="white-space:nowrap; text-align:center;" id="TBL-40-4-1"  
class="td11"> </td> <td  style="white-space:nowrap; text-align:center;" id="TBL-40-4-2"  
class="td11"></td> <td  style="white-space:nowrap; text-align:center;" id="TBL-40-4-3"  
class="td10">    </td> <td  style="white-space:nowrap; text-align:center;" id="TBL-40-4-4"  
class="td01"> and</td>
</tr><tr  
 style="vertical-align:baseline;" id="TBL-40-5-"><td  style="white-space:nowrap; text-align:center;" id="TBL-40-5-1"  
class="td11"></td><td  style="white-space:nowrap; text-align:center;" id="TBL-40-5-2"  
class="td11"></td><td  style="white-space:nowrap; text-align:center;" id="TBL-40-5-3"  
class="td10">                </td><td  style="white-space:nowrap; text-align:center;" id="TBL-40-5-4"  
class="td01">\(i&lt;j\) (lex.) resp. \(i&gt;j\) (revlex.)</td>
</tr><tr  
 style="vertical-align:baseline;" id="TBL-40-6-"><td  style="white-space:nowrap; text-align:center;" id="TBL-40-6-1"  
class="td11"></td></tr></table>
</div></div>
<!--l. 683--><p class="noindent" >Every dpmat \(M\) has its own column degrees (no default !). They are managed through a
global (symbolic) variable <span 
class="pcrr8t-x-x-109">cali!=degrees</span><a 
 id="dx170-371005"></a>. </p>
     <ul class="itemize1">
     <li class="itemize">
     <!--l. 687--><p class="noindent" ><a 
 id="operator:GETDEGREES"></a>
       </p><div class="syntax">
        <span 
class="pcrr8t-x-x-109">getdegrees</span>\(\langle \)<span 
class="ptmri8t-x-x-109">m</span>\(\rangle \)</div>
<a 
 id="dx170-371006"></a>
     <!--l. 693--><p class="noindent" >returns the column degrees of the object with identiﬁer \(\langle \)<span 
class="ptmri8t-x-x-109">m</span>\(\rangle \).
     </p></li>
     <li class="itemize">
     <!--l. 695--><p class="noindent" >
       </p><div class="syntax">
        <span 
class="pcrr8t-x-x-109">getdegrees</span>()</div>
     <!--l. 699--><p class="noindent" >returns the current setting of <span 
class="pcrr8t-x-x-109">cali!=degrees</span>.
     </p></li>
     <li class="itemize">
     <!--l. 701--><p class="noindent" ><a 
 id="operator:SETDEGREES"></a>
       </p><div class="syntax">
        <span 
class="pcrr8t-x-x-109">setdegrees</span>\(\langle \)<span 
class="ptmri8t-x-x-109">list of monomials</span>\(\rangle \)</div>
<a 
 id="dx170-371007"></a>
     <!--l. 712--><p class="noindent" >sets <span 
class="pcrr8t-x-x-109">cali!=degrees </span>correspondingly. Use this command before executing
<span 
class="pcrr8t-x-x-109">setmodule </span>to give a dpmat prescribed column degrees since cali!=degrees
has  no  default  value  and  changes  during  computations.  A  good  guess  is  to
supply the empty list (i.e. all column degrees are equal to \(\mathbf {x}^0\)). Be careful deﬁning
modules without prescribed column degrees.
     </p></li></ul>
                                                                     

                                                                     
<!--l. 715--><p class="noindent" >To distinguish between <span 
class="ptmri8t-x-x-109">ideals</span><a 
 id="dx170-371008"></a> and <span 
class="ptmri8t-x-x-109">modules</span><a 
 id="dx170-371009"></a> the former are represented as a <span 
class="ptmri8t-x-x-109">dpmat</span><a 
 id="dx170-371010"></a> with \(c=0\)
(and hence without column degrees). If \(I \subset S\) is such an ideal one has to distinguish between
the ideal \(I\) (with \(c=0\), allowing special ideal operations as e.g. ideal multiplication) and the
submodule \(I\) of the free one dimensional module \(S^1\) (with \(c=1\), allowing matrix operations as
e.g. transposition, matrix multiplication etc.). <span 
class="ptmri8t-x-x-109">ideal2mat</span><a 
 id="dx170-371011"></a> converts an (algebraic) list of
polynomials into an (algebraic) matrix column whereas <span 
class="ptmri8t-x-x-109">mat2list</span><a 
 id="dx170-371012"></a> collects all matrix
entries into a list.
</p>
<h5 class="subsubsectionHead"><a 
 id="x170-37200020.7.2"></a>The Algebraic Mode Interface</h5>
<!--l. 728--><p class="noindent" >Corresponding to <span 
class="ptmrc8t-x-x-109">C<span 
class="small-caps">A</span><span 
class="small-caps">L</span><span 
class="small-caps">I</span></span>’s general philosophy explained in the introduction the algebraic
mode interface translates algebraic input into <span 
class="ptmrc8t-x-x-109">C<span 
class="small-caps">A</span><span 
class="small-caps">L</span><span 
class="small-caps">I</span></span>’s internal data representation, calls
the corresponding symbolic functions, and retranslates the result back into algebraic
mode. Since Gröbner basis computations may be very tedious even on small examples,
one should ﬁnd a well balance between the storage of results computed earlier and the
unavoidable time overhead and memory request associated with the management of these
results.
</p><!--l. 737--><p class="noindent" >Therefore <span 
class="ptmrc8t-x-x-109">C<span 
class="small-caps">A</span><span 
class="small-caps">L</span><span 
class="small-caps">I</span> </span>distinguishes between <span 
class="ptmri8t-x-x-109">free </span>and <span 
class="ptmri8t-x-x-109">bounded</span> <a 
 id="dx170-372001"></a><a 
 id="dx170-372002"></a> identiﬁers. Free identiﬁers
stand only for their value whereas to bounded identiﬁers several internal information is
attached to their property list for later use.
</p><!--l. 744--><p class="noindent" >After the initialization of the <span 
class="ptmri8t-x-x-109">base ring </span>bounded identiﬁers for ideals or modules should
be declared via <a 
 id="operator:SETMODULE"></a> <a 
 id="operator:SETIDEAL"></a>
  </p><div class="syntax">
   <span 
class="pcrr8t-x-x-109">setmodule</span>(\(\langle \)<span 
class="ptmri8t-x-x-109">name</span>\(\rangle \),\(\langle \)<span 
class="ptmri8t-x-x-109">matrix value</span>\(\rangle \))</div>
<!--l. 751--><p class="noindent" >resp.
  </p><div class="syntax">
   <span 
class="pcrr8t-x-x-109">setideal</span>(\(\langle \)<span 
class="ptmri8t-x-x-109">name</span>\(\rangle \),\(\langle \)<span 
class="ptmri8t-x-x-109">list of polynomials</span>\(\rangle \))</div>
<a 
 id="dx170-372003"></a>
<a 
 id="dx170-372004"></a>
<!--l. 756--><p class="noindent" >This way the corresponding internal representation (as <span 
class="ptmri8t-x-x-109">dpmat</span><a 
 id="dx170-372005"></a>) is attached to \(\langle \)<span 
class="ptmri8t-x-x-109">name</span>\(\rangle \) as the
property <span 
class="ptmri8t-x-x-109">basis</span><a 
 id="dx170-372006"></a>, the preﬁx form as its value and the current base ring as the property
<span 
class="ptmri8t-x-x-109">ring</span><a 
 id="dx170-372007"></a>.
</p><!--l. 761--><p class="noindent" >Performing any algebraic operation on objects deﬁned this way their ring will
be compared with the current base ring (including the term order). If they are
diﬀerent an error message occurs. If <span 
class="pcrr8t-x-x-109">m </span>is a valid name, after resetting the base
ring
                                                                     

                                                                     
</p>
<pre class="verbatim" id="verbatim-694">
setmodule(m1,m)
</pre>
<!--l. 767--><p class="nopar" > reevaluates <span 
class="pcrr8t-x-x-109">m </span>with respect to the new base ring (since the <span 
class="ptmri8t-x-x-109">value </span>of <span 
class="pcrr8t-x-x-109">m </span>is its preﬁx form)
and assigns the reordered dpmat to <span 
class="pcrr8t-x-x-109">m1 </span>clearing all information previously computed for
<span 
class="pcrr8t-x-x-109">m1 </span>(<span 
class="pcrr8t-x-x-109">m1 </span>and <span 
class="pcrr8t-x-x-109">m </span>may coincide).
</p><!--l. 773--><p class="noindent" >All computations are performed with respect to the ring \(S=k[x_v\in \texttt {vars}]\) over the ﬁeld \(k\). Nevertheless by
eﬃciency reasons <span 
class="ptmri8t-x-x-109">base coeﬃcients</span><a 
 id="dx170-372008"></a> are represented in a denominator free way as standard
forms. Hence the computational properties of the base coeﬃcient domain depend on the
<span 
class="ptmri8t-x-x-109">dmode</span><a 
 id="dx170-372009"></a> and also on auxiliary variables, contained in the expressions, but not in the
variable list. They are assumed to be parameters.
</p><!--l. 781--><p class="noindent" >Best performance will be obtained with integer or modular domain modes, but one can
also try <span 
class="ptmri8t-x-x-109">Algebraic numbers</span><a 
 id="dx170-372010"></a> as coeﬃcients as e.g. generated by <span 
class="pcrr8t-x-x-109">sqrt </span>or the <span 
class="ptmrc8t-x-x-109">A<span 
class="small-caps">R</span><span 
class="small-caps">N</span><span 
class="small-caps">U</span><span 
class="small-caps">M</span></span>
package. To avoid an unnecessary slow-down connected with the management of
simpliﬁed algebraic expressions there is a <span 
class="ptmri8t-x-x-109">switch hardzerotest</span><a 
 id="dx170-372011"></a> (default: oﬀ) that may be
turned on to force an additional simpliﬁcation of algebraic coeﬃcients during each zero
test. It should be turned on only for domain modes without canonical representations as
e.g. mixtures of arnums and square roots. We remind the general zero decision problem
for such domains.
</p><!--l. 792--><p class="noindent" >Alternatively, <span 
class="ptmrc8t-x-x-109">C<span 
class="small-caps">A</span><span 
class="small-caps">L</span><span 
class="small-caps">I</span> </span>oﬀers the possibility to deﬁne a set of algebraic substitution rules
that will aﬀect <span 
class="ptmrc8t-x-x-109">C<span 
class="small-caps">A</span><span 
class="small-caps">L</span><span 
class="small-caps">I</span></span>’s base coeﬃcient arithmetic only. <a 
 id="operator:SETRULES"></a> </p>
     <ul class="itemize1">
     <li class="itemize">
     <!--l. 797--><p class="noindent" >
       </p><div class="syntax">
        <span 
class="pcrr8t-x-x-109">setrules</span>\(\langle \)<span 
class="ptmri8t-x-x-109">rule list</span>\(\rangle \)</div>
<a 
 id="dx170-372012"></a>
     <!--l. 805--><p class="noindent" >transfers the (algebraic) \(\langle \)<span 
class="ptmri8t-x-x-109">rule list</span>\(\rangle \) into the internal representation stored at the
<span 
class="pcrr8t-x-x-109">cali </span>value <span 
class="pcrr8t-x-x-109">rules</span>.
In particular, <span 
class="pcrr8t-x-x-109">setrules {} </span>clears the rules previously set.
     </p></li>
     <li class="itemize">
                                                                     

                                                                     
     <!--l. 807--><p class="noindent" ><a 
 id="operator:GETRULES"></a>
       </p><div class="syntax">
        <span 
class="pcrr8t-x-x-109">getrules</span>()</div>
<a 
 id="dx170-372013"></a>
     <!--l. 813--><p class="noindent" >returns the internal <span 
class="ptmrc8t-x-x-109">C<span 
class="small-caps">A</span><span 
class="small-caps">L</span><span 
class="small-caps">I</span> </span>rules list in algebraic form.
     </p></li></ul>
<!--l. 816--><p class="noindent" >We recommend to use <span 
class="pcrr8t-x-x-109">setrules</span><a 
 id="dx170-372014"></a> for computations with algebraic numbers since they are
better adapted to the data structure of <span 
class="ptmrc8t-x-x-109">C<span 
class="small-caps">A</span><span 
class="small-caps">L</span><span 
class="small-caps">I</span> </span>than the algebraic numbers provided by the
<span 
class="ptmrc8t-x-x-109">A<span 
class="small-caps">R</span><span 
class="small-caps">N</span><span 
class="small-caps">U</span><span 
class="small-caps">M</span> </span>package. Note, that due to the zero decision problem complicated <span 
class="pcrr8t-x-x-109">setrules</span>
based computations may produce wrong results if base coeﬃcient’s pseudo division is
involved (as e.g. with <span 
class="pcrr8t-x-x-109">dp_pseudodivmod</span><a 
 id="dx170-372015"></a>). In this case we recommend to enlarge the
variable set and add the deﬁning equations of the algebraic numbers to the equations of the
problem<span class="footnote-mark"><a 
href="manual177.html#fn7x20"><sup class="textsuperscript">7</sup></a></span><a 
 id="x170-372016f7"></a> .
</p><!--l. 829--><p class="noindent" >The standard domain (Integer) doesn’t allow denominators for input. <span 
class="pcrr8t-x-x-109">setideal</span><a 
 id="dx170-372017"></a> clears
automatically the common denominator of each input expression whereas a
polynomial matrix with true rational coeﬃcients will be rejected by <span 
class="pcrr8t-x-x-109">setmodule</span><a 
 id="dx170-372018"></a>.
</p><!--l. 835--><p class="noindent" >One can save/initialize ideal and module bases together with their accompanying data
(base ring, degrees) to/from a ﬁle:
  </p><div class="syntax">
   <span 
class="pcrr8t-x-x-109">savemat</span>(\(\langle \)<span 
class="ptmri8t-x-x-109">m</span>\(\rangle \),\(\langle \)<span 
class="ptmri8t-x-x-109">name</span>\(\rangle \))</div>
<!--l. 840--><p class="noindent" >resp.
  </p><div class="syntax">
   <span 
class="pcrr8t-x-x-109">initmat</span>\(\langle \)<span 
class="ptmri8t-x-x-109">name</span>\(\rangle \)</div>
<!--l. 843--><p class="noindent" >execute the ﬁle transfer from/to disk ﬁles with the speciﬁed ﬁle \(\langle \)<span 
class="ptmri8t-x-x-109">name</span>\(\rangle \). e.g. 
                                                                     

                                                                     
</p>
<pre class="verbatim" id="verbatim-695">
savemat(m,&#x0022;myfile&#x0022;);
</pre>
<!--l. 847--><p class="nopar" > saves the base ring and the ideal basis of <span 
class="pcrr8t-x-x-109">m </span>to the ﬁle “<span 
class="pcrr8t-x-x-109">myfile</span>” whereas
                                                                     

                                                                     
</p>
<pre class="verbatim" id="verbatim-696">
setideal(m,initmat &#x0022;myfile&#x0022;);
</pre>
<!--l. 852--><p class="nopar" > sets the current base ring (via a call to <span 
class="pcrr8t-x-x-109">setring</span>) to the base ring of <span 
class="pcrr8t-x-x-109">m </span>saved at
“<span 
class="pcrr8t-x-x-109">myfile</span>” and then recovers the basis of <span 
class="pcrr8t-x-x-109">m </span>from the same ﬁle.
</p>
<h5 class="subsubsectionHead"><a 
 id="x170-37300020.7.2"></a>Switches and Global Variables</h5>
<!--l. 859--><p class="noindent" >There are several switches, (ﬂuid) global variables, a trace facility, and global parameters
on the property list of the package name <span 
class="pcrr8t-x-x-109">cali </span>to control <span 
class="ptmrc8t-x-x-109">C<span 
class="small-caps">A</span><span 
class="small-caps">L</span><span 
class="small-caps">I</span></span>’s computations.
</p><!--l. 864--><p class="noindent" >
</p>
<h5 class="likesubsubsectionHead"><a 
 id="x170-37400020.7.2"></a>Switches</h5>
     <dl class="description"><dt class="description">
     <!--l. 867--><p class="noindent" >
 </p></dt><dd 
class="description">
     <!--l. 867--><p class="noindent" ><span 
class="pcrr8t-x-x-109">bcsimp</span><a 
 id="dx170-374001"></a><a 
 id="dx170-374002"></a><a 
 id="dx170-374003"></a><a 
 id="switch:BCSIMP"></a> (Default:on) <br 
class="newline" />On: Cancel out gcd’s of base coeﬃcients.
     </p></dd><dt class="description">
     <!--l. 873--><p class="noindent" >
<span 
class="pcrr8t-x-x-109">detectunits</span> </p></dt><dd 
class="description">
     <!--l. 873--><p class="noindent" ><a 
 id="dx170-374004"></a><a 
 id="dx170-374005"></a><a 
 id="dx170-374006"></a><a 
 id="switch:DETECTUNITS"></a> (Default: oﬀ)<br 
class="newline" />On: replace polynomials of the form \(\langle monomial\rangle * \langle polynomial\ unit\rangle \) by \(\langle monomial\rangle \) during interreductions and standard
     basis computations.
     </p><!--l. 882--><p class="noindent" >Aﬀects only local computations.
     </p></dd><dt class="description">
                                                                     

                                                                     
     <!--l. 884--><p class="noindent" >
<span 
class="pcrr8t-x-x-109">factorprimes</span> </p></dt><dd 
class="description">
     <!--l. 884--><p class="noindent" ><a 
 id="dx170-374007"></a><a 
 id="dx170-374008"></a><a 
 id="dx170-374009"></a><a 
 id="switch:FACTORPRIMES"></a> (Default: on)<br 
class="newline" />On: Invoke the Gröbner factorizer during computation of isolated primes.
     Note  that  REDUCE  lacks  a  modular  multivariate  factorizer,  hence  for
     modular prime decomposition computations this switch has to be turned oﬀ.
     </p></dd><dt class="description">
     <!--l. 893--><p class="noindent" >
<span 
class="pcrr8t-x-x-109">factorunits</span> </p></dt><dd 
class="description">
     <!--l. 893--><p class="noindent" ><a 
 id="dx170-374010"></a><a 
 id="dx170-374011"></a><a 
 id="dx170-374012"></a><a 
 id="switch:FACTORUNITS"></a> (Default: oﬀ) <br 
class="newline" />On:   factor   polynomials   and   remove   polynomial   unit   factors   during
     interreductions and standard basis computations.
     </p><!--l. 900--><p class="noindent" >Aﬀects only local computations.
     </p></dd><dt class="description">
     <!--l. 902--><p class="noindent" >
<span 
class="pcrr8t-x-x-109">hardzerotest</span> </p></dt><dd 
class="description">
     <!--l. 902--><p class="noindent" ><a 
 id="dx170-374013"></a><a 
 id="dx170-374014"></a><a 
 id="dx170-374015"></a><a 
 id="switch:HARDZEROTEST"></a> (Default: oﬀ) <br 
class="newline" />On:  try  an  additional  algebraic  simpliﬁcation  of  base  coeﬃcients  at  each
     base  coeﬃcient’s  zero  test.  Useful  only  for  advanced  base  coeﬃcient
     domains  without  canonical  REDUCE  representation.  May  slow  down  the
     computation drastically.
     </p></dd><dt class="description">
     <!--l. 911--><p class="noindent" >
<span 
class="pcrr8t-x-x-109">lexefgb</span> </p></dt><dd 
class="description">
     <!--l. 911--><p class="noindent" ><a 
 id="dx170-374016"></a><a 
 id="dx170-374017"></a><a 
 id="dx170-374018"></a> <a 
 id="switch:LEXEFGB"></a> (Default:  oﬀ)  On:  Use  the  pure  lexicographic  term  order  and  <span 
class="ptmri8t-x-x-109">zerosolve</span><a 
 id="dx170-374019"></a>
     during reduction to dimension zero in the <span 
class="ptmri8t-x-x-109">extended Gr</span><span 
class="ptmri8t-x-x-109">ö</span><span 
class="ptmri8t-x-x-109">bner factorizer</span><a 
 id="dx170-374020"></a>. This
     is a single, but possibly hard task compared to the degrevlex invocation of
     <span 
class="ptmri8t-x-x-109">zerosolve1</span><a 
 id="dx170-374021"></a>.  See  <span class="cite">[<a 
href="manualap2.html#XGraebe:95b">Grä95b</a>]</span>  for  a  discussion  of  diﬀerent  zero  dimensional
     solver strategies.
     </p></dd><dt class="description">
     <!--l. 921--><p class="noindent" >
<span 
class="pcrr8t-x-x-109">Noetherian</span> </p></dt><dd 
class="description">
     <!--l. 921--><p class="noindent" ><a 
 id="dx170-374022"></a><a 
 id="dx170-374023"></a><a 
 id="dx170-374024"></a><a 
 id="switch:NOETHERIAN"></a> (Default: on)<br 
class="newline" />On: choose algorithms for Noetherian term orders.
     </p><!--l. 927--><p class="noindent" >Oﬀ: choose algorithms for local term orders.
     </p></dd><dt class="description">
                                                                     

                                                                     
     <!--l. 929--><p class="noindent" >
<span 
class="pcrr8t-x-x-109">red_total</span> </p></dt><dd 
class="description">
     <!--l. 929--><p class="noindent" ><a 
 id="dx170-374025"></a><a 
 id="dx170-374026"></a><a 
 id="dx170-374027"></a><a 
 id="switch:RED_TOTAL"></a> (Default: on)<br 
class="newline" />On:  compute  total  normal  forms,  i.e.  apply  reduction  (Noetherian  term
     orders) or reduction with bounded ecart (non Noetherian term orders to tail
     terms of polynomials, too.
     </p><!--l. 937--><p class="noindent" >Oﬀ: Do only top reduction.
</p>
     </dd></dl>
<!--l. 941--><p class="noindent" >
</p>
<h5 class="likesubsubsectionHead"><a 
 id="x170-37500020.7.2"></a>Tracing</h5>
<!--l. 943--><p class="noindent" >Diﬀerent to v. 2.1 now intermediate output during the computations is controlled by the
value of the <span 
class="pcrr8t-x-x-109">trace </span>and <span 
class="pcrr8t-x-x-109">printterms </span>entries on the property list of the package name
<span 
class="pcrr8t-x-x-109">cali</span>. The former value controls the intensity of the intermediate output (Default: 0, no
tracing), the latter the number of terms printed in such intermediate polynomials
(Default: all). </p>
     <ul class="itemize1">
     <li class="itemize">
     <!--l. 950--><p class="noindent" ><a 
 id="operator:SETCALITRACE"></a>
       </p><div class="syntax">
        <span 
class="pcrr8t-x-x-109">setcalitrace</span>\(\langle \)<span 
class="ptmri8t-x-x-109">n</span>\(\rangle \)</div>
<a 
 id="dx170-375001"></a>
     <!--l. 956--><p class="noindent" >Changes the trace intensity. Set \(n=2\) for a sparse tracing (a dot for each reduction step).
     Other good suggestions are the values 30 or 40 for tracing the Gröbner algorithm
     or \(n&gt;70\) for tracing the normal form algorithm. The higher \(n\) the more intermediate
     information will be given.
     </p></li>
     <li class="itemize">
     <!--l. 962--><p class="noindent" ><a 
 id="operator:SETCALIPRINTTERMS"></a>
       </p><div class="syntax">
        <span 
class="pcrr8t-x-x-109">setcaliprintterms</span>\(\langle \)<span 
class="ptmri8t-x-x-109">n</span>\(\rangle \)</div>
<a 
 id="dx170-375002"></a>
     <!--l. 968--><p class="noindent" >Sets the number of terms that are printed in intermediate polynomials.
                                                                     

                                                                     
     Note that this does not aﬀect the output of whole <span 
class="ptmri8t-x-x-109">dpmats</span>. The output
     of polynomials with more than \(n\) terms (\(n&gt;0\)) breaks oﬀ and continues with
     ellipses.
     </p></li>
     <li class="itemize">
     <!--l. 973--><p class="noindent" ><a 
 id="operator:CLEARCALIPRINTTERMS"></a>
       </p><div class="syntax">
        <span 
class="pcrr8t-x-x-109">clearcaliprintterms</span>()</div>
<a 
 id="dx170-375003"></a>
     <!--l. 979--><p class="noindent" >Clears the <span 
class="pcrr8t-x-x-109">printterms </span>value forcing full intermediate output (according to the
     current trace level).</p></li></ul>
<!--l. 983--><p class="noindent" >
</p>
<h5 class="likesubsubsectionHead"><a 
 id="x170-37600020.7.2"></a>Global Variables</h5>
     <dl class="description"><dt class="description">
     <!--l. 986--><p class="noindent" >
<span 
class="pcrr8t-x-x-109">cali!=basering</span> </p></dt><dd 
class="description">
     <!--l. 986--><p class="noindent" ><a 
 id="dx170-376001"></a><a 
 id="variable:CALI!=BASERING"></a> The currently active base ring initialized e.g. by <span 
class="pcrr8t-x-x-109">setring</span><a 
 id="dx170-376002"></a>.
     </p></dd><dt class="description">
     <!--l. 991--><p class="noindent" >
<span 
class="pcrr8t-x-x-109">cali!=degrees</span> </p></dt><dd 
class="description">
     <!--l. 991--><p class="noindent" ><a 
 id="dx170-376003"></a> <a 
 id="variable:CALI!=DEGREES"></a> The  currently  active  module  component  degrees  initialized  e.g. by
     <span 
class="pcrr8t-x-x-109">setdegrees</span><a 
 id="dx170-376004"></a>.
     </p></dd><dt class="description">
     <!--l. 996--><p class="noindent" >
<span 
class="pcrr8t-x-x-109">cali!=monset</span> </p></dt><dd 
class="description">
     <!--l. 996--><p class="noindent" ><a 
 id="dx170-376005"></a> <a 
 id="variable:CALI!=MONSET"></a> A   list   of   variable   names   considered   as   non   zero   divisors   during
     Gröbner   basis   computations   initialized   e.g. by   <span 
class="pcrr8t-x-x-109">setmonset</span><a 
 id="dx170-376006"></a>.   Useful
     e.g. for binomial ideals deﬁning monomial varieties or other prime ideals.
</p>
     </dd></dl>
                                                                     

                                                                     
<!--l. 1005--><p class="noindent" >
</p>
<h5 class="likesubsubsectionHead"><a 
 id="x170-37700020.7.2"></a>Entries on the Property List of <span 
class="pcrr8t-x-x-109">cali</span></h5>
<!--l. 1007--><p class="noindent" >This approach is new for v. 2.2. Information concerning the state of the computational
model as e.g. trace intensity, base coeﬃcient rules, or algorithm versions are
stored as values on the property list of the identiﬁer (package name) <span 
class="pcrr8t-x-x-109">cali</span>. This
concerns
     </p><dl class="description"><dt class="description">
     <!--l. 1012--><p class="noindent" >
 </p></dt><dd 
class="description">
     <!--l. 1012--><p class="noindent" ><span 
class="pcrr8t-x-x-109">trace</span><a 
 id="dx170-377001"></a> and <span 
class="pcrr8t-x-x-109">printterms</span><a 
 id="dx170-377002"></a>
     </p><!--l. 1014--><p class="noindent" >see above.
     </p></dd><dt class="description">
     <!--l. 1016--><p class="noindent" >
 </p></dt><dd 
class="description">
     <!--l. 1016--><p class="noindent" ><span 
class="pcrr8t-x-x-109">efgb</span><a 
 id="dx170-377003"></a>
     </p><!--l. 1018--><p class="noindent" >Changed by the <span 
class="ptmri8t-x-x-109">switch lexefgb</span><a 
 id="dx170-377004"></a>.
     </p></dd><dt class="description">
     <!--l. 1020--><p class="noindent" >
 </p></dt><dd 
class="description">
     <!--l. 1020--><p class="noindent" ><span 
class="pcrr8t-x-x-109">groeb!=rf</span><a 
 id="dx170-377005"></a> Reduction function invoked during the Gröbner algorithm. It can be changed
 with <span 
class="ptmri8t-x-x-109">gbtestversion</span><a 
 id="dx170-377006"></a> \(&lt;n&gt;\) (\(n=1,2,3\), default is 1).
     </p></dd><dt class="description">
     <!--l. 1024--><p class="noindent" >
 </p></dt><dd 
class="description">
     <!--l. 1024--><p class="noindent" ><span 
class="pcrr8t-x-x-109">hf!=hf</span><a 
 id="dx170-377007"></a>
     </p><!--l. 1027--><p class="noindent" >Variant for the computation of the Hilbert series numerator. It can be changed
with <span 
class="ptmri8t-x-x-109">hftestversion</span><a 
 id="dx170-377008"></a> \(&lt;n&gt;\) (\(n=1,2\), default is 1).
     </p></dd><dt class="description">
     <!--l. 1029--><p class="noindent" >
 </p></dt><dd 
class="description">
     <!--l. 1029--><p class="noindent" ><span 
class="pcrr8t-x-x-109">rules</span><a 
 id="dx170-377009"></a>
     </p><!--l. 1032--><p class="noindent" >Algebraic   “replaceby”   rules   introduced   to   <span 
class="ptmrc8t-x-x-109">C<span 
class="small-caps">A</span><span 
class="small-caps">L</span><span 
class="small-caps">I</span>   </span>with   the   <span 
class="pcrr8t-x-x-109">setrules</span><a 
 id="dx170-377010"></a>
command.
                                                                     

                                                                     
     </p></dd><dt class="description">
     <!--l. 1034--><p class="noindent" >
 </p></dt><dd 
class="description">
     <!--l. 1034--><p class="noindent" ><span 
class="pcrr8t-x-x-109">evlf</span><a 
 id="dx170-377011"></a>,     <span 
class="pcrr8t-x-x-109">varlessp</span><a 
 id="dx170-377012"></a>,     <span 
class="pcrr8t-x-x-109">sublist</span><a 
 id="dx170-377013"></a>,     <span 
class="pcrr8t-x-x-109">varnames</span><a 
 id="dx170-377014"></a>,     <span 
class="pcrr8t-x-x-109">oldborderbasis</span><a 
 id="dx170-377015"></a>,
     <span 
class="pcrr8t-x-x-109">oldring</span><a 
 id="dx170-377016"></a>, <span 
class="pcrr8t-x-x-109">oldbasis</span><a 
 id="dx170-377017"></a>
     </p><!--l. 1037--><p class="noindent" >see <span 
class="ptmri8t-x-x-109">module lf</span> <a 
 id="dx170-377018"></a>, implementing the dual bases approach.
     </p></dd></dl>
<!--l. 1041--><p class="noindent" >
</p>
<h4 class="subsectionHead"><span class="titlemark">20.7.3    </span> <a 
 id="x170-37800020.7.3"></a>Basic Data Structures</h4>
<!--l. 1043--><p class="noindent" >In the following we describe the data structure layers underlying the dpmat
representation in <span 
class="ptmrc8t-x-x-109">C<span 
class="small-caps">A</span><span 
class="small-caps">L</span><span 
class="small-caps">I</span> </span>and some important (symbolic) procedures to handle them. We
refer to the source code and the comments therein for a more complete survey about the
procedures available for diﬀerent data types.
</p><!--l. 1049--><p class="noindent" >
</p>
<h5 class="subsubsectionHead"><a 
 id="x170-37900020.7.3"></a>The Coeﬃcient Domain</h5>
<!--l. 1051--><p class="noindent" >Base coeﬃcients as implemented in the <span 
class="ptmri8t-x-x-109">module bcsf</span> <a 
 id="dx170-379001"></a> are standard forms
in the variables outside the variable list of the current ring. All computations
are executed &#x0022;denominator free&#x0022; over the corresponding quotient ﬁeld,
i.e. gcd’s are canceled out without request. To avoid this set the <span 
class="pcrr8t-x-x-109">bcsimp</span><a 
 id="dx170-379002"></a><a 
 id="dx170-379003"></a><a 
 id="dx170-379004"></a>
oﬀ.<span class="footnote-mark"><a 
href="manual178.html#fn8x20"><sup class="textsuperscript">8</sup></a></span><a 
 id="x170-379005f8"></a> 
In the given implementation we use the s.f. procedure <span 
class="pcrr8t-x-x-109">qremf </span>for eﬀective divisibility
test. We had some trouble with it under <span 
class="pcrr8t-x-x-109">on factor</span>.
</p><!--l. 1062--><p class="noindent" >Additionally it is possible to supply the parameters occuring as base coeﬃcients with a (global) set of
                                                                     

                                                                     
algebraic rules.<span class="footnote-mark"><a 
href="manual179.html#fn9x20"><sup class="textsuperscript">9</sup></a></span><a 
 id="x170-379006f9"></a> 
     </p><dl class="description"><dt class="description">
     <!--l. 1069--><p class="noindent" >
 </p></dt><dd 
class="description">
     <!--l. 1069--><p class="noindent" ><a 
 id="dx170-379007"></a> <a 
 id="procedure:SETRULES!*"></a>
       </p><div class="syntax">
        <span 
class="pcrr8t-x-x-109">setrules!*</span>\(\langle \)<span 
class="ptmri8t-x-x-109">r</span>\(\rangle \)</div>
     <!--l. 1076--><p class="noindent" >converts an algebraic mode rules list \(r\) as e.g. used in WHERE statements into
the internal <span 
class="ptmrc8t-x-x-109">C<span 
class="small-caps">A</span><span 
class="small-caps">L</span><span 
class="small-caps">I</span> </span>format.</p></dd></dl>
<h5 class="subsubsectionHead"><a 
 id="x170-38000020.7.3"></a>The Base Ring</h5>
<!--l. 1081--><p class="noindent" >The <span 
class="ptmri8t-x-x-109">base ring</span><a 
 id="dx170-380001"></a> is deﬁned by its <span 
class="pcrr8t-x-x-109">name list</span>, the <span 
class="pcrr8t-x-x-109">degree matrix </span>(a list of lists of
integers), the <span 
class="pcrr8t-x-x-109">ring tag </span>(LEX or REVLEX), and the <span 
class="pcrr8t-x-x-109">ecart</span>. The name list
contains a phantom name <span 
class="pcrr8t-x-x-109">cali!=mk </span>for the module component at place 0.
</p><!--l. 1087--><p class="noindent" >The <span 
class="ptmri8t-x-x-109">module ring</span><a 
 id="dx170-380002"></a> exports among others the selectors <span 
class="pcrr8t-x-x-109">ring_names</span><a 
 id="dx170-380003"></a>, <span 
class="pcrr8t-x-x-109">ring_degrees</span><a 
 id="dx170-380004"></a>,
<span 
class="pcrr8t-x-x-109">ring_tag</span><a 
 id="dx170-380005"></a>, <span 
class="pcrr8t-x-x-109">ring_ecart</span><a 
 id="dx170-380006"></a>, the test function <span 
class="pcrr8t-x-x-109">ring_isnoetherian</span><a 
 id="dx170-380007"></a> and the transfer
procedures from/to an (appropriate, printable by <span 
class="pcrr8t-x-x-109">mathprint</span><a 
 id="dx170-380008"></a>) algebraic preﬁx form
<span 
class="pcrr8t-x-x-109">ring_from_a</span><a 
 id="dx170-380009"></a> (including extensive tests of the supplied parameters for consistency)
and <span 
class="pcrr8t-x-x-109">ring_2a</span><a 
 id="dx170-380010"></a>.
</p><!--l. 1096--><p class="noindent" >The following procedures allow to deﬁne a base ring:
     </p><dl class="description"><dt class="description">
     <!--l. 1098--><p class="noindent" >
 </p></dt><dd 
class="description">
     <!--l. 1098--><p class="noindent" ><a 
 id="dx170-380011"></a> <a 
 id="procedure:RING_DEFINE"></a>
       </p><div class="syntax">
        <span 
class="pcrr8t-x-x-109">ring_define</span>(\(\langle \)<span 
class="ptmri8t-x-x-109">name list</span>\(\rangle \), \(\langle \)<span 
class="ptmri8t-x-x-109">degree matrix</span>\(\rangle \), \(\langle \)<span 
class="ptmri8t-x-x-109">ring tag</span>\(\rangle \), \(\langle \)<span 
class="ptmri8t-x-x-109">ecart</span>\(\rangle \)</div>
     <!--l. 1104--><p class="noindent" >combines the given parameters to a ring.
                                                                     

                                                                     
     </p></dd><dt class="description">
     <!--l. 1106--><p class="noindent" >
 </p></dt><dd 
class="description">
     <!--l. 1106--><p class="noindent" ><a 
 id="dx170-380012"></a> <a 
 id="procedure:SETRING!*"></a>
       </p><div class="syntax">
        <span 
class="pcrr8t-x-x-109">setring!*</span>\(\langle \)<span 
class="ptmri8t-x-x-109">ring</span>\(\rangle \)</div>
     <!--l. 1116--><p class="noindent" >sets <span 
class="pcrr8t-x-x-109">cali!=basering </span>and checks for consistency with the <span 
class="pcrr8t-x-x-109">Noetherian</span><a 
 id="dx170-380013"></a><a 
 id="dx170-380014"></a><a 
 id="dx170-380015"></a>.
It also sets through <span 
class="pcrr8t-x-x-109">setkorder</span><a 
 id="dx170-380016"></a>he current variable list as main variables. It is
strongly recommended to use <span 
class="pcrr8t-x-x-109">setring!* </span><span 
class="pcrr8t-x-x-109">… </span>instead of <span 
class="pcrr8t-x-x-109">cali!=basering</span>
<span 
class="pcrr8t-x-x-109">:= </span><span 
class="pcrr8t-x-x-109">…</span>.</p></dd></dl>
<a 
 id="dx170-380017"></a>
<a 
 id="dx170-380018"></a>
<a 
 id="dx170-380019"></a>
<a 
 id="dx170-380020"></a>
<!--l. 1122--><p class="noindent" ><span 
class="pcrr8t-x-x-109">degreeorder!* </span>, <span 
class="pcrr8t-x-x-109">localorder!*</span>, <span 
class="pcrr8t-x-x-109">eliminationorder!*</span>, and
<span 
class="pcrr8t-x-x-109">blockorder!* </span>deﬁne term order matrices in full analogy to algebraic mode.
</p><!--l. 1127--><p class="noindent" >There are three ring constructors for special purposes:
     </p><dl class="description"><dt class="description">
     <!--l. 1129--><p class="noindent" >
 </p></dt><dd 
class="description">
     <!--l. 1129--><p class="noindent" >
       </p><div class="syntax">
        <span 
class="pcrr8t-x-x-109">ring_sum</span>(\(\langle \)<span 
class="ptmri8t-x-x-109">a</span>\(\rangle \),\(\langle \)<span 
class="ptmri8t-x-x-109">b</span>\(\rangle \))</div>
<a 
 id="dx170-380021"></a>
     <!--l. 1134--><p class="noindent" ><a 
 id="procedure:RING_SUM"></a> returns a ring, that is constructed in the following way: Its variable list is the
 union of the (disjoint) lists of the variables of the rings \(\langle \)<span 
class="ptmri8t-x-x-109">a</span>\(\rangle \) and \(\langle \)<span 
class="ptmri8t-x-x-109">b</span>\(\rangle \) (in this order)
 whereas the degree list is the union of the (appropriately shifted) degree lists
 of \(\langle \)<span 
class="ptmri8t-x-x-109">b</span>\(\rangle \) and \(\langle \)<span 
class="ptmri8t-x-x-109">a</span>\(\rangle \) (in this order). The ring tag is that of \(\langle \)<span 
class="ptmri8t-x-x-109">a</span>\(\rangle \). Hence it returns (essentially)
 the ring \(b\bigoplus a\) if \(b\) has a degree part (e.g. useful for elimination problems, introducing
 “big” new variables) and the ring \(a\bigoplus b\) if \(b\) has no degree part (introducing “small”
 new variables).
     </p></dd><dt class="description">
     <!--l. 1145--><p class="noindent" >
 </p></dt><dd 
class="description">
                                                                     

                                                                     
     <!--l. 1145--><p class="noindent" >
       </p><div class="syntax">
        <span 
class="pcrr8t-x-x-109">ring_rlp</span>(\(\langle \)<span 
class="ptmri8t-x-x-109">r</span>\(\rangle \),\(\langle \)<span 
class="ptmri8t-x-x-109">u</span>\(\rangle \))</div>
<a 
 id="dx170-380022"></a>
     <!--l. 1150--><p class="noindent" ><a 
 id="procedure:RING_RLP"></a>
     </p><!--l. 1153--><p class="noindent" >\(\langle \)<span 
class="ptmri8t-x-x-109">u</span>\(\rangle \) is a subset of the names of the ring \(\langle \)<span 
class="ptmri8t-x-x-109">r</span>\(\rangle \). Returns the ring \(\langle \)<span 
class="ptmri8t-x-x-109">r</span>\(\rangle \), but with a term order
“ﬁrst degrevlex on \(\langle \)<span 
class="ptmri8t-x-x-109">u</span>\(\rangle \), then the order on \(\langle \)<span 
class="ptmri8t-x-x-109">r</span>\(\rangle \)”.
     </p></dd><dt class="description">
     <!--l. 1155--><p class="noindent" >
 </p></dt><dd 
class="description">
     <!--l. 1155--><p class="noindent" >
       </p><div class="syntax">
        <span 
class="pcrr8t-x-x-109">ring_lp</span>(\(\langle \)<span 
class="ptmri8t-x-x-109">r</span>\(\rangle \),\(\langle \)<span 
class="ptmri8t-x-x-109">u</span>\(\rangle \))</div>
<a 
 id="dx170-380023"></a>
     <!--l. 1160--><p class="noindent" ><a 
 id="procedure:RING_LP"></a>
     </p><!--l. 1163--><p class="noindent" >As <span 
class="pcrr8t-x-x-109">ring_rlp</span>, but with a term order “ﬁrst lex on \(\langle \)<span 
class="ptmri8t-x-x-109">u</span>\(\rangle \), then the order on \(\langle \)<span 
class="ptmri8t-x-x-109">r</span>\(\rangle \)”.
     </p></dd></dl>
<!--l. 1166--><p class="noindent" >Example:
                                                                     

                                                                     
</p>
<pre class="verbatim" id="verbatim-697">
vars:=’(x y z)
setring!* ring_define(vars,degreeorder!* vars,’lex,’(1 1 1));
                        % GRADLEX in the groebner package.
</pre>
<!--l. 1171--><p class="nopar" >
</p><!--l. 1173--><p class="noindent" >
</p>
<h5 class="subsubsectionHead"><a 
 id="x170-38100020.7.3"></a>Monomials</h5>
<!--l. 1175--><p class="noindent" >The current version uses a place-driven exponent representation closely related to a
vector model. This model handles term orders on \(S\) and module term orders on \(S^c\) in a unique
way. The zero component of the exponent list of a monomial contains its module
component (\(&gt;0\)) or 0 (ring element). All computations are executed with respect to a <span 
class="ptmri8t-x-x-109">current</span>
<span 
class="ptmri8t-x-x-109">ring </span>(<span 
class="pcrr8t-x-x-109">cali!=basering</span><a 
 id="dx170-381001"></a>) and <span 
class="ptmri8t-x-x-109">current (monomial) weights </span>of the free generators \(e_i, i=1,\ldots ,c\), of \(S^c\)
(<span 
class="pcrr8t-x-x-109">cali!=degrees</span><a 
 id="dx170-381002"></a>). For eﬃciency reasons every monomial has a precomputed
degree part that should be reevaluated if <span 
class="pcrr8t-x-x-109">cali!=basering </span>(i.e. the term
order) or <span 
class="pcrr8t-x-x-109">cali!=degrees </span>were changed. <span 
class="pcrr8t-x-x-109">cali!=degrees </span>contains the
list of column degrees of the current module as an assoc. list and will be set
automatically by (almost) all dpmat procedure calls. Since monomial operations use the
degree list that was precomputed with respect to ﬁxed column degrees (and base
ring)
     </p><blockquote class="quote">
     <!--l. 1195--><p class="noindent" ><span 
class="ptmb8t-x-x-109">watch   carefully   for   </span><span 
class="pcrr8t-x-x-109">cali!=degrees </span><span 
class="ptmb8t-x-x-109">programming   at   the</span>
     <span 
class="ptmb8t-x-x-109">monomial or dpoly level !</span></p></blockquote>
<!--l. 1198--><p class="noindent" >As procedures there are selectors for the module component, the exponent and the degree
parts, comparison procedures, procedures for the management of the module component
and the degree vector, monomial arithmetic, transfer from/to preﬁx form, and more
special tools.
</p><!--l. 1203--><p class="noindent" >
                                                                     

                                                                     
</p>
<h5 class="subsubsectionHead"><a 
 id="x170-38200020.7.3"></a>Polynomials and Polynomial Vectors</h5>
<!--l. 1205--><p class="noindent" ><span 
class="ptmrc8t-x-x-109">C<span 
class="small-caps">A</span><span 
class="small-caps">L</span><span 
class="small-caps">I</span> </span>uses a distributive representation as a list of terms for both polynomials and
polynomial vectors, where a <span 
class="ptmri8t-x-x-109">term</span><a 
 id="dx170-382001"></a> is a dotted pair
     </p><blockquote class="quote">
     <!--l. 1209--><p class="noindent" ><span 
class="pcrr8t-x-x-109">(</span>\(\langle \)<span 
class="ptmri8t-x-x-109">monomial</span>\(\rangle \) <span 
class="pcrr8t-x-x-109">.</span>\(\langle \)<span 
class="ptmri8t-x-x-109">base coeﬃcient</span>\(\rangle \)<span 
class="pcrr8t-x-x-109">)</span></p></blockquote>
<!--l. 1211--><p class="noindent" >The <span 
class="ptmri8t-x-x-109">ecart</span><a 
 id="dx170-382002"></a> of a polynomial (vector) \(f=\sum {t_i}\) with (module) terms \(t_i\) is deﬁned as \[\max (\mathop {\mathrm {ec}}(t_i))-\mathop {\mathrm {ec}}(lt(t_i)),\] see <span class="cite">[<a 
href="manualap2.html#XGraebe:94">Grä94b</a>]</span>.
Here \(\mathop {\mathrm {ec}}(t_i)\) denotes the ecart of the term \(t_i\), i.e. the scalar product of the exponent vector of \(t_i\)
(including the monomial weight of the module generator) with the ecart vector of the
current base ring.
</p><!--l. 1218--><p class="noindent" >As procedures there are selectors, dpoly arithmetic including the management of the
module component, procedures for reordering (and reevaluating) polynomials wrt. new
term order degrees, for extracting common base coeﬃcient or monomial factors, for
transfer from/to preﬁx form and for homogenization and dehomogenization (wrt. the
current ecart vector).
</p><!--l. 1224--><p class="noindent" >Two advanced procedures use ideal theory ingredients:
     </p><dl class="description"><dt class="description">
     <!--l. 1226--><p class="noindent" >
 </p></dt><dd 
class="description">
     <!--l. 1226--><p class="noindent" >
       </p><div class="syntax">
        <span 
class="pcrr8t-x-x-109">dp_pseudodivmod</span>(\(\langle \)<span 
class="ptmri8t-x-x-109">g</span>\(\rangle \),\(\langle \)<span 
class="ptmri8t-x-x-109">f</span> \(\rangle \))</div>
<a 
 id="dx170-382003"></a>
     <!--l. 1231--><p class="noindent" ><a 
 id="procedure:DP_PSEUDODIVMOD"></a> returns a dpoly list \(\{q,r,z\}\) such that \(z\cdot g = q\cdot f + r\) and \(z\) is a dpoly unit (i.e. a scalar for Noetherian
 term orders). For non Noetherian term orders the necessary modiﬁcations are
 described in <span class="cite">[<a 
href="manualap2.html#XGraebe:95a">Grä95a</a>]</span>.
 \(g, f\) and \(r\) belong to the same free module or ideal.
     </p></dd><dt class="description">
     <!--l. 1240--><p class="noindent" >
 </p></dt><dd 
class="description">
     <!--l. 1240--><p class="noindent" >
       </p><div class="syntax">
        <span 
class="pcrr8t-x-x-109">dpgcd</span>(\(\langle \)<span 
class="ptmri8t-x-x-109">a</span>\(\rangle \),\(\langle \)<span 
class="ptmri8t-x-x-109">b</span>\(\rangle \))</div>
<a 
 id="dx170-382004"></a>
                                                                     

                                                                     
     <!--l. 1245--><p class="noindent" ><a 
 id="procedure:DPGCD"></a> computes  the  gcd  of  two  dpolys  \(a\)  and  \(b\)  by  the  syzygy  method:  The  syzygy
 module of \(\{a,b\}\) is generated by a single element \([-b_0\ \ a_0]\) with \(a=ga_0, b=gb_0\), where \(g\) is the gcd of \(a\) and \(b\).
 Since it uses dpoly pseudodivision it may work not properly with <span 
class="pcrr8t-x-x-109">setrules</span><a 
 id="dx170-382005"></a>.
     </p></dd></dl>
<!--l. 1254--><p class="noindent" >
</p>
<h5 class="subsubsectionHead"><a 
 id="x170-38300020.7.3"></a>Base Lists</h5>
<!--l. 1256--><p class="noindent" >Ideal bases are one of the main ingredients for dpmats. They are represented as lists of
<span 
class="ptmri8t-x-x-109">base elements</span><a 
 id="dx170-383001"></a> and contain together with each dpoly entry the following information:
</p>
     <ul class="itemize1">
     <li class="itemize">
     <!--l. 1260--><p class="noindent" >a number (the row number of the polynomial vector in the corresponding
     dpmat).
     </p></li>
     <li class="itemize">
     <!--l. 1263--><p class="noindent" >the dpoly, its ecart (as the main sort criterion), and length.
     </p></li>
     <li class="itemize">
     <!--l. 1265--><p class="noindent" >a representation part, that may contain a representation of the given dpoly in
     terms of a certain ﬁxed basis (default: empty).</p></li></ul>
<!--l. 1269--><p class="noindent" >The representation part is managed during normal form computations and other row
arithmetic of dpmats appropriately with the following procedures:
     </p><dl class="description"><dt class="description">
     <!--l. 1273--><p class="noindent" >
 </p></dt><dd 
class="description">
     <!--l. 1273--><p class="noindent" >
       </p><div class="syntax">
        <span 
class="pcrr8t-x-x-109">bas_setrelations</span>\(\langle \)<span 
class="ptmri8t-x-x-109">b</span>\(\rangle \)</div>
<a 
 id="dx170-383002"></a>
     <!--l. 1278--><p class="noindent" ><a 
 id="procedure:BAS_SETRELATIONS"></a> sets the relation part of the base element \(i\) in the base list \(\langle \)<span 
class="ptmri8t-x-x-109">b</span>\(\rangle \) to \(e_i\).
                                                                     

                                                                     
     </p></dd><dt class="description">
     <!--l. 1282--><p class="noindent" >
 </p></dt><dd 
class="description">
     <!--l. 1282--><p class="noindent" >
       </p><div class="syntax">
        <span 
class="pcrr8t-x-x-109">bas_removerelations</span>\(\langle \)<span 
class="ptmri8t-x-x-109">b</span>\(\rangle \)</div>
<a 
 id="dx170-383003"></a>
     <!--l. 1287--><p class="noindent" ><a 
 id="procedure:BAS_REMOVERELATIONS"></a> removes all relations, i.e. replaces them with the zero polynomial vector.
     </p></dd><dt class="description">
     <!--l. 1291--><p class="noindent" >
 </p></dt><dd 
class="description">
     <!--l. 1291--><p class="noindent" >
       </p><div class="syntax">
        <span 
class="pcrr8t-x-x-109">bas_getrelations</span>\(\langle \)<span 
class="ptmri8t-x-x-109">b</span>\(\rangle \)</div>
<a 
 id="dx170-383004"></a>
     <!--l. 1296--><p class="noindent" ><a 
 id="procedure:BAS_GETRELATIONS"></a> gets the relation part of \(\langle \)<span 
class="ptmri8t-x-x-109">b</span>\(\rangle \) as a separate base list.
     </p></dd></dl>
<!--l. 1300--><p class="noindent" >Further there are procedures for selection and construction of base elements and for the
manipulation of lists of base elements as e.g. sorting, renumbering, reordering,
simpliﬁcation, deleting zero base elements, transfer from/to preﬁx form, homogenization
and dehomogenization.
</p><!--l. 1305--><p class="noindent" >
</p>
<h5 class="subsubsectionHead"><a 
 id="x170-38400020.7.3"></a>Dpoly Matrices</h5>
<!--l. 1307--><p class="noindent" >Ideals and matrices, represented as <span 
class="ptmri8t-x-x-109">dpmat</span><a 
 id="dx170-384001"></a>s, are the central data type of the <span 
class="ptmrc8t-x-x-109">C<span 
class="small-caps">A</span><span 
class="small-caps">L</span><span 
class="small-caps">I</span></span>
package, as already explained above. Every dpmat \(m\) combines the following information:
</p>
     <ul class="itemize1">
     <li class="itemize">
     <!--l. 1311--><p class="noindent" >its size (<span 
class="pcrr8t-x-x-109">dpmat_rows</span><a 
 id="dx170-384002"></a> m,<span 
class="pcrr8t-x-x-109">dpmat_cols</span><a 
 id="dx170-384003"></a> m),
                                                                     

                                                                     
     </p></li>
     <li class="itemize">
     <!--l. 1313--><p class="noindent" >its base list (<span 
class="pcrr8t-x-x-109">dpmat_list</span><a 
 id="dx170-384004"></a> m) and
     </p></li>
     <li class="itemize">
     <!--l. 1315--><p class="noindent" >its column degrees as an assoc. list of monomials (<span 
class="pcrr8t-x-x-109">dpmat_coldegs</span><a 
 id="dx170-384005"></a> m). If
     this list is empty, all degrees are assumed to be equal to \(x^0\).
     </p></li>
     <li class="itemize">
     <!--l. 1319--><p class="noindent" >New in v. 2.2 there is a <span 
class="ptmri8t-x-x-109">gb-tag</span><a 
 id="dx170-384006"></a> (<span 
class="pcrr8t-x-x-109">dpmat_gbtag</span><a 
 id="dx170-384007"></a> m), indicating that the given
     base list is already a Gröbner basis (under the given term order).</p></li></ul>
<!--l. 1324--><p class="noindent" >The <span 
class="ptmri8t-x-x-109">module dpmat</span><a 
 id="dx170-384008"></a> contains selectors, constructors, and the algorithms for the basic
management of this data structure as e.g. ﬁle transfer, transfer from/to algebraic preﬁx
forms, reordering, simpliﬁcation, extracting row degrees and leading terms, dpmat matrix
arithmetic, homogenization and dehomogenization.
</p><!--l. 1330--><p class="noindent" >The modules <span 
class="ptmri8t-x-x-109">matop </span>and <span 
class="ptmri8t-x-x-109">quot </span>collect more advanced procedures for the algebraic
management of dpmats.
</p><!--l. 1333--><p class="noindent" >
</p>
<h5 class="subsubsectionHead"><a 
 id="x170-38500020.7.3"></a>Extending the REDUCE Matrix Package</h5>
<!--l. 1335--><p class="noindent" >In v. 2.2 minors, Jacobian matrix, and Pfaﬃans are available for general REDUCE
matrices. They are collected in the <span 
class="ptmri8t-x-x-109">module calimat</span><a 
 id="dx170-385001"></a> and allow to deﬁne procedures in
more generality, especially allowing variable exponents in polynomial expressions. Such
a generalization is especially useful for the investigation of whole classes of examples
that may be obtained from a generic one by specialization. In the following \(\langle \)<span 
class="ptmri8t-x-x-109">m</span>\(\rangle \) is a matrix
given in algebraic preﬁx form.
     </p><dl class="description"><dt class="description">
     <!--l. 1344--><p class="noindent" >
 </p></dt><dd 
class="description">
     <!--l. 1344--><p class="noindent" >
       </p><div class="syntax">
        <span 
class="pcrr8t-x-x-109">matjac</span>(\(\langle \)<span 
class="ptmri8t-x-x-109">m</span>\(\rangle \),\(\langle \)<span 
class="ptmri8t-x-x-109">l</span>\(\rangle \))</div>
<a 
 id="dx170-385002"></a>
                                                                     

                                                                     
     <!--l. 1349--><p class="noindent" ><a 
 id="procedure:MATJAC"></a> returns the Jacobian matrix of the ideal \(\langle \)<span 
class="ptmri8t-x-x-109">m</span>\(\rangle \) (given as an algebraic mode list)
 with respect to the variable list \(\langle \)<span 
class="ptmri8t-x-x-109">l</span>\(\rangle \).
     </p></dd><dt class="description">
     <!--l. 1353--><p class="noindent" >
 </p></dt><dd 
class="description">
     <!--l. 1353--><p class="noindent" >
       </p><div class="syntax">
        <span 
class="pcrr8t-x-x-109">minors</span>(\(\langle \)<span 
class="ptmri8t-x-x-109">m</span>\(\rangle \),\(\langle \)<span 
class="ptmri8t-x-x-109">k</span>\(\rangle \))</div>
<a 
 id="dx170-385003"></a>
     <!--l. 1358--><p class="noindent" ><a 
 id="procedure:MINORS"></a> returns the matrix of \(k\)-minors of the matrix \(m\).
     </p></dd><dt class="description">
     <!--l. 1361--><p class="noindent" >
 </p></dt><dd 
class="description">
     <!--l. 1361--><p class="noindent" >
       </p><div class="syntax">
        <span 
class="pcrr8t-x-x-109">ideal_of_minors</span>(\(\langle \)<span 
class="ptmri8t-x-x-109">m</span>\(\rangle \),\(\langle \)<span 
class="ptmri8t-x-x-109">k</span>\(\rangle \))</div>
<a 
 id="dx170-385004"></a>
     <!--l. 1366--><p class="noindent" ><a 
 id="procedure:IDEAL_OF_MINORS"></a> returns the ideal of the \(k\)-minors of the matrix \(m\).
     </p></dd><dt class="description">
     <!--l. 1369--><p class="noindent" >
 </p></dt><dd 
class="description">
     <!--l. 1369--><p class="noindent" >
       </p><div class="syntax">
        <span 
class="pcrr8t-x-x-109">pfaffian</span>\(\langle \)<span 
class="ptmri8t-x-x-109">m</span>\(\rangle \)</div>
<a 
 id="dx170-385005"></a>
     <!--l. 1374--><p class="noindent" ><a 
 id="procedure:PFAFFIAN"></a> returns the pfaﬃan of a skewsymmetric matrix \(m\).
     </p></dd><dt class="description">
     <!--l. 1377--><p class="noindent" >
 </p></dt><dd 
class="description">
                                                                     

                                                                     
     <!--l. 1377--><p class="noindent" >
       </p><div class="syntax">
        <span 
class="pcrr8t-x-x-109">ideal_of_pfaffians</span>(\(\langle \)<span 
class="ptmri8t-x-x-109">m</span>\(\rangle \),\(\langle \)<span 
class="ptmri8t-x-x-109">k</span>\(\rangle \))</div>
<a 
 id="dx170-385006"></a>
     <!--l. 1382--><p class="noindent" ><a 
 id="procedure:IDEAL_OF_PFAFFIANS"></a> returns the ideal of the \(2k\)-pfaﬃans of the skewsymmetric matrix \(m\).
     </p></dd><dt class="description">
     <!--l. 1386--><p class="noindent" >
 </p></dt><dd 
class="description">
     <!--l. 1386--><p class="noindent" >
       </p><div class="syntax">
        <span 
class="pcrr8t-x-x-109">random_linear_form</span>(\(\langle \)<span 
class="ptmri8t-x-x-109">vars</span>\(\rangle \),\(\langle \)<span 
class="ptmri8t-x-x-109">bound</span>\(\rangle \))</div>
<a 
 id="dx170-385007"></a>
     <!--l. 1391--><p class="noindent" ><a 
 id="procedure:RANDOM_LINEAR_FORM"></a> returns a random linear form in algebraic preﬁx form in the supplied variables
 \(vars\) with integer coeﬃcients bounded by the supplied \(bound\).
     </p></dd><dt class="description">
     <!--l. 1396--><p class="noindent" >
 </p></dt><dd 
class="description">
     <!--l. 1396--><p class="noindent" >
       </p><div class="syntax">
        <span 
class="pcrr8t-x-x-109">singular_locus!*</span>(\(\langle \)<span 
class="ptmri8t-x-x-109">m</span>\(\rangle \),\(\langle \)<span 
class="ptmri8t-x-x-109">c</span>\(\rangle \))</div>
<a 
 id="dx170-385008"></a>
     <!--l. 1401--><p class="noindent" ><a 
 id="procedure:SINGULAR_LOCUS!*"></a> returns the singular locus of \(m\) (as dpmat). \(m\) must be an ideal of codimension \(c\)
 given as a list of polynomials in preﬁx form. <span 
class="pcrr8t-x-x-109">singular_locus</span><a 
 id="dx170-385009"></a> computes
 the ideal generated by the corresponding Jacobian and \(m\) itself.
     </p></dd></dl>
<!--l. 1409--><p class="noindent" >
</p>
<h4 class="subsectionHead"><span class="titlemark">20.7.4    </span> <a 
 id="x170-38600020.7.4"></a>About the Algorithms Implemented in <span 
class="ptmrc8t-x-x-109">C<span 
class="small-caps">A</span><span 
class="small-caps">L</span><span 
class="small-caps">I</span></span></h4>
<!--l. 1411--><p class="noindent" >Below we give a short explanation of the main algorithmic ideas of <span 
class="ptmrc8t-x-x-109">C<span 
class="small-caps">A</span><span 
class="small-caps">L</span><span 
class="small-caps">I</span> </span>and the way
they are implemented and may be accessed (symbolically).
                                                                     

                                                                     
</p><!--l. 1415--><p class="noindent" >
</p>
<h5 class="subsubsectionHead"><a 
 id="x170-38700020.7.4"></a>Normal Form Algorithms</h5>
<!--l. 1417--><p class="noindent" >For v. 2.2 we completely revised the implementation of normal form algorithms due to
the insight obtained from our investigations of normal form procedures for local term
orders in <span class="cite">[<a 
href="manualap2.html#XGraebe:95a">Grä95a</a>]</span> and <span class="cite">[<a 
href="manualap2.html#XGraebe:94">Grä94b</a>]</span>. It allows a common handling of Noetherian and non
Noetherian term orders already on this level thus making superﬂuous the former
duplication of reduction procedures in the modules <span 
class="ptmri8t-x-x-109">red </span>and <span 
class="ptmri8t-x-x-109">mora </span>as in v. 2.1.
</p><!--l. 1426--><p class="noindent" >Normal form algorithms reduce polynomials (or polynomial vectors) with respect to a
given ﬁnite set of generators of an ideal or module. The result is not unique
except for a total normal form with respect to a Gröbner basis. Furthermore
diﬀerent reduction strategies may yield signiﬁcant diﬀerences in computing
time.
</p><!--l. 1432--><p class="noindent" ><span 
class="ptmrc8t-x-x-109">C<span 
class="small-caps">A</span><span 
class="small-caps">L</span><span 
class="small-caps">I</span> </span>reduces by ﬁrst matching, usually keeping base lists sorted with respect to the sort
predicate <span 
class="ptmri8t-x-x-109">red_better</span><a 
 id="dx170-387001"></a>. In v. 2.2 we sort solely by the dpoly length, since the introduction
of <span 
class="ptmri8t-x-x-109">red_TopRedBE</span><a 
 id="dx170-387002"></a>, i.e. reduction with bounded ecart, guarantees termination also for
non Noetherian term orders. Overload red_better for other reduction strategies.
</p><!--l. 1440--><p class="noindent" >Reduction procedures produce for a given ideal basis \(B\subset S\) and a polynomial \(f\in S\) a (pseudo)
normal form \(h\in S\) such that \(h\equiv u\cdot f\ mod\ B\) where \(u\in S\) is a polynomial unit, i.e. a (polynomially represented)
non zero domain element in the Noetherian case (pseudodivision of \(f\) by \(B\)) or a polynomial
with a scalar as leading term in the non Noetherian case. Following up the reduction
steps one can even produce a presentation of \(h-u\cdot f\) as a polynomial combination of the base
elements in \(B\).
</p><!--l. 1449--><p class="noindent" >More general, given for \(f_i\in B\) and \(f\) representations \(f_i = \sum {r_{ik}e_k} = R_i\cdot E^T\) and \(f=R\cdot E^T\) as polynomial combinations wrt. a
ﬁxed basis \(E\) one can produce such a presentation also for \(h\). For this purpose
the dpoly \(f\) and its representation are collected into a base element and reduced
simultaneously by the base list \(B\), that collects the base elements and their representations.
</p><!--l. 1458--><p class="noindent" >The main procedures of the newly designed reduction package are the following:
     </p><dl class="description"><dt class="description">
     <!--l. 1462--><p class="noindent" >
 </p></dt><dd 
class="description">
     <!--l. 1462--><p class="noindent" >
       </p><div class="syntax">
        <span 
class="pcrr8t-x-x-109">red_TopRedBE</span>(\(\langle \)<span 
class="ptmri8t-x-x-109">bas</span>\(\rangle \),\(\langle \)<span 
class="ptmri8t-x-x-109">model</span>\(\rangle \))</div>
<a 
 id="dx170-387003"></a>
                                                                     

                                                                     
     <!--l. 1467--><p class="noindent" ><a 
 id="procedure:RED_TOPREDBE"></a> Top  reduction  with  bounded  ecart  of  the  base  element  \(model\)  by  the  base  list  \(bas\),
 i.e. only reducing the top term and only with base elements with ecart bounded
 by that of \(model\).
     </p></dd><dt class="description">
     <!--l. 1472--><p class="noindent" >
 </p></dt><dd 
class="description">
     <!--l. 1472--><p class="noindent" >
       </p><div class="syntax">
        <span 
class="pcrr8t-x-x-109">red_TopRed</span>(\(\langle \)<span 
class="ptmri8t-x-x-109">bas</span>\(\rangle \),\(\langle \)<span 
class="ptmri8t-x-x-109">model</span>\(\rangle \))</div>
<a 
 id="dx170-387004"></a>
     <!--l. 1477--><p class="noindent" ><a 
 id="procedure:RED_TOPRED"></a> Top reduction of \(model\), but without restrictions.
     </p></dd><dt class="description">
     <!--l. 1480--><p class="noindent" >
 </p></dt><dd 
class="description">
     <!--l. 1480--><p class="noindent" >
       </p><div class="syntax">
        <span 
class="pcrr8t-x-x-109">red_TailRed</span>(\(\langle \)<span 
class="ptmri8t-x-x-109">bas</span>\(\rangle \),\(\langle \)<span 
class="ptmri8t-x-x-109">model</span>\(\rangle \))</div>
<a 
 id="dx170-387005"></a>
     <!--l. 1485--><p class="noindent" ><a 
 id="procedure:RED_TAILRED"></a> Make tail reduction on \(model\), i.e. top reduction on the tail terms. For convergence
 this uses reduction with bounded ecart for non Noetherian term orders and full
 reduction otherwise.
     </p><!--l. 1491--><p class="noindent" >There is a common <span 
class="pcrr8t-x-x-109">red_TailRedDriver</span><a 
 id="dx170-387006"></a> that takes a top reduction function as
     parameter. It can be used for experiments with other top reduction procedure
     combinations.
     </p></dd><dt class="description">
     <!--l. 1495--><p class="noindent" >
 </p></dt><dd 
class="description">
     <!--l. 1495--><p class="noindent" >
       </p><div class="syntax">
        <span 
class="pcrr8t-x-x-109">red_TotalRed</span>(\(\langle \)<span 
class="ptmri8t-x-x-109">bas</span>\(\rangle \),\(\langle \)<span 
class="ptmri8t-x-x-109">model</span>\(\rangle \))</div>
<a 
 id="dx170-387007"></a>
     <!--l. 1500--><p class="noindent" ><a 
 id="procedure:RED_TOTALRED"></a> A terminating total reduction, i.e. for Noetherian term orders the classical one
 and for local term orders using tail reduction with bounded ecart.
                                                                     

                                                                     
     </p></dd><dt class="description">
     <!--l. 1505--><p class="noindent" >
 </p></dt><dd 
class="description">
     <!--l. 1505--><p class="noindent" >
       </p><div class="syntax">
        <span 
class="pcrr8t-x-x-109">red_Straight</span>\(\langle \)<span 
class="ptmri8t-x-x-109">bas</span>\(\rangle \)</div>
<a 
 id="dx170-387008"></a>
     <!--l. 1510--><p class="noindent" ><a 
 id="procedure:RED_STRAIGHT"></a> Reduce (with <span 
class="pcrr8t-x-x-109">red_TailRed</span>) the tails of the polynomials in the base list \(bas\).
     </p></dd><dt class="description">
     <!--l. 1514--><p class="noindent" >
 </p></dt><dd 
class="description">
     <!--l. 1514--><p class="noindent" >
       </p><div class="syntax">
        <span 
class="pcrr8t-x-x-109">red_TopInterreduce</span>\(\langle \)<span 
class="ptmri8t-x-x-109">bas</span>\(\rangle \)</div>
<a 
 id="dx170-387009"></a>
     <!--l. 1519--><p class="noindent" ><a 
 id="procedure:RED_TOPINTERREDUCE"></a> Reduces the base list \(bas\) with \(red\_TopRed\) until it has pairwise incomparable leading terms,
 computes correct representation parts, but does no tail reduction.
     </p></dd><dt class="description">
     <!--l. 1524--><p class="noindent" >
 </p></dt><dd 
class="description">
     <!--l. 1524--><p class="noindent" >
       </p><div class="syntax">
        <span 
class="pcrr8t-x-x-109">red_Interreduce</span>\(\langle \)<span 
class="ptmri8t-x-x-109">bas</span>\(\rangle \)</div>
<a 
 id="dx170-387010"></a>
     <!--l. 1529--><p class="noindent" ><a 
 id="procedure:RED_INTERREDUCE"></a> Does top and, if the switch <span 
class="pcrr8t-x-x-109">red_total</span><a 
 id="dx170-387011"></a><a 
 id="dx170-387012"></a><a 
 id="dx170-387013"></a> is on, also tail interreduction on the
 base list \(bas\).</p></dd></dl>
<!--l. 1534--><p class="noindent" >Usually, e.g. for ideal generation problems, there is no need to care about the multiplier \(u\).
If nevertheless one needs its value, the base element \(f\) may be prepared with
<span 
class="pcrr8t-x-x-109">red_prepare</span><a 
 id="dx170-387014"></a> to collect this information in the 0-slot of its representation part. Extract
this information with <span 
class="pcrr8t-x-x-109">red_extract</span><a 
 id="dx170-387015"></a>.
     </p><dl class="description"><dt class="description">
     <!--l. 1541--><p class="noindent" >
 </p></dt><dd 
class="description">
                                                                     

                                                                     
     <!--l. 1541--><p class="noindent" >
       </p><div class="syntax">
        <span 
class="pcrr8t-x-x-109">red_redpol</span>(\(\langle \)<span 
class="ptmri8t-x-x-109">bas</span>\(\rangle \),\(\langle \)<span 
class="ptmri8t-x-x-109">model</span>\(\rangle \))</div>
<a 
 id="dx170-387016"></a>
     <!--l. 1546--><p class="noindent" ><a 
 id="procedure:RED_REDPOL"></a> combines this tool with a total reduction of the base element \(model\) and returns a
 dotted pair
          </p><blockquote class="quote">
          <!--l. 1550--><p class="noindent" ><span 
class="pcrr8t-x-x-109">(</span>\(\langle \)<span 
class="ptmri8t-x-x-109">reduced model</span>\(\rangle \) <span 
class="pcrr8t-x-x-109">.</span>\(\langle \)<span 
class="ptmri8t-x-x-109">dpoly unit multiplier</span>\(\rangle \)<span 
class="pcrr8t-x-x-109">)</span></p></blockquote>
     </dd></dl>
<!--l. 1554--><p class="noindent" >Advanced applications call the interfacing procedures
     </p><dl class="description"><dt class="description">
     <!--l. 1557--><p class="noindent" >
 </p></dt><dd 
class="description">
     <!--l. 1557--><p class="noindent" >
       </p><div class="syntax">
        <span 
class="pcrr8t-x-x-109">interreduce!*</span>\(\langle \)<span 
class="ptmri8t-x-x-109">m</span>\(\rangle \)</div>
<a 
 id="dx170-387017"></a>
     <!--l. 1562--><p class="noindent" ><a 
 id="procedure:INTERREDUCE!*("></a> that returns an interreduced basis of the dpmat \(m\).
     </p></dd><dt class="description">
     <!--l. 1565--><p class="noindent" >
 </p></dt><dd 
class="description">
     <!--l. 1565--><p class="noindent" >
       </p><div class="syntax">
        <span 
class="pcrr8t-x-x-109">mod!*</span>(\(\langle \)<span 
class="ptmri8t-x-x-109">f</span> \(\rangle \),\(\langle \)<span 
class="ptmri8t-x-x-109">m</span>\(\rangle \))</div>
<a 
 id="dx170-387018"></a>
     <!--l. 1570--><p class="noindent" ><a 
 id="procedure:MOD!*"></a> that returns the dotted pair \((h.u)\) where \(h\) is the pseudo normal form of the dpoly \(f\)
 modulo the dpmat \(m\) and \(u\) the corresponding polynomial unit multiplier.
                                                                     

                                                                     
     </p></dd><dt class="description">
     <!--l. 1575--><p class="noindent" >
 </p></dt><dd 
class="description">
     <!--l. 1575--><p class="noindent" >
       </p><div class="syntax">
        <span 
class="pcrr8t-x-x-109">normalform!*</span>(\(\langle \)<span 
class="ptmri8t-x-x-109">a</span>\(\rangle \),\(\langle \)<span 
class="ptmri8t-x-x-109">b</span>\(\rangle \))</div>
<a 
 id="dx170-387019"></a>
     <!--l. 1580--><p class="noindent" ><a 
 id="procedure:NORMALFORM!*"></a> that returns \(\{a_1,r,z\}\) with \(a_1=z*a-r*b\) where the rows of the dpmat \(a_1\) are the normalforms of the
 rows of the dpmat \(a\) with respect to the dpmat \(b\).
     </p></dd></dl>
<!--l. 1586--><p class="noindent" >For local standard bases the ideal generated by the basic polynomials may have
components not passing through the origin. Although they do not contribute to the ideal
in \(Loc(S)=S_{\mathbf {m}}\) they usually heavily increase the necessary computational eﬀort. Hence for local term
orders one should try to remove polynomial units as soon as they are detected. To remove
them from base elements in an early stage of the computation one can either try the
(cheap) test, whether \(f\in S\) is of the form \(\langle \)<span 
class="ptmri8t-x-x-109">monomial</span>\(\rangle \) * \(\langle \)<span 
class="ptmri8t-x-x-109">polynomial unit</span>\(\rangle \) or factor \(f\) completely
and remove polynomial unit factors. For base elements this may be done with
<span 
class="pcrr8t-x-x-109">bas_detectunits</span><a 
 id="dx170-387020"></a> or <span 
class="pcrr8t-x-x-109">bas_factorunits</span><a 
 id="dx170-387021"></a>.
</p><!--l. 1597--><p class="noindent" >Moreover there are two switches <span 
class="pcrr8t-x-x-109">detectunits</span><a 
 id="dx170-387022"></a><a 
 id="dx170-387023"></a><a 
 id="dx170-387024"></a> and <span 
class="pcrr8t-x-x-109">factorunits</span><a 
 id="dx170-387025"></a><a 
 id="dx170-387026"></a><a 
 id="dx170-387027"></a>, both oﬀ
by default, that force such automatic simpliﬁcations during more advanced
computations.
</p><!--l. 1601--><p class="noindent" >The procedure <span 
class="pcrr8t-x-x-109">deleteunits!*</span><a 
 id="dx170-387028"></a> tries explicitely to factor the basis polynomials of a
dpmat and to remove polynomial units occuring as one of the factors.
</p><!--l. 1605--><p class="noindent" >
</p>
<h5 class="subsubsectionHead"><a 
 id="x170-38800020.7.4"></a>The Gröbner and Standard Basis Algorithms</h5>
<!--l. 1607--><p class="noindent" >There is now a unique <span 
class="ptmri8t-x-x-109">module groeb</span><a 
 id="dx170-388001"></a> that contains the Gröbner resp. standard
basis algorithms with syzygy computation facility and related topics. There are
common procedures (working for both Noetherian and non Noetherian term
orders)
     </p><dl class="description"><dt class="description">
     <!--l. 1613--><p class="noindent" >
 </p></dt><dd 
class="description">
                                                                     

                                                                     
     <!--l. 1613--><p class="noindent" >
       </p><div class="syntax">
        <span 
class="pcrr8t-x-x-109">gbasis!*</span>\(\langle \)<span 
class="ptmri8t-x-x-109">m</span>\(\rangle \)</div>
<a 
 id="dx170-388002"></a>
     <!--l. 1618--><p class="noindent" ><a 
 id="procedure:GBASIS!*"></a> that returns a minimal Gröbner or standard basis of the dpmat \(m\),
     </p></dd><dt class="description">
     <!--l. 1621--><p class="noindent" >
 </p></dt><dd 
class="description">
     <!--l. 1621--><p class="noindent" >
       </p><div class="syntax">
        <span 
class="pcrr8t-x-x-109">syzygies!*</span>\(\langle \)<span 
class="ptmri8t-x-x-109">m</span>\(\rangle \)</div>
<a 
 id="dx170-388003"></a>
     <!--l. 1626--><p class="noindent" ><a 
 id="procedure:SYZYGIES!*"></a> that returns an interreduced basis of the ﬁrst syzygy module of the dpmat \(m\) and
     </p></dd><dt class="description">
     <!--l. 1630--><p class="noindent" >
 </p></dt><dd 
class="description">
     <!--l. 1630--><p class="noindent" >
       </p><div class="syntax">
        <span 
class="pcrr8t-x-x-109">syzygies1!*</span>\(\langle \)<span 
class="ptmri8t-x-x-109">m</span>\(\rangle \)</div>
<a 
 id="dx170-388004"></a>
     <!--l. 1635--><p class="noindent" ><a 
 id="procedure:SYZYGIES1!*"></a> that returns a (not yet interreduced) basis of the syzygy module of the dpmat \(m\).
     </p></dd></dl>
<!--l. 1640--><p class="noindent" >These procedures start the outer Gröbner engine (now also common for both Noetherian
and non Noetherian term orders)
     </p><dl class="description"><dt class="description">
     <!--l. 1644--><p class="noindent" >
 </p></dt><dd 
class="description">
     <!--l. 1644--><p class="noindent" >
       </p><div class="syntax">
        <span 
class="pcrr8t-x-x-109">groeb_stbasis</span>(\(\langle \)<span 
class="ptmri8t-x-x-109">m</span>\(\rangle \),\(\langle \)<span 
class="ptmri8t-x-x-109">mgb</span>\(\rangle \),\(\langle \)<span 
class="ptmri8t-x-x-109">ch</span>\(\rangle \),\(\langle \)<span 
class="ptmri8t-x-x-109">syz</span>\(\rangle \))</div>
<a 
 id="dx170-388005"></a>
     <!--l. 1649--><p class="noindent" ><a 
 id="procedure:GROEB_STBASIS"></a></p></dd></dl>
                                                                     

                                                                     
<!--l. 1651--><p class="noindent" >that returns, applied to the dpmat \(m\), three dpmats \(g,c,s\) with
     </p><dl class="description"><dt class="description">
     <!--l. 1653--><p class="noindent" >
\(g\) <span 
class="ptmb8t-x-x-109">—</span> </p></dt><dd 
class="description">
     <!--l. 1653--><p class="noindent" >the minimal reduced Gröbner basis of \(m\) if \(mgb=t\),
     </p></dd><dt class="description">
     <!--l. 1655--><p class="noindent" >
\(c\) <span 
class="ptmb8t-x-x-109">—</span> </p></dt><dd 
class="description">
     <!--l. 1655--><p class="noindent" >the transition matrix \(g=c\cdot m\) if \(ch=t\), and
     </p></dd><dt class="description">
     <!--l. 1657--><p class="noindent" >
\(s\) <span 
class="ptmb8t-x-x-109">—</span> </p></dt><dd 
class="description">
     <!--l. 1657--><p class="noindent" >the (not yet interreduced) syzygy matrix of \(m\) if \(syz=t\).</p></dd></dl>
<!--l. 1660--><p class="noindent" >The next layer manages the preparation of the representation parts of the base
elements to carry the syzygy information, calls the <span 
class="ptmri8t-x-x-109">general internal driver</span>,
and extracts the relevant information from the result of that computation. The
general internal driver branches according to diﬀerent reduction functions into
several versions. Upto now there are three diﬀerent strategies for the reduction
procedures for the S-polynomial reduction (diﬀerent versions may be chosen via
<span 
class="ptmri8t-x-x-109">gbtestversion</span><a 
 id="dx170-388006"></a>):
     </p><ol  class="enumerate1" >
<li 
  class="enumerate" id="x170-388008x1">
     <!--l. 1669--><p class="noindent" >Total  reduction  with  local  simpliﬁer  lists.  For  local  term  orders  this  is
     (almost) Mora’s ﬁrst version for the tangent cone (the default).
     </p></li>
<li 
  class="enumerate" id="x170-388010x2">
     <!--l. 1673--><p class="noindent" >Total  reduction  with  global  simpliﬁer  list.  For  local  term  orders  this  is
     (almost) Mora’s SimpStBasis, see <span class="cite">[<a 
href="manualap2.html#XMoraPfisterTraverso:92">MPT92</a>]</span>.
     </p></li>
<li 
  class="enumerate" id="x170-388012x3">
     <!--l. 1676--><p class="noindent" >Total reduction with bounded ecart.</p></li></ol>
                                                                     

                                                                     
<!--l. 1678--><p class="noindent" >The ﬁrst two versions (almost) coincide for Noetherian term orders. The third version
reduces only with bounded ecart, thus forcing more pairs to be treated than necessary, but
usually less expensive to be reduced. It is not yet well understood, whether this idea is of
practical importance.
</p><!--l. 1684--><p class="noindent" ><span 
class="ptmri8t-x-x-109">groeb_lazystbasis</span><a 
 id="dx170-388013"></a> calls the lazy standard basis driver instead, that implements Mora’s
lazy algorithm, see <span class="cite">[<a 
href="manualap2.html#XMoraPfisterTraverso:92">MPT92</a>]</span>. As <span 
class="ptmri8t-x-x-109">groeb_homstbasis</span><a 
 id="dx170-388014"></a>, the computation of Gröbner and
standard bases via homogenization (Lazard’s approach), it is not fully integrated into the
algebraic interface. Use
     </p><dl class="description"><dt class="description">
     <!--l. 1691--><p class="noindent" >
 </p></dt><dd 
class="description">
     <!--l. 1691--><p class="noindent" >
       </p><div class="syntax">
        <span 
class="pcrr8t-x-x-109">homstbasis!*</span>\(\langle \)<span 
class="ptmri8t-x-x-109">m</span>\(\rangle \)</div>
<a 
 id="dx170-388015"></a>
     <!--l. 1696--><p class="noindent" ><a 
 id="procedure:HOMSTBASIS!*"></a> for the invocation of the homogenization approach to compute a standard basis
 of the dpmat \(m\) and
     </p></dd><dt class="description">
     <!--l. 1700--><p class="noindent" >
 </p></dt><dd 
class="description">
     <!--l. 1700--><p class="noindent" >
       </p><div class="syntax">
        <span 
class="pcrr8t-x-x-109">lazystbasis!*</span>\(\langle \)<span 
class="ptmri8t-x-x-109">m</span>\(\rangle \)</div>
<a 
 id="dx170-388016"></a>
     <!--l. 1705--><p class="noindent" ><a 
 id="procedure:LAZYSTBASIS!*"></a> for the lazy algorithm.
     </p></dd></dl>
<!--l. 1708--><p class="noindent" >Experts commonly agree that the classical approach is better for “computable” examples,
but computations done by the author on large examples indicate, that both approaches are
in fact independent.
</p><!--l. 1714--><p class="noindent" >The pair list management uses the sugar strategy, see <span class="cite">[<a 
href="manualap2.html#XGiovini:91">GMN\(^{+}\)91</a>]</span>, with respect
to the current ecart vector. If the input is homogeneous and the ecart vector
reﬂects this homogeneity then pairs are sorted by ascending degree. Hence no
superﬂuous base elements will be computed in this case. In general the sugar
strategy performs best if the ecart vector is chosen to make the input close to be
homogeneous.
                                                                     

                                                                     
</p><!--l. 1722--><p class="noindent" >There is another global variable <span 
class="pcrr8t-x-x-109">cali!=monset</span><a 
 id="dx170-388017"></a> that may contain a list of variable
names (a subset of the variable names of the current base ring). During the “pure”
Gröbner algorithm (without syzygy and representation computations) common
monomial factors containing only these variables will be canceled out. This shortcut is
useful if some of the variables are known to be non zero divisors as e.g. in most
implicitation problems.
     </p><dl class="description"><dt class="description">
     <!--l. 1732--><p class="noindent" >
 </p></dt><dd 
class="description">
     <!--l. 1732--><p class="noindent" >
       </p><div class="syntax">
        <span 
class="pcrr8t-x-x-109">setmonset!*</span>\(\langle \)<span 
class="ptmri8t-x-x-109">vars</span>\(\rangle \)</div>
<a 
 id="dx170-388018"></a>
     <!--l. 1737--><p class="noindent" ><a 
 id="procedure:SETMONSET!*"></a> initializes <span 
class="pcrr8t-x-x-109">cali!=monset </span>with a given list of variables \(vars\).
     </p></dd></dl>
<!--l. 1742--><p class="noindent" >The Gröbner tools as e.g. pair criteria, pair list update, pair management and
S-polynomial construction are available.
     </p><dl class="description"><dt class="description">
     <!--l. 1746--><p class="noindent" >
 </p></dt><dd 
class="description">
     <!--l. 1746--><p class="noindent" >
       </p><div class="syntax">
        <span 
class="pcrr8t-x-x-109">groeb_mingb</span>\(\langle \)<span 
class="ptmri8t-x-x-109">m</span>\(\rangle \)</div>
<a 
 id="dx170-388019"></a>
     <!--l. 1751--><p class="noindent" ><a 
 id="procedure:GROEB_MINGB"></a> extracts a minimal Gröbner basis from the dpmat \(m\), removing base elements
 with leading terms, divisible by other leading terms.
     </p></dd><dt class="description">
     <!--l. 1755--><p class="noindent" >
 </p></dt><dd 
class="description">
     <!--l. 1755--><p class="noindent" >
       </p><div class="syntax">
        <span 
class="pcrr8t-x-x-109">groeb_minimize</span>(\(\langle \)<span 
class="ptmri8t-x-x-109">bas</span>\(\rangle \),\(\langle \)<span 
class="ptmri8t-x-x-109">syz</span>\(\rangle \))</div>
<a 
 id="dx170-388020"></a>
     <!--l. 1760--><p class="noindent" ><a 
 id="procedure:GROEB_MINIMIZE"></a> minimizes  the  dpmat  pair  \((bas,syz)\)  deleting  superﬂuous  base  elements  from  \(bas\)  using
 syzygies from \(syz\) containing unit entries.
     </p></dd></dl>
                                                                     

                                                                     
<!--l. 1766--><p class="noindent" >
</p>
<h5 class="subsubsectionHead"><a 
 id="x170-38900020.7.4"></a>The Gröbner Factorizer</h5>
<!--l. 1768--><p class="noindent" >If \(\bar {k}\) is the algebraic closure of \(k\), \(B:=\{f_1,\ldots ,f_m\}\subset S\) a ﬁnite system of polynomials, and \(C:=\{g_1,\ldots ,g_k\}\) a set of side
conditions deﬁne the <span 
class="ptmri8t-x-x-109">relative set of zeroes </span>\[Z(B,C):=\{a\in \bar {k}^n : \forall \ f\in B\ f(a)=0\mbox { and } \forall g\in C\ g(a)\neq 0\}.\] Its Zariski closure is the zero set of
\(I(B):&lt;\prod C&gt;\).
</p><!--l. 1776--><p class="noindent" >The Gröbner factorizer solves the following problem:
     </p><blockquote class="quote">
     <!--l. 1779--><p class="noindent" ><span 
class="ptmri8t-x-x-109">Find a collection</span> \((B_\alpha ,C_\alpha )\) <span 
class="ptmri8t-x-x-109">of Gr</span><span 
class="ptmri8t-x-x-109">ö</span><span 
class="ptmri8t-x-x-109">bner bases</span> \(B_\alpha \) <span 
class="ptmri8t-x-x-109">and side conditions</span> \(C_\alpha \) <span 
class="ptmri8t-x-x-109">such that </span>\[Z(B,C) = \bigcup _\alpha Z(B_\alpha ,C_\alpha ).\]</p></blockquote>
<!--l. 1782--><p class="noindent" >The <span 
class="ptmri8t-x-x-109">module groebf</span> <a 
 id="dx170-389001"></a> and the <span 
class="ptmri8t-x-x-109">module triang</span><a 
 id="dx170-389002"></a> contain algorithms related to that problem,
triangular systems, and their generalizations as described in <span class="cite">[<a 
href="manualap2.html#XGraebe:94a">Grä94a</a>]</span> and <span class="cite">[<a 
href="manualap2.html#XGraebe:95b">Grä95b</a>]</span>. V.
2.2 thus heavily extends the algorithmic possibilities that were implemented in former
releases of <span 
class="ptmrc8t-x-x-109">C<span 
class="small-caps">A</span><span 
class="small-caps">L</span><span 
class="small-caps">I</span></span>.
</p><!--l. 1788--><p class="noindent" >Note that, diﬀerent to v. 2.1, we work with constraint <span 
class="ptmri8t-x-x-109">lists</span>.
     </p><dl class="description"><dt class="description">
     <!--l. 1790--><p class="noindent" >
 </p></dt><dd 
class="description">
     <!--l. 1790--><p class="noindent" >
       </p><div class="syntax">
        <span 
class="pcrr8t-x-x-109">groebfactor!*</span>(\(\langle \)<span 
class="ptmri8t-x-x-109">bas</span>\(\rangle \),\(\langle \)<span 
class="ptmri8t-x-x-109">con</span>\(\rangle \))</div>
<a 
 id="dx170-389003"></a>
     <!--l. 1795--><p class="noindent" ><a 
 id="procedure:GROEBFACTOR!*"></a> returns for the dpmat ideal \(bas\) and the constraint list \(con\) (of dpolys) a minimal list of
 \((dpmat, constraint\ list)\) pairs with the desired property.
     </p></dd></dl>
<!--l. 1800--><p class="noindent" >During a preprocessing it splits the submitted basis \(bas\) by a recursive factorization of
polynomials and interreduction of bases into a (reduced) list of smaller subproblems
consisting of a partly computed Gröbner basis, a constraint list, and a list of pairs not
yet processed. The main procedure forces the next subproblem to be processed until
another factorization is possible. Then the subproblem splits into subsubproblems, and
the subproblem list will be updated. Subproblems are kept sorted with respect to their
expected dimension <span 
class="ptmri8t-x-x-109">easydim</span><a 
 id="dx170-389004"></a> forcing this way a <span 
class="ptmri8t-x-x-109">depth ﬁrst </span>recursion. Returned
and not yet interreduced Gröbner bases are, after interreduction, subject to
another call of the preprocessor since interreduced polynomials may factor
anew.
                                                                     

                                                                     
     </p><dl class="description"><dt class="description">
     <!--l. 1813--><p class="noindent" >
 </p></dt><dd 
class="description">
     <!--l. 1813--><p class="noindent" >
       </p><div class="syntax">
        <span 
class="pcrr8t-x-x-109">listgroebfactor!*</span>\(\langle \)<span 
class="ptmri8t-x-x-109">l</span>\(\rangle \)</div>
<a 
 id="dx170-389005"></a>
     <!--l. 1818--><p class="noindent" ><a 
 id="procedure:LISTGROEBFACTOR!*"></a> processes a whole list of dpmats (without constraints) at once and strips oﬀ
 constraints at the end.</p></dd></dl>
<!--l. 1824--><p class="noindent" >Using the (ordinary) Gröbner factorizer even components of diﬀerent dimension may
keep gluing together. The <span 
class="ptmri8t-x-x-109">extended Gr</span><span 
class="ptmri8t-x-x-109">ö</span><span 
class="ptmri8t-x-x-109">bner factorizer</span><a 
 id="dx170-389006"></a> involves a postprocessing, that
guarantees a decomposition into puredimensional components, given by triangular
systems instead of Gröbner bases. Triangular systems in positive dimension must not be
Gröbner bases of the underlying ideal. They should be preferred, since they are more
simple but contain all information about the (quasi) prime component that they represent.
The complete Gröbner basis of the corresponding component can be obtained by an
easy stable quotient computation, see <span class="cite">[<a 
href="manualap2.html#XGraebe:95b">Grä95b</a>]</span>. We refer to the same paper for the
deﬁnition of <span 
class="ptmri8t-x-x-109">triangular systems</span><a 
 id="dx170-389007"></a> in positive dimension, that is consistent with our
approach.
     </p><dl class="description"><dt class="description">
     <!--l. 1837--><p class="noindent" >
 </p></dt><dd 
class="description">
     <!--l. 1837--><p class="noindent" >
       </p><div class="syntax">
       <!--tex4ht:inline--><div class="tabular"> <table id="TBL-41" class="tabular" 
 
><colgroup id="TBL-41-1g"><col 
id="TBL-41-1" /><col 
id="TBL-41-2" /><col 
id="TBL-41-3" /></colgroup><tr  
 style="vertical-align:baseline;" id="TBL-41-1-"><td  style="white-space:nowrap; text-align:left;" id="TBL-41-1-1"  
class="td01"><span 
class="pcrr8t-x-x-109">extendedgroebfactor!*</span>(\(\langle \)<span 
class="ptmri8t-x-x-109">bas</span>\(\rangle \),\(\langle \)<span 
class="ptmri8t-x-x-109">c</span>\(\rangle \)) </td>
</tr><tr  
 style="vertical-align:baseline;" id="TBL-41-2-"><td  style="white-space:nowrap; text-align:left;" id="TBL-41-2-1"  
class="td01"><span 
class="pcrr8t-x-x-109">extendedgroebfactor1!*</span>(\(\langle \)<span 
class="ptmri8t-x-x-109">bas</span>\(\rangle \),\(\langle \)<span 
class="ptmri8t-x-x-109">c</span>\(\rangle \))</td></tr></table>
       </div></div>
<a 
 id="dx170-389008"></a>
<a 
 id="dx170-389009"></a>
     <!--l. 1844--><p class="noindent" ><a 
 id="procedure:EXTENDEDGROEBFACTOR!*"></a> return  a  list  of  results  \(\{b_i,c_i,v_i\}\)  in  algebraic  preﬁx  form  such  that  \(b_i\)  is  a  triangular
 set  wrt. the  variables  \(v_i\)  and  \(c_i\)  is  a  list  of  constraints,  such  that  \(b_i:&lt;\prod c_i&gt;\)  is  the
 (puredimensional)  recontraction  of  the  zerodimensional  ideal  \(b_i\bigotimes _k k(v_i)\).  For  the  ﬁrst
 version  the  recontraction  is  not  computed,  hence  the  output  may  be  not
 minimal. The second version computes recontractions to decide superﬂuous
 components  already  during  the  algorithm.  Note  that  the  stable  quotient
 computation involved for that purpose may drastically slow down the whole
 attempt.
     </p></dd></dl>
                                                                     

                                                                     
<!--l. 1856--><p class="noindent" >The postprocessing involves a change to dimension zero and invokes (zero
dimensional) triangular system computations from the <span 
class="ptmri8t-x-x-109">module triang</span><a 
 id="dx170-389010"></a>. In a ﬁrst step
<span 
class="pcrr8t-x-x-109">groebf_zeroprimes1</span><a 
 id="dx170-389011"></a> incorporates the square free parts of certain univariate
polynomials into these systems and strips oﬀ the constraints (since relative sets of zeroes
in dimension zero are Zariski closed), using a splitting approach analogous to the
Gröbner factorizer. In a second step, according to the switch <span 
class="pcrr8t-x-x-109">lexefgb</span><a 
 id="dx170-389012"></a><a 
 id="dx170-389013"></a><a 
 id="dx170-389014"></a>, either
<span 
class="pcrr8t-x-x-109">zerosolve!*</span><a 
 id="dx170-389015"></a> or <span 
class="pcrr8t-x-x-109">zerosolve1!*</span><a 
 id="dx170-389016"></a> converts these intermediate results into
lists of triangular systems in preﬁx form. If <span 
class="pcrr8t-x-x-109">lexefgb</span><a 
 id="dx170-389017"></a><a 
 id="dx170-389018"></a><a 
 id="dx170-389019"></a> is <span 
class="pcrr8t-x-x-109">off </span>(the default), the
zero dimensional term order is degrevlex and <span 
class="pcrr8t-x-x-109">zerosolve1!*</span>, the “slow turn
to lex” is involved, with <span 
class="pcrr8t-x-x-109">lexefgb </span>on the pure lexicographic term order and
<span 
class="pcrr8t-x-x-109">zerosolve!*</span>, Möllers original approach, see <span class="cite">[<a 
href="manualap2.html#XMoeller:93">M<span class='accentuml'>9</span>3</a>]</span>, are used. Note that
for this term order we need only a single Gröbner basis computation at this
level.
</p><!--l. 1873--><p class="noindent" >A third version, <span 
class="pcrr8t-x-x-109">zerosolve2!*</span><a 
 id="dx170-389020"></a>, mixes the ﬁrst approach with the FGLM change of
term orders. It is not incorporated into the extended Gröbner factorizer.
</p><!--l. 1878--><p class="noindent" >
</p>
<h5 class="subsubsectionHead"><a 
 id="x170-39000020.7.4"></a>Basic Operations on Ideals and Modules</h5>
<!--l. 1880--><p class="noindent" >Gröbner and local standard bases are the heart of several basic algorithms in ideal
theory, see e.g. <span class="cite">[<a 
href="manualap2.html#XBecker:93">BWK93</a>, 6.2.]</span>. <span 
class="ptmrc8t-x-x-109">C<span 
class="small-caps">A</span><span 
class="small-caps">L</span><span 
class="small-caps">I</span> </span>oﬀers the following facilities:
     </p><dl class="description"><dt class="description">
     <!--l. 1884--><p class="noindent" >
 </p></dt><dd 
class="description">
     <!--l. 1884--><p class="noindent" >
       </p><div class="syntax">
        <span 
class="pcrr8t-x-x-109">submodulep!*</span>(\(\langle \)<span 
class="ptmri8t-x-x-109">m</span>\(\rangle \),\(\langle \)<span 
class="ptmri8t-x-x-109">n</span>\(\rangle \))</div>
<a 
 id="dx170-390001"></a>
     <!--l. 1889--><p class="noindent" ><a 
 id="procedure:SUBMODULEP!*"></a> tests  the  dpmat  \(m\)  for  being  a  submodule  of  the  dpmat  \(n\)  reducing  the  basis
 elements of \(m\) with respect to \(n\). The result will be correct provided \(n\) is a Gröbner
 basis.
     </p></dd><dt class="description">
     <!--l. 1894--><p class="noindent" >
 </p></dt><dd 
class="description">
                                                                     

                                                                     
     <!--l. 1894--><p class="noindent" >
       </p><div class="syntax">
        <span 
class="pcrr8t-x-x-109">modequalp!*</span>(\(\langle \)<span 
class="ptmri8t-x-x-109">m</span>\(\rangle \),\(\langle \)<span 
class="ptmri8t-x-x-109">n</span>\(\rangle \))</div>
<a 
 id="dx170-390002"></a>
     <!--l. 1899--><p class="noindent" ><a 
 id="procedure:MODEQUALP!*"></a> = submodulep!*(m,n) and submodulep!*(n,m).
     </p></dd><dt class="description">
     <!--l. 1902--><p class="noindent" >
 </p></dt><dd 
class="description">
     <!--l. 1902--><p class="noindent" >
       </p><div class="syntax">
        <span 
class="pcrr8t-x-x-109">eliminate!*</span>(\(\langle \)<span 
class="ptmri8t-x-x-109">m</span>\(\rangle \),\(\langle \)<span 
class="ptmri8t-x-x-109">variable list</span>\(\rangle \))</div>
<a 
 id="dx170-390003"></a>
     <!--l. 1907--><p class="noindent" ><a 
 id="procedure:ELIMINATE!*"></a> computes the elimination ideal/module eliminating the variables in the given
 variable  list  (a  subset  of  the  variables  of  the  current  base  ring).  Changes
 temporarily the term order to degrevlex.
     </p></dd><dt class="description">
     <!--l. 1912--><p class="noindent" >
 </p></dt><dd 
class="description">
     <!--l. 1912--><p class="noindent" >
       </p><div class="syntax">
        <span 
class="pcrr8t-x-x-109">matintersect!*</span>\(\langle \)<span 
class="ptmri8t-x-x-109">l</span>\(\rangle \)</div>
<a 
 id="dx170-390004"></a>
     <!--l. 1917--><p class="noindent" ><a 
 id="procedure:MATINTERSECT!*"></a> computes  the  intersection  of  the  dpmats  in  the  dpmat  list  \(l\)  along  <span class="cite">[<a 
href="manualap2.html#XBecker:93">BWK93</a>,
 6.20]</span>.<span class="footnote-mark"><a 
href="manual180.html#fn10x20"><sup class="textsuperscript">10</sup></a></span><a 
 id="x170-390005f10"></a>
</p>
     </dd></dl>
<!--l. 1926--><p class="noindent" ><span 
class="ptmrc8t-x-x-109">C<span 
class="small-caps">A</span><span 
class="small-caps">L</span><span 
class="small-caps">I</span> </span>oﬀers several quotient algorithms. They rest on the computation of quotients by a
single element of the following kind: Assume \(M\subset S^c, v\in S^c, f\in S\). Then there are </p>
     <ul class="itemize1">
     <li class="itemize">
     <!--l. 1930--><p class="noindent" >the <span 
class="ptmri8t-x-x-109">module quotient</span><a 
 id="dx170-390006"></a> \(M : (v) = \{g\in S\ |\ gv\in M\}\),
                                                                     

                                                                     
     </p></li>
     <li class="itemize">
     <!--l. 1932--><p class="noindent" >the <span 
class="ptmri8t-x-x-109">ideal quotient</span><a 
 id="dx170-390007"></a> \(M : (f) = \{w\in S^c\ |\ fw\in M\}\), and
     </p></li>
     <li class="itemize">
     <!--l. 1934--><p class="noindent" >the <span 
class="ptmri8t-x-x-109">stable quotient</span><a 
 id="dx170-390008"></a> \(M : (f)^\infty = \{w\in S^c\ |\ \exists \, n\, :\, f^nw\in M\}\).</p></li></ul>
<!--l. 1938--><p class="noindent" ><span 
class="ptmrc8t-x-x-109">C<span 
class="small-caps">A</span><span 
class="small-caps">L</span><span 
class="small-caps">I</span> </span>uses the elimination approach <span class="cite">[<a 
href="manualap2.html#XCox:92">CLO92</a>, 4.4.]</span> and <span class="cite">[<a 
href="manualap2.html#XBecker:93">BWK93</a>, 6.38]</span> for their
computation:
     </p><dl class="description"><dt class="description">
     <!--l. 1942--><p class="noindent" >
 </p></dt><dd 
class="description">
     <!--l. 1942--><p class="noindent" >
       </p><div class="syntax">
        <span 
class="pcrr8t-x-x-109">matquot!*</span>(\(\langle \)<span 
class="ptmri8t-x-x-109">M</span>\(\rangle \),\(\langle \)<span 
class="ptmri8t-x-x-109">f</span> \(\rangle \))</div>
<a 
 id="dx170-390009"></a>
     <!--l. 1947--><p class="noindent" ><a 
 id="procedure:MATQUOT!*"></a> returns the module or ideal quotient \(M:(f)\) depending on \(f\).
     </p></dd><dt class="description">
     <!--l. 1950--><p class="noindent" >
 </p></dt><dd 
class="description">
     <!--l. 1950--><p class="noindent" >
       </p><div class="syntax">
        <span 
class="pcrr8t-x-x-109">matqquot!*</span>(\(\langle \)<span 
class="ptmri8t-x-x-109">M</span>\(\rangle \),\(\langle \)<span 
class="ptmri8t-x-x-109">f</span> \(\rangle \))</div>
<a 
 id="dx170-390010"></a>
     <!--l. 1955--><p class="noindent" ><a 
 id="procedure:MATQQUOT!*"></a> returns the stable quotient \(M:(f)^\infty \).
     </p></dd></dl>
<!--l. 1958--><p class="noindent" ><span 
class="pcrr8t-x-x-109">matquot!* </span>calls the pseudo division with remainder
     </p><dl class="description"><dt class="description">
     <!--l. 1961--><p class="noindent" >
 </p></dt><dd 
class="description">
     <!--l. 1961--><p class="noindent" >
       </p><div class="syntax">
        <span 
class="pcrr8t-x-x-109">dp_pseudodivmod!*</span>(\(\langle \)<span 
class="ptmri8t-x-x-109">g</span>\(\rangle \),\(\langle \)<span 
class="ptmri8t-x-x-109">f</span> \(\rangle \))</div>
<a 
 id="dx170-390011"></a>
                                                                     

                                                                     
     <!--l. 1966--><p class="noindent" ><a 
 id="procedure:DP_PSEUDODIVMOD!*"></a> that returns a dpoly list \(\{q,r,z\}\) such that \(z\cdot g = q\cdot f + r\) with a dpoly unit \(z\). (\(g, f\) and \(r\) must belong to
 the same free module). This is done uniformly for noetherian and local term
 orders with an extended normal form algorithm as described in <span class="cite">[<a 
href="manualap2.html#XGraebe:95a">Grä95a</a>]</span>.
     </p></dd></dl>
<!--l. 1975--><p class="noindent" >In the same way one deﬁnes the quotient of a module by another module (both
embedded in a common free module \(S^c\)), the quotient of a module by an ideal, and the
stable quotient of a module by an ideal. Algorithms for their computation can be
obtained from the corresponding algorithms for a single element as divisor
either by the generic element method <span class="cite">[<a 
href="manualap2.html#XEisenbud:95">Eis95</a>]</span> or as an intersection <span class="cite">[<a 
href="manualap2.html#XBecker:93">BWK93</a>,
6.31]</span>. <span 
class="ptmrc8t-x-x-109">C<span 
class="small-caps">A</span><span 
class="small-caps">L</span><span 
class="small-caps">I</span> </span>oﬀers both approaches (X=1 or 2 below) at the symbolic level,
but for true quotients only the latter one is integrated into the algebraic mode
interface.
     </p><dl class="description"><dt class="description">
     <!--l. 1986--><p class="noindent" >
 </p></dt><dd 
class="description">
     <!--l. 1986--><p class="noindent" >
       </p><div class="syntax">
        <span 
class="pcrr8t-x-x-109">idealquotientX!*</span>(\(\langle \)<span 
class="ptmri8t-x-x-109">M</span>\(\rangle \),\(\langle \)<span 
class="ptmri8t-x-x-109">I</span>\(\rangle \))</div>
<a 
 id="dx170-390012"></a>
     <!--l. 1991--><p class="noindent" ><a 
 id="procedure:IDEALQUOTIENTX!*"></a> returns the ideal quotient \(M:I\) of the dpmat \(M\) by the dpmat ideal \(I\).
     </p></dd><dt class="description">
     <!--l. 1995--><p class="noindent" >
 </p></dt><dd 
class="description">
     <!--l. 1995--><p class="noindent" >
       </p><div class="syntax">
        <span 
class="pcrr8t-x-x-109">modulequotientX!*</span>(\(\langle \)<span 
class="ptmri8t-x-x-109">M</span>\(\rangle \),\(\langle \)<span 
class="ptmri8t-x-x-109">N</span>\(\rangle \))</div>
<a 
 id="dx170-390013"></a>
     <!--l. 2000--><p class="noindent" ><a 
 id="procedure:MODULEQUOTIENTX!*"></a> returns the module quotient \(M:N\) of the dpmat \(M\) by the dpmat \(N\).
     </p></dd><dt class="description">
     <!--l. 2004--><p class="noindent" >
 </p></dt><dd 
class="description">
     <!--l. 2004--><p class="noindent" >
       </p><div class="syntax">
        <span 
class="pcrr8t-x-x-109">annihilatorX!*</span>\(\langle \)<span 
class="ptmri8t-x-x-109">M</span>\(\rangle \)</div>
<a 
 id="dx170-390014"></a>
                                                                     

                                                                     
     <!--l. 2009--><p class="noindent" ><a 
 id="procedure:ANNIHILATORX!*"></a> returns the annihilator of \(\mathop {\mathrm {coker}} M\), i.e. the module quotient \(S^c:M\), if \(M\) is a submodule of \(S^c\).
     </p></dd><dt class="description">
     <!--l. 2013--><p class="noindent" >
 </p></dt><dd 
class="description">
     <!--l. 2013--><p class="noindent" >
       </p><div class="syntax">
        <span 
class="pcrr8t-x-x-109">matstabquot!*</span>(\(\langle \)<span 
class="ptmri8t-x-x-109">M</span>\(\rangle \),\(\langle \)<span 
class="ptmri8t-x-x-109">I</span>\(\rangle \))</div>
<a 
 id="dx170-390015"></a>
     <!--l. 2018--><p class="noindent" ><a 
 id="procedure:MATSTABQUOT!*"></a> returns the stable quotient \(M:I^\infty \) (only by the general element method).
     </p></dd></dl>
<!--l. 2024--><p class="noindent" >
</p>
<h5 class="subsubsectionHead"><a 
 id="x170-39100020.7.4"></a>Monomial Ideals</h5>
<!--l. 2026--><p class="noindent" >Monomial ideals occur as ideals of leading terms of (ideal’s) Gröbner bases and also as
components of leading term modules of submodules of free modules, see <span class="cite">[<a 
href="manualap2.html#XGraebe:93a">Grä93</a>]</span>, and
reﬂect some properties of the original ideal/module. Several parameters of the
original ideal or module may be read oﬀ from it as e.g. dimension and Hilbert
series.
</p><!--l. 2032--><p class="noindent" >The <span 
class="ptmri8t-x-x-109">module moid</span><a 
 id="dx170-391001"></a> contains the corresponding algorithms on monomial ideals. Monomial
ideals are lists of monomials, kept sorted by descending lexicographic order as proposed
in <span class="cite">[<a 
href="manualap2.html#XBayerStillman:92">BS92</a>]</span>.
     </p><dl class="description"><dt class="description">
     <!--l. 2038--><p class="noindent" >
 </p></dt><dd 
class="description">
     <!--l. 2038--><p class="noindent" >
       </p><div class="syntax">
        <span 
class="pcrr8t-x-x-109">moid_primes</span>\(\langle \)<span 
class="ptmri8t-x-x-109">u</span>\(\rangle \)</div>
<a 
 id="dx170-391002"></a>
     <!--l. 2043--><p class="noindent" ><a 
 id="procedure:MOID_PRIMES"></a> returns  the  minimal  primes  (as  a  list  of  lists  of  variable  names)  of  the
 monomial ideal \(u\) using an adaption of the algorithm, proposed in <span class="cite">[<a 
href="manualap2.html#XBayerStillman:92">BS92</a>]</span> for
 the computation of the codimension.
                                                                     

                                                                     
     </p></dd><dt class="description">
     <!--l. 2048--><p class="noindent" >
 </p></dt><dd 
class="description">
     <!--l. 2048--><p class="noindent" >
       </p><div class="syntax">
        <span 
class="pcrr8t-x-x-109">indepvarsets!*</span>\(\langle \)<span 
class="ptmri8t-x-x-109">m</span>\(\rangle \)</div>
<a 
 id="dx170-391003"></a>
     <!--l. 2053--><p class="noindent" ><a 
 id="procedure:INDEPVARSETS!*"></a> returns (based on <span 
class="pcrr8t-x-x-109">moid_primes</span>) the list of strongly independent sets of \(m\), see
 <span class="cite">[<a 
href="manualap2.html#XKredel:88a">KW88</a>]</span> and <span class="cite">[<a 
href="manualap2.html#XGraebe:93a">Grä93</a>]</span> for deﬁnitions.
     </p></dd><dt class="description">
     <!--l. 2058--><p class="noindent" >
 </p></dt><dd 
class="description">
     <!--l. 2058--><p class="noindent" >
       </p><div class="syntax">
        <span 
class="pcrr8t-x-x-109">dim!*</span>\(\langle \)<span 
class="ptmri8t-x-x-109">m</span>\(\rangle \)</div>
<a 
 id="dx170-391004"></a>
     <!--l. 2063--><p class="noindent" ><a 
 id="procedure:DIM!*"></a> returns the dimension of \(\mathop {\mathrm {coker}} m\) as the size of the largest independent set.
     </p></dd><dt class="description">
     <!--l. 2067--><p class="noindent" >
 </p></dt><dd 
class="description">
     <!--l. 2067--><p class="noindent" >
       </p><div class="syntax">
        <span 
class="pcrr8t-x-x-109">codim!*</span>\(\langle \)<span 
class="ptmri8t-x-x-109">m</span>\(\rangle \)</div>
<a 
 id="dx170-391005"></a>
     <!--l. 2072--><p class="noindent" ><a 
 id="procedure:CODIM!*"></a> returns the codimension of \(\mathop {\mathrm {coker}} m\).
     </p></dd><dt class="description">
     <!--l. 2075--><p class="noindent" >
 </p></dt><dd 
class="description">
     <!--l. 2075--><p class="noindent" >
       </p><div class="syntax">
        <span 
class="pcrr8t-x-x-109">easyindepset!*</span>\(\langle \)<span 
class="ptmri8t-x-x-109">m</span>\(\rangle \)</div>
<a 
 id="dx170-391006"></a>
     <!--l. 2080--><p class="noindent" ><a 
 id="procedure:EASYINDEPSET!*"></a> returns a maximal with respect to inclusion independent set of \(m\).
                                                                     

                                                                     
     </p></dd><dt class="description">
     <!--l. 2084--><p class="noindent" >
 </p></dt><dd 
class="description">
     <!--l. 2084--><p class="noindent" >
       </p><div class="syntax">
        <span 
class="pcrr8t-x-x-109">easydim!*</span>\(\langle \)<span 
class="ptmri8t-x-x-109">m</span>\(\rangle \)</div>
<a 
 id="dx170-391007"></a>
     <!--l. 2089--><p class="noindent" ><a 
 id="procedure:EASYDIM!*"></a> is a fast dimension algorithm (based on <span 
class="pcrr8t-x-x-109">easyindepset</span>), that will be correct
 if  \(m\)  is  (radically)  unmixed.  Since  it  is  signiﬁcantly  faster  than  the  general
 dimension algorithm<span class="footnote-mark"><a 
href="manual181.html#fn11x20"><sup class="textsuperscript">11</sup></a></span>, it should be used, if all maximal independent sets are
 known  to  be  of  equal  cardinality  (as  e.g. for  prime  or  unmixed  ideals,  see
 <span class="cite">[<a 
href="manualap2.html#XGraebe:93a">Grä93</a>]</span>).<a 
 id="x170-391008f11"></a></p></dd></dl>
<!--l. 2102--><p class="noindent" >
</p>
<h5 class="subsubsectionHead"><a 
 id="x170-39200020.7.4"></a>Hilbert Series</h5>
<!--l. 2104--><p class="noindent" ><span 
class="ptmrc8t-x-x-109">C<span 
class="small-caps">A</span><span 
class="small-caps">L</span><span 
class="small-caps">I</span> </span>v. 2.2 now oﬀers also <span 
class="ptmri8t-x-x-109">weighted Hilbert series</span><a 
 id="dx170-392001"></a>, i.e. series that may reﬂect
multihomogeneity of ideals and modules. For this purpose a weighted Hilbert series has a
list of (integer) degree vectors as second parameter, and the ideal(s) of leading terms are
evaluated wrt. these weights. For the output and polynomial arithmetic, involved during
the computation of the Hilbert series numerator, the diﬀerent weight levels are mapped
onto the ﬁrst variables of the current ring. If \(w\) is such a weight vector list and \(I\) is a
monomial ideal in the polynomial ring \(S=k[x_v\,:\,v\in V]\) we get (using multi exponent notation) \[H(S/I,t) := \sum _{\alpha }{|\{x^a\not \in I\,:\,w(a)=\alpha \}|\cdot t^\alpha } = \frac {Q(t)}{\prod _{v\in V}{\left (1-t^{w(x_v)}\right )} }\]
for a certain polynomial Hilbert series numerator \(Q(t)\). \(H(R/I,t)\) is known to be a rational
function with pole order at \(t=1\) equal to \(dim\ R/I\). Note that <span 
class="ptmri8t-x-x-109">WeightedHilbertSeries</span><a 
 id="dx170-392002"></a> returns a
<span 
class="ptmri8t-x-x-109">reduced </span>rational function where the gcd of numerator and denominator is canceled
out.
</p><!--l. 2123--><p class="noindent" >(Non weighted) Hilbert series call the weighted Hilbert series procedure with a single
weight vector, the ecart vector of the current ring.
</p><!--l. 2127--><p class="noindent" >The Hilbert series numerator \(Q(t)\) is computed using (the obvious generalizations to the
weighted case of) the algorithms in <span class="cite">[<a 
href="manualap2.html#XBayerStillman:92">BS92</a>]</span> and <span class="cite">[<a 
href="manualap2.html#XBigatti:93">BCRT93</a>]</span>. Experiments suggest that the
former is better for few generators of high degree whereas the latter has to be preferred
for many generators of low degree. Choose the version with <span 
class="ptmri8t-x-x-109">hftestversion</span><a 
 id="dx170-392003"></a> \(n\), \(n=1,\,2\).
Bayer/Stillman’s approach (\(n=1\)) is the default. In the following \(m\) is a dpmat and Gröbner
                                                                     

                                                                     
basis.
     </p><dl class="description"><dt class="description">
     <!--l. 2137--><p class="noindent" >
 </p></dt><dd 
class="description">
     <!--l. 2137--><p class="noindent" >
       </p><div class="syntax">
        <span 
class="pcrr8t-x-x-109">hf_whilb</span>(\(\langle \)<span 
class="ptmri8t-x-x-109">m</span>\(\rangle \),\(\langle \)<span 
class="ptmri8t-x-x-109">w</span>\(\rangle \))</div>
<a 
 id="dx170-392004"></a>
     <!--l. 2142--><p class="noindent" ><a 
 id="procedure:HF_WHILB"></a> returns  the  weighted  Hilbert  series  numerator  \(Q(t)\)  of  \(m\)  according  to  the  version
 chosen with <span 
class="ptmri8t-x-x-109">hftestversion</span><a 
 id="dx170-392005"></a>.
     </p></dd><dt class="description">
     <!--l. 2146--><p class="noindent" >
 </p></dt><dd 
class="description">
     <!--l. 2146--><p class="noindent" >
       </p><div class="syntax">
        <span 
class="pcrr8t-x-x-109">WeightedHilbertSeries!*</span>(\(\langle \)<span 
class="ptmri8t-x-x-109">m</span>\(\rangle \),\(\langle \)<span 
class="ptmri8t-x-x-109">w</span>\(\rangle \))</div>
<a 
 id="dx170-392006"></a>
     <!--l. 2151--><p class="noindent" ><a 
 id="procedure:WEIGHTEDHILBERTSERIES!*"></a> returns the weighted Hilbert series reduced rational function of \(m\) as s.q.
     </p></dd><dt class="description">
     <!--l. 2155--><p class="noindent" >
 </p></dt><dd 
class="description">
     <!--l. 2155--><p class="noindent" >
       </p><div class="syntax">
        <span 
class="pcrr8t-x-x-109">HilbertSeries!*</span>(\(\langle \)<span 
class="ptmri8t-x-x-109">m</span>\(\rangle \),\(\langle \)<span 
class="ptmri8t-x-x-109">w</span>\(\rangle \))</div>
<a 
 id="dx170-392007"></a>
     <!--l. 2160--><p class="noindent" ><a 
 id="procedure:HILBERTSERIES!*"></a> returns the Hilbert series reduced rational function of \(m\) wrt. the ecart vector of
 the current ring as s.q.
     </p></dd><dt class="description">
     <!--l. 2164--><p class="noindent" >
 </p></dt><dd 
class="description">
                                                                     

                                                                     
     <!--l. 2164--><p class="noindent" >
       </p><div class="syntax">
       <!--tex4ht:inline--><div class="tabular"> <table id="TBL-42" class="tabular" 
 
><colgroup id="TBL-42-1g"><col 
id="TBL-42-1" /><col 
id="TBL-42-2" /><col 
id="TBL-42-3" /></colgroup><tr  
 style="vertical-align:baseline;" id="TBL-42-1-"><td  style="white-space:nowrap; text-align:left;" id="TBL-42-1-1"  
class="td01"><span 
class="pcrr8t-x-x-109">hf_whilb3</span>(\(\langle \)<span 
class="ptmri8t-x-x-109">u</span>\(\rangle \),\(\langle \)<span 
class="ptmri8t-x-x-109">w</span>\(\rangle \))                              </td>
</tr><tr  
 style="vertical-align:baseline;" id="TBL-42-2-"><td  style="white-space:nowrap; text-align:left;" id="TBL-42-2-1"  
class="td01"><div class="multicolumn"  style="white-space:nowrap; text-align:left;">and</div></td></tr><tr  
 style="vertical-align:baseline;" id="TBL-42-3-"><td  style="white-space:nowrap; text-align:left;" id="TBL-42-3-1"  
class="td01"><span 
class="pcrr8t-x-x-109">hf_whs_from_resolution</span>(\(\langle \)<span 
class="ptmri8t-x-x-109">u</span>\(\rangle \),\(\langle \)<span 
class="ptmri8t-x-x-109">w</span>\(\rangle \))</td>
</tr><tr  
 style="vertical-align:baseline;" id="TBL-42-4-"><td  style="white-space:nowrap; text-align:left;" id="TBL-42-4-1"  
class="td01">                         </td></tr></table></div></div>
<a 
 id="dx170-392008"></a>
<a 
 id="dx170-392009"></a>
     <!--l. 2172--><p class="noindent" ><a 
 id="procedure:HF_WHILB3"></a><a 
 id="procedure:HF_WHS_FROM_RESOLUTION"></a> compute the weighted Hilbert series numerator and the corresponding reduced 
rational function from (the column degrees of) a given resolution \(u\).
     </p></dd><dt class="description">
     <!--l. 2178--><p class="noindent" >
 </p></dt><dd 
class="description">
     <!--l. 2178--><p class="noindent" >
       </p><div class="syntax">
        <span 
class="pcrr8t-x-x-109">degree!*</span>\(\langle \)<span 
class="ptmri8t-x-x-109">m</span>\(\rangle \)</div>
<a 
 id="dx170-392010"></a>
     <!--l. 2183--><p class="noindent" ><a 
 id="procedure:DEGREE!*"></a> returns the value of the numerator of the reduced Hilbert series of \(m\) at \(t=1\). i.e. the
 sum of its coeﬃcients. For the standard ecart this is the degree of \(\mathop {\mathrm {coker}} m\).
     </p></dd></dl>
<!--l. 2189--><p class="noindent" >
</p>
<h5 class="subsubsectionHead"><a 
 id="x170-39300020.7.4"></a>Resolutions</h5>
<!--l. 2191--><p class="noindent" >Resolutions of ideals and modules, represented as lists of dpmats, are computed via
repeated syzygy computation with minimization steps between them to get minimal
bases and generators of syzygy modules. Note that the algorithms apply simultaneously
to both Noetherian and non Noetherian term orders. For compatibility reasons with
further releases v. 2.2 introduces a second parameter to bound the number of syzygy
modules to be computed, since Hilbert’s syzygy theorem applies only to regular
rings.
     </p><dl class="description"><dt class="description">
     <!--l. 2201--><p class="noindent" >
 </p></dt><dd 
class="description">
                                                                     

                                                                     
     <!--l. 2201--><p class="noindent" >
       </p><div class="syntax">
        <span 
class="pcrr8t-x-x-109">Resolve!*</span>(\(\langle \)<span 
class="ptmri8t-x-x-109">m</span>\(\rangle \),\(\langle \)<span 
class="ptmri8t-x-x-109">d</span>\(\rangle \))</div>
<a 
 id="dx170-393001"></a>
     <!--l. 2206--><p class="noindent" ><a 
 id="procedure:RESOLVE!*"></a> computes a minimal resolution of the dpmat \(m\), i.e. a list of dpmats \(\{s_0, s_1, s_2,\ldots \}\), where \(s_k\) is
 the \(k\)-th syzygy module of \(m\), upto part \(s_d\).
     </p></dd><dt class="description">
     <!--l. 2211--><p class="noindent" >
 </p></dt><dd 
class="description">
     <!--l. 2211--><p class="noindent" >
       </p><div class="syntax">
       <!--tex4ht:inline--><div class="tabular"> <table id="TBL-43" class="tabular" 
 
><colgroup id="TBL-43-1g"><col 
id="TBL-43-1" /><col 
id="TBL-43-2" /><col 
id="TBL-43-3" /></colgroup><tr  
 style="vertical-align:baseline;" id="TBL-43-1-"><td  style="white-space:nowrap; text-align:left;" id="TBL-43-1-1"  
class="td01"><span 
class="pcrr8t-x-x-109">BettiNumbers!*</span>\(\langle \)<span 
class="ptmri8t-x-x-109">c</span>\(\rangle \)             </td></tr><tr  
 style="vertical-align:baseline;" id="TBL-43-2-"><td  style="white-space:nowrap; text-align:left;" id="TBL-43-2-1"  
class="td01"><div class="multicolumn"  style="white-space:nowrap; text-align:left;">and</div>
</td></tr><tr  
 style="vertical-align:baseline;" id="TBL-43-3-"><td  style="white-space:nowrap; text-align:left;" id="TBL-43-3-1"  
class="td01"><span 
class="pcrr8t-x-x-109">GradedBettiNumbers!*</span>\(\langle \)<span 
class="ptmri8t-x-x-109">c</span>\(\rangle \)</td></tr></table>
       </div></div>
<a 
 id="dx170-393002"></a>
<a 
 id="dx170-393003"></a>
     <!--l. 2219--><p class="noindent" ><a 
 id="procedure:BETTINUMBERS!*"></a> <a 
 id="procedure:GRADEDBETTINUMBERS!*"></a> returns  the  Betti  numbers  resp. the  graded  Betti  numbers  of  the  resolution 
\(c\),  i.e. the  list  of  the  lengths  resp. the  degree  lists  (according  to  the  ecart) 
themselves of the dpmats in \(c\).
     </p></dd></dl>
<!--l. 2226--><p class="noindent" >
</p>
<h5 class="subsubsectionHead"><a 
 id="x170-39400020.7.4"></a>Zero Dimensional Ideals and Modules</h5>
<!--l. 2228--><p class="noindent" >There are several algorithms that either force the reduction of a given problem to
dimension zero or work only for zero dimensional ideals or modules. The <span 
class="ptmri8t-x-x-109">module odim</span><a 
 id="dx170-394001"></a>
oﬀers such algorithms. It contains, e.g. 
     </p><dl class="description"><dt class="description">
     <!--l. 2233--><p class="noindent" >
 </p></dt><dd 
class="description">
     <!--l. 2233--><p class="noindent" >
       </p><div class="syntax">
        <span 
class="pcrr8t-x-x-109">dimzerop!*</span>\(\langle \)<span 
class="ptmri8t-x-x-109">m</span>\(\rangle \)</div>
<a 
 id="dx170-394002"></a>
     <!--l. 2238--><p class="noindent" ><a 
 id="procedure:DIMZEROP!*"></a> that tests a dpmat \(m\) for being zero dimensional.
                                                                     

                                                                     
     </p></dd><dt class="description">
     <!--l. 2241--><p class="noindent" >
 </p></dt><dd 
class="description">
     <!--l. 2241--><p class="noindent" >
       </p><div class="syntax">
        <span 
class="pcrr8t-x-x-109">getkbase!*</span>\(\langle \)<span 
class="ptmri8t-x-x-109">u</span>\(\rangle \)</div>
<a 
 id="dx170-394003"></a>
     <!--l. 2246--><p class="noindent" ><a 
 id="procedure:GETKBASE!*"></a> that  returns  a  (monomial)  k-vector  space  basis  of  \(Coker\ m\)  provided  \(m\)  is  a  Gröbner
 basis.
     </p></dd><dt class="description">
     <!--l. 2250--><p class="noindent" >
 </p></dt><dd 
class="description">
     <!--l. 2250--><p class="noindent" >
       </p><div class="syntax">
        <span 
class="pcrr8t-x-x-109">odim_borderbasis</span>\(\langle \)<span 
class="ptmri8t-x-x-109">m</span>\(\rangle \)</div>
<a 
 id="dx170-394004"></a>
     <!--l. 2255--><p class="noindent" ><a 
 id="procedure:ODIM_BORDERBASIS"></a> that returns a border basis, see <span class="cite">[<a 
href="manualap2.html#XMarinari:91">MMM91</a>]</span>, of the zero dimensional dpmat \(m\) as a
 list of base elements.
     </p></dd><dt class="description">
     <!--l. 2259--><p class="noindent" >
 </p></dt><dd 
class="description">
     <!--l. 2259--><p class="noindent" >
       </p><div class="syntax">
        <span 
class="pcrr8t-x-x-109">odim_parameter</span>\(\langle \)<span 
class="ptmri8t-x-x-109">m</span>\(\rangle \)</div>
<a 
 id="dx170-394005"></a>
     <!--l. 2264--><p class="noindent" ><a 
 id="procedure:ODIM_PARAMETER"></a> that returns a parameter of the dpmat \(m\), i.e. a variable \(x \in vars\) such that \(k[x]\bigcap Ann\ S^c/m=(0)\), or <span 
class="ptmri8t-x-x-109">nil </span>if \(m\) is
 zero dimensional.
     </p></dd><dt class="description">
     <!--l. 2269--><p class="noindent" >
 </p></dt><dd 
class="description">
     <!--l. 2269--><p class="noindent" >
       </p><div class="syntax">
        <span 
class="pcrr8t-x-x-109">odim_up</span>(\(\langle \)<span 
class="ptmri8t-x-x-109">a</span>\(\rangle \),\(\langle \)<span 
class="ptmri8t-x-x-109">m</span>\(\rangle \))</div>
<a 
 id="dx170-394006"></a>
                                                                     

                                                                     
     <!--l. 2274--><p class="noindent" ><a 
 id="procedure:ODIM_UP"></a> that returns an univariate polynomial (of smallest possible degree if \(m\) is a gbasis)
 in  the  variable  \(a\),  that  belongs  to  the  zero  dimensional  dpmat  ideal  \(m\),  using
 Buchberger’s approach <span class="cite">[<a 
href="manualap2.html#XBuchberger:85">Buc85</a>]</span>.
     </p></dd></dl>
<!--l. 2281--><p class="noindent" >
</p>
<h5 class="subsubsectionHead"><a 
 id="x170-39500020.7.4"></a>Primary Decomposition and Related Algorithms</h5>
<!--l. 2283--><p class="noindent" >The algorithms of the <span 
class="ptmri8t-x-x-109">module prime</span><a 
 id="dx170-395001"></a> implement the ideas of <span class="cite">[<a 
href="manualap2.html#XGianni:88">GTZ88</a>]</span> with modiﬁcations
along <span class="cite">[<a 
href="manualap2.html#XKredel:87">Kre87</a>]</span> and their natural generalizations to modules as e.g. explained in <span class="cite">[<a 
href="manualap2.html#XRutman:92">Rut92</a>]</span>.
Version 2.2.1 ﬁxes a serious bug detecting superﬂuous embedded primary components,
see section <a 
href="manualse130.html#x170-36800020.7.1">20.7.1<!--tex4ht:ref: 221 --></a>, and contains now a second primary decomposition algorithm, based
on ideal separation, as standard. For a discussion about embedded primes and the ideal
separation approach, see <span class="cite">[<a 
href="manualap2.html#XGraebe:97">Grä97</a>]</span>.
</p><!--l. 2293--><p class="noindent" ><span 
class="ptmrc8t-x-x-109">C<span 
class="small-caps">A</span><span 
class="small-caps">L</span><span 
class="small-caps">I</span> </span>contains also algorithms for the computation of the unmixed part of a given module
and the unmixed radical of a given ideal (along the same lines). We followed the stepwise
recursion decreasing dimension in each step by 1 as proposed in (the ﬁnal version of)
<span class="cite">[<a 
href="manualap2.html#XGianni:88">GTZ88</a>]</span> rather than the “one step” method described in <span class="cite">[<a 
href="manualap2.html#XBecker:93">BWK93</a>]</span> since handling leading
coeﬃcients, i.e. standard forms, depending on several variables is a quite hard job for
REDUCE<span class="footnote-mark"><a 
href="manual182.html#fn12x20"><sup class="textsuperscript">12</sup></a></span><a 
 id="x170-395002f12"></a> .
</p><!--l. 2303--><p class="noindent" >In the following procedures \(m\) must be a Gröbner basis.
     </p><dl class="description"><dt class="description">
     <!--l. 2306--><p class="noindent" >
 </p></dt><dd 
class="description">
     <!--l. 2306--><p class="noindent" >
       </p><div class="syntax">
        <span 
class="pcrr8t-x-x-109">zeroradical!*</span>\(\langle \)<span 
class="ptmri8t-x-x-109">m</span>\(\rangle \)</div>
<a 
 id="dx170-395004"></a>
     <!--l. 2311--><p class="noindent" ><a 
 id="procedure:ZERORADICAL!*"></a> returns   the   radical   of   the   zero   dimensional   ideal   \(m\),   using   squarefree
 decomposition of univariate polynomials.
     </p></dd><dt class="description">
     <!--l. 2315--><p class="noindent" >
 </p></dt><dd 
class="description">
                                                                     

                                                                     
     <!--l. 2315--><p class="noindent" >
       </p><div class="syntax">
        <span 
class="pcrr8t-x-x-109">zeroprimes!*</span>\(\langle \)<span 
class="ptmri8t-x-x-109">m</span>\(\rangle \)</div>
<a 
 id="dx170-395005"></a>
     <!--l. 2320--><p class="noindent" ><a 
 id="procedure:ZEROPRIMES!*"></a> computes as in <span class="cite">[<a 
href="manualap2.html#XGianni:88">GTZ88</a>]</span> the list of prime ideals of \(Ann\ F/M\) if \(m\) is zero dimensional,
 using the (sparse) general position argument from <span class="cite">[<a 
href="manualap2.html#XKredel:88a">KW88</a>]</span>.
     </p></dd><dt class="description">
     <!--l. 2325--><p class="noindent" >
 </p></dt><dd 
class="description">
     <!--l. 2325--><p class="noindent" >
       </p><div class="syntax">
        <span 
class="pcrr8t-x-x-109">zeroprimarydecomposition!*</span>\(\langle \)<span 
class="ptmri8t-x-x-109">m</span>\(\rangle \)</div>
<a 
 id="dx170-395006"></a>
     <!--l. 2330--><p class="noindent" ><a 
 id="procedure:ZEROPRIMARYDECOMPOSITION!*"></a> computes the primary components of the zero dimensional dpmat \(m\) using prime
 splitting  with  the  prime  ideals  of  \(Ann\ F/M\).  It  returns  a  list  of  pairs  with  ﬁrst  entry
 the primary component and second entry the corresponding associated prime
 ideal.
     </p></dd><dt class="description">
     <!--l. 2336--><p class="noindent" >
 </p></dt><dd 
class="description">
     <!--l. 2336--><p class="noindent" >
       </p><div class="syntax">
        <span 
class="pcrr8t-x-x-109">isprime!*</span>\(\langle \)<span 
class="ptmri8t-x-x-109">m</span>\(\rangle \)</div>
<a 
 id="dx170-395007"></a>
     <!--l. 2341--><p class="noindent" ><a 
 id="procedure:ISPRIME!*"></a> a (one step) primality test for ideals, extracted from <span class="cite">[<a 
href="manualap2.html#XGianni:88">GTZ88</a>]</span>.
     </p></dd><dt class="description">
     <!--l. 2345--><p class="noindent" >
 </p></dt><dd 
class="description">
     <!--l. 2345--><p class="noindent" >
       </p><div class="syntax">
        <span 
class="pcrr8t-x-x-109">isolatedprimes!*</span>\(\langle \)<span 
class="ptmri8t-x-x-109">m</span>\(\rangle \)</div>
<a 
 id="dx170-395008"></a>
     <!--l. 2350--><p class="noindent" ><a 
 id="procedure:ISOLATEDPRIMES!*"></a> computes (only) the isolated prime ideals of \(Ann\ F/M\).
                                                                     

                                                                     
     </p></dd><dt class="description">
     <!--l. 2353--><p class="noindent" >
 </p></dt><dd 
class="description">
     <!--l. 2353--><p class="noindent" >
       </p><div class="syntax">
        <span 
class="pcrr8t-x-x-109">radical!*</span>\(\langle \)<span 
class="ptmri8t-x-x-109">m</span>\(\rangle \)</div>
<a 
 id="dx170-395009"></a>
     <!--l. 2358--><p class="noindent" ><a 
 id="procedure:RADICAL!*"></a> computes the radical of the dpmat ideal \(m\), reducing as in <span class="cite">[<a 
href="manualap2.html#XGianni:88">GTZ88</a>]</span> to the zero
 dimensional case.
     </p></dd><dt class="description">
     <!--l. 2362--><p class="noindent" >
 </p></dt><dd 
class="description">
     <!--l. 2362--><p class="noindent" >
       </p><div class="syntax">
        <span 
class="pcrr8t-x-x-109">easyprimarydecomposition!*</span>\(\langle \)<span 
class="ptmri8t-x-x-109">m</span>\(\rangle \)</div>
<a 
 id="dx170-395010"></a>
     <!--l. 2367--><p class="noindent" ><a 
 id="procedure:EASYPRIMARYDECOMPOSITION!*"></a> computes  the  primary  components  of  the  dpmat  \(m\),  if  it  has  no  embedded
 components. The algorithm uses prime splitting with the isolated prime ideals
 of \(Ann\ F/M\). It returns a list of pairs as in <span 
class="pcrr8t-x-x-109">zeroprimarydecomposition!*</span>.
     </p></dd><dt class="description">
     <!--l. 2373--><p class="noindent" >
 </p></dt><dd 
class="description">
     <!--l. 2373--><p class="noindent" >
       </p><div class="syntax">
        <span 
class="pcrr8t-x-x-109">primarydecomposition!*</span>\(\langle \)<span 
class="ptmri8t-x-x-109">m</span>\(\rangle \)</div>
<a 
 id="dx170-395011"></a>
     <!--l. 2378--><p class="noindent" ><a 
 id="procedure:PRIMARYDECOMPOSITION!*"></a> computes the primary components of the dpmat \(m\) along the lines of <span class="cite">[<a 
href="manualap2.html#XGianni:88">GTZ88</a>]</span>. It
 returns a list of two-element lists as in <span 
class="pcrr8t-x-x-109">zeroprimarydecomposition!*</span>.
     </p></dd><dt class="description">
     <!--l. 2383--><p class="noindent" >
 </p></dt><dd 
class="description">
     <!--l. 2383--><p class="noindent" >
       </p><div class="syntax">
        <span 
class="pcrr8t-x-x-109">unmixedradical!*</span>\(\langle \)<span 
class="ptmri8t-x-x-109">m</span>\(\rangle \)</div>
<a 
 id="dx170-395012"></a>
                                                                     

                                                                     
     <!--l. 2388--><p class="noindent" ><a 
 id="procedure:UNMIXEDRADICAL!*"></a> returns the unmixed radical, i.e. the intersection of the isolated primes of top
 dimension, associated to the dpmat ideal \(m\).
     </p></dd><dt class="description">
     <!--l. 2392--><p class="noindent" >
 </p></dt><dd 
class="description">
     <!--l. 2392--><p class="noindent" >
       </p><div class="syntax">
        <span 
class="pcrr8t-x-x-109">eqhull!*</span>\(\langle \)<span 
class="ptmri8t-x-x-109">m</span>\(\rangle \)</div>
<a 
 id="dx170-395013"></a>
     <!--l. 2397--><p class="noindent" ><a 
 id="procedure:EQHULL!*"></a> returns the equidimensional hull, i.e. the intersection of the top dimensional
 primary components of the dpmat \(m\).
     </p></dd></dl>
<h5 class="subsubsectionHead"><a 
 id="x170-39600020.7.4"></a>Advanced Algorithms</h5>
<!--l. 2404--><p class="noindent" >The <span 
class="ptmri8t-x-x-109">module scripts</span><a 
 id="dx170-396001"></a> just under further development oﬀers some advanced topics of the
Gröbner bases theory. It introduces the new data structure of a <span 
class="ptmri8t-x-x-109">map</span><a 
 id="dx170-396002"></a> between base rings:
</p><!--l. 2409--><p class="noindent" >A ring map \[ \phi \ :\ R\longrightarrow S\] for \(R=k[r_i], S=k[s_j]\) is represented in symbolic mode as a list \[ \{preimage\_ring\ R,\ image\_ring\ S, subst\_list\},\] where <span 
class="pcrr8t-x-x-109">subst_list </span>is a
substitution list \(\{r_1=\phi _1(s), r_2=\phi _2(s),\ldots \}\) in algebraic preﬁx form, i.e. looks like <span 
class="pcrr8t-x-x-109">(list (equal var</span>
<span 
class="pcrr8t-x-x-109">image) </span><span 
class="pcrr8t-x-x-109">…)</span>.
</p><!--l. 2417--><p class="noindent" >The central tool for several applications is the computation of the preimage \(\phi ^{-1}(I)\subset R\) of an ideal \(I\subset S\)
either under a polynomial map \(\phi \) or its closure in \(R\) under a rational map \(\phi \), see <span class="cite">[<a 
href="manualap2.html#XBecker:93">BWK93</a>,
7.69 and 7.71]</span>.
     </p><dl class="description"><dt class="description">
     <!--l. 2423--><p class="noindent" >
 </p></dt><dd 
class="description">
     <!--l. 2423--><p class="noindent" >
       </p><div class="syntax">
        <span 
class="pcrr8t-x-x-109">preimage!*</span>(\(\langle \)<span 
class="ptmri8t-x-x-109">m</span>\(\rangle \),\(\langle \)<span 
class="ptmri8t-x-x-109">map</span>\(\rangle \))</div>
<a 
 id="dx170-396003"></a>
     <!--l. 2428--><p class="noindent" ><a 
 id="procedure:PREIMAGE!*"></a> computes the preimage of the ideal \(m\) in algebraic preﬁx form under the given
 polynomial map and sets the current base ring to the preimage ring. Returns
 the result also in algebraic preﬁx form.
                                                                     

                                                                     
     </p></dd><dt class="description">
     <!--l. 2433--><p class="noindent" >
 </p></dt><dd 
class="description">
     <!--l. 2433--><p class="noindent" >
       </p><div class="syntax">
        <span 
class="pcrr8t-x-x-109">ratpreimage!*</span>(\(\langle \)<span 
class="ptmri8t-x-x-109">m</span>\(\rangle \),\(\langle \)<span 
class="ptmri8t-x-x-109">map</span>\(\rangle \))</div>
<a 
 id="dx170-396004"></a>
     <!--l. 2438--><p class="noindent" ><a 
 id="procedure:RATPREIMAGE!*"></a> computes the closure of the preimage of the ideal \(m\) in algebraic preﬁx form
 under the given rational map and sets the current base ring to the preimage
 ring. Returns the result also in algebraic preﬁx form.
</p>
     </dd></dl>
<!--l. 2446--><p class="noindent" >Derived applications are
     </p><dl class="description"><dt class="description">
     <!--l. 2449--><p class="noindent" >
 </p></dt><dd 
class="description">
     <!--l. 2449--><p class="noindent" >
       </p><div class="syntax">
        <span 
class="pcrr8t-x-x-109">affine_monomial_curve!*</span>(\(\langle \)<span 
class="ptmri8t-x-x-109">l</span>\(\rangle \),\(\langle \)<span 
class="ptmri8t-x-x-109">vars</span>\(\rangle \))</div>
<a 
 id="dx170-396005"></a>
     <!--l. 2454--><p class="noindent" ><a 
 id="procedure:AFFINE_MONOMIAL_CURVE!*"></a> \(l\)  is  a  list  of  integers,  \(vars\)  a  list  of  variable  names  of  the  same  length  as  \(l\).  The
 procedure sets the current base ring and returns the deﬁning ideal of the aﬃne
 monomial curve with generic point \((t^i\ :\ i\in l)\) computing the corresponding preimage.
     </p></dd><dt class="description">
     <!--l. 2461--><p class="noindent" >
 </p></dt><dd 
class="description">
     <!--l. 2461--><p class="noindent" >
       </p><div class="syntax">
        <span 
class="pcrr8t-x-x-109">analytic_spread!*</span>\(\langle \)<span 
class="ptmri8t-x-x-109">m</span>\(\rangle \)</div>
<a 
 id="dx170-396006"></a>
     <!--l. 2466--><p class="noindent" ><a 
 id="procedure:ANALYTIC_SPREAD!*"></a> Computes the analytic spread of \(M\), i.e. the dimension of the exceptional ﬁber \({\cal R}(M)/m{\cal R}(M)\)
 of the blowup along \(M\) over the irrelevant ideal \(m\) of the current base ring.
                                                                     

                                                                     
     </p></dd><dt class="description">
     <!--l. 2471--><p class="noindent" >
 </p></dt><dd 
class="description">
     <!--l. 2471--><p class="noindent" >
       </p><div class="syntax">
        <span 
class="pcrr8t-x-x-109">assgrad!*</span>(\(\langle \)<span 
class="ptmri8t-x-x-109">M</span>\(\rangle \),\(\langle \)<span 
class="ptmri8t-x-x-109">N</span>\(\rangle \),\(\langle \)<span 
class="ptmri8t-x-x-109">vars</span>\(\rangle \))</div>
<a 
 id="dx170-396007"></a>
     <!--l. 2476--><p class="noindent" ><a 
 id="procedure:ASSGRAD!*"></a> Computes the associated graded ring \[gr_R(N):= (R/N\oplus N/N^2\oplus \ldots )={\cal R}(N)/N{\cal R}(N)\] over the ring \(R=S/M\), where \(M\) and \(N\) are dpmat
 ideals deﬁned over the current base ring \(S\). \(\langle \)<span 
class="ptmri8t-x-x-109">vars</span>\(\rangle \) is a list of new variable names
 one for each generator of \(N\). They are used to create a second ring \(T\) with degree
 order corresponding to the ecart of the row degrees of \(N\) and a ring map \[\phi : S\oplus T\longrightarrow S.\] It returns
 a dpmat ideal \(J\) such that \((S\oplus T)/J\) is a presentation of the desired associated graded ring
 over the new current base ring \(S\oplus T\).
     </p></dd><dt class="description">
     <!--l. 2490--><p class="noindent" >
 </p></dt><dd 
class="description">
     <!--l. 2490--><p class="noindent" >
       </p><div class="syntax">
        <span 
class="pcrr8t-x-x-109">blowup!*</span>(\(\langle \)<span 
class="ptmri8t-x-x-109">M</span>\(\rangle \),\(\langle \)<span 
class="ptmri8t-x-x-109">N</span>\(\rangle \),\(\langle \)<span 
class="ptmri8t-x-x-109">vars</span>\(\rangle \))</div>
<a 
 id="dx170-396008"></a>
     <!--l. 2495--><p class="noindent" ><a 
 id="procedure:BLOWUP!*"></a> Computes the blow up \({\cal R}(N):=R[N\cdot t]\) of \(N\) over the ring \(R=S/M\), where \(M\) and \(N\) are dpmat ideals deﬁned
 over  the  current  base  ring  \(S\).  <span 
class="pcrr8t-x-x-109">vars </span>is  a  list  of  new  variable  names  one  for
 each generator of \(N\). They are used to create a second ring \(T\) with degree order
 corresponding to the ecart of the row degrees of \(N\) and a ring map \[\phi : S\oplus T\longrightarrow S.\] It returns a
 dpmat ideal \(J\) such that \((S\oplus T)/J\) is a presentation of the desired blowup ring over the
 new current base ring \(S\oplus T\).
     </p></dd><dt class="description">
     <!--l. 2507--><p class="noindent" >
 </p></dt><dd 
class="description">
     <!--l. 2507--><p class="noindent" >
       </p><div class="syntax">
        <span 
class="pcrr8t-x-x-109">proj_monomial_curve!*</span>(\(\langle \)<span 
class="ptmri8t-x-x-109">l</span>\(\rangle \),\(\langle \)<span 
class="ptmri8t-x-x-109">vars</span>\(\rangle \))</div>
<a 
 id="dx170-396009"></a>
     <!--l. 2512--><p class="noindent" ><a 
 id="procedure:PROJ_MONOMIAL_CURVE!*"></a> \(l\)  is  a  list  of  integers,  \(vars\)  a  list  of  variable  names  of  the  same  length  as  \(l\).  The
 procedure  set  the  current  base  ring  and  returns  the  deﬁning  ideal  of  the
 projective  monomial  curve  with  generic  point  \((s^{d-i}\cdot t^i\ :\ i\in l)\)  in  \(R\),  where  \(d=max\{ x\, :\, x\in l\}\),  computing  the
 corresponding preimage.
                                                                     

                                                                     
     </p></dd><dt class="description">
     <!--l. 2519--><p class="noindent" >
 </p></dt><dd 
class="description">
     <!--l. 2519--><p class="noindent" >
       </p><div class="syntax">
        <span 
class="pcrr8t-x-x-109">sym!*</span>(\(\langle \)<span 
class="ptmri8t-x-x-109">M</span>\(\rangle \),\(\langle \)<span 
class="ptmri8t-x-x-109">vars</span>\(\rangle \))</div>
<a 
 id="dx170-396010"></a>
     <!--l. 2524--><p class="noindent" ><a 
 id="procedure:SYM!*"></a> Computes the symmetric algebra \(Sym(M)\) where \(M\) is a dpmat ideal deﬁned over the
 current base ring \(S\). \(\langle \)<span 
class="ptmri8t-x-x-109">vars</span>\(\rangle \) is a list of new variable names one for each generator
 of \(M\). They are used to create a second ring \(R\) with degree order corresponding to
 the ecart of the row degrees of \(N\) and a ring map \[\phi : S\oplus R\longrightarrow S.\] It returns a dpmat ideal \(J\) such
 that \((S\oplus R)/J\) is the desired symmetric algebra over the new current base ring \(S\oplus R\).
</p>
     </dd></dl>
<!--l. 2537--><p class="noindent" >There are several other applications:
     </p><dl class="description"><dt class="description">
     <!--l. 2540--><p class="noindent" >
 </p></dt><dd 
class="description">
     <!--l. 2540--><p class="noindent" >
       </p><div class="syntax">
        <span 
class="pcrr8t-x-x-109">minimal_generators!*</span>\(\langle \)<span 
class="ptmri8t-x-x-109">m</span>\(\rangle \)</div>
<a 
 id="dx170-396011"></a>
     <!--l. 2545--><p class="noindent" ><a 
 id="procedure:MINIMAL_GENERATORS!*"></a> returns a set of minimal generators of the dpmat \(m\) inspecting the ﬁrst syzygy
 module.
     </p></dd><dt class="description">
     <!--l. 2549--><p class="noindent" >
 </p></dt><dd 
class="description">
     <!--l. 2549--><p class="noindent" >
       </p><div class="syntax">
        <span 
class="pcrr8t-x-x-109">nzdp!*</span>(\(\langle \)<span 
class="ptmri8t-x-x-109">f</span> \(\rangle \),\(\langle \)<span 
class="ptmri8t-x-x-109">m</span>\(\rangle \))</div>
<a 
 id="dx170-396012"></a>
     <!--l. 2554--><p class="noindent" ><a 
 id="procedure:NZDP!*"></a> tests whether the dpoly \(f\) is a non zero divisor on \(\mathop {\mathrm {coker}} m\). \(m\) must be a Gröbner basis.
                                                                     

                                                                     
     </p></dd><dt class="description">
     <!--l. 2558--><p class="noindent" >
 </p></dt><dd 
class="description">
     <!--l. 2558--><p class="noindent" >
       </p><div class="syntax">
        <span 
class="pcrr8t-x-x-109">symbolic_power!*</span>(\(\langle \)<span 
class="ptmri8t-x-x-109">m</span>\(\rangle \),\(\langle \)<span 
class="ptmri8t-x-x-109">d</span>\(\rangle \))</div>
<a 
 id="dx170-396013"></a>
     <!--l. 2563--><p class="noindent" ><a 
 id="procedure:SYMBOLIC_POWER!*"></a> returns the \(d\)th symbolic power of the prime dpmat ideal \(m\) as the equidimensional
 hull of the \(d\)th true power. (Hence applies also to unmixed ideals.)
     </p></dd><dt class="description">
     <!--l. 2568--><p class="noindent" >
 </p></dt><dd 
class="description">
     <!--l. 2568--><p class="noindent" >
       </p><div class="syntax">
        <span 
class="pcrr8t-x-x-109">varopt!*</span>\(\langle \)<span 
class="ptmri8t-x-x-109">m</span>\(\rangle \)</div>
<a 
 id="dx170-396014"></a>
     <!--l. 2573--><p class="noindent" ><a 
 id="procedure:VAROPT!*"></a> ﬁnds a heuristically optimal variable order by the approach in <span class="cite">[<a 
href="manualap2.html#XBoege:86">BGK86</a>]</span> and
 returns the corresponding list of variables.
     </p></dd></dl>
<!--l. 2579--><p class="noindent" >
</p>
<h5 class="subsubsectionHead"><a 
 id="x170-39700020.7.4"></a>Dual Bases</h5>
<!--l. 2582--><p class="noindent" >For the general ideas underlying the dual bases approach see e.g. <span class="cite">[<a 
href="manualap2.html#XMarinari:91">MMM91</a>]</span>. This paper
explains, that constructive problems from very diﬀerent areas of commutative
algebra can be formulated in a uniﬁed way as the computation of a basis for the
intersection of the kernels of a ﬁnite number of linear functionals generating a
dual \(S\)-module. Our implementation honours this point of view, presenting two
general drivers <span 
class="ptmri8t-x-x-109">dualbases</span><a 
 id="dx170-397001"></a> and <span 
class="ptmri8t-x-x-109">dualhbases</span><a 
 id="dx170-397002"></a> for the computation of such bases
(even as submodules of a free module \(M=S^m\)) with aﬃne resp. projective dimension
zero.
</p><!--l. 2592--><p class="noindent" >Such a collection of \(N\) linear functionals \[L\,:\, M=S^m \longrightarrow k^N\] should be given through values \(\{[e_i,L(e_i)], i=1,\ldots ,m\}\) on the generators
\(e_i\) of \(M\) and an evaluation function <span 
class="pcrr8t-x-x-109">evlf([p,L(p)],x)</span>, that evaluates \(L(p\cdot x)\) from \(L(p)\) for \(p\in M\) and the
variable \(x\in S\).
                                                                     

                                                                     
</p><!--l. 2599--><p class="noindent" ><span 
class="ptmri8t-x-x-109">dualbases</span><a 
 id="dx170-397003"></a> starts with a list of such generator/value constructs generating \(M\) and performs
Gaussian reduction on expressions \([p\cdot x,L(p\cdot x)]\), where \(p\) was already processed, \(L(p)\neq 0\), and \(x\in S\) is a variable.
These elements are processed in ascending order wrt. the term order on \(M\). This guarantees
both termination and that the resulting basis of \(ker\ L\) is a Gröbner basis. The \(N\) values of \(L\) are
attached to \(N\) variables, that are ordered linearly. Gaussian elimination is executed
wrt. this variable order.
</p><!--l. 2608--><p class="noindent" >To initialize the dual bases driver one has to supply the basic generator/value list
(through the parameter list; for ideals just the one element list containing the generator \([1\in S,L(1)]\)),
the evaluation function, and the linear algebra variable order. The latter are supplied via
the property list of <span 
class="pcrr8t-x-x-109">cali </span>as properties <span 
class="pcrr8t-x-x-109">evlf </span>and <span 
class="pcrr8t-x-x-109">varlessp</span>. Diﬀerent applications
need more entries on the property list of <span 
class="pcrr8t-x-x-109">cali </span>to manage the communication between
the driver and the calling routine.
</p><!--l. 2617--><p class="noindent" ><span 
class="ptmri8t-x-x-109">dualhbases</span><a 
 id="dx170-397004"></a> realizes the same idea for (homogeneous) ideals and modules of (projective)
dimension zero. It produces zerodimensional “slices” with ascending degree
until it reaches a supremum supplied by the user, see <span class="cite">[<a 
href="manualap2.html#XMarinari:91">MMM91</a>]</span> for details.
</p><!--l. 2623--><p class="noindent" >Applications concern aﬃne and projective deﬁning ideals of a ﬁnite number of
points<span class="footnote-mark"><a 
href="manual183.html#fn13x20"><sup class="textsuperscript">13</sup></a></span><a 
 id="x170-397005f13"></a> 
and two versions (with and without precomputed border basis) of term order changes for
zerodimensional ideals and modules as ﬁrst described in <span class="cite">[<a 
href="manualap2.html#XFaugere:93">FGLM93</a>]</span>.
     </p><dl class="description"><dt class="description">
     <!--l. 2635--><p class="noindent" >
 </p></dt><dd 
class="description">
     <!--l. 2635--><p class="noindent" >
       </p><div class="syntax">
        <span 
class="pcrr8t-x-x-109">affine_points!*</span>\(\langle \)<span 
class="ptmri8t-x-x-109">m</span>\(\rangle \)</div>
<a 
 id="dx170-397008"></a>
     <!--l. 2640--><p class="noindent" ><a 
 id="procedure:AFFINE_POINTS!*"></a> \(m\)  is  a  matrix  of  domain  elements  (in  algebraic  preﬁx  form)  with  as  many
 columns as the current base ring has ring variables. This procedure returns the
 deﬁning ideal of the collection of points in aﬃne space with coordinates given
 by the rows of \(m\). Note that \(m\) may contain parameters. In this case \(k\) is treated as
 rational function ﬁeld.
                                                                     

                                                                     
     </p></dd><dt class="description">
     <!--l. 2648--><p class="noindent" >
 </p></dt><dd 
class="description">
     <!--l. 2648--><p class="noindent" >
       </p><div class="syntax">
       <!--tex4ht:inline--><div class="tabular"> <table id="TBL-44" class="tabular" 
 
><colgroup id="TBL-44-1g"><col 
id="TBL-44-1" /><col 
id="TBL-44-2" /><col 
id="TBL-44-3" /></colgroup><tr  
 style="vertical-align:baseline;" id="TBL-44-1-"><td  style="white-space:nowrap; text-align:left;" id="TBL-44-1-1"  
class="td01"><span 
class="pcrr8t-x-x-109">change_termorder!*</span>(\(\langle \)<span 
class="ptmri8t-x-x-109">m</span>\(\rangle \),\(\langle \)<span 
class="ptmri8t-x-x-109">r</span>\(\rangle \)) </td>
</tr><tr  
 style="vertical-align:baseline;" id="TBL-44-2-"><td  style="white-space:nowrap; text-align:left;" id="TBL-44-2-1"  
class="td01"><div class="multicolumn"  style="white-space:nowrap; text-align:left;">and</div></td></tr><tr  
 style="vertical-align:baseline;" id="TBL-44-3-"><td  style="white-space:nowrap; text-align:left;" id="TBL-44-3-1"  
class="td01"><span 
class="pcrr8t-x-x-109">change_termorder1!*</span>(\(\langle \)<span 
class="ptmri8t-x-x-109">m</span>\(\rangle \),\(\langle \)<span 
class="ptmri8t-x-x-109">r</span>\(\rangle \))</td>
</tr><tr  
 style="vertical-align:baseline;" id="TBL-44-4-"><td  style="white-space:nowrap; text-align:left;" id="TBL-44-4-1"  
class="td01">                      </td></tr></table></div></div>
<a 
 id="dx170-397009"></a>
<a 
 id="dx170-397010"></a>
     <!--l. 2656--><p class="noindent" ><a 
 id="procedure:CHANGE_TERMORDER!*"></a><a 
 id="procedure:CHANGE_TERMORDER1!*"></a>\(m\) is a Gröbner basis of a zero dimensional ideal wrt. the current base ring. 
These procedures change the current ring to \(r\) and compute the Gröbner basis 
of \(m\) wrt. the new ring \(r\). The former uses a precomputed border basis.
     </p></dd><dt class="description">
     <!--l. 2663--><p class="noindent" >
 </p></dt><dd 
class="description">
     <!--l. 2663--><p class="noindent" >
       </p><div class="syntax">
        <span 
class="pcrr8t-x-x-109">proj_points!*</span>\(\langle \)<span 
class="ptmri8t-x-x-109">m</span>\(\rangle \)</div>
<a 
 id="dx170-397011"></a>
     <!--l. 2668--><p class="noindent" ><a 
 id="procedure:PROJ_POINTS!*"></a> \(m\)  is  a  matrix  of  domain  elements  (in  algebraic  preﬁx  form)  with  as  many
 columns as the current base ring has ring variables. This procedure returns the
 deﬁning ideal of the collection of points in projective space with homogeneous
 coordinates given by the rows of \(m\). Note that \(m\) may as for <span 
class="pcrr8t-x-x-109">affine_points</span>
 contain parameters.
     </p></dd></dl>
<h4 class="subsectionHead"><span class="titlemark">20.7.5    </span> <a 
 id="x170-39800020.7.5"></a>A Short Description of Procedures Available in Algebraic Mode</h4>
<!--l. 2683--><p class="noindent" >Here we give a short description, ordered alphabetically, of
<span 
class="ptmb8t-x-x-109">algebraic </span>procedures oﬀered by <span 
class="ptmrc8t-x-x-109">C<span 
class="small-caps">A</span><span 
class="small-caps">L</span><span 
class="small-caps">I</span> </span>in the algebraic mode
interface<span class="footnote-mark"><a 
href="manual184.html#fn14x20"><sup class="textsuperscript">14</sup></a></span><a 
 id="x170-398001f14"></a> .
</p><!--l. 2688--><p class="noindent" >If not stated explicitely procedures take (algebraic mode) polynomial matrices (\(c&gt;0\)) or
polynomial lists (\(c=0\)) \(m,m1,m2,\ldots \ \) as input and return results of the same type. \(\langle \)<span 
class="ptmri8t-x-x-109">gb</span>\(\rangle \) stands for a bounded
                                                                     

                                                                     
identiﬁer<span class="footnote-mark"><a 
href="manual185.html#fn15x20"><sup class="textsuperscript">15</sup></a></span><a 
 id="x170-398002f15"></a> ,
\(\langle \)<span 
class="ptmri8t-x-x-109">gbr</span>\(\rangle \) for one with precomputed resolution. For the mechanism of <span 
class="ptmri8t-x-x-109">bounded identiﬁer</span><a 
 id="dx170-398003"></a> see
the section “Algebraic Mode Interface”.
     </p><dl class="description"><dt class="description">
     <!--l. 2698--><p class="noindent" >
 </p></dt><dd 
class="description">
     <!--l. 2698--><p class="noindent" >
       </p><div class="syntax">
        <span 
class="pcrr8t-x-x-109">affine_monomial_curve</span>(\(\langle \)<span 
class="ptmri8t-x-x-109">l</span>\(\rangle \),\(\langle \)<span 
class="ptmri8t-x-x-109">vars</span>\(\rangle \))</div>
<a 
 id="dx170-398004"></a>
     <!--l. 2703--><p class="noindent" ><a 
 id="operator:AFFINE_MONOMIAL_CURVE"></a> \(l\)  is  a  list  of  integers,  \(vars\)  a  list  of  variable  names  of  the  same  length  as  \(l\).  The
 procedure sets the current base ring and returns the deﬁning ideal of the aﬃne
 monomial curve with generic point \((t^i\ :\ i\in l)\).
     </p></dd><dt class="description">
     <!--l. 2709--><p class="noindent" >
 </p></dt><dd 
class="description">
     <!--l. 2709--><p class="noindent" >
       </p><div class="syntax">
        <span 
class="pcrr8t-x-x-109">affine_points</span>\(\langle \)<span 
class="ptmri8t-x-x-109">m</span>\(\rangle \)</div>
<a 
 id="dx170-398005"></a>
     <!--l. 2714--><p class="noindent" ><a 
 id="operator:AFFINE_POINTS"></a> \(m\)  is  a  matrix  of  domain  elements  (in  algebraic  preﬁx  form)  with  as  many
 columns as the current base ring has ring variables. This procedure returns the
 deﬁning ideal of the collection of points in aﬃne space with coordinates given
 by the rows of \(m\). Note that \(m\) may contain parameters. In this case \(k\) is treated as
 rational function ﬁeld.
     </p></dd><dt class="description">
     <!--l. 2722--><p class="noindent" >
 </p></dt><dd 
class="description">
     <!--l. 2722--><p class="noindent" >
       </p><div class="syntax">
        <span 
class="pcrr8t-x-x-109">analytic_spread</span>\(\langle \)<span 
class="ptmri8t-x-x-109">m</span>\(\rangle \)</div>
<a 
 id="dx170-398006"></a>
                                                                     

                                                                     
     <!--l. 2727--><p class="noindent" ><a 
 id="operator:ANALYTIC_SPREAD"></a> Computes the analytic spread of \(m\).
     </p></dd><dt class="description">
     <!--l. 2730--><p class="noindent" >
 </p></dt><dd 
class="description">
     <!--l. 2730--><p class="noindent" >
       </p><div class="syntax">
        <span 
class="pcrr8t-x-x-109">annihilator</span>\(\langle \)<span 
class="ptmri8t-x-x-109">m</span>\(\rangle \)</div>
<a 
 id="dx170-398007"></a>
     <!--l. 2735--><p class="noindent" ><a 
 id="operator:ANNIHILATOR"></a> returns the annihilator of the dpmat \(m\subseteq S^c\), i.e. \(Ann\ S^c/M\).
     </p></dd><dt class="description">
     <!--l. 2739--><p class="noindent" >
 </p></dt><dd 
class="description">
     <!--l. 2739--><p class="noindent" >
       </p><div class="syntax">
        <span 
class="pcrr8t-x-x-109">assgrad</span>(\(\langle \)<span 
class="ptmri8t-x-x-109">M</span>\(\rangle \),\(\langle \)<span 
class="ptmri8t-x-x-109">N</span>\(\rangle \),\(\langle \)<span 
class="ptmri8t-x-x-109">vars</span>\(\rangle \))</div>
<a 
 id="dx170-398008"></a>
     <!--l. 2744--><p class="noindent" ><a 
 id="operator:ASSGRAD"></a> Computes the associated graded ring \(gr_R(N)\) over \(R=S/M\), where \(S\) is the current base ring.
 \(\langle \)<span 
class="ptmri8t-x-x-109">vars</span>\(\rangle \) is a list of new variable names, one for each generator of \(N\). They are used
 to create a second ring \(T\) to return an ideal \(J\) such that \((S\oplus T)/J\) is the desired associated
 graded ring over the new current base ring \(S\oplus T\).
     </p></dd><dt class="description">
     <!--l. 2752--><p class="noindent" >
 </p></dt><dd 
class="description">
     <!--l. 2752--><p class="noindent" >
       </p><div class="syntax">
        <span 
class="pcrr8t-x-x-109">bettiNumbers</span>\(\langle \)<span 
class="ptmri8t-x-x-109">gbr</span>\(\rangle \)</div>
<a 
 id="dx170-398009"></a>
     <!--l. 2757--><p class="noindent" ><a 
 id="operator:BETTINUMBERS"></a> extracts the list of Betti numbers from the resolution of \(gbr\).
                                                                     

                                                                     
     </p></dd><dt class="description">
     <!--l. 2760--><p class="noindent" >
 </p></dt><dd 
class="description">
     <!--l. 2760--><p class="noindent" >
       </p><div class="syntax">
        <span 
class="pcrr8t-x-x-109">blowup</span>(\(\langle \)<span 
class="ptmri8t-x-x-109">M</span>\(\rangle \),\(\langle \)<span 
class="ptmri8t-x-x-109">N</span>\(\rangle \),\(\langle \)<span 
class="ptmri8t-x-x-109">vars</span>\(\rangle \))</div>
<a 
 id="dx170-398010"></a>
     <!--l. 2765--><p class="noindent" ><a 
 id="operator:BLOWUP"></a> Computes the blow up \({\cal R}(N)\) of \(N\) over the ring \(R=S/M\), where \(S\) is the current base ring. <span 
class="pcrr8t-x-x-109">vars</span>
 is a list of new variable names, one for each generator of \(N\). They are used to
 create a second ring \(T\) to return an ideal \(J\) such that \((S\oplus T)/J\) is the desired blowup ring
 over the new current base ring \(S\oplus T\).
     </p></dd><dt class="description">
     <!--l. 2772--><p class="noindent" >
 </p></dt><dd 
class="description">
     <!--l. 2772--><p class="noindent" >
       </p><div class="syntax">
       <!--tex4ht:inline--><div class="tabular"> <table id="TBL-45" class="tabular" 
 
><colgroup id="TBL-45-1g"><col 
id="TBL-45-1" /><col 
id="TBL-45-2" /><col 
id="TBL-45-3" /></colgroup><tr  
 style="vertical-align:baseline;" id="TBL-45-1-"><td  style="white-space:nowrap; text-align:left;" id="TBL-45-1-1"  
class="td01"><span 
class="pcrr8t-x-x-109">change_termorder</span>(\(\langle \)<span 
class="ptmri8t-x-x-109">m</span>\(\rangle \),\(\langle \)<span 
class="ptmri8t-x-x-109">r</span>\(\rangle \)) </td>
</tr><tr  
 style="vertical-align:baseline;" id="TBL-45-2-"><td  style="white-space:nowrap; text-align:left;" id="TBL-45-2-1"  
class="td01"><div class="multicolumn"  style="white-space:nowrap; text-align:left;">and</div></td></tr><tr  
 style="vertical-align:baseline;" id="TBL-45-3-"><td  style="white-space:nowrap; text-align:left;" id="TBL-45-3-1"  
class="td01"><span 
class="pcrr8t-x-x-109">change_termorder1</span>(\(\langle \)<span 
class="ptmri8t-x-x-109">m</span>\(\rangle \),\(\langle \)<span 
class="ptmri8t-x-x-109">r</span>\(\rangle \))</td>
</tr></table></div></div>
<a 
 id="dx170-398011"></a>
<a 
 id="dx170-398012"></a>
     <!--l. 2780--><p class="noindent" ><a 
 id="operator:CHANGE_TERMORDER"></a> <a 
 id="operator:CHANGE_TERMORDER1"></a> Change the current ring to \(r\) and compute the Gröbner basis of \(m\) wrt. the new 
ring \(r\) by the FGLM approach. The former uses internally a precomputed border 
basis.
     </p></dd><dt class="description">
     <!--l. 2786--><p class="noindent" >
 </p></dt><dd 
class="description">
     <!--l. 2786--><p class="noindent" >
       </p><div class="syntax">
        <span 
class="pcrr8t-x-x-109">codim</span>\(\langle \)<span 
class="ptmri8t-x-x-109">gb</span>\(\rangle \)</div>
<a 
 id="dx170-398013"></a>
     <!--l. 2791--><p class="noindent" ><a 
 id="operator:CODIM"></a> returns the codimension of \(S^c/gb\).
                                                                     

                                                                     
     </p></dd><dt class="description">
     <!--l. 2794--><p class="noindent" >
 </p></dt><dd 
class="description">
     <!--l. 2794--><p class="noindent" >
       </p><div class="syntax">
        <span 
class="pcrr8t-x-x-109">degree</span>\(\langle \)<span 
class="ptmri8t-x-x-109">gb</span>\(\rangle \)</div>
<a 
 id="dx170-398014"></a>
     <!--l. 2799--><p class="noindent" ><a 
 id="operator:DEGREE"></a> returns  the  multiplicity  of  \(gb\)  as  the  sum  of  the  coeﬃcients  of  the  (classical)
 Hilbert series numerator.
     </p></dd><dt class="description">
     <!--l. 2803--><p class="noindent" >
 </p></dt><dd 
class="description">
     <!--l. 2803--><p class="noindent" >
       </p><div class="syntax">
        <span 
class="pcrr8t-x-x-109">degsfromresolution</span>\(\langle \)<span 
class="ptmri8t-x-x-109">gbr</span>\(\rangle \)</div>
<a 
 id="dx170-398015"></a>
     <!--l. 2808--><p class="noindent" ><a 
 id="operator:DEGSFROMRESOLUTION"></a> returns the list of column degrees from the minimal resolution of \(gbr\).
     </p></dd><dt class="description">
     <!--l. 2812--><p class="noindent" >
 </p></dt><dd 
class="description">
     <!--l. 2812--><p class="noindent" >
       </p><div class="syntax">
        <span 
class="pcrr8t-x-x-109">deleteunits</span>\(\langle \)<span 
class="ptmri8t-x-x-109">m</span>\(\rangle \)</div>
<a 
 id="dx170-398016"></a>
     <!--l. 2817--><p class="noindent" ><a 
 id="operator:DELETEUNITS"></a> factors each basis element of the dpmat ideal \(m\) and removes factors that are
 polynomial units. Applies only to non Noetherian term orders.
     </p></dd><dt class="description">
     <!--l. 2822--><p class="noindent" >
 </p></dt><dd 
class="description">
     <!--l. 2822--><p class="noindent" >
       </p><div class="syntax">
        <span 
class="pcrr8t-x-x-109">dim</span>\(\langle \)<span 
class="ptmri8t-x-x-109">gb</span>\(\rangle \)</div>
<a 
 id="dx170-398017"></a>
                                                                     

                                                                     
     <!--l. 2827--><p class="noindent" ><a 
 id="operator:DIM"></a> returns the dimension of \(S^c/gb\).
     </p></dd><dt class="description">
     <!--l. 2830--><p class="noindent" >
 </p></dt><dd 
class="description">
     <!--l. 2830--><p class="noindent" >
       </p><div class="syntax">
        <span 
class="pcrr8t-x-x-109">dimzerop</span>\(\langle \)<span 
class="ptmri8t-x-x-109">gb</span>\(\rangle \)</div>
<a 
 id="dx170-398018"></a>
     <!--l. 2835--><p class="noindent" ><a 
 id="operator:DIMZEROP"></a> tests whether \(S^c/gb\) is zerodimensional.
     </p></dd><dt class="description">
     <!--l. 2838--><p class="noindent" >
 </p></dt><dd 
class="description">
     <!--l. 2838--><p class="noindent" >
       </p><div class="syntax">
        <span 
class="pcrr8t-x-x-109">directsum</span>(\(\langle \)<span 
class="ptmri8t-x-x-109">m1</span>\(\rangle \),\(\langle \)<span 
class="ptmri8t-x-x-109">m2</span>\(\rangle \),…)</div>
<a 
 id="dx170-398019"></a>
     <!--l. 2843--><p class="noindent" ><a 
 id="operator:DIRECTSUM"></a> returns the direct sum of the modules \(m1,m2,\ldots \), embedded into the direct sum of the
 corresponding free modules.
     </p></dd><dt class="description">
     <!--l. 2847--><p class="noindent" >
 </p></dt><dd 
class="description">
     <!--l. 2847--><p class="noindent" >
       </p><div class="syntax">
        <span 
class="pcrr8t-x-x-109">dpgcd</span>(\(\langle \)<span 
class="ptmri8t-x-x-109">f</span> \(\rangle \),\(\langle \)<span 
class="ptmri8t-x-x-109">g</span>\(\rangle \))</div>
<a 
 id="dx170-398020"></a>
     <!--l. 2852--><p class="noindent" ><a 
 id="operator:DPGCD"></a> returns the gcd of two polynomials \(f\) and \(g\), computed by the syzygy method.
     </p></dd><dt class="description">
     <!--l. 2856--><p class="noindent" >
 </p></dt><dd 
class="description">
                                                                     

                                                                     
     <!--l. 2856--><p class="noindent" >
       </p><div class="syntax">
       <!--tex4ht:inline--><div class="tabular"> <table id="TBL-46" class="tabular" 
 
><colgroup id="TBL-46-1g"><col 
id="TBL-46-1" /><col 
id="TBL-46-2" /><col 
id="TBL-46-3" /></colgroup><tr  
 style="vertical-align:baseline;" id="TBL-46-1-"><td  style="white-space:nowrap; text-align:left;" id="TBL-46-1-1"  
class="td01"><span 
class="pcrr8t-x-x-109">easydim</span>\(\langle \)<span 
class="ptmri8t-x-x-109">m</span>\(\rangle \)           </td>
</tr><tr  
 style="vertical-align:baseline;" id="TBL-46-2-"><td  style="white-space:nowrap; text-align:left;" id="TBL-46-2-1"  
class="td01"><div class="multicolumn"  style="white-space:nowrap; text-align:left;">and</div></td></tr><tr  
 style="vertical-align:baseline;" id="TBL-46-3-"><td  style="white-space:nowrap; text-align:left;" id="TBL-46-3-1"  
class="td01"><span 
class="pcrr8t-x-x-109">easyindepset</span>\(\langle \)<span 
class="ptmri8t-x-x-109">m</span>\(\rangle \)</td>
</tr></table></div></div>
<a 
 id="dx170-398021"></a>
<a 
 id="dx170-398022"></a>
     <!--l. 2864--><p class="noindent" ><a 
 id="operator:EASYDIM"></a> <a 
 id="operator:EASYINDEPSET"></a> If the given ideal or module is unmixed (e.g. prime) then all maximal strongly 
independent  sets  are  of  equal  size  and  one  can  look  for  a  maximal  with 
respect to inclusion rather than size strongly independent set. These procedures 
don’t test the input for being a Gröbner basis or unmixed, but construct a 
maximal with respect to inclusion independent set of the basic leading terms 
resp. detect from this (an approximation for) the dimension.
     </p></dd><dt class="description">
     <!--l. 2874--><p class="noindent" >
 </p></dt><dd 
class="description">
     <!--l. 2874--><p class="noindent" >
       </p><div class="syntax">
        <span 
class="pcrr8t-x-x-109">easyprimarydecomposition</span>\(\langle \)<span 
class="ptmri8t-x-x-109">m</span>\(\rangle \)</div>
<a 
 id="dx170-398023"></a>
     <!--l. 2879--><p class="noindent" ><a 
 id="operator:EASYPRIMARYDECOMPOSITION"></a> a  short  primary  decomposition  using  ideal  separation  of  isolated  primes  of
 \(m\),  that  yields  true  results  only  for  modules  without  embedded  components.
 Returns a list of \(\{component, associated\prime\}\) pairs.
     </p></dd><dt class="description">
     <!--l. 2885--><p class="noindent" >
 </p></dt><dd 
class="description">
     <!--l. 2885--><p class="noindent" >
       </p><div class="syntax">
        <span 
class="pcrr8t-x-x-109">eliminate</span>(\(\langle \)<span 
class="ptmri8t-x-x-109">m</span>\(\rangle \),\(\langle \)<span 
class="ptmri8t-x-x-109">variable list</span>\(\rangle \))</div>
<a 
 id="dx170-398024"></a>
     <!--l. 2890--><p class="noindent" ><a 
 id="operator:ELIMINATE"></a> computes the elimination ideal/module eliminating the variables in the given
 variable  list  (a  subset  of  the  variables  of  the  current  base  ring).  Changes
 temporarily the term order to degrevlex.
     </p></dd><dt class="description">
     <!--l. 2895--><p class="noindent" >
 </p></dt><dd 
class="description">
                                                                     

                                                                     
     <!--l. 2895--><p class="noindent" >
       </p><div class="syntax">
        <span 
class="pcrr8t-x-x-109">eqhull</span>\(\langle \)<span 
class="ptmri8t-x-x-109">m</span>\(\rangle \)</div>
<a 
 id="dx170-398025"></a>
     <!--l. 2900--><p class="noindent" ><a 
 id="operator:EQHULL"></a> returns the equidimensional hull of the dpmat \(m\).
     </p></dd><dt class="description">
     <!--l. 2903--><p class="noindent" >
 </p></dt><dd 
class="description">
     <!--l. 2903--><p class="noindent" >
       </p><div class="syntax">
       <!--tex4ht:inline--><div class="tabular"> <table id="TBL-47" class="tabular" 
 
><colgroup id="TBL-47-1g"><col 
id="TBL-47-1" /><col 
id="TBL-47-2" /><col 
id="TBL-47-3" /></colgroup><tr  
 style="vertical-align:baseline;" id="TBL-47-1-"><td  style="white-space:nowrap; text-align:left;" id="TBL-47-1-1"  
class="td01"><span 
class="pcrr8t-x-x-109">extendedgroebfactor</span>(\(\langle \)<span 
class="ptmri8t-x-x-109">m</span>\(\rangle \),\(\langle \)<span 
class="ptmri8t-x-x-109">c</span>\(\rangle \)) </td>
</tr><tr  
 style="vertical-align:baseline;" id="TBL-47-2-"><td  style="white-space:nowrap; text-align:left;" id="TBL-47-2-1"  
class="td01"><div class="multicolumn"  style="white-space:nowrap; text-align:left;">and</div></td></tr><tr  
 style="vertical-align:baseline;" id="TBL-47-3-"><td  style="white-space:nowrap; text-align:left;" id="TBL-47-3-1"  
class="td01"><span 
class="pcrr8t-x-x-109">extendedgroebfactor1</span>(\(\langle \)<span 
class="ptmri8t-x-x-109">m</span>\(\rangle \),\(\langle \)<span 
class="ptmri8t-x-x-109">c</span>\(\rangle \))</td>
</tr></table></div></div>
<a 
 id="dx170-398026"></a>
<a 
 id="dx170-398027"></a>
     <!--l. 2911--><p class="noindent" ><a 
 id="operator:EXTENDEDGROEBFACTOR"></a> <a 
 id="operator:EXTENDEDGROEBFACTOR1"></a> return for a polynomial ideal \(m\) and a list of (polynomial) constraints \(c\) a list of 
results \(\{b_i,c_i,v_i\}\), where \(b_i\) is a triangular set wrt. the variables \(v_i\) and \(c_i\) is a list of constraints, 
such that \(Z(m,c) = \bigcup Z(b_i,c_i)\). For the ﬁrst version the output may be not minimal. The second 
version decides superﬂuous components already during the algorithm.
     </p></dd><dt class="description">
     <!--l. 2921--><p class="noindent" >
 </p></dt><dd 
class="description">
     <!--l. 2921--><p class="noindent" >
       </p><div class="syntax">
        <span 
class="pcrr8t-x-x-109">gbasis</span>\(\langle \)<span 
class="ptmri8t-x-x-109">gb</span>\(\rangle \)</div>
<a 
 id="dx170-398028"></a>
     <!--l. 2926--><p class="noindent" ><a 
 id="operator:GBASIS"></a> returns the Gröbner resp. local standard basis of \(gb\).
     </p></dd><dt class="description">
     <!--l. 2929--><p class="noindent" >
 </p></dt><dd 
class="description">
     <!--l. 2929--><p class="noindent" >
       </p><div class="syntax">
        <span 
class="pcrr8t-x-x-109">getkbase</span>\(\langle \)<span 
class="ptmri8t-x-x-109">gb</span>\(\rangle \)</div>
<a 
 id="dx170-398029"></a>
                                                                     

                                                                     
     <!--l. 2934--><p class="noindent" ><a 
 id="operator:GETKBASE"></a> returns a k-vector space basis of \(S^c/gb\), consisting of module terms, provided \(gb\) is
 zerodimensional.
     </p></dd><dt class="description">
     <!--l. 2938--><p class="noindent" >
 </p></dt><dd 
class="description">
     <!--l. 2938--><p class="noindent" >
       </p><div class="syntax">
        <span 
class="pcrr8t-x-x-109">getleadterms</span>\(\langle \)<span 
class="ptmri8t-x-x-109">gb</span>\(\rangle \)</div>
<a 
 id="dx170-398030"></a>
     <!--l. 2943--><p class="noindent" ><a 
 id="operator:GETLEADTERMS"></a> returns the dpmat of leading terms of a Gröbner resp. local standard basis of
 \(gb\).
     </p></dd><dt class="description">
     <!--l. 2947--><p class="noindent" >
 </p></dt><dd 
class="description">
     <!--l. 2947--><p class="noindent" >
       </p><div class="syntax">
        <span 
class="pcrr8t-x-x-109">GradedBettinumbers</span>\(\langle \)<span 
class="ptmri8t-x-x-109">gbr</span>\(\rangle \)</div>
<a 
 id="dx170-398031"></a>
     <!--l. 2952--><p class="noindent" ><a 
 id="operator:GRADEDBETTINUMBERS"></a> extracts the list of degree lists of the free summands in a minimal resolution of
 \(gbr\).
     </p></dd><dt class="description">
     <!--l. 2956--><p class="noindent" >
 </p></dt><dd 
class="description">
     <!--l. 2956--><p class="noindent" >
       </p><div class="syntax">
        <span 
class="pcrr8t-x-x-109">groebfactor </span>(\(\langle \)<span 
class="ptmri8t-x-x-109">m</span>\(\rangle \)[,\(\langle \)<span 
class="ptmri8t-x-x-109">c</span>\(\rangle \)])</div>
<a 
 id="dx170-398032"></a>
     <!--l. 2961--><p class="noindent" ><a 
 id="operator:GROEBFACTOR"></a> returns for the dpmat ideal \(m\) and an optional constraint list \(c\) a (reduced) list of
 dpmats such that the union of their zeroes is exactly \(Z(m,c)\). Factors all polynomials
 involved in the Gröbner algorithms of the partial results.
     </p></dd><dt class="description">
     <!--l. 2967--><p class="noindent" >
 </p></dt><dd 
class="description">
                                                                     

                                                                     
     <!--l. 2967--><p class="noindent" >
       </p><div class="syntax">
        <span 
class="pcrr8t-x-x-109">HilbertSeries</span>\(\langle \)<span 
class="ptmri8t-x-x-109">gb</span>\(\rangle \)</div>
<a 
 id="dx170-398033"></a>
     <!--l. 2972--><p class="noindent" ><a 
 id="operator:HILBERTSERIES"></a> returns the Hilbert series of \(gb\) with respect to the current ecart vector.
     </p></dd><dt class="description">
     <!--l. 2976--><p class="noindent" >
 </p></dt><dd 
class="description">
     <!--l. 2976--><p class="noindent" >
       </p><div class="syntax">
        <span 
class="pcrr8t-x-x-109">homstbasis</span>\(\langle \)<span 
class="ptmri8t-x-x-109">m</span>\(\rangle \)</div>
<a 
 id="dx170-398034"></a>
     <!--l. 2981--><p class="noindent" ><a 
 id="operator:HOMSTBASIS"></a> computes the standard basis of \(m\) by Lazard’s homogenization approach.
     </p></dd><dt class="description">
     <!--l. 2985--><p class="noindent" >
 </p></dt><dd 
class="description">
     <!--l. 2985--><p class="noindent" >
       </p><div class="syntax">
        <span 
class="pcrr8t-x-x-109">ideal2mat</span>\(\langle \)<span 
class="ptmri8t-x-x-109">m</span>\(\rangle \)</div>
<a 
 id="dx170-398035"></a>
     <!--l. 2990--><p class="noindent" ><a 
 id="operator:IDEAL2MAT"></a> converts the ideal (=list of polynomials) \(m\) into a column vector.
     </p></dd><dt class="description">
     <!--l. 2994--><p class="noindent" >
 </p></dt><dd 
class="description">
     <!--l. 2994--><p class="noindent" >
       </p><div class="syntax">
        <span 
class="pcrr8t-x-x-109">ideal_of_minors</span>(\(\langle \)<span 
class="ptmri8t-x-x-109">mat</span>\(\rangle \),\(\langle \)<span 
class="ptmri8t-x-x-109">k</span>\(\rangle \))</div>
<a 
 id="dx170-398036"></a>
     <!--l. 2999--><p class="noindent" ><a 
 id="operator:IDEAL_OF_MINORS"></a> computes the generators for the ideal of \(k\)-minors of the matrix \(mat\).
                                                                     

                                                                     
     </p></dd><dt class="description">
     <!--l. 3003--><p class="noindent" >
 </p></dt><dd 
class="description">
     <!--l. 3003--><p class="noindent" >
       </p><div class="syntax">
        <span 
class="pcrr8t-x-x-109">ideal_of_pfaffians</span>(\(\langle \)<span 
class="ptmri8t-x-x-109">mat</span>\(\rangle \),\(\langle \)<span 
class="ptmri8t-x-x-109">k</span>\(\rangle \))</div>
<a 
 id="dx170-398037"></a>
     <!--l. 3008--><p class="noindent" ><a 
 id="operator:IDEAL_OF_PFAFFIANS"></a> computes the generators for the ideal of the \(2k\)-pfaﬃans of the skewsymmetric
 matrix \(mat\).
     </p></dd><dt class="description">
     <!--l. 3012--><p class="noindent" >
 </p></dt><dd 
class="description">
     <!--l. 3012--><p class="noindent" >
       </p><div class="syntax">
        <span 
class="pcrr8t-x-x-109">idealpower</span>(\(\langle \)<span 
class="ptmri8t-x-x-109">m</span>\(\rangle \),\(\langle \)<span 
class="ptmri8t-x-x-109">n</span>\(\rangle \))</div>
<a 
 id="dx170-398038"></a>
     <!--l. 3017--><p class="noindent" ><a 
 id="operator:IDEALPOWER"></a> returns the interreduced basis of the ideal power \(m^n\) with respect to the integer \(n\geq 0\).
     </p></dd><dt class="description">
     <!--l. 3021--><p class="noindent" >
 </p></dt><dd 
class="description">
     <!--l. 3021--><p class="noindent" >
       </p><div class="syntax">
        <span 
class="pcrr8t-x-x-109">idealprod</span>(\(\langle \)<span 
class="ptmri8t-x-x-109">m1</span>\(\rangle \),\(\langle \)<span 
class="ptmri8t-x-x-109">m2</span>\(\rangle \),…)</div>
<a 
 id="dx170-398039"></a>
     <!--l. 3026--><p class="noindent" ><a 
 id="operator:IDEALPROD"></a> returns the interreduced basis of the ideal product \(m1\cdot m2\cdot \ldots \) of the ideals \(m1,m2,\ldots \).
     </p></dd><dt class="description">
     <!--l. 3030--><p class="noindent" >
 </p></dt><dd 
class="description">
     <!--l. 3030--><p class="noindent" >
       </p><div class="syntax">
        <span 
class="pcrr8t-x-x-109">idealquotient</span>(\(\langle \)<span 
class="ptmri8t-x-x-109">m1</span>\(\rangle \),\(\langle \)<span 
class="ptmri8t-x-x-109">m2</span>\(\rangle \))</div>
<a 
 id="dx170-398040"></a>
     <!--l. 3035--><p class="noindent" ><a 
 id="operator:CALI_IDEALQUOTIENT"></a> returns the ideal quotient \(m1:m2\) of the module \(m1\subseteq S^c\) by the ideal \(m2\).
                                                                     

                                                                     
     </p></dd><dt class="description">
     <!--l. 3039--><p class="noindent" >
 </p></dt><dd 
class="description">
     <!--l. 3039--><p class="noindent" >
       </p><div class="syntax">
        <span 
class="pcrr8t-x-x-109">idealsum</span>(\(\langle \)<span 
class="ptmri8t-x-x-109">m1</span>\(\rangle \),\(\langle \)<span 
class="ptmri8t-x-x-109">m2</span>\(\rangle \),…)</div>
<a 
 id="dx170-398041"></a>
     <!--l. 3044--><p class="noindent" ><a 
 id="operator:CALI_IDEALSUM"></a> returns the interreduced basis of the ideal sum \(m1+m2+\ldots \).
     </p></dd><dt class="description">
     <!--l. 3047--><p class="noindent" >
 </p></dt><dd 
class="description">
     <!--l. 3047--><p class="noindent" >
       </p><div class="syntax">
        <span 
class="pcrr8t-x-x-109">indepvarsets</span>\(\langle \)<span 
class="ptmri8t-x-x-109">gb</span>\(\rangle \)</div>
<a 
 id="dx170-398042"></a>
     <!--l. 3052--><p class="noindent" ><a 
 id="operator:INDEPVARSETS"></a> returns  the  list  of  strongly  independent  sets  of  \(gb\)  with  respect  to  the  current
 term order, see <span class="cite">[<a 
href="manualap2.html#XKredel:88a">KW88</a>]</span> for a deﬁnition in the case of ideals and <span class="cite">[<a 
href="manualap2.html#XGraebe:93a">Grä93</a>]</span> for
 submodules of free modules.
     </p></dd><dt class="description">
     <!--l. 3057--><p class="noindent" >
 </p></dt><dd 
class="description">
     <!--l. 3057--><p class="noindent" >
       </p><div class="syntax">
        <span 
class="pcrr8t-x-x-109">initmat</span>(\(\langle \)<span 
class="ptmri8t-x-x-109">m</span>\(\rangle \),\(\langle \)<span 
class="ptmri8t-x-x-109">ﬁlename</span>\(\rangle \))</div>
<a 
 id="dx170-398043"></a>
     <!--l. 3062--><p class="noindent" ><a 
 id="operator:INITMAT"></a> initializes the dpmat \(m\) together with its base ring, term order and column degrees
 from a ﬁle.
     </p></dd><dt class="description">
     <!--l. 3066--><p class="noindent" >
 </p></dt><dd 
class="description">
     <!--l. 3066--><p class="noindent" >
       </p><div class="syntax">
        <span 
class="pcrr8t-x-x-109">interreduce</span>\(\langle \)<span 
class="ptmri8t-x-x-109">m</span>\(\rangle \)</div>
<a 
 id="dx170-398044"></a>
                                                                     

                                                                     
     <!--l. 3071--><p class="noindent" ><a 
 id="operator:INTERREDUCE"></a> returns the interreduced module basis given by the rows of \(m\), i.e. a basis with
 pairwise indivisible leading terms.
     </p></dd><dt class="description">
     <!--l. 3075--><p class="noindent" >
 </p></dt><dd 
class="description">
     <!--l. 3075--><p class="noindent" >
       </p><div class="syntax">
        <span 
class="pcrr8t-x-x-109">isolatedprimes</span>\(\langle \)<span 
class="ptmri8t-x-x-109">m</span>\(\rangle \)</div>
<a 
 id="dx170-398045"></a>
     <!--l. 3080--><p class="noindent" ><a 
 id="operator:ISOLATEDPRIMES"></a> returns the list of isolated primes of the dpmat \(m\), i.e. the isolated primes of \(Ann\ S^c/M\).
     </p></dd><dt class="description">
     <!--l. 3084--><p class="noindent" >
 </p></dt><dd 
class="description">
     <!--l. 3084--><p class="noindent" >
       </p><div class="syntax">
        <span 
class="pcrr8t-x-x-109">isprime</span>\(\langle \)<span 
class="ptmri8t-x-x-109">gb</span>\(\rangle \)</div>
<a 
 id="dx170-398046"></a>
     <!--l. 3089--><p class="noindent" ><a 
 id="operator:ISPRIME"></a> tests the ideal \(gb\) to be prime.
     </p></dd><dt class="description">
     <!--l. 3092--><p class="noindent" >
 </p></dt><dd 
class="description">
     <!--l. 3092--><p class="noindent" >
       </p><div class="syntax">
        <span 
class="pcrr8t-x-x-109">iszeroradical</span>\(\langle \)<span 
class="ptmri8t-x-x-109">gb</span>\(\rangle \)</div>
<a 
 id="dx170-398047"></a>
     <!--l. 3097--><p class="noindent" ><a 
 id="operator:ISZERORADICAL"></a> tests the zerodimensional ideal \(gb\) to be radical.
     </p></dd><dt class="description">
     <!--l. 3100--><p class="noindent" >
 </p></dt><dd 
class="description">
                                                                     

                                                                     
     <!--l. 3100--><p class="noindent" >
       </p><div class="syntax">
        <span 
class="pcrr8t-x-x-109">lazystbasis</span>\(\langle \)<span 
class="ptmri8t-x-x-109">m</span>\(\rangle \)</div>
<a 
 id="dx170-398048"></a>
     <!--l. 3105--><p class="noindent" ><a 
 id="operator:LAZYSTBASIS"></a> computes the standard basis of \(m\) by the lazy algorithm, see e.g. <span class="cite">[<a 
href="manualap2.html#XMoraPfisterTraverso:92">MPT92</a>]</span>.
     </p></dd><dt class="description">
     <!--l. 3109--><p class="noindent" >
 </p></dt><dd 
class="description">
     <!--l. 3109--><p class="noindent" >
       </p><div class="syntax">
        <span 
class="pcrr8t-x-x-109">listgroebfactor</span>\(\langle \)<span 
class="ptmri8t-x-x-109">in</span>\(\rangle \)</div>
<a 
 id="dx170-398049"></a>
     <!--l. 3114--><p class="noindent" ><a 
 id="operator:LISTGROEBFACTOR"></a> computes for the list \(in\) of ideal bases a list \(out\) of Gröbner bases by the Gröbner
 factorization method, such that \(\bigcup _{m\in in}Z(m) = \bigcup _{m\in out}Z(m)\).
     </p></dd><dt class="description">
     <!--l. 3119--><p class="noindent" >
 </p></dt><dd 
class="description">
     <!--l. 3119--><p class="noindent" >
       </p><div class="syntax">
        <span 
class="pcrr8t-x-x-109">mat2list</span>\(\langle \)<span 
class="ptmri8t-x-x-109">m</span>\(\rangle \)</div>
<a 
 id="dx170-398050"></a>
     <!--l. 3124--><p class="noindent" ><a 
 id="operator:MAT2LIST"></a> converts the matrix \(m\) into a list of its entries.
     </p></dd><dt class="description">
     <!--l. 3127--><p class="noindent" >
 </p></dt><dd 
class="description">
     <!--l. 3127--><p class="noindent" >
       </p><div class="syntax">
        <span 
class="pcrr8t-x-x-109">matappend</span>(\(\langle \)<span 
class="ptmri8t-x-x-109">m1</span>\(\rangle \),\(\langle \)<span 
class="ptmri8t-x-x-109">m2</span>\(\rangle \),…)</div>
<a 
 id="dx170-398051"></a>
     <!--l. 3132--><p class="noindent" ><a 
 id="operator:MATAPPEND"></a> collects the rows of the dpmats \(m1,m2,\ldots \) to a common matrix. \(m1,m2,\ldots \) must be submodules of
 the same free module, i.e. have equal column degrees (and size).
                                                                     

                                                                     
     </p></dd><dt class="description">
     <!--l. 3137--><p class="noindent" >
 </p></dt><dd 
class="description">
     <!--l. 3137--><p class="noindent" >
       </p><div class="syntax">
        <span 
class="pcrr8t-x-x-109">mathomogenize</span>(\(\langle \)<span 
class="ptmri8t-x-x-109">m</span>\(\rangle \),\(\langle \)<span 
class="ptmri8t-x-x-109">var</span>\(\rangle \))<span class="footnote-mark"><a 
href="manual186.html#fn16x20"><sup class="textsuperscript">16</sup></a></span></div>
<a 
 id="dx170-398052"></a>
     <!--l. 3142--><p class="noindent" ><a 
 id="operator:MATHOMOGENIZE"></a> <a 
 id="x170-398053f16"></a> 
     returns the result obtained by homogenization of the rows of m with respect to
     the variable \(\langle \)<span 
class="ptmri8t-x-x-109">var</span>\(\rangle \) and the current <span 
class="ptmri8t-x-x-109">ecart vector</span><a 
 id="dx170-398054"></a>.
     </p></dd><dt class="description">
     <!--l. 3149--><p class="noindent" >
 </p></dt><dd 
class="description">
     <!--l. 3149--><p class="noindent" >
       </p><div class="syntax">
        <span 
class="pcrr8t-x-x-109">matintersect</span>(\(\langle \)<span 
class="ptmri8t-x-x-109">m1</span>\(\rangle \),\(\langle \)<span 
class="ptmri8t-x-x-109">m2</span>\(\rangle \),…)</div>
<a 
 id="dx170-398055"></a>
     <!--l. 3154--><p class="noindent" ><a 
 id="operator:MATINTERSECT"></a> returns the interreduced basis of the intersection \(m1\bigcap m2\bigcap \ldots \).
     </p></dd><dt class="description">
     <!--l. 3158--><p class="noindent" >
 </p></dt><dd 
class="description">
     <!--l. 3158--><p class="noindent" >
       </p><div class="syntax">
        <span 
class="pcrr8t-x-x-109">matjac</span>(\(\langle \)<span 
class="ptmri8t-x-x-109">m</span>\(\rangle \),\(\langle \)<span 
class="ptmri8t-x-x-109">variable list</span>\(\rangle \))</div>
<a 
 id="dx170-398056"></a>
     <!--l. 3163--><p class="noindent" ><a 
 id="operator:MATJAC"></a> returns the Jacobian matrix of the ideal m with respect to the supplied variable
 list
     </p></dd><dt class="description">
     <!--l. 3167--><p class="noindent" >
 </p></dt><dd 
class="description">
                                                                     

                                                                     
     <!--l. 3167--><p class="noindent" >
       </p><div class="syntax">
        <span 
class="pcrr8t-x-x-109">matqquot</span>(\(\langle \)<span 
class="ptmri8t-x-x-109">m</span>\(\rangle \),\(\langle \)<span 
class="ptmri8t-x-x-109">f</span> \(\rangle \))</div>
<a 
 id="dx170-398057"></a>
     <!--l. 3172--><p class="noindent" ><a 
 id="operator:MATQQUOT"></a> returns the stable quotient \(m:(f)^\infty \) of the dpmat \(m\) by the polynomial \(f\in S\).
     </p></dd><dt class="description">
     <!--l. 3176--><p class="noindent" >
 </p></dt><dd 
class="description">
     <!--l. 3176--><p class="noindent" >
       </p><div class="syntax">
        <span 
class="pcrr8t-x-x-109">matquot</span>(\(\langle \)<span 
class="ptmri8t-x-x-109">m</span>\(\rangle \),\(\langle \)<span 
class="ptmri8t-x-x-109">f</span> \(\rangle \))</div>
<a 
 id="dx170-398058"></a>
     <!--l. 3181--><p class="noindent" ><a 
 id="operator:MATQUOT"></a> returns the quotient \(m:(f)\) of the dpmat \(m\) by the polynomial \(f\in S\).
     </p></dd><dt class="description">
     <!--l. 3185--><p class="noindent" >
 </p></dt><dd 
class="description">
     <!--l. 3185--><p class="noindent" >
       </p><div class="syntax">
        <span 
class="pcrr8t-x-x-109">matstabquot</span>(\(\langle \)<span 
class="ptmri8t-x-x-109">m1</span>\(\rangle \),\(\langle \)<span 
class="ptmri8t-x-x-109">id</span>\(\rangle \))</div>
<a 
 id="dx170-398059"></a>
     <!--l. 3190--><p class="noindent" ><a 
 id="operator:MATSTABQUOT"></a> returns the stable quotient \(m1:id^\infty \) of the dpmat \(m1\) by the ideal \(id\).
     </p></dd><dt class="description">
     <!--l. 3194--><p class="noindent" >
 </p></dt><dd 
class="description">
     <!--l. 3194--><p class="noindent" >
       </p><div class="syntax">
        <span 
class="pcrr8t-x-x-109">matsum</span>(\(\langle \)<span 
class="ptmri8t-x-x-109">m1</span>\(\rangle \),\(\langle \)<span 
class="ptmri8t-x-x-109">m2</span>\(\rangle \),…)</div>
<a 
 id="dx170-398060"></a>
     <!--l. 3199--><p class="noindent" ><a 
 id="operator:MATSUM"></a> returns the interreduced basis of the module sum \(m1+m2+\ldots \) in a common free module.
                                                                     

                                                                     
     </p></dd><dt class="description">
     <!--l. 3203--><p class="noindent" >
 </p></dt><dd 
class="description">
     <!--l. 3203--><p class="noindent" >
       </p><div class="syntax">
        <span 
class="pcrr8t-x-x-109">minimal_generators</span>\(\langle \)<span 
class="ptmri8t-x-x-109">m</span>\(\rangle \)</div>
<a 
 id="dx170-398061"></a>
     <!--l. 3208--><p class="noindent" ><a 
 id="operator:MINIMAL_GENERATORS"></a> returns a set of minimal generators of the dpmat \(m\).
     </p></dd><dt class="description">
     <!--l. 3211--><p class="noindent" >
 </p></dt><dd 
class="description">
     <!--l. 3211--><p class="noindent" >
       </p><div class="syntax">
        <span 
class="pcrr8t-x-x-109">minors</span>(\(\langle \)<span 
class="ptmri8t-x-x-109">m</span>\(\rangle \),\(\langle \)<span 
class="ptmri8t-x-x-109">n</span>\(\rangle \))</div>
<a 
 id="dx170-398062"></a>
     <!--l. 3216--><p class="noindent" ><a 
 id="operator:MINORS"></a> returns the matrix of minors of size \(b\times b\) of the matrix \(m\).
     </p></dd><dt class="description">
     <!--l. 3220--><p class="noindent" >
 </p></dt><dd 
class="description">
     <!--l. 3220--><p class="noindent" >
       </p><div class="syntax">
        \(\langle \)<span 
class="ptmri8t-x-x-109">a</span>\(\rangle \) <span 
class="pcrr8t-x-x-109">mod</span>\(\langle \)<span 
class="ptmri8t-x-x-109">b</span>\(\rangle \)</div>
<a 
 id="dx170-398063"></a>
     <!--l. 3225--><p class="noindent" ><a 
 id="operator:CALI_MOD"></a> computes the (true) normal form(s), i.e. a standard quotient representation, of
 \(a\) modulo the dpmat \(m\). \(a\) may be either a polynomial or a polynomial list (\(c=0\)) or a
 matrix (\(c&gt;0\)) of the correct number of columns.
     </p></dd><dt class="description">
     <!--l. 3231--><p class="noindent" >
 </p></dt><dd 
class="description">
     <!--l. 3231--><p class="noindent" >
       </p><div class="syntax">
        <span 
class="pcrr8t-x-x-109">modequalp</span>(\(\langle \)<span 
class="ptmri8t-x-x-109">gb1</span>\(\rangle \),\(\langle \)<span 
class="ptmri8t-x-x-109">gb2</span>\(\rangle \))</div>
<a 
 id="dx170-398064"></a>
                                                                     

                                                                     
     <!--l. 3236--><p class="noindent" ><a 
 id="operator:MODEQUALP"></a> tests, whether \(gb1\) and \(gb2\) are equal (returns YES or NO).
     </p></dd><dt class="description">
     <!--l. 3239--><p class="noindent" >
 </p></dt><dd 
class="description">
     <!--l. 3239--><p class="noindent" >
       </p><div class="syntax">
        <span 
class="pcrr8t-x-x-109">modulequotient</span>(\(\langle \)<span 
class="ptmri8t-x-x-109">m1</span>\(\rangle \),\(\langle \)<span 
class="ptmri8t-x-x-109">m2</span>\(\rangle \))</div>
<a 
 id="dx170-398065"></a>
     <!--l. 3244--><p class="noindent" ><a 
 id="operator:MODULEQUOTIENT"></a> returns the module quotient \(m1:m2\) of two dpmats \(m1,m2\) in a common free module.
     </p></dd><dt class="description">
     <!--l. 3248--><p class="noindent" >
 </p></dt><dd 
class="description">
     <!--l. 3248--><p class="noindent" >
       </p><div class="syntax">
        <span 
class="pcrr8t-x-x-109">normalform</span>(\(\langle \)<span 
class="ptmri8t-x-x-109">m1</span>\(\rangle \),\(\langle \)<span 
class="ptmri8t-x-x-109">m2</span>\(\rangle \))</div>
<a 
 id="dx170-398066"></a>
     <!--l. 3253--><p class="noindent" ><a 
 id="operator:NORMALFORM"></a> returns a list of three dpmats \(\{m3,r,z\}\), where \(m3\) is the normalform of \(m1\) modulo \(m2\), \(z\) a scalar
 matrix of polynomial units (i.e. polynomials of degree 0 in the noetherian case
 and polynomials with leading term of degree 0 in the tangent cone case), and \(r\)
 the relation matrix, such that \[m3=z*m1+r*m2.\]
     </p></dd><dt class="description">
     <!--l. 3260--><p class="noindent" >
 </p></dt><dd 
class="description">
     <!--l. 3260--><p class="noindent" >
       </p><div class="syntax">
        <span 
class="pcrr8t-x-x-109">nzdp</span>(\(\langle \)<span 
class="ptmri8t-x-x-109">f</span> \(\rangle \),\(\langle \)<span 
class="ptmri8t-x-x-109">m</span>\(\rangle \))</div>
<a 
 id="dx170-398067"></a>
     <!--l. 3265--><p class="noindent" ><a 
 id="operator:NZDP"></a> tests whether the dpoly \(f\) is a non zero divisor on \(\mathop {\mathrm {coker}} m\).
                                                                     

                                                                     
     </p></dd><dt class="description">
     <!--l. 3269--><p class="noindent" >
 </p></dt><dd 
class="description">
     <!--l. 3269--><p class="noindent" >
       </p><div class="syntax">
        <span 
class="pcrr8t-x-x-109">pfaffian</span>\(\langle \)<span 
class="ptmri8t-x-x-109">mat</span>\(\rangle \)</div>
<a 
 id="dx170-398068"></a>
     <!--l. 3274--><p class="noindent" ><a 
 id="operator:PFAFFIAN"></a> returns the pfaﬃan of a skewsymmetric matrix \(mat\).
     </p></dd><dt class="description">
     <!--l. 3277--><p class="noindent" >
 </p></dt><dd 
class="description">
     <!--l. 3277--><p class="noindent" >
       </p><div class="syntax">
        <span 
class="pcrr8t-x-x-109">preimage</span>(\(\langle \)<span 
class="ptmri8t-x-x-109">m</span>\(\rangle \),\(\langle \)<span 
class="ptmri8t-x-x-109">map</span>\(\rangle \))</div>
<a 
 id="dx170-398069"></a>
     <!--l. 3282--><p class="noindent" ><a 
 id="operator:PREIMAGE"></a> computes the preimage of the ideal \(m\) under the given polynomial map and sets
 the current base ring to the preimage ring.
     </p></dd><dt class="description">
     <!--l. 3286--><p class="noindent" >
 </p></dt><dd 
class="description">
     <!--l. 3286--><p class="noindent" >
       </p><div class="syntax">
        <span 
class="pcrr8t-x-x-109">primarydecomposition</span>\(\langle \)<span 
class="ptmri8t-x-x-109">m</span>\(\rangle \)</div>
<a 
 id="dx170-398070"></a>
     <!--l. 3291--><p class="noindent" ><a 
 id="operator:PRIMARYDECOMPOSITION"></a> returns the primary decomposition of the dpmat \(m\) as a list of \(\{component, associated\ prime\}\) pairs.
     </p></dd><dt class="description">
     <!--l. 3295--><p class="noindent" >
 </p></dt><dd 
class="description">
     <!--l. 3295--><p class="noindent" >
       </p><div class="syntax">
        <span 
class="pcrr8t-x-x-109">proj_monomial_curve</span>(\(\langle \)<span 
class="ptmri8t-x-x-109">l</span>\(\rangle \),\(\langle \)<span 
class="ptmri8t-x-x-109">vars</span>\(\rangle \))</div>
<a 
 id="dx170-398071"></a>
                                                                     

                                                                     
     <!--l. 3300--><p class="noindent" ><a 
 id="operator:PROJ_MONOMIAL_CURVE"></a> \(l\)  is  a  list  of  integers,  \(vars\)  a  list  of  variable  names  of  the  same  length  as  \(l\).  The
 procedure  sets  the  current  base  ring  and  returns  the  deﬁning  ideal  of  the
 projective monomial curve with generic point \((s^{d-i}\cdot t^i\ :\ i\in l)\) in \(R\) where \(d=max\{ x\, :\, x\in l\}\).
     </p></dd><dt class="description">
     <!--l. 3307--><p class="noindent" >
 </p></dt><dd 
class="description">
     <!--l. 3307--><p class="noindent" >
       </p><div class="syntax">
        <span 
class="pcrr8t-x-x-109">proj_points</span>\(\langle \)<span 
class="ptmri8t-x-x-109">m</span>\(\rangle \)</div>
<a 
 id="dx170-398072"></a>
     <!--l. 3312--><p class="noindent" ><a 
 id="operator:PROJ_POINTS"></a> \(m\)  is  a  matrix  of  domain  elements  (in  algebraic  preﬁx  form)  with  as  many
 columns as the current base ring has ring variables. This procedure returns the
 deﬁning ideal of the collection of points in projective space with homogeneous
 coordinates given by the rows of \(m\). Note that \(m\) may as for <span 
class="pcrr8t-x-x-109">affine_points</span>
 contain parameters.
     </p></dd><dt class="description">
     <!--l. 3320--><p class="noindent" >
 </p></dt><dd 
class="description">
     <!--l. 3320--><p class="noindent" >
       </p><div class="syntax">
        <span 
class="pcrr8t-x-x-109">radical</span>\(\langle \)<span 
class="ptmri8t-x-x-109">m</span>\(\rangle \)</div>
<a 
 id="dx170-398073"></a>
     <!--l. 3325--><p class="noindent" ><a 
 id="operator:RADICAL"></a> returns the radical of the dpmat ideal \(m\).
     </p></dd><dt class="description">
     <!--l. 3328--><p class="noindent" >
 </p></dt><dd 
class="description">
     <!--l. 3328--><p class="noindent" >
       </p><div class="syntax">
        <span 
class="pcrr8t-x-x-109">random_linear_form</span>(\(\langle \)<span 
class="ptmri8t-x-x-109">vars</span>\(\rangle \),\(\langle \)<span 
class="ptmri8t-x-x-109">bound</span>\(\rangle \))</div>
<a 
 id="dx170-398074"></a>
     <!--l. 3333--><p class="noindent" ><a 
 id="operator:RANDOM_LINEAR_FORM"></a> returns a random linear form in the variables \(\langle \)<span 
class="ptmri8t-x-x-109">vars</span>\(\rangle \) with integer coeﬃcients less
 than the supplied <span 
class="pcrr8t-x-x-109">bound</span>.
                                                                     

                                                                     
     </p></dd><dt class="description">
     <!--l. 3337--><p class="noindent" >
 </p></dt><dd 
class="description">
     <!--l. 3337--><p class="noindent" >
       </p><div class="syntax">
        <span 
class="pcrr8t-x-x-109">ratpreimage</span>(\(\langle \)<span 
class="ptmri8t-x-x-109">m</span>\(\rangle \),\(\langle \)<span 
class="ptmri8t-x-x-109">map</span>\(\rangle \))</div>
<a 
 id="dx170-398075"></a>
     <!--l. 3342--><p class="noindent" ><a 
 id="operator:RATPREIMAGE"></a> computes the closure of the preimage of the ideal \(m\) under the given rational map
 and sets the current base ring to the preimage ring.
     </p></dd><dt class="description">
     <!--l. 3347--><p class="noindent" >
 </p></dt><dd 
class="description">
     <!--l. 3347--><p class="noindent" >
       </p><div class="syntax">
        <span 
class="pcrr8t-x-x-109">resolve</span>(\(\langle \)<span 
class="ptmri8t-x-x-109">m</span>\(\rangle \)[,\(\langle \)<span 
class="ptmri8t-x-x-109">d</span>\(\rangle \)])</div>
<a 
 id="dx170-398076"></a>
     <!--l. 3352--><p class="noindent" ><a 
 id="operator:RESOLVE"></a> returns the ﬁrst \(d\) members of the minimal resolution of the bounded identiﬁer
 \(m\) as a list of matrices. If the resolution has less than \(d\) non zero members, only
 those are collected. (Default: \(d=100\))
     </p></dd><dt class="description">
     <!--l. 3358--><p class="noindent" >
 </p></dt><dd 
class="description">
     <!--l. 3358--><p class="noindent" >
       </p><div class="syntax">
        <span 
class="pcrr8t-x-x-109">savemat</span>(\(\langle \)<span 
class="ptmri8t-x-x-109">m</span>\(\rangle \),\(\langle \)<span 
class="ptmri8t-x-x-109">ﬁle name</span>\(\rangle \))</div>
<a 
 id="dx170-398077"></a>
     <!--l. 3363--><p class="noindent" ><a 
 id="operator:SAVEMAT"></a> save the dpmat \(m\) together with the settings of it base ring, term order and column
 degrees to a ﬁle.
     </p></dd><dt class="description">
     <!--l. 3367--><p class="noindent" >
 </p></dt><dd 
class="description">
     <!--l. 3367--><p class="noindent" >
       </p><div class="syntax">
        <span 
class="pcrr8t-x-x-109">setgbasis</span>\(\langle \)<span 
class="ptmri8t-x-x-109">m</span>\(\rangle \)</div>
<a 
 id="dx170-398078"></a>
                                                                     

                                                                     
     <!--l. 3372--><p class="noindent" ><a 
 id="operator:SETGBASIS"></a> declares the rows of the bounded identiﬁer \(m\) to be already a Gröbner resp. local
 standard basis thus avoiding a possibly time consuming Gröbner or standard
 basis computation.
     </p></dd><dt class="description">
     <!--l. 3377--><p class="noindent" >
 </p></dt><dd 
class="description">
     <!--l. 3377--><p class="noindent" >
       </p><div class="syntax">
        <span 
class="pcrr8t-x-x-109">sive</span>(\(\langle \)<span 
class="ptmri8t-x-x-109">m</span>\(\rangle \),\(\langle \)<span 
class="ptmri8t-x-x-109">variable list</span>\(\rangle \))</div>
<a 
 id="dx170-398079"></a>
     <!--l. 3382--><p class="noindent" ><a 
 id="operator:SIEVE"></a> sieves out all base elements with leading terms having a factor contained in
 the speciﬁed variable list (a subset of the variables of the current base ring).
 Useful for elimination problems solved “by hand”.
     </p></dd><dt class="description">
     <!--l. 3388--><p class="noindent" >
 </p></dt><dd 
class="description">
     <!--l. 3388--><p class="noindent" >
       </p><div class="syntax">
        <span 
class="pcrr8t-x-x-109">singular_locus</span>(\(\langle \)<span 
class="ptmri8t-x-x-109">M</span>\(\rangle \),\(\langle \)<span 
class="ptmri8t-x-x-109">c</span>\(\rangle \))</div>
<a 
 id="dx170-398080"></a>
     <!--l. 3393--><p class="noindent" ><a 
 id="operator:SINGULAR_LOCUS"></a> returns  the  deﬁning  ideal  of  the  singular  locus  of  \(Spec\ S/M\)  where  \(M\)  is  an  ideal  of
 codimension  \(c\),  adding  to  \(M\)  the  generators  of  the  ideal  of  the  \(c\)-minors  of  the
 Jacobian of \(M\).
     </p></dd><dt class="description">
     <!--l. 3398--><p class="noindent" >
 </p></dt><dd 
class="description">
     <!--l. 3398--><p class="noindent" >
       </p><div class="syntax">
        <span 
class="pcrr8t-x-x-109">submodulep</span>(\(\langle \)<span 
class="ptmri8t-x-x-109">m</span>\(\rangle \),\(\langle \)<span 
class="ptmri8t-x-x-109">gb</span>\(\rangle \))</div>
<a 
 id="dx170-398081"></a>
     <!--l. 3403--><p class="noindent" ><a 
 id="operator:SUBMODULEP"></a> tests, whether \(m\) is a submodule of \(gb\) (returns YES or NO).
                                                                     

                                                                     
     </p></dd><dt class="description">
     <!--l. 3406--><p class="noindent" >
 </p></dt><dd 
class="description">
     <!--l. 3406--><p class="noindent" >
       </p><div class="syntax">
        <span 
class="pcrr8t-x-x-109">sym</span>(\(\langle \)<span 
class="ptmri8t-x-x-109">M</span>\(\rangle \),\(\langle \)<span 
class="ptmri8t-x-x-109">vars</span>\(\rangle \))</div>
<a 
 id="dx170-398082"></a>
     <!--l. 3411--><p class="noindent" ><a 
 id="operator:SYM"></a> Computes the symmetric algebra \(Sym(M)\) where \(M\) is an ideal deﬁned over the current
 base ring \(S\). \(\langle \)<span 
class="ptmri8t-x-x-109">vars</span>\(\rangle \) is a list of new variable names, one for each generator of \(M\). They
 are used to create a second ring \(R\) to return an ideal \(J\) such that \((S\oplus R)/J\) is the desired
 symmetric algebra over the new current base ring \(S\oplus R\).
     </p></dd><dt class="description">
     <!--l. 3419--><p class="noindent" >
 </p></dt><dd 
class="description">
     <!--l. 3419--><p class="noindent" >
       </p><div class="syntax">
        <span 
class="pcrr8t-x-x-109">symbolic_power</span>(\(\langle \)<span 
class="ptmri8t-x-x-109">m</span>\(\rangle \),\(\langle \)<span 
class="ptmri8t-x-x-109">d</span>\(\rangle \))</div>
<a 
 id="dx170-398083"></a>
     <!--l. 3424--><p class="noindent" ><a 
 id="operator:SYMBOLIC_POWER"></a> returns the \(d\)th symbolic power of the prime dpmat ideal \(m\).
     </p></dd><dt class="description">
     <!--l. 3427--><p class="noindent" >
 </p></dt><dd 
class="description">
     <!--l. 3427--><p class="noindent" >
       </p><div class="syntax">
        <span 
class="pcrr8t-x-x-109">syzygies</span>\(\langle \)<span 
class="ptmri8t-x-x-109">m</span>\(\rangle \)</div>
<a 
 id="dx170-398084"></a>
     <!--l. 3432--><p class="noindent" ><a 
 id="operator:SYZYGIES"></a> returns the ﬁrst syzygy module of the bounded identiﬁer \(m\).
     </p></dd><dt class="description">
     <!--l. 3435--><p class="noindent" >
 </p></dt><dd 
class="description">
     <!--l. 3435--><p class="noindent" >
       </p><div class="syntax">
        <span 
class="pcrr8t-x-x-109">tangentcone</span>\(\langle \)<span 
class="ptmri8t-x-x-109">gb</span>\(\rangle \)</div>
<a 
 id="dx170-398085"></a>
                                                                     

                                                                     
     <!--l. 3440--><p class="noindent" ><a 
 id="operator:TANGENTCONE"></a> returns the tangent cone part, i.e. the homogeneous part of highest degree with
 respect to the ﬁrst degree vector of the term order from the Gröbner basis
 elements of the dpmat \(gb\). The term order must be a degree order.
     </p></dd><dt class="description">
     <!--l. 3446--><p class="noindent" >
 </p></dt><dd 
class="description">
     <!--l. 3446--><p class="noindent" >
       </p><div class="syntax">
        <span 
class="pcrr8t-x-x-109">unmixedradical</span>\(\langle \)<span 
class="ptmri8t-x-x-109">m</span>\(\rangle \)</div>
<a 
 id="dx170-398086"></a>
     <!--l. 3451--><p class="noindent" ><a 
 id="operator:UNMIXEDRADICAL"></a> returns the unmixed radical of the dpmat ideal \(m\).
     </p></dd><dt class="description">
     <!--l. 3454--><p class="noindent" >
 </p></dt><dd 
class="description">
     <!--l. 3454--><p class="noindent" >
       </p><div class="syntax">
        <span 
class="pcrr8t-x-x-109">varopt</span>\(\langle \)<span 
class="ptmri8t-x-x-109">m</span>\(\rangle \)</div>
<a 
 id="dx170-398087"></a>
     <!--l. 3459--><p class="noindent" ><a 
 id="operator:VAROPT"></a> ﬁnds a heuristically optimal variable order, see <span class="cite">[<a 
href="manualap2.html#XBoege:86">BGK86</a>]</span>.
          </p><blockquote class="quote">
          <!--l. 3465--><p class="noindent" ><span 
class="pcrr8t-x-x-109">vars:=varopt m; setring(vars,{},lex);</span>
    <span 
class="pcrr8t-x-x-109">setideal(m,m);</span></p></blockquote>
<!--l. 3465--><p class="noindent" >changes to the lexicographic term order with heuristically best performance for a
 lexicographic Gröbner basis computation.
     </p></dd><dt class="description">
     <!--l. 3467--><p class="noindent" >
 </p></dt><dd 
class="description">
     <!--l. 3467--><p class="noindent" >
       </p><div class="syntax">
        <span 
class="pcrr8t-x-x-109">WeightedHilbertSeries</span>(\(\langle \)<span 
class="ptmri8t-x-x-109">m</span>\(\rangle \),\(\langle \)<span 
class="ptmri8t-x-x-109">w</span>\(\rangle \))</div>
<a 
 id="dx170-398088"></a>
     <!--l. 3472--><p class="noindent" ><a 
 id="operator:WEIGHTEDHILBERTSERIES"></a> returns the weighted Hilbert series of the dpmat \(m\). Note that \(m\) is not a bounded
 identiﬁer and hence not checked to be a Gröbner basis. \(w\) is a list of integer
 weight vectors.
                                                                     

                                                                     
     </p></dd><dt class="description">
     <!--l. 3477--><p class="noindent" >
 </p></dt><dd 
class="description">
     <!--l. 3477--><p class="noindent" >
       </p><div class="syntax">
        <span 
class="pcrr8t-x-x-109">zeroprimarydecomposition</span>\(\langle \)<span 
class="ptmri8t-x-x-109">m</span>\(\rangle \)</div>
<a 
 id="dx170-398089"></a>
     <!--l. 3482--><p class="noindent" ><a 
 id="operator:ZEROPRIMARYDECOMPOSITION"></a> returns the primary decomposition of the zerodimensional dpmat \(m\) as a list of \(\{component, associated\ prime\}\)
 pairs.
     </p></dd><dt class="description">
     <!--l. 3486--><p class="noindent" >
 </p></dt><dd 
class="description">
     <!--l. 3486--><p class="noindent" >
       </p><div class="syntax">
        <span 
class="pcrr8t-x-x-109">zeroprimes</span>\(\langle \)<span 
class="ptmri8t-x-x-109">m</span>\(\rangle \)</div>
<a 
 id="dx170-398090"></a>
     <!--l. 3491--><p class="noindent" ><a 
 id="operator:ZEROPRIMES"></a> returns the list of primes of the zerodimensional dpmat \(m\).
     </p></dd><dt class="description">
     <!--l. 3494--><p class="noindent" >
 </p></dt><dd 
class="description">
     <!--l. 3494--><p class="noindent" >
       </p><div class="syntax">
        <span 
class="pcrr8t-x-x-109">zeroradical</span>\(\langle \)<span 
class="ptmri8t-x-x-109">gb</span>\(\rangle \)</div>
<a 
 id="dx170-398091"></a>
     <!--l. 3499--><p class="noindent" ><a 
 id="operator:ZERORADICAL"></a> returns the radical of the zerodimensional ideal \(gb\).
     </p></dd><dt class="description">
     <!--l. 3502--><p class="noindent" >
 </p></dt><dd 
class="description">
     <!--l. 3502--><p class="noindent" >
       </p><div class="syntax">
       <!--tex4ht:inline--><div class="tabular"> <table id="TBL-48" class="tabular" 
 
><colgroup id="TBL-48-1g"><col 
id="TBL-48-1" /><col 
id="TBL-48-2" /><col 
id="TBL-48-3" /></colgroup><tr  
 style="vertical-align:baseline;" id="TBL-48-1-"><td  style="white-space:nowrap; text-align:left;" id="TBL-48-1-1"  
class="td01"><span 
class="pcrr8t-x-x-109">zerosolve</span>\(\langle \)<span 
class="ptmri8t-x-x-109">m</span>\(\rangle \) </td></tr><tr  
 style="vertical-align:baseline;" id="TBL-48-2-"><td  style="white-space:nowrap; text-align:left;" id="TBL-48-2-1"  
class="td01"><div class="multicolumn"  style="white-space:nowrap; text-align:left;">and</div>
</td></tr><tr  
 style="vertical-align:baseline;" id="TBL-48-3-"><td  style="white-space:nowrap; text-align:left;" id="TBL-48-3-1"  
class="td01"><span 
class="pcrr8t-x-x-109">zerosolve1</span>\(\langle \)<span 
class="ptmri8t-x-x-109">m</span>\(\rangle \)</td></tr><tr  
 style="vertical-align:baseline;" id="TBL-48-4-"><td  style="white-space:nowrap; text-align:left;" id="TBL-48-4-1"  
class="td01"><div class="multicolumn"  style="white-space:nowrap; text-align:left;">and</div>
</td></tr><tr  
 style="vertical-align:baseline;" id="TBL-48-5-"><td  style="white-space:nowrap; text-align:left;" id="TBL-48-5-1"  
class="td01"><span 
class="pcrr8t-x-x-109">zerosolve2</span>\(\langle \)<span 
class="ptmri8t-x-x-109">m</span>\(\rangle \)</td></tr></table>
                                                                     

                                                                     
       </div></div>
<a 
 id="dx170-398092"></a>
<a 
 id="dx170-398093"></a>
<a 
 id="dx170-398094"></a>
     <!--l. 3513--><p class="noindent" ><a 
 id="operator:ZEROSOLVE"></a> <a 
 id="operator:ZEROSOLVE1"></a> <a 
 id="operator:ZEROSOLVE2"></a> Returns  for  a  zerodimensional  ideal  a  list  of  triangular  systems  that  cover
 \(Z(m)\).  <span 
class="pcrr8t-x-x-109">zerosolve </span>needs  a  pure  lex. term  order  for  the  “fast”  turn  to  lex. as
 described in <span class="cite">[<a 
href="manualap2.html#XMoeller:93">M<span class='accentuml'>9</span>3</a>]</span>, <span 
class="pcrr8t-x-x-109">zerosolve1 </span>is the “slow” turn to lex. as described in
 <span class="cite">[<a 
href="manualap2.html#XGraebe:95b">Grä95b</a>]</span>, and <span 
class="pcrr8t-x-x-109">zerosolve2 </span>incorporated the FGLM term order change into
 <span 
class="pcrr8t-x-x-109">zerosolve1</span>.</p></dd></dl>
                                                                     

                                                                     
<h4 class="subsectionHead"><span class="titlemark">20.7.6    </span> <a 
 id="x170-39900020.7.6"></a>The <span 
class="ptmrc8t-x-x-109">C<span 
class="small-caps">A</span><span 
class="small-caps">L</span><span 
class="small-caps">I</span> </span>Module Structure</h4>
<div class="tabular"> <table id="TBL-49" class="tabular" 
 
><colgroup id="TBL-49-1g"><col 
id="TBL-49-1" /></colgroup><colgroup id="TBL-49-2g"><col 
id="TBL-49-2" /></colgroup><colgroup id="TBL-49-3g"><col 
id="TBL-49-3" /></colgroup><colgroup id="TBL-49-4g"><col 
id="TBL-49-4" /></colgroup><tr 
class="hline"><td><hr /></td><td><hr /></td><td><hr /></td><td><hr /></td></tr><tr  
 style="vertical-align:baseline;" id="TBL-49-1-"><td  style="white-space:normal; text-align:left;" id="TBL-49-1-1"  
class="td11"><!--l. 3532--><p class="noindent" >name       </p></td><td  style="white-space:normal; text-align:left;" id="TBL-49-1-2"  
class="td11"><!--l. 3532--><p class="noindent" >subject                                              </p></td><td  style="white-space:normal; text-align:left;" id="TBL-49-1-3"  
class="td11"><!--l. 3532--><p class="noindent" >data type      </p></td><td  style="white-space:normal; text-align:left;" id="TBL-49-1-4"  
class="td11"><!--l. 3532--><p class="noindent" >representation                   </p></td>
</tr><tr 
class="hline"><td><hr /></td><td><hr /></td><td><hr /></td><td><hr /></td></tr><tr  
 style="vertical-align:baseline;" id="TBL-49-2-"><td  style="white-space:normal; text-align:left;" id="TBL-49-2-1"  
class="td11"><!--l. 3535--><p class="noindent" >cali           </p></td><td  style="white-space:normal; text-align:left;" id="TBL-49-2-2"  
class="td11"><!--l. 3535--><p class="noindent" >Header          module,          contains
global variables, switches etc.         </p></td><td  style="white-space:normal; text-align:left;" id="TBL-49-2-3"  
class="td11"><!--l. 3536--><p class="noindent" >—                 </p></td><td  style="white-space:normal; text-align:left;" id="TBL-49-2-4"  
class="td11"><!--l. 3536--><p class="noindent" >—                                      </p></td>
</tr><tr  
 style="vertical-align:baseline;" id="TBL-49-3-"><td  style="white-space:normal; text-align:left;" id="TBL-49-3-1"  
class="td11"><!--l. 3538--><p class="noindent" >bcsf          </p></td><td  style="white-space:normal; text-align:left;" id="TBL-49-3-2"  
class="td11"><!--l. 3538--><p class="noindent" >Base coeﬃcient arithmetic              </p></td><td  style="white-space:normal; text-align:left;" id="TBL-49-3-3"  
class="td11"><!--l. 3538--><p class="noindent" >base coeﬀ.    </p></td><td  style="white-space:normal; text-align:left;" id="TBL-49-3-4"  
class="td11"><!--l. 3538--><p class="noindent" >standard forms                  </p></td></tr><tr  
 style="vertical-align:baseline;" id="TBL-49-4-"><td  style="white-space:normal; text-align:left;" id="TBL-49-4-1"  
class="td11"><!--l. 3540--><p class="noindent" >ring </p> </td><td  style="white-space:normal; text-align:left;" id="TBL-49-4-2"  
class="td11"><!--l. 3540--><p class="noindent" >Base ring setting, deﬁnition of the
term order                                        </p></td><td  style="white-space:normal; text-align:left;" id="TBL-49-4-3"  
class="td11"><!--l. 3540--><p class="noindent" >base ring      </p></td><td  style="white-space:normal; text-align:left;" id="TBL-49-4-4"  
class="td11"><!--l. 3541--><p class="noindent" >special type RING            </p></td>
</tr><tr  
 style="vertical-align:baseline;" id="TBL-49-5-"><td  style="white-space:normal; text-align:left;" id="TBL-49-5-1"  
class="td11"><!--l. 3543--><p class="noindent" >mo           </p></td><td  style="white-space:normal; text-align:left;" id="TBL-49-5-2"  
class="td11"><!--l. 3543--><p class="noindent" >monomial arithmetic                        </p></td><td  style="white-space:normal; text-align:left;" id="TBL-49-5-3"  
class="td11"><!--l. 3543--><p class="noindent" >monomials   </p></td><td  style="white-space:normal; text-align:left;" id="TBL-49-5-4"  
class="td11"><!--l. 3543--><p class="noindent" >(exp. list . degree list)       </p></td>
</tr><tr  
 style="vertical-align:baseline;" id="TBL-49-6-"><td  style="white-space:normal; text-align:left;" id="TBL-49-6-1"  
class="td11"><!--l. 3545--><p class="noindent" >dpoly       </p></td><td  style="white-space:normal; text-align:left;" id="TBL-49-6-2"  
class="td11"><!--l. 3545--><p class="noindent" >Polynomial and vector arithmetic    </p></td><td  style="white-space:normal; text-align:left;" id="TBL-49-6-3"  
class="td11"><!--l. 3545--><p class="noindent" >dpolys          </p></td><td  style="white-space:normal; text-align:left;" id="TBL-49-6-4"  
class="td11"><!--l. 3545--><p class="noindent" >list of terms                      </p></td>
</tr><tr  
 style="vertical-align:baseline;" id="TBL-49-7-"><td  style="white-space:normal; text-align:left;" id="TBL-49-7-1"  
class="td11"><!--l. 3547--><p class="noindent" >bas           </p></td><td  style="white-space:normal; text-align:left;" id="TBL-49-7-2"  
class="td11"><!--l. 3547--><p class="noindent" >Operations on base lists                   </p></td><td  style="white-space:normal; text-align:left;" id="TBL-49-7-3"  
class="td11"><!--l. 3547--><p class="noindent" >base list        </p></td><td  style="white-space:normal; text-align:left;" id="TBL-49-7-4"  
class="td11"><!--l. 3547--><p class="noindent" >list of base elements         </p></td>
</tr><tr  
 style="vertical-align:baseline;" id="TBL-49-8-"><td  style="white-space:normal; text-align:left;" id="TBL-49-8-1"  
class="td11"><!--l. 3549--><p class="noindent" >dpmat       </p></td><td  style="white-space:normal; text-align:left;" id="TBL-49-8-2"  
class="td11"><!--l. 3549--><p class="noindent" >Operations on polynomial matrices,
the central data type of <span 
class="ptmrc8t-x-x-109">C<span 
class="small-caps">A</span><span 
class="small-caps">L</span><span 
class="small-caps">I</span></span>           </p></td><td  style="white-space:normal; text-align:left;" id="TBL-49-8-3"  
class="td11"><!--l. 3550--><p class="noindent" >dpmat           </p></td><td  style="white-space:normal; text-align:left;" id="TBL-49-8-4"  
class="td11"><!--l. 3550--><p class="noindent" >special type DPMAT        </p></td>
</tr><tr  
 style="vertical-align:baseline;" id="TBL-49-9-"><td  style="white-space:normal; text-align:left;" id="TBL-49-9-1"  
class="td11"><!--l. 3552--><p class="noindent" >red           </p></td><td  style="white-space:normal; text-align:left;" id="TBL-49-9-2"  
class="td11"><!--l. 3552--><p class="noindent" >Normal form algorithms                  </p></td><td  style="white-space:normal; text-align:left;" id="TBL-49-9-3"  
class="td11"><!--l. 3552--><p class="noindent" >—                 </p></td><td  style="white-space:normal; text-align:left;" id="TBL-49-9-4"  
class="td11"><!--l. 3552--><p class="noindent" >—                                      </p></td>
</tr><tr  
 style="vertical-align:baseline;" id="TBL-49-10-"><td  style="white-space:normal; text-align:left;" id="TBL-49-10-1"  
class="td11"><!--l. 3554--><p class="noindent" >groeb       </p></td><td  style="white-space:normal; text-align:left;" id="TBL-49-10-2"  
class="td11"><!--l. 3554--><p class="noindent" >Gröbner    basis    algorithm    and
related ones                                      </p></td><td  style="white-space:normal; text-align:left;" id="TBL-49-10-3"  
class="td11"><!--l. 3554--><p class="noindent" >—                 </p></td><td  style="white-space:normal; text-align:left;" id="TBL-49-10-4"  
class="td11"><!--l. 3554--><p class="noindent" >—                                      </p></td>
</tr><tr  
 style="vertical-align:baseline;" id="TBL-49-11-"><td  style="white-space:normal; text-align:left;" id="TBL-49-11-1"  
class="td11"><!--l. 3556--><p class="noindent" >groebf      </p></td><td  style="white-space:normal; text-align:left;" id="TBL-49-11-2"  
class="td11"><!--l. 3556--><p class="noindent" >the   Gröbner   factorizer   and   its
extensions                                        </p></td><td  style="white-space:normal; text-align:left;" id="TBL-49-11-3"  
class="td11"><!--l. 3556--><p class="noindent" >—                 </p></td><td  style="white-space:normal; text-align:left;" id="TBL-49-11-4"  
class="td11"><!--l. 3556--><p class="noindent" >—                                      </p></td>
</tr><tr  
 style="vertical-align:baseline;" id="TBL-49-12-"><td  style="white-space:normal; text-align:left;" id="TBL-49-12-1"  
class="td11"><!--l. 3558--><p class="noindent" >matop       </p></td><td  style="white-space:normal; text-align:left;" id="TBL-49-12-2"  
class="td11"><!--l. 3558--><p class="noindent" >Operations        on        (lists        of)
dpmats      that      correspond      to
ideal/module operations                   </p></td><td  style="white-space:normal; text-align:left;" id="TBL-49-12-3"  
class="td11"><!--l. 3559--><p class="noindent" >—                 </p></td><td  style="white-space:normal; text-align:left;" id="TBL-49-12-4"  
class="td11"><!--l. 3559--><p class="noindent" >—                                      </p></td>
</tr><tr  
 style="vertical-align:baseline;" id="TBL-49-13-"><td  style="white-space:normal; text-align:left;" id="TBL-49-13-1"  
class="td11"><!--l. 3561--><p class="noindent" >quot         </p></td><td  style="white-space:normal; text-align:left;" id="TBL-49-13-2"  
class="td11"><!--l. 3561--><p class="noindent" >Diﬀerent quotient algorithms          </p></td><td  style="white-space:normal; text-align:left;" id="TBL-49-13-3"  
class="td11"><!--l. 3561--><p class="noindent" >—                 </p></td><td  style="white-space:normal; text-align:left;" id="TBL-49-13-4"  
class="td11"><!--l. 3561--><p class="noindent" >—                                      </p></td>
</tr><tr  
 style="vertical-align:baseline;" id="TBL-49-14-"><td  style="white-space:normal; text-align:left;" id="TBL-49-14-1"  
class="td11"><!--l. 3563--><p class="noindent" >moid        </p></td><td  style="white-space:normal; text-align:left;" id="TBL-49-14-2"  
class="td11"><!--l. 3563--><p class="noindent" >Monomial ideal algorithms              </p></td><td  style="white-space:normal; text-align:left;" id="TBL-49-14-3"  
class="td11"><!--l. 3563--><p class="noindent" >monomial
ideal             </p></td><td  style="white-space:normal; text-align:left;" id="TBL-49-14-4"  
class="td11"><!--l. 3563--><p class="noindent" >list of monomials              </p></td>
</tr><tr  
 style="vertical-align:baseline;" id="TBL-49-15-"><td  style="white-space:normal; text-align:left;" id="TBL-49-15-1"  
class="td11"><!--l. 3565--><p class="noindent" >hf             </p></td><td  style="white-space:normal; text-align:left;" id="TBL-49-15-2"  
class="td11"><!--l. 3565--><p class="noindent" >weighted Hilbert series                    </p></td><td  style="white-space:normal; text-align:left;" id="TBL-49-15-3"  
class="td11"><!--l. 3565--><p class="noindent" >–                   </p></td><td  style="white-space:normal; text-align:left;" id="TBL-49-15-4"  
class="td11"><!--l. 3565--><p class="noindent" >–                                        </p></td>
</tr><tr  
 style="vertical-align:baseline;" id="TBL-49-16-"><td  style="white-space:normal; text-align:left;" id="TBL-49-16-1"  
class="td11"><!--l. 3567--><p class="noindent" >res            </p></td><td  style="white-space:normal; text-align:left;" id="TBL-49-16-2"  
class="td11"><!--l. 3567--><p class="noindent" >Resolutions of dpmats                     </p></td><td  style="white-space:normal; text-align:left;" id="TBL-49-16-3"  
class="td11"><!--l. 3567--><p class="noindent" >resolution     </p></td><td  style="white-space:normal; text-align:left;" id="TBL-49-16-4"  
class="td11"><!--l. 3567--><p class="noindent" >list of dpmats                    </p></td>
</tr><tr  
 style="vertical-align:baseline;" id="TBL-49-17-"><td  style="white-space:normal; text-align:left;" id="TBL-49-17-1"  
class="td11"><!--l. 3569--><p class="noindent" >intf           </p></td><td  style="white-space:normal; text-align:left;" id="TBL-49-17-2"  
class="td11"><!--l. 3569--><p class="noindent" >Interface to algebraic mode             </p></td><td  style="white-space:normal; text-align:left;" id="TBL-49-17-3"  
class="td11"><!--l. 3569--><p class="noindent" >—                 </p></td><td  style="white-space:normal; text-align:left;" id="TBL-49-17-4"  
class="td11"><!--l. 3569--><p class="noindent" >—                                      </p></td>
</tr><tr  
 style="vertical-align:baseline;" id="TBL-49-18-"><td  style="white-space:normal; text-align:left;" id="TBL-49-18-1"  
class="td11"><!--l. 3571--><p class="noindent" >odim        </p></td><td  style="white-space:normal; text-align:left;" id="TBL-49-18-2"  
class="td11"><!--l. 3571--><p class="noindent" >Algorithms    for    zerodimensional
ideals and modules                           </p></td><td  style="white-space:normal; text-align:left;" id="TBL-49-18-3"  
class="td11"><!--l. 3571--><p class="noindent" >—                 </p></td><td  style="white-space:normal; text-align:left;" id="TBL-49-18-4"  
class="td11"><!--l. 3571--><p class="noindent" >—                                      </p></td>
</tr><tr  
 style="vertical-align:baseline;" id="TBL-49-19-"><td  style="white-space:normal; text-align:left;" id="TBL-49-19-1"  
class="td11"><!--l. 3573--><p class="noindent" >prime       </p></td><td  style="white-space:normal; text-align:left;" id="TBL-49-19-2"  
class="td11"><!--l. 3573--><p class="noindent" >Primary decomposition and related
questions                                          </p></td><td  style="white-space:normal; text-align:left;" id="TBL-49-19-3"  
class="td11"><!--l. 3573--><p class="noindent" >—                 </p></td><td  style="white-space:normal; text-align:left;" id="TBL-49-19-4"  
class="td11"><!--l. 3573--><p class="noindent" >—                                      </p></td>
</tr><tr  
 style="vertical-align:baseline;" id="TBL-49-20-"><td  style="white-space:normal; text-align:left;" id="TBL-49-20-1"  
class="td11"><!--l. 3575--><p class="noindent" >scripts      </p></td><td  style="white-space:normal; text-align:left;" id="TBL-49-20-2"  
class="td11"><!--l. 3575--><p class="noindent" >Advanced applications                     </p></td><td  style="white-space:normal; text-align:left;" id="TBL-49-20-3"  
class="td11"><!--l. 3575--><p class="noindent" >—                 </p></td><td  style="white-space:normal; text-align:left;" id="TBL-49-20-4"  
class="td11"><!--l. 3575--><p class="noindent" >—                                      </p></td>
</tr><tr  
 style="vertical-align:baseline;" id="TBL-49-21-"><td  style="white-space:normal; text-align:left;" id="TBL-49-21-1"  
class="td11"><!--l. 3577--><p class="noindent" >calimat     </p></td><td  style="white-space:normal; text-align:left;" id="TBL-49-21-2"  
class="td11"><!--l. 3577--><p class="noindent" >Extension of the matrix package     </p></td><td  style="white-space:normal; text-align:left;" id="TBL-49-21-3"  
class="td11"><!--l. 3577--><p class="noindent" >—                 </p></td><td  style="white-space:normal; text-align:left;" id="TBL-49-21-4"  
class="td11"><!--l. 3577--><p class="noindent" >—                                      </p></td>
</tr><tr  
 style="vertical-align:baseline;" id="TBL-49-22-"><td  style="white-space:normal; text-align:left;" id="TBL-49-22-1"  
class="td11"><!--l. 3579--><p class="noindent" >lf              </p></td><td  style="white-space:normal; text-align:left;" id="TBL-49-22-2"  
class="td11"><!--l. 3579--><p class="noindent" >The dual bases approach                  </p></td><td  style="white-space:normal; text-align:left;" id="TBL-49-22-3"  
class="td11"><!--l. 3579--><p class="noindent" >—                 </p></td><td  style="white-space:normal; text-align:left;" id="TBL-49-22-4"  
class="td11"><!--l. 3579--><p class="noindent" >—                                      </p></td>
</tr><tr  
 style="vertical-align:baseline;" id="TBL-49-23-"><td  style="white-space:normal; text-align:left;" id="TBL-49-23-1"  
class="td11"><!--l. 3581--><p class="noindent" >triang       </p></td><td  style="white-space:normal; text-align:left;" id="TBL-49-23-2"  
class="td11"><!--l. 3581--><p class="noindent" >(Zero      dimensional)      triangular
systems                                            </p></td><td  style="white-space:normal; text-align:left;" id="TBL-49-23-3"  
class="td11"><!--l. 3581--><p class="noindent" >—                 </p></td><td  style="white-space:normal; text-align:left;" id="TBL-49-23-4"  
class="td11"><!--l. 3581--><p class="noindent" >—                                      </p></td>
</tr><tr 
class="hline"><td><hr /></td><td><hr /></td><td><hr /></td><td><hr /></td></tr><tr  
 style="vertical-align:baseline;" id="TBL-49-24-"><td  style="white-space:normal; text-align:left;" id="TBL-49-24-1"  
class="td11">       </td>
</tr></table></div>
<!--l. 195--><p class="noindent" >
                                                                     

                                                                     
                                                                     

                                                                     
</p><!--l. 197--><p class="noindent" ><table cellspacing="5"><tr><td class="clinks"><a 
href="../manual-lookup.php%3FUser&#32;Contributed&#32;Packages.html#manualse130.html" >Up</a></td><td class="clinks"><a 
href="manualse131.html" >Next</a></td><td class="clinks"><a 
href="manualse129.html" >Prev</a></td><td class="clinks"><a 
href="manualse129.html#tailmanualse129.html" >PrevTail</a></td><td class="clinks"><a 
href="manualse130.html" >Front</a></td></tr></table><a 
 id="tailmanualse130.html"></a>  <hr> <p style="font-family:sans-serif">Hosted by <a href="https://sourceforge.net/p/reduce-algebra/"> <img title="Download REDUCE" alt="Download REDUCE" style="vertical-align:middle" src="https://sourceforge.net/sflogo.php?type=16&amp;group_id=248416"/></a> <a href="https://www.mathjax.org"> <img title="Powered by MathJax" alt="Powered by MathJax" style="float:right" src="https://www.mathjax.org/badge/badge.gif"/></a></p></p> 
</body> 
</html>