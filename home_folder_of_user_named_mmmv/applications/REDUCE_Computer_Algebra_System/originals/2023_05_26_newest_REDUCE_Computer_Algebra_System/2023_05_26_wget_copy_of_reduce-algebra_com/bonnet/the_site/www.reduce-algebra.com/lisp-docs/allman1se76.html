<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"  
  "http://www.w3.org/TR/html4/loose.dtd">  
<html > 
<head><title>Scanalyzer</title> 
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1"> 
<meta name="generator" content="TeX4ht (http://www.cse.ohio-state.edu/~gurari/TeX4ht/)"> 
<meta name="originator" content="TeX4ht (http://www.cse.ohio-state.edu/~gurari/TeX4ht/)"> 
<!-- 3,html --> 
<meta name="src" content="allman1.tex"> 
<meta name="date" content="2014-05-02 18:10:00"> 
<link rel="stylesheet" type="text/css" href="allman1.css"> 
</head><body 
>
<p align="centre"><img src="http://www.reduce-algebra.com/lisp-docs/redlogo.png" width=621 height=60 border=0 alt="REDUCE"></p><table cellspacing="5"><tr><td class="clinks"><a 
href="allman1li16.html#allman1se76.html" >Up</a></td><td class="clinks"><a 
href="allman1se75.html" >Prev</a></td><td class="clinks"><a 
href="allman1se75.html#tailallman1se75.html" >PrevTail</a></td><td class="clinks"><a 
href="allman1se76.html#tailallman1se76.html">Tail</a></td></tr></table><h3 class="sectionHead"><span class="titlemark">17.2    </span> <a 
 id="x95-18400017.2"></a>Scanalyzer</h3>
<!--l. 196--><p class="noindent" >
<h4 class="subsectionHead"><span class="titlemark">17.2.1    </span> <a 
 id="x95-18500017.2.1"></a>Introduction</h4>
<!--l. 198--><p class="noindent" >The scanalyzer module is a tool for analyzing PSL functions, expressions, and source files. It
makes it easy to analyze PSL code and to write preprocessors for PSL. It supports
preprocessing of PSL code in much the way that macroexpand does, but is more flexible and
extensible. The scanalyzer understands the various PSL function types, including
macros, and has some understanding of each of the PSL special forms. Scanalyzer
lives in SCANALYZER.SL, some support functions (including scanalyze-file) live in
XREF-SUPPORT.SL.
<!--l. 208--><p class="noindent" >Apologies to John Brunner, author of &#8221;Stand on Zanzibar&#8221;, for the name of this facility.
<!--l. 211--><p class="noindent" >
<h4 class="subsectionHead"><span class="titlemark">17.2.2    </span> <a 
 id="x95-18600017.2.2"></a>Philosophy</h4>
<!--l. 213--><p class="noindent" >The meaning of a piece of LISP code can depend a great deal on the context in which it is
compiled or evaluated. Virtually everything in a LISP system can change dynamically, and
analyzing the meaning of code in the right context is a significant problem.
<!--l. 219--><p class="noindent" >This facility focuses on analysis of code that is compiled, and it does so for two reasons. One is
that most large systems written in PSL run compiled. The other is that once LISP code is
compiled, the meaning of the object code is much more static than the meaning of the
corresponding interpretive code.
<!--l. 225--><p class="noindent" >Reliable system operation depends on modules being compiled in an environment that is known
and fixed as much as possible. To do this, we compile each module with a compiler that is
started afresh. After one module has been compiled we do not compile other modules with the
same compiler.
<!--l. 231--><p class="noindent" >To precisely analyze a module, we can start a compiler. To it we add the analysis facility, which
should not change the compilation context. We then analyze the module, just as we would
compile it. The analysis facility must be sensitive to the same contextual information that the
compiler is.
<!--l. 237--><p class="noindent" >Many modules have some side-effects on the context of compilation &#8211; defining a macro is just
one of the things that affects compilation context. To be sure that a module is analyzed in the
right context, the analysis should have the same side-effects on compilation context as the
compilation would have.
<!--l. 244--><p class="noindent" >
<h4 class="subsectionHead"><span class="titlemark">17.2.3    </span> <a 
 id="x95-18700017.2.3"></a>Functions</h4>

<!--l. 272--><p class="noindent" ><div class="minipage"><a 
 id="dx95-187001"></a>
<span 
class="ptmb7t-x-x-120">(scanalyze-file INPUT-FILE:string, pathname</span><br 
class="newline" /><span 
class="ptmb7t-x-x-120">OUTPUT-FILE:string, pathname): string                                                                </span><span 
class="ptmri7t-x-x-120">expr</span>
<br 
class="newline" /><div class="minipage">Applies the function scanalyze-form (defined in section 2.3.3) to every form
in  input-file.  Scanalyze-file  assumes  that  information  accumulates  in  the
list xref-assertions. After all the forms have been analyzed, scanalyze-file
dumps all the assertions into output-file as a list (reversing the list first). The
assertion (<span 
class="cmmi-12">&#x003C; input</span><span 
class="cmsy-10x-x-120">-</span><span 
class="cmmi-12">file &#x003E; </span>IS-SOURCE-FILE) is added to the front of the
assertion list.
<!--l. 272--><p class="noindent" >File name defaulting: As its arguments scanalyze-file accepts both filename
strings  and  pathnames.  In  any  case  the  output-file  argument  is  defaulted
from  the  input-file  argument.  Any  missing  components  of  the  name  in
output-file are defaulted using the function merge-pathname-defaults to be
the  same  as  in  input-file,  except  for  the  file  type  (suffix).  If  that  is  not
specified in output-file it is set to &#8221;.XD&#8221;, which is the tentative standard for
Xref-Databases.
<!--l. 272--><p class="noindent" >For   example,   in   the   call   (scanalyze-file   &#8221;pk:load.sl&#8221;   &#8221;mydir:&#8221;),   the
output  filename  generated  is  &#8221;mydir:load.xd&#8221;.  In  the  call  (scanalyze-file
&#8221;#5:/pslroot/foo/test.sl&#8221; &#8221;mydir:test-out.dat&#8221;, the output filename generated
is &#8221;mydir:test-out.dat&#8221;.</div>
</div>
<!--l. 280--><p class="noindent" ><div class="minipage"><a 
 id="dx95-187002"></a>
<span 
class="ptmb7t-x-x-120">(scanalyze-form FORM:form): form                                                                         </span><span 
class="ptmri7t-x-x-120">expr</span>
<br 
class="newline" /><div class="minipage">This expects an s-expression as its argument and analyzes it as a top-level
form in a source file. By recognizing which forms would be evaluated at
compile-time, load-time, or at both times, this keeps the context for analysis
the same as the context would be for compilation. Those forms that would
be compiled are passed to the function Scanalyze.</div>
</div>
<!--l. 282--><p class="noindent" >Scanalyze-Form recognizes forms such as compiletime bothtimes, and loadtime. It evaluates
each at compiletime if the compiler would and analyzes each if the compiler would
compile it. Actually, it recognizes the IGNORE and EVAL flags used internally by the
compiler. This means that if analysis is started in the same context as a compilation,
during analysis macros are defined in the same way in both cases, as are wconsts, if
systems expand the same way, the same &#8221;compiletime-loaded&#8221; modules are loaded, etc..
In PSL this means that the analysis context very closely matches the compilation
context.

<!--l. 302--><p class="noindent" ><div class="minipage"><a 
 id="dx95-187003"></a>
<span 
class="ptmb7t-x-x-120">(scanalyze FORM:form ENV:form): form                                                                </span><span 
class="ptmri7t-x-x-120">expr</span>
<br 
class="newline" /><div class="minipage">Analyzes the given form (s-expression) in the given environment. The value
returned  depends  on  whether  the  caller  has  set  up  values  for  functional
variables or properties that this function is sensitive to. If the caller has set
up no special actions, the value returned should be the same that the function
MACROEXPAND would return.</div></div>
<h4 class="subsectionHead"><span class="titlemark">17.2.4    </span> <a 
 id="x95-18800017.2.4"></a>Environment Arguments</h4>
<!--l. 305--><p class="noindent" >The caller can set up special actions that are in two categories. These are &#8221;analysis hooks&#8221; and
&#8221;preprocessing hooks&#8221;.
<!--l. 309--><p class="noindent" >The ENV arguments to various things are environments. An environment is currently a list of
&#8221;frames&#8221;. Each frame is a list of 2 elements. The first identifies the type of frame, currently
always &#8217;LOCALS. The second is the &#8221;contents&#8221;, for locals a list of the local variable
names.
<!--l. 315--><p class="noindent" >
<h4 class="subsectionHead"><span class="titlemark">17.2.5    </span> <a 
 id="x95-18900017.2.5"></a>Analysis Hooks</h4>
<!--l. 317--><p class="noindent" >The scanalyzer defines a number of variables that the user may give functional values to. Some
support the user of this module in analyzing code. Others provide the means to preprocess or
transform code. The hooks are functional variables of 2 args (expression and environment) to
attach an analysis function to. Each of these must either be NIL or a list of functions. The first
three of these hooks are called before any preprocessing or expansion of the form is
done; the last is called after all preprocessing and expansion of a form is complete.
Scan-Macro-Hooks Called before each macro is expanded. Scan-Fn-Hooks Called before
descending into any expr to analyze it. Scan-Non-Pair-Hooks Called with each non-pair
examined.
<!--l. 330--><p class="noindent" >After-Expansion-Hooks Called with each fully expanded expression. Not applied to forms such
as macro calls, because they are expanded further before being returned.
<!--l. 336--><p class="noindent" >
<h4 class="subsectionHead"><span class="titlemark">17.2.6    </span> <a 
 id="x95-19000017.2.6"></a>Properties</h4>
<!--l. 338--><p class="noindent" >These are checked respectively before and after an expression has been expanded. After
expansion means that the call has been expanded until it is not a macro call, and all
subexpressions have been expanded also. If the car of an expression is an id that has the
appropriate property, each member of the list that is the property value will be funcalled. These
properties are checked at the same points where the scan-xxx hooks are checked.
Thus it is of no use to give a macro a post-expand-scanners property. The properties
are:
<!--l. 348--><p class="noindent" >- Pre-Expand-Scanners
<!--l. 350--><p class="noindent" >- Post-Expand-Scanners

<!--l. 352--><p class="noindent" >Pre-expand-scanners take precedence over scan-macro-hooks and scan-fn-hooks.
<!--l. 355--><p class="noindent" >
<h4 class="subsectionHead"><span class="titlemark">17.2.7    </span> <a 
 id="x95-19100017.2.7"></a>Information Made Available By Scanalyzer</h4>
<!--l. 357--><p class="noindent" >Current-Function This has the name of the current function where that can be determined. Forms
such as DE and DEFUN that expand into calls on PUTD with constant function names cause
this to be rebound inside analysis of the function body argument.
<!--l. 362--><p class="noindent" >Current-Top-Level-Form Contains the argument that was passed to the call on scanalyze-form
currently being executed.
<!--l. 365--><p class="noindent" >Top-Level-Code? Is T for expressions not nested in any invocation of the function FUNCTION.
Expressions for which this variable is T are known to be performed at initialization
time.
<!--l. 370--><p class="noindent" >
<h4 class="subsectionHead"><span class="titlemark">17.2.8    </span> <a 
 id="x95-19200017.2.8"></a>Expansion And Preprocessing Hooks</h4>
<!--l. 372--><p class="noindent" >Special-Expander Should be a functional variable of 2 arguments when set to a non-NIL value.
If it is, and if the similar functional value of expand-specially? is non-NIL, the special-expander
function will be used to expand the form.
<!--l. 377--><p class="noindent" >Expand-Specially? If non-NIL, we use special-expander to expand the form. Non-Pair-Expander
Either NIL or a functional value of 2 arguments used to expand expressions that are
&#8221;atomic&#8221;.
<!--l. 382--><p class="noindent" >If any function or macro, etc.has an Expr-Expander property, its value must be a 2
argument function that scans and expands expressions whose first element is that id.
This module provides several such functions so that built-in special forms can be
analyzed.
<!--l. 388--><p class="noindent" >Special-Expander and Non-Pair-Expander have first priority. Then comes any Expr-Expander
property. Then normal processing by type of function.
<!--l. 392--><p class="noindent" >
<h4 class="subsectionHead"><span class="titlemark">17.2.9    </span> <a 
 id="x95-19300017.2.9"></a>Cross Reference Support</h4>
<!--l. 394--><p class="noindent" >The fluid xref-assertions holds the assertions generated by xref-assert and xref-assert-list,
dumped out to a file by scanalyze-file.
<!--l. 400--><p class="noindent" ><div class="minipage"><a 
 id="dx95-193001"></a>
<span 
class="ptmb7t-x-x-120">(xref-assert A:assertion): assertion                                                                            </span><span 
class="ptmri7t-x-x-120">expr</span>
<br 
class="newline" /><div class="minipage">
</div></div><div class="minipage"><a 
 id="dx95-193002"></a>
<span 
class="ptmb7t-x-x-120">(xref-assert-list L:list): assertion-list                                                                          </span><span 
class="ptmri7t-x-x-120">expr</span>
<br 
class="newline" /><div class="minipage">
</div>

</div>These functions add the single assertion or list of assertions to xref-assertions.
<!--l. 417--><p class="noindent" ><div class="minipage"><a 
 id="dx95-193003"></a>
<span 
class="ptmb7t-x-x-120">(record-usage EXPR:form ENV:form): nil                                                               </span><span 
class="ptmri7t-x-x-120">expr</span>
<br 
class="newline" /><div class="minipage">Suitable as a function to be applied to each (non-atomic) expression and
subexpression being analyzed. It is especially suitable as an after-expansion
hook. Except for various special cases described below, record-usage makes
an assertion for each expression that is a function call. The assertion is of the
form, (<span 
class="cmmi-12">&#x003C;</span>fn1<span 
class="cmmi-12">&#x003E; </span>CALLS <span 
class="cmmi-12">&#x003C;</span>fn2<span 
class="cmmi-12">&#x003E;</span>) where <span 
class="cmmi-12">&#x003C;</span>fn2<span 
class="cmmi-12">&#x003E; </span>is the function being called
(car of the expression). <span 
class="cmmi-12">&#x003C;</span>Fn1<span 
class="cmmi-12">&#x003E; </span>is the current-function, or if that is NIL, it
is the current-file.</div></div>
<!--l. 419--><p class="noindent" >Record-usage ignores non-pair expressions. Expressions that are pairs (function calls) are
checked for an openfn or opencode property, which would imply that they are compiled in-line.
No assertion is made for these or for expressions where the function part (car) is not an
id.
<!--l. 425--><p class="noindent" >If the function being called has a usage-asserter property, the value of that property is funcalled
to make whatever assertions it will. Otherwise if the function is flagged dont-record-usage, no
assertion is made.
<!--l. 438--><p class="noindent" ><div class="minipage"><a 
 id="dx95-193004"></a>
<span 
class="ptmb7t-x-x-120">(record-macro-usage EXPR:form ENV:form): nil                                                   </span><span 
class="ptmri7t-x-x-120">expr</span>
<br 
class="newline" /><div class="minipage">record-macro-usage is like record-usage, but it is for macros and cmacros.
This function is suitable as a scan-macro hook. The assertions generated by
this function in the usual case are (<span 
class="cmmi-12">&#x003C;</span>fn1<span 
class="cmmi-12">&#x003E; </span>USES-MACRO <span 
class="cmmi-12">&#x003C;</span>macro<span 
class="cmmi-12">&#x003E;</span>) or for
cmacros, (<span 
class="cmmi-12">&#x003C;</span>fn1<span 
class="cmmi-12">&#x003E; </span>USES-CMACRO <span 
class="cmmi-12">&#x003C;</span>cmacro<span 
class="cmmi-12">&#x003E;</span>).</div>
</div>
<!--l. 449--><p class="noindent" ><div class="minipage"><a 
 id="dx95-193005"></a>
<span 
class="ptmb7t-x-x-120">(setup-some-xref-actions): t                                                                                        </span><span 
class="ptmri7t-x-x-120">expr</span>
<br 
class="newline" /><div class="minipage">The programmer who likes some of the facilities in this module, but doesn&#8217;t
want  everything  here  can  just  load  the  module.  If  you  want  to  use  the
facilities and defaults available in the module, call this function. In addition
to setting up record-usage and record-macro-usage as analysis hooks, it flags
some sets of functions as not having their usage recorded. It also sets up
some special usage asserters for certain functions.</div>
</div>
<!--l. 451--><p class="noindent" >The value of each of these variables is a list of functions (or macros or both). The &#8221;setup&#8221;
function, above, flags each function on each of these lists as dont- record-usage.

<!--l. 457--><p class="noindent" ><div class="minipage"><a 
 id="dx95-193006"></a>
<span 
class="ptmb7t-x-x-120">kernel-fns </span>= [Initially: A list of all defined<br 
class="newline" />functions in a PSL kernel.]                                                                                         <span 
class="ptmri7t-x-x-120">global</span>
<br 
class="newline" />&#x00A0;       &#x00A0;<div class="minipage">
</div></div><div class="minipage"><a 
 id="dx95-193007"></a>
<span 
class="ptmb7t-x-x-120">useful-fns </span>= [Initially: A list of frequently-used functions<br 
class="newline" />and macros defined in the USEFUL library module.]                                                <span 
class="ptmri7t-x-x-120">global</span>
<br 
class="newline" />&#x00A0;       &#x00A0;<div class="minipage">
</div>
</div><div class="minipage"><a 
 id="dx95-193008"></a>
<span 
class="ptmb7t-x-x-120">object-fns </span>= [Initially: A list of frequently-used functions<br 
class="newline" />and macros in the OBJECTS module.]                                                                      <span 
class="ptmri7t-x-x-120">global</span>
<br 
class="newline" />&#x00A0;       &#x00A0;<div class="minipage">
</div>
</div>The following are special usage asserters for certain functions and macros. See the source code
for details.<br 
class="newline" />
<!--l. 467--><p class="noindent" >- Load-Usage-Asserter
<!--l. 469--><p class="noindent" >- Imports-Usage-Asserter
<!--l. 471--><p class="noindent" >- Send-Usage-Asserter
<!--l. 473--><p class="noindent" >- Defmethod-Usage-Asserter

<!--l. 1--><p class="noindent" ><table cellspacing="5"><tr><td class="clinks"><a 
href="allman1li16.html#allman1se76.html" >Up</a></td><td class="clinks"><a 
href="allman1se75.html" >Prev</a></td><td class="clinks"><a 
href="allman1se75.html#tailallman1se75.html" >PrevTail</a></td><td class="clinks"><a 
href="allman1se76.html" >Front</a></td></tr></table><a 
 id="tailallman1se76.html"></a>   
</body></html> 
