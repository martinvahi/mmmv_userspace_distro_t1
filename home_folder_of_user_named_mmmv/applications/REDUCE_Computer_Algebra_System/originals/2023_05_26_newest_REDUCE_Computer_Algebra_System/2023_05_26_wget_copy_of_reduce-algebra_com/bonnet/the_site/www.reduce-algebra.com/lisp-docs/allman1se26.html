<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"  
  "http://www.w3.org/TR/html4/loose.dtd">  
<html > 
<head><title>Wrappers</title> 
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1"> 
<meta name="generator" content="TeX4ht (http://www.cse.ohio-state.edu/~gurari/TeX4ht/)"> 
<meta name="originator" content="TeX4ht (http://www.cse.ohio-state.edu/~gurari/TeX4ht/)"> 
<!-- 3,html --> 
<meta name="src" content="allman1.tex"> 
<meta name="date" content="2014-05-02 18:10:00"> 
<link rel="stylesheet" type="text/css" href="allman1.css"> 
</head><body 
>
<p align="centre"><img src="http://www.reduce-algebra.com/lisp-docs/redlogo.png" width=621 height=60 border=0 alt="REDUCE"></p><table cellspacing="5"><tr><td class="clinks"><a 
href="allman1li7.html#allman1se26.html" >Up</a></td><td class="clinks"><a 
href="allman1se27.html" >Next</a></td><td class="clinks"><a 
href="allman1se25.html" >Prev</a></td><td class="clinks"><a 
href="allman1se25.html#tailallman1se25.html" >PrevTail</a></td><td class="clinks"><a 
href="allman1se26.html#tailallman1se26.html">Tail</a></td></tr></table><h3 class="sectionHead"><span class="titlemark">8.2    </span> <a 
 id="x36-960008.2"></a>Wrappers</h3>
<!--l. 549--><p class="noindent" >Once a function has been defined, one may want it to do something a little different, or just a
little bit more. Breaking and tracing functions for debugging purposes can be thought of in
this way. Having a function keep track of the time spent in its execution can also be
thought of in this way. The Wrappers module provides a convenient facility to support
this.
<!--l. 557--><p class="noindent" >When a function is wrapped, its name becomes a reference for two different function
definitions. In PSL it is possible to create distinct identifiers which have the same
name. The original name of the function is associated with a new function called the
wrapper. In general a wrapper does additional work before and/or after applying the
original definition. The original definition is associated with an identifier whose name is
identical with the original name but which is not interned. Application of getd to the
original name will return the original definition. Since a wrapper is identified by an
indicator on the property list of its name getd knows when to look elsewhere for the
original function definition, and putd knows to alter the original definition, not the
wrapper.
<!--l. 571--><p class="noindent" >Typically a wrapper may be added to a function and later removed. A function potentially may
be wrapped up inside more than one wrapper at the same time. It is possible to redefine a
wrapped function but if the order or number of formal parameters is changed then it will be
necessary to unwrap all wrappers first.
<!--l. 578--><p class="noindent" >
<h4 class="subsectionHead"><span class="titlemark">8.2.1    </span> <a 
 id="x36-970008.2.1"></a>Notes on Writing Wrappers</h4>
<!--l. 580--><p class="noindent" >This section describes guidelines for writing wrappers.
<!--l. 582--><p class="noindent" >If a wrapper is put on a function that is used either directly or indirectly by the wrapper body an
infinite recursion may result. Functions used by the PSL interpreter are particularly susceptible
to this problem. We require a means to avoid infinite recursion. In general it is not easy to
restrict the set of functions which can be called indirectly by a piece of code. Many PSL system
functions use other system functions. Furthermore, a modification to the system may change
these relationships. Some system functions call functions through functional variables or
functional values stored on property lists. This means that some of the relationships between
system functions change over time.
<!--l. 595--><p class="noindent" >Instead of avoiding recursion introduced by wrappers, we can detect and recover from it.
Wrapper bypasses do this. A wrapper bypass is implemented through a fluid variable, called the
controlling variable for that wrapper. On entry to a wrapper, the value of the controlling variable
is checked. A non-nil value implies that a previous invocation of this wrapper has not been
completed. To avoid a recursive call on the wrapper, a call on the wrapped function replaces
evaluation of the wrapper.
<!--l. 605--><p class="noindent" >If the value of the controlling variable is nil the wrapper is evaluated. During evaluation of the
wrapper the controlling variable is set to t except during the application of the wrapped function,
at which point it should be set to nil.

<!--l. 610--><p class="noindent" >Syntactically, wrapper bodies of the following form are supported:

<div class="verbatim" id="verbatim-260">
(lambda&#x00A0;&#x003C;args&#x003E;
&#x00A0;<br />&#x00A0;&#x00A0;(cond&#x00A0;(&#x003C;var&#x003E;&#x00A0;&#x003C;wrapped-fn-call&#x003E;)
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;(t&#x00A0;(prog&#x00A0;(&#x003C;var&#x003E;&#x00A0;&#x003C;id&#x003E;&#x22C6;)
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;(setq&#x00A0;&#x003C;var&#x003E;&#x00A0;t)
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x003C;call-expr&#x003E;&#x22C6;))))
&#x00A0;<br />
&#x00A0;<br />&#x003C;call-expr&#x003E;&#x00A0;::=&#x00A0;&#x003C;expr&#x003E;
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;|&#x00A0;(&#x003C;call-expr&#x003E;&#x22C6;)
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;|&#x00A0;(setq&#x00A0;&#x003C;var&#x003E;&#x00A0;nil)&#x00A0;&#x003C;setq-and-wrapped-fn-call&#x003E;&#x00A0;(setq&#x00A0;&#x003C;var&#x003E;&#x00A0;t)
&#x00A0;<br />
&#x00A0;<br />&#x003C;setq-and-wrapped-fn-call&#x003E;&#x00A0;::=
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;|&#x00A0;&#x003C;wrapped-fn-call&#x003E;
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;|&#x00A0;(setq&#x00A0;&#x003C;id&#x003E;&#x00A0;&#x003C;wrapped-fn-call&#x003E;)
&#x00A0;<br />
&#x00A0;<br />&#x003C;wrapped-fn-call&#x003E;&#x00A0;::=&#x00A0;(wrapped-function&#x00A0;&#x003C;expr&#x003E;&#x22C6;)
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;|&#x00A0;(funcall&#x00A0;'wrapped-function&#x00A0;&#x003C;expr&#x003E;&#x22C6;)
&#x00A0;<br />
&#x00A0;<br />&#x003C;var&#x003E;&#x00A0;::=&#x00A0;&#x003C;id&#x003E;
&#x00A0;<br />&#x003C;id&#x003E;&#x00A0;is&#x00A0;any&#x00A0;PSL&#x00A0;identifier&#x00A0;&#x003C;expr&#x003E;&#x00A0;is&#x00A0;any&#x00A0;PSL&#x00A0;s-expression.
</div>
<!--l. 633--><p class="nopar" >
<!--l. 635--><p class="noindent" >The controlling variable of the wrapper is <span 
class="cmmi-12">&#x003C; var &#x003E;</span>. It must be a fluid variable whose top level
value is nil.
<!--l. 638--><p class="noindent" >The notation is BNF with the addition of the regular expression &#8221;*&#8221; operator. This operator is
used to indicate zero or more repetitions of an item.
<!--l. 642--><p class="noindent" >Note that setf is not supported in place of setq. You should not use apply in place of funcall or let
in place of prog. You can eliminate redundant instances of (setq <span 
class="cmmi-12">&#x003C; var &#x003E; </span>t) and (setq <span 
class="cmmi-12">&#x003C; var &#x003E;</span>
nil). For example, if a <span class="verb"><span 
class="pcrr7t-x-x-120">&#x003C;wrapped-fn-call&#x003E; </span>appears at the beginning of a prog then the form
<span class="verb"><span 
class="pcrr7t-x-x-120">(setq</span><span 
class="pcrr7t-x-x-120">&#x00A0;&#x003C;var&#x003E;</span><span 
class="pcrr7t-x-x-120">&#x00A0;nil) </span>can be omitted.
<!--l. 650--><p class="noindent" >
<h4 class="subsectionHead"><span class="titlemark">8.2.2    </span> <a 
 id="x36-980008.2.2"></a>Exported Functions</h4>
<!--l. 659--><p class="noindent" ><div class="minipage"><a 
 id="dx36-98001"></a>
<span 
class="ptmb7t-x-x-120">(wrap name:id wtype:id BODY:list COMPILE?:boolean): id                                </span><span 
class="ptmri7t-x-x-120">expr</span>
<br 
class="newline" /><div class="minipage">Wrap creates a wrapper. name is the name of the function to be wrapped.
wtype is an id which identifies the wrapper type, it must be a member of
the list wrapper-standard-order (documented below). BODY is a list which
should be a lambda expression.</div>
</div>Wrap redefines the functional value of name. The original function is renamed. The print
representation of this new name is identical to name but the identifiers are distinct.

<!--l. 664--><p class="noindent" >When BODY is a lambda expression (you are encouraged to use a lambda expression for this
argument), then the new name of the function which is being wrapped is substituted for each
occurance of wrapper-function. The result of this substitution becomes the definition of the
wrapper.
<!--l. 670--><p class="noindent" >When BODY is not a lambda expression a different method is used to create the wrapper. BODY
is embedded within a lambda expression which has the same number of arguments as the
function which is being wrapped. Each occurance of the form (wrapped-invocation), is replaced
by an application of the wrapped function.
<!--l. 677--><p class="noindent" >If COMPILE? is t then the wrapper will be compiled.
<!--l. 679--><p class="noindent" >The wrappers package permits a function to have any number of wrappers of any permitted type.
For a given type of wrapper, a new wrapper always encloses preexisting wrappers of that type.
However, you are advised against depending upon this ordering.
<!--l. 690--><p class="noindent" ><div class="minipage"><a 
 id="dx36-98002"></a>
<span 
class="ptmb7t-x-x-120">(remove-wrapper name:id TYPE:id): boolean                                                         </span><span 
class="ptmri7t-x-x-120">expr</span>
<br 
class="newline" /><div class="minipage">Removes a wrapper of type TYPE from the identifier name. If name does
not have a wrapper of this type then the return value will be nil, otherwise t
is returned.</div></div>
<!--l. 694--><p class="noindent" ><div class="minipage"><a 
 id="dx36-98003"></a>
<span 
class="ptmb7t-x-x-120">(wrapped? name:id): boolean                                                                                     </span><span 
class="ptmri7t-x-x-120">expr</span>
<br 
class="newline" /><div class="minipage">Returns t if there is at least one wrapper on name.
</div></div>
<!--l. 699--><p class="noindent" ><div class="minipage"><a 
 id="dx36-98004"></a>
<span 
class="ptmb7t-x-x-120">(wrapper-of-type? name:id TYPE:id): name:id nil                                                  </span><span 
class="ptmri7t-x-x-120">expr</span>
<br 
class="newline" /><div class="minipage">Searches for a wrapper of the given type on name. name is returned if a
wrapper is found, otherwise nil is returned.</div>
</div>
<!--l. 704--><p class="noindent" ><div class="minipage"><a 
 id="dx36-98005"></a>
<span 
class="ptmb7t-x-x-120">(wrapper-types name:id): list                                                                                     </span><span 
class="ptmri7t-x-x-120">expr</span>
<br 
class="newline" /><div class="minipage">Returns a list of all the types of all the wrappers around the function named
name.</div></div>

<!--l. 714--><p class="noindent" ><div class="minipage"><a 
 id="dx36-98006"></a>
<span 
class="ptmb7t-x-x-120">(function-lambda-list FN:id, code-pointer, lambda): list                                         </span><span 
class="ptmri7t-x-x-120">expr</span>
<br 
class="newline" /><div class="minipage">Returns a list suitable for use as the formal parameter list of a wrapper
for  that  function.  If  the  function  is  interpreted,  the  argument  list  of  the
definition is returned. If the actual argument list is not available, names for
the arguments are invented. If FN is not a lambda expression, code-pointer,
or identifier then it is an error.</div></div>

<div class="verbatim" id="verbatim-261">
&#x22C6;&#x22C6;&#x22C6;&#x22C6;&#x22C6;&#x00A0;FN&#x00A0;is&#x00A0;not&#x00A0;a&#x00A0;function.
</div>
<!--l. 717--><p class="nopar" >It is also an error if FN is an identifier which does not have a functional value.
<!--l. 722--><p class="noindent" ><span 
class="pcrr7t-x-x-120">&#x22C6;&#x22C6;&#x22C6;&#x22C6;&#x22C6; FN is not defined as a function.</span>
<!--l. 735--><p class="noindent" ><div class="minipage"><a 
 id="dx36-98007"></a>
<span 
class="ptmb7t-x-x-120">(function-basic-definition name:id): name:id                                                           </span><span 
class="ptmri7t-x-x-120">expr</span>
<br 
class="newline" /><div class="minipage">Returns the basic definition of name, whether or not a set or wrappers is
associated with it. Note that getd and putd operate on this basic definition. If
you wish to redefine a wrapped function and the number or order of formal
parameters  will  change  it  is  necessary  to  first  unwrap  all  wrappers  first.
Applications of the wrapped function within the wrapper will not be updated
when the wrapped function is redefined.</div>
</div>
<!--l. 748--><p class="noindent" ><div class="minipage"><a 
 id="dx36-98008"></a>
<span 
class="ptmb7t-x-x-120">wrapper-standard-order </span>= [Initially: (trace break meter)]                                      <span 
class="ptmri7t-x-x-120">global</span>
<br 
class="newline" />&#x00A0;       &#x00A0;<div class="minipage">Only  wrapper  types  which  are  members  of  this  list  are  legal  arguments
to   primitive   functions   that   operate   on   wrappers.   The   wrappers   of
each  function  are  nested  so  that  each  wrapper  type  appears  earlier  in
wrapper-standard-order  than  the  type  of  any  wrapper  it  encloses.  Wrap
wraps according to this ordering, but changing this list does not cause the
ordering of existing wrappers to be changed.</div>
</div>
<!--l. 750--><p class="noindent" >
<h4 class="subsectionHead"><span class="titlemark">8.2.3    </span> <a 
 id="x36-990008.2.3"></a>Examples</h4>
<!--l. 752--><p class="noindent" >Assume that foo is a commonly called function whose argument is a large data structure. You
have found that foo is sometimes called with an argument of nil and would like to cause a
break when this situation arises so that you can discover where foo is being called
from.
<!--l. 758--><p class="noindent" >Since foo is a commonly used function a break on each entry to foo is unsatisfactory. A
trace of each entry and exit is not sufficient &#8211; it doesn&#8217;t tell you who called foo in
the critical case. The solution is to wrap foo is an advice wrapper. Such a wrapper
will print a backtrace and enter a continuable break loop when an argument of nil is
discovered.
<!--l. 765--><p class="noindent" >First, load the <span 
class="ptmb7t-x-x-120">break-trace </span>module. This will result in the <span 
class="ptmb7t-x-x-120">wrappers </span>module being
loaded and the breaktrace function being defined (see Chapter 17 for more information
on breaktrace). The wrapper-type advice is added as the innermost wrapper on the
ordered list referenced by wrapper-standard-order (assuming it is not already on the
list).

<div class="verbatim" id="verbatim-262">
&#x00A0;&#x00A0;(load&#x00A0;break-trace)&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;%&#x00A0;loads&#x00A0;wrappers&#x00A0;&amp;
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;breakpoint&#x00A0;function
&#x00A0;<br />&#x00A0;&#x00A0;(if&#x00A0;(not&#x00A0;member&#x00A0;'advice&#x00A0;wrapper-standard-order)&#x00A0;then
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;(setf&#x00A0;wrapper-standard-order
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;(append&#x00A0;wrapper-standard-order&#x00A0;'(advice))))
&#x00A0;<br />
&#x00A0;<br />&#x00A0;&#x00A0;(de&#x00A0;debug-foo&#x00A0;()
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;(wrap
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;'foo&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;%&#x00A0;function&#x00A0;to&#x00A0;wrap
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;'advice&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;%&#x00A0;wrapper&#x00A0;type
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#8216;(lambda&#x00A0;(x)&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;%&#x00A0;wrapper&#x00A0;body&#x00A0;generator
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;(cond&#x00A0;((null&#x00A0;x)
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;(backtrace)
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;(breakpoint&#x00A0;"Foo&#x00A0;(x=nil)")))
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;(wrapped-function&#x00A0;x))
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;nil))&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;%&#x00A0;don't&#x00A0;compile
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;%&#x00A0;the&#x00A0;wrapper&#x00A0;body
</div>
<!--l. 790--><p class="nopar" >The above will work fine as long as foo is an expr which is not used by the interpreter or by the
<span 
class="ptmb7t-x-x-120">wrappers </span>module itself. In the more general case, the function debug-foo must have three
changes:
<!--l. 797--><p class="noindent" >
      <ol  class="enumerate1" >
      <li 
  class="enumerate" id="x36-99002x1">If foo is not an expr, then all occurrences of (wrapped-function <span 
class="cmmi-12">&#x003C; args &#x003E;</span>) must be
      replaced by (funcall &#8217;wrapped-function <span 
class="cmmi-12">&#x003C; args &#x003E;</span>).
      </li>
      <li 
  class="enumerate" id="x36-99004x2">If foo is used by the PSL interpreter, by the <span 
class="pcrr7t-x-x-120">wrappers </span>module, or by expression
      in the wrapper body then it will be necessary to know when foo is called during the
      evaluation of foo&#8217;s wrapper. This will allow you to bypass evaluation of the wrapper,
      you can simply apply the wrapped function. Otherwise an infinite recursion could
      result. The definition below uses the fluid variable (called a controlling variable)
      in-foo-wrapper? to achieve this effect.
      </li>
      <li 
  class="enumerate" id="x36-99006x3">If foo is possibly used within the interpreter, then the wrapper must be compiled.
      This means that if (not (interpretive-wrapper-ok? &#8217;foo)), then the fourth argument
      to the function wrap must be t, or wrap will signal an error.</li></ol>
<!--l. 817--><p class="noindent" >The revised definition of debug-foo follows.

<div class="verbatim" id="verbatim-263">
&#x00A0;<br />(fluid&#x00A0;&#x00A0;'(in-foo-wrapper?))&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;%&#x00A0;necessary&#x00A0;initializations&#x00A0;of
&#x00A0;<br />&#x00A0;&#x00A0;(setq&#x00A0;in-foo-wrapper?&#x00A0;nil)&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;%&#x00A0;the&#x00A0;controlling&#x00A0;&#x00A0;variable
&#x00A0;<br />(change&#x00A0;2)
</div>
<!--l. 823--><p class="nopar" >

<div class="verbatim" id="verbatim-264">
&#x00A0;&#x00A0;(de&#x00A0;debug-foo&#x00A0;()
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;(wrap
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;'foo
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;'advice
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#8216;(lambda&#x00A0;(x)
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;(cond&#x00A0;(in-foo-wrapper?&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;%&#x00A0;change&#x00A0;2
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;(funcall&#x00A0;'wrapped-function&#x00A0;x))&#x00A0;&#x00A0;&#x00A0;%&#x00A0;change&#x00A0;1
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;(t
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;(prog&#x00A0;(in-foo-wrapper?)
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;(setq&#x00A0;in-foo-wrapper?&#x00A0;t)
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;(cond&#x00A0;((null&#x00A0;x)
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;(backtrace)
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;(breakpoint&#x00A0;"Foo&#x00A0;(x=nil)")))
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;(setq&#x00A0;in-foo-wrapper?&#x00A0;nil)
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;(return
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;(funcall&#x00A0;'wrapped-function&#x00A0;x)&#x00A0;%&#x00A0;change&#x00A0;1
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;))))
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;(not&#x00A0;(interpretive-wrapper-ok?&#x00A0;'foo))))&#x00A0;&#x00A0;&#x00A0;&#x00A0;%&#x00A0;change&#x00A0;3
</div>
<!--l. 843--><p class="nopar" >The function break-on-condition will cause entry into a continuable break loop just before the
function fn is applied if the result of evaluating the form bound to bool-expr is non-nil. A sample
call might be (break-on-condition &#8217;foo &#8217;(eq x 2)).

<div class="verbatim" id="verbatim-265">
(setf&#x00A0;in-wrapper?&#x00A0;nil)
&#x00A0;<br />(fluid&#x00A0;'(in-wrapper?))
&#x00A0;<br />
&#x00A0;<br />(de&#x00A0;break-on-condition&#x00A0;(fn&#x00A0;bool-expr)
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;%&#x00A0;First,&#x00A0;get&#x00A0;the&#x00A0;parameter-list&#x00A0;of&#x00A0;the&#x00A0;function.
&#x00A0;<br />&#x00A0;&#x00A0;(let&#x00A0;((parameter-list&#x00A0;(function-lambda-list&#x00A0;fn)))
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;(wrap
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;fn
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;'advice
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#8216;(lambda&#x00A0;,parameter-list
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;(cond&#x00A0;(in-wrapper?
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;(funcall&#x00A0;'wrapped-function&#x00A0;,@parameter-list))
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;(t
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;(prog&#x00A0;(in-wrapper?)
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;(setq&#x00A0;in-wrapper?&#x00A0;t)
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;(cond&#x00A0;(,bool-expr
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;(breakpoint&#x00A0;"In&#x00A0;%p,&#x00A0;condition&#x00A0;%p=%p"
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;',fn&#x00A0;&#x00A0;',bool-expr&#x00A0;,bool-expr)))
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;(setq&#x00A0;in-wrapper?&#x00A0;nil)
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;(return
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;(funcall&#x00A0;'wrapped-function
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;,@parameter-list))
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;))))
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;(not&#x00A0;(interpretive-wrapper-ok?&#x00A0;fn))
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;)
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;))
</div>
<!--l. 876--><p class="nopar" >

<table cellspacing="5"><tr><td class="clinks"><a 
href="allman1li7.html#allman1se26.html" >Up</a></td><td class="clinks"><a 
href="allman1se27.html" >Next</a></td><td class="clinks"><a 
href="allman1se25.html" >Prev</a></td><td class="clinks"><a 
href="allman1se25.html#tailallman1se25.html" >PrevTail</a></td><td class="clinks"><a 
href="allman1se26.html" >Front</a></td></tr></table><a 
 id="tailallman1se26.html"></a>   
</body></html> 
