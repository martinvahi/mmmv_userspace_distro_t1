<!DOCTYPE html> 
<html lang="en-US" xml:lang="en-US" > 
<head><title>DUMMY: Canonical Form of Expressions with Dummy Variables</title> 
<meta  charset="utf-8" /> 
<meta name="generator" content="TeX4ht (https://tug.org/tex4ht/)" /> 
<meta name="viewport" content="width=device-width,initial-scale=1" /> 
<link rel="stylesheet" type="text/css" href="manual.css" /> 
<meta name="src" content="manual.tex" /> 
<script>window.MathJax = { tex: { tags: "ams", }, }; </script> 
 <script type="text/javascript" async="async" id="MathJax-script" src="../../cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js"></script>  
<meta name="description" content="The REDUCE Computer Algebra System User's Manual" /> 
</head><body 
>
<header>REDUCE</header><table cellspacing="5"><tr><td class="clinks"><a 
href="../manual-lookup.php%3FUser&#32;Contributed&#32;Packages.html#manualse140.html" >Up</a></td><td class="clinks"><a 
href="manualse141.html" >Next</a></td><td class="clinks"><a 
href="manualse139.html" >Prev</a></td><td class="clinks"><a 
href="manualse139.html#tailmanualse139.html" >PrevTail</a></td><td class="clinks"><a 
href="manualse140.html#tailmanualse140.html">Tail</a></td></tr></table><h3 class="sectionHead"><span class="titlemark">20.17    </span> <a 
 id="x205-51600020.17"></a>DUMMY: Canonical Form of Expressions with
Dummy Variables</h3>
<a 
 id="dx205-516001"></a>
<a 
 id="dx205-516002"></a>
<!--l. 367--><p class="noindent" >This package allows a user to ﬁnd the canonical form of expressions involving dummy
variables. In that way, the simpliﬁcation of polynomial expressions can be fully
done. The indeterminates are general operator objects endowed with as few
properties as possible. In that way the package may be used in a large spectrum of
applications.
</p><!--l. 373--><p class="noindent" >Author: Alain Dresse.
<a 
 id="dx205-516003"></a>
<a 
 id="dx205-516004"></a>
</p><!--l. 4--><p class="noindent" >
</p>
<h4 class="subsectionHead"><span class="titlemark">20.17.1    </span> <a 
 id="x205-51700020.17.1"></a>Introduction</h4>
<!--l. 5--><p class="noindent" >The possibility to handle dummy variables and to manipulate dummy summations are
important features in many applications. In particular, in theoretical physics, the
possibility to represent complicated expressions concisely and to realize simpliﬁcations
eﬃciently depend on both capabilities. However, when dummy variables are
used, there are many more ways to express a given mathematical objects since
the names of dummy variables may be chosen almost arbitrarily. Therefore,
from the point of view of computer algebra the simpliﬁcation problem is much
more diﬃcult. Given a deﬁnite ordering, one is, at least, to ﬁnd a representation
which is independent of the names chosen for the dummy variables otherwise,
simpliﬁcations are impossible. The package does handle any number of dummy
variables and summations present in expressions which are arbitrary multivariate
polynomials and which have operator objects eventually dependent on one (or several)
dummy variable(s) as some of their indeterminates. These operators have the
same generality as the one existing in REDUCE. They can be noncommutative,
anticommutative or commutative. They can have any kind of symmetry property. Such
polynomials will be called in the following <span 
class="ptmri8t-x-x-109">dummy </span>polynomials. Any monomial of
this kind will be called <span 
class="ptmri8t-x-x-109">dummy </span>monomial. For any such object, the package
allows to ﬁnd a well deﬁned <span 
class="ptmri8t-x-x-109">normal form </span>in one-to-one correspondance with
                                                                     

                                                                     
it.
</p><!--l. 30--><p class="noindent" >In section 2, the convention for writing dummy summations is explained and the
available declarations to introduce or suppress dummy variables are given.
</p><!--l. 34--><p class="noindent" >In section 3, the commands allowing to give various algebraic properties to the operators
are described.
</p><!--l. 37--><p class="noindent" >In section 4, the use of the function <span 
class="pcrr8t-x-x-109">canonical </span>is explained and illustrated.
</p><!--l. 40--><p class="noindent" >For  references,  see
<span class="cite">[<a 
href="manualap2.html#XBUTLER1985363">BL85</a>, <a 
href="manualap2.html#XButlerCannon1982a">BC82</a>, <a 
href="manualap2.html#XButler1982a">But82</a>, <a 
href="manualap2.html#XLeon1980a">Leo80</a>, <a 
href="manualap2.html#XLeon1984a">Leo84</a>, <a 
href="manualap2.html#XLeon1991PermutationGA">Leo91</a>, <a 
href="manualap2.html#XLinton1991415">Lin91</a>, <a 
href="manualap2.html#XMcKay1977a">McK78</a>, <a 
href="manualap2.html#XRodinonovElAl1989a">RT89</a>, <a 
href="manualap2.html#XSims1971a">Sim71b</a>, <a 
href="manualap2.html#XSims1971b">Sim71a</a>, <a 
href="manualap2.html#XBurnel1994a">BC94</a>, <a 
href="manualap2.html#XCaprasse1997a">Cap97</a>]</span>.
</p><!--l. 42--><p class="noindent" >The use of <span 
class="ptmrc8t-x-x-109">D<span 
class="small-caps">U</span><span 
class="small-caps">M</span><span 
class="small-caps">M</span><span 
class="small-caps">Y</span> </span>requires that the package <span 
class="ptmrc8t-x-x-109">A<span 
class="small-caps">S</span><span 
class="small-caps">S</span><span 
class="small-caps">I</span><span 
class="small-caps">S</span><span 
class="small-caps">T</span> </span>version 2.2 be available. It is
loaded automatically when <span 
class="ptmrc8t-x-x-109">D<span 
class="small-caps">U</span><span 
class="small-caps">M</span><span 
class="small-caps">M</span><span 
class="small-caps">Y</span> </span>is loaded.
</p><!--l. 45--><p class="noindent" >
</p>
<h4 class="subsectionHead"><span class="titlemark">20.17.2    </span> <a 
 id="x205-51800020.17.2"></a>Dummy variables and dummy summations</h4>
<!--l. 46--><p class="noindent" >A dummy variable (let us name it <span 
class="pcrr8t-x-x-109">dv</span>) is an identiﬁer which runs from the integer \(i_1\) to
another integer \(i_2\). To the extent that no deﬁnite space is deﬁned, \(i_1\) and \(i_2\) are assumed to be
some integers which are the <span 
class="ptmri8t-x-x-109">same </span>for all dummy variables.
</p><!--l. 51--><p class="noindent" >If <span 
class="pcrr8t-x-x-109">f </span>is any REDUCE operator, then the simplest dummy summation associated to <span 
class="pcrr8t-x-x-109">dv </span>is
the sum \[ \sum _{dv=i_1}^{i_2} f(dv) \] and is simply written as \[ f(dv). \] No other rules govern the implicit summations. <span 
class="pcrr8t-x-x-109">dv </span>can
appear as many times we want since the operator <span 
class="pcrr8t-x-x-109">f </span>may depend on an arbitrary
number of variables. So, the package is potentially applicable to many contexts.
For instance, it is possible to add rules of the kind one encounters in tensor
calculus.
</p><!--l. 66--><p class="noindent" >Obviously, there are as many ways we want to express the <span 
class="ptmri8t-x-x-109">same </span>quantity. If the name of
another dummy variable is <span 
class="pcrr8t-x-x-109">dum </span>then the previous expression is written as \[ \sum _{dum=i_1}^{i_2} f(dum) \] and the
computer algebra system should be able to ﬁnd that the expression \[ f(dv)-f(dum); \] is equal to \(0\). A very
special case which is <span 
class="ptmri8t-x-x-109">allowed </span>is when <span 
class="pcrr8t-x-x-109">f </span>is the identity operator. So, a generic dummy
polynomial will be a sum of dummy monomials of the kind \[ \prod _i c_i*f_i(dv_1,\ldots ,dv_{k_i},fr_1,\ldots , fr_{l_i}) \] where \(dv_1,\ldots ,\) are dummy variables
while \(fr_1, \ldots , \) are ordinary or free variables.
<a 
 id="dx205-518001"></a>
<a 
 id="dx205-518002"></a>
</p><!--l. 89--><p class="noindent" ><a 
 id="command:DUMMY_BASE"></a> <a 
 id="command:DUMMY_NAME"></a> To declare dummy variables, two commands are available: </p>
     <ul class="itemize1">
     <li class="itemize">
                                                                     

                                                                     
     <!--l. 93--><p class="noindent" >i.
       </p><div class="syntax">
        <span 
class="pcrr8t-x-x-109">dummy_base</span>\(\langle \)<span 
class="ptmri8t-x-x-109">idp</span>\(\rangle \);</div>
     <!--l. 97--><p class="noindent" >where \(\langle \)<span 
class="ptmri8t-x-x-109">idp</span>\(\rangle \) is the name of any unassigned identiﬁer.
     </p></li>
     <li class="itemize">
     <!--l. 98--><p class="noindent" >ii.
       </p><div class="syntax">
        <span 
class="pcrr8t-x-x-109">dummy_names</span>\(\langle \)<span 
class="ptmri8t-x-x-109">d</span>\(\rangle \),\(\langle \)<span 
class="ptmri8t-x-x-109">dp</span>\(\rangle \),\(\langle \)<span 
class="ptmri8t-x-x-109">dpp</span>\(\rangle \), …;</div>
     </li></ul>
<!--l. 103--><p class="noindent" >The ﬁrst one declares <span 
class="pcrr8t-x-x-109">idp_1</span>,…,<span 
class="pcrr8t-x-x-109">idp_n </span>as dummy variables i.e. all variables of the
form <span 
class="pcrr8t-x-x-109">idp_xxx </span>where \(xxx\) is a number will be dummy variables, such as <span 
class="pcrr8t-x-x-109">idp_1</span>,
<span 
class="pcrr8t-x-x-109">idp_2</span>,…, <span 
class="pcrr8t-x-x-109">idp_23</span>. The second one gives special names for dummy variables. All
other identiﬁers which may appear are assumed to be <span 
class="ptmri8t-x-x-109">free</span>. However, there is a
restriction: named and base dummy variables cannot be declared <span 
class="ptmri8t-x-x-109">simultaneously</span>.
The above declarations are mutually <span 
class="ptmri8t-x-x-109">exclusive</span>. Here is an example showing
that:
                                                                     

                                                                     
</p>
<pre class="verbatim" id="verbatim-997">

     dummy_base dv; ==&#x003E; dv

               % dummy indices are dv1, dv2, dv3, ...

     dummy_names i,j,k; ==&#x003E;

               ***** The created dummy base dv must be cleared
</pre>
<!--l. 121--><p class="nopar" >
</p><!--l. 123--><p class="noindent" >When this is done, an expression like
                                                                     

                                                                     
</p>
<pre class="verbatim" id="verbatim-998">
     op(dv1)*sin(dv2)*abs(i)*op(dv2)$
</pre>
<!--l. 126--><p class="nopar" > means a sum over \(dv_1,dv_2\). To clear the dummy base, and to create the dummy names \(i,j,k\) one is to
do <a 
 id="dx205-518003"></a> <a 
 id="command:CLEAR_DUMMY_BASE"></a>
                                                                     

                                                                     
</p>
<pre class="verbatim" id="verbatim-999">

      clear_dummy_base; ==&#x003E; t

      dummy_names i,j,k; ==&#x003E; t

                 % dummy indices are i,j,k.
</pre>
<!--l. 139--><p class="nopar" > When this is done, an expression like
                                                                     

                                                                     
</p>
<pre class="verbatim" id="verbatim-1000">
     op(dv1)*sin(dv2)*abs(x)*op(i)^3*op(dv2)$
</pre>
<!--l. 143--><p class="nopar" > means a sum over \(i\). Similarly, the command <span 
class="pcrr8t-x-x-109">clear_dummy_names</span><a 
 id="dx205-518004"></a><a 
 id="command:CLEAR_DUMMY_NAMES"></a> clears earlier
deﬁned named dummy variables.
</p><!--l. 150--><p class="noindent" >One should keep in mind that every application of the above commands erases the
previous ones. It is also possible to display the declared dummy names using
<span 
class="pcrr8t-x-x-109">show_dummy_names</span>:<a 
 id="dx205-518005"></a> <a 
 id="command:SHOW_DUMMY_NAMES"></a>
                                                                     

                                                                     
</p>
<pre class="verbatim" id="verbatim-1001">
     show_dummy_names(); ==&#x003E; {i,j,k}
</pre>
<!--l. 157--><p class="nopar" > To suppress <span 
class="ptmri8t-x-x-109">all </span>dummy variables one can enter
                                                                     

                                                                     
</p>
<pre class="verbatim" id="verbatim-1002">
     clear_dummy_names; clear_dummy_base;
</pre>
<!--l. 161--><p class="nopar" >
</p><!--l. 163--><p class="noindent" >
</p>
<h4 class="subsectionHead"><span class="titlemark">20.17.3    </span> <a 
 id="x205-51900020.17.3"></a>The Operators and their Properties</h4>
<!--l. 164--><p class="noindent" >All dummy variables <span 
class="ptmri8t-x-x-109">should appear at ﬁrst level </span>as arguments of operators. For instance,
if \(i\) and \(j\) are dummy variables, the expression
                                                                     

                                                                     
</p>
<pre class="verbatim" id="verbatim-1003">
     rr:=  op(i,j)-op(j,j)
</pre>
<!--l. 169--><p class="nopar" > is allowed but the expression
                                                                     

                                                                     
</p>
<pre class="verbatim" id="verbatim-1004">
     op(i,op(j)) - op(j,op(j))
</pre>
<!--l. 173--><p class="nopar" > is <span 
class="ptmri8t-x-x-109">not </span>allowed. This is because dummy variables are not detected if they appear at a level
larger than 1. Apart from that there is no restrictions. Operators may be commutative,
noncommutative or even anticommutative. Therefore they may be elements of an
algebra, they may be tensors, spinors, grassman variables, etc. \(\ldots \) By default they are
assumed to be <span 
class="ptmri8t-x-x-109">commutative </span>and without symmetry properties. The REDUCE
command <span 
class="pcrr8t-x-x-109">noncom</span><a 
 id="dx205-519001"></a>declaration is taken into account and, in addition, the command
<a 
 id="dx205-519002"></a> <a 
 id="command:ANTICOM"></a>
                                                                     

                                                                     
</p>
<pre class="verbatim" id="verbatim-1005">
     anticom at1, at2;
</pre>
<!--l. 187--><p class="nopar" > makes the operators \(at_1\) and \(at_2\) anticommutative.
</p><!--l. 190--><p class="noindent" >One can also give symmetry properties to them. The usual declarations <span 
class="pcrr8t-x-x-109">symmetric </span>and
<span 
class="pcrr8t-x-x-109">antisymmetric </span>are taken into account. Moreover and most important they can be
endowed with a <span 
class="ptmri8t-x-x-109">partial </span>symmetry through the command <span 
class="pcrr8t-x-x-109">symtree</span>.<a 
 id="dx205-519003"></a> <a 
 id="command:SYMTREE"></a> Here are three
illustrative examples for the \(r\) operator:
                                                                     

                                                                     
</p>
<pre class="verbatim" id="verbatim-1006">
     symtree (r,{!+, 1, 2, 3, 4});
     symtree (r,{!*, 1, {!-, 2, 3, 4}});
     symtree (r, {!+, {!-, 1, 2}, {!-, 3, 4}});
</pre>
<!--l. 200--><p class="nopar" > The ﬁrst one makes the operator (fully) symmetric. The second one declares it
antisymmetric with respect to the three last indices. The symbols !*, !+ and !- at the
beginning of each list mean that the operator has no symmetry, is symmetric or is
antisymmetric with respect to the indices inside the list. Notice that the indices are not
denoted by their names but merely by their natural order of appearance. 1 means the ﬁrst
written argument of \(r\), 2 its second argument etc. The ﬁrst command is equivalent to the
declaration <span 
class="pcrr8t-x-x-109">symmetric </span>except that the number of indices of \(r\) is <span 
class="ptmri8t-x-x-109">restricted </span>to 4 i.e. to the
number declared in <span 
class="pcrr8t-x-x-109">symtree</span>. In the second example \(r\) is stated to have no
symmetry with respect to the ﬁrst index and is declared to be antisymmetric with
respect to the three last indices. In the third example, \(r\) is made symmetric with
respect to the interchange of the pairs of indices 1,2 and 3,4 respectively and is
made antisymmetric separately within the pairs \((1,2)\) and \((3,4)\). It is the symmetry of
the Riemann tensor. The anticommutation property and the various symmetry
properties may be suppressed by the commands <span 
class="pcrr8t-x-x-109">remanticom </span>and <span 
class="pcrr8t-x-x-109">remsym</span>.
To eliminate partial symmetry properties one can also use <span 
class="pcrr8t-x-x-109">symtree </span>itself.
For example, assuming that \(r\) has the Riemann symmetry, to eliminate it do<a 
 id="dx205-519004"></a><a 
 id="dx205-519005"></a> <a 
 id="command:REMANTICOM"></a>
<a 
 id="command:REMSYM"></a>
                                                                     

                                                                     
</p>
<pre class="verbatim" id="verbatim-1007">
     symtree (r,{!*, 1, 2, 3, 4});
</pre>
<!--l. 227--><p class="nopar" > However, notice that the number of indices remains ﬁxed and equal to 4 while with
<span 
class="pcrr8t-x-x-109">remsym </span>it becomes again arbitrary.
</p>
<h4 class="subsectionHead"><span class="titlemark">20.17.4    </span> <a 
 id="x205-52000020.17.4"></a>The <span 
class="pcrr8t-x-x-109">canonical </span>Operator</h4>
<a 
 id="dx205-520001"></a>
<!--l. 232--><p class="noindent" ><a 
 id="operator:CANONICAL"></a> <span 
class="pcrr8t-x-x-109">canonical </span>is the most important functionality of the package. It can be
applied on any polynomial whether it is a dummy polynommial or not. It returns a
normal form uniquely determined from the current ordering of the system. If
the polynomial does not contain any dummy index, it is rewriten taking into
account the various operator properties or symmetries described above. For
instance,
                                                                     

                                                                     
</p>
<pre class="verbatim" id="verbatim-1008">
     symtree (r, {!+, {!-, 1, 2}, {!-, 3, 4}});

     aa:=r(x3,x4,x2,x1)$

     canonical aa; ==&#x003E;  - r(x1,x2,x3,x4).
</pre>
<!--l. 247--><p class="nopar" > If it contains dummy indices, <span 
class="pcrr8t-x-x-109">canonical </span>takes also into account the various
dummy summations, makes the relevant simpliﬁcations, eventually rename
the dummy indices and returns the resulting normal form. Here is a simple
example:
                                                                     

                                                                     
</p>
<pre class="verbatim" id="verbatim-1009">
    operator at1,at2;
    anticom at1,at2;

    dummy_names i,j,k; ==&#x003E; t

    show_dummy_names(); ==&#x003E; {i,j,k}

    rr:=at1(i)*at2(k) -at2(k)*at1(i)$


    canonical rr; =&#x003E; 2*at1(i)*at2(j)
</pre>
<!--l. 264--><p class="nopar" > It is important to notice, in the above example, that in addition to the summations over
indices \(i\) and \(k\), and of the anticommutativity property of the operators, <span 
class="pcrr8t-x-x-109">canonical </span>has
replaced the index \(k\) by the index \(j\). This substitution is essential to get full simpliﬁcation.
Several other examples are given in the test ﬁle and, there, the output of <span 
class="pcrr8t-x-x-109">canonical </span>is
explained.
</p><!--l. 272--><p class="noindent" >As stated in the previous section, the dependence of operators on dummy indices is
limited to <span 
class="ptmri8t-x-x-109">ﬁrst </span>level. An erroneous result will be generated if it is not the case as the
subsequent example illustrates:
                                                                     

                                                                     
</p>
<pre class="verbatim" id="verbatim-1010">
    operator op;

    dummy_names i,j;

    rr:=op(i,op(j))-op(j,op(j))$

    canonical rr; ==&#x003E; 0
</pre>
<!--l. 284--><p class="nopar" > Zero is obtained because, in the second term, <span 
class="pcrr8t-x-x-109">canonical </span>has replaced \(j\) by \(i\) but has
left \(op(j)\) unchanged because it <span 
class="ptmri8t-x-x-109">does not recognize </span>the index \(j\) which is inside. This
fact has also the consequence that it is unable to simplify correctly (or at all)
expressions which contain some derivatives. For instance (\(i\) and \(j\) are dummy
indices):
                                                                     

                                                                     
</p>
<pre class="verbatim" id="verbatim-1011">
    aa:=df(op(x,i),x) -df(op(x,j),x)$

    canonical aa; ==&#x003E; df(op(x,i),x) - df(op(x,j),x)
</pre>
<!--l. 295--><p class="nopar" > instead of zero. A second limitation is that <span 
class="pcrr8t-x-x-109">canonical </span>does not add anything to
the problem of simpliﬁcations when side relations (like Bianchi identities) are
present.
</p><!--l. 377--><p class="noindent" >
                                                                     

                                                                     
                                                                     

                                                                     
</p><!--l. 379--><p class="noindent" ><table cellspacing="5"><tr><td class="clinks"><a 
href="../manual-lookup.php%3FUser&#32;Contributed&#32;Packages.html#manualse140.html" >Up</a></td><td class="clinks"><a 
href="manualse141.html" >Next</a></td><td class="clinks"><a 
href="manualse139.html" >Prev</a></td><td class="clinks"><a 
href="manualse139.html#tailmanualse139.html" >PrevTail</a></td><td class="clinks"><a 
href="manualse140.html" >Front</a></td></tr></table><a 
 id="tailmanualse140.html"></a>  <hr> <p style="font-family:sans-serif">Hosted by <a href="https://sourceforge.net/p/reduce-algebra/"> <img title="Download REDUCE" alt="Download REDUCE" style="vertical-align:middle" src="https://sourceforge.net/sflogo.php?type=16&amp;group_id=248416"/></a> <a href="https://www.mathjax.org"> <img title="Powered by MathJax" alt="Powered by MathJax" style="float:right" src="https://www.mathjax.org/badge/badge.gif"/></a></p></p> 
</body> 
</html>