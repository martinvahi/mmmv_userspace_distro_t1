<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"  
  "http://www.w3.org/TR/html4/loose.dtd">  
<html > 
<head><title>Using Inheritance</title> 
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1"> 
<meta name="generator" content="TeX4ht (http://www.cse.ohio-state.edu/~gurari/TeX4ht/)"> 
<meta name="originator" content="TeX4ht (http://www.cse.ohio-state.edu/~gurari/TeX4ht/)"> 
<!-- 3,html --> 
<meta name="src" content="allman1.tex"> 
<meta name="date" content="2014-05-02 18:10:00"> 
<link rel="stylesheet" type="text/css" href="allman1.css"> 
</head><body 
>
<p align="centre"><img src="https://reduce-algebra.sourceforge.io/lisp-docs/redlogo.png" width=621 height=60 border=0 alt="REDUCE"></p><table cellspacing="5"><tr><td class="clinks"><a 
href="allman1li18.html#allman1se85.html" >Up</a></td><td class="clinks"><a 
href="allman1se86.html" >Next</a></td><td class="clinks"><a 
href="allman1se84.html" >Prev</a></td><td class="clinks"><a 
href="allman1se84.html#tailallman1se84.html" >PrevTail</a></td><td class="clinks"><a 
href="allman1se85.html#tailallman1se85.html">Tail</a></td></tr></table><h3 class="sectionHead"><span class="titlemark">19.4    </span> <a 
 id="x106-21500019.4"></a>Using Inheritance</h3>
<!--l. 676--><p class="noindent" >Inheritance is a mechanism that allows a flavor to be defined in terms of other flavors.
This allows objects to be created that are specializations or generalizations of other
objects. The object package supports what is called single inheritance &#8211; only one
flavor can be inherited from by another flavor. The flavor being inherited, however,
could have inherited from one other flavor, and so on. Note that the LISP machine
supports multiple inheritance allowing more than one flavor to be inherited from at a
time.<br 
class="newline" />
<!--l. 686--><p class="noindent" >The best way to explain single inheritance is through an example:<br 
class="newline" />Suppose we have defined the flavor mother and then define the flavor daughter in
which we specified the inheritance-flavor-list to be mother. The inheriting process
causes daughter to contain all the instance variables as well as the methods that were
defined for mother. That is,a daughter object can deal with any of the instance variables
and receive any of the messages defined for flavor mother without having to recreate
them.
<!--l. 694--><p class="noindent" >We refer to flavor mother as the parent of flavor daughter, and daughter as a child of mother.
daughter, in turn, can be the parent of other flavors. Each child inherits the instance variables and
methods of its parent, its parent&#8217;s parent, and so on.
<!--l. 700--><p class="noindent" >When inheriting instance variables, a child flavor has as its instance variables the union of all
those defined for its parents and those specifically defined for the new flavor. As a result, it
would not make sense to give a child flavor an instance variable with the same name as one
in one of its parent&#8217;s. For this reason, duplicate instance variables are flagged as an
error.
<!--l. 708--><p class="noindent" >Inheriting methods, however, is different. It is possible to define a method in a child flavor
with the same name as a method in one of the parents. The effect is to override the
parent&#8217;s method with the child&#8217;s method, as far as the child flavor is concerned. In other
words, when sending a message to an object, the method executed is the first one found
by searching backward from it through its parents. First the methods defined for the
child flavor are searched, then the child&#8217;s parent&#8217;s methods, and so on until one is
found.
<!--l. 718--><p class="noindent" >As an example of overriding methods, the following code defines a flavor geometric-object.
Then, a new flavor square is created with geometric-object as its parent. Finally, a flavor
colored-square is created with square as its parent.

<div class="verbatim" id="verbatim-407">
(defflavor&#x00A0;geometric-object
&#x00A0;<br />&#x00A0;&#x00A0;(name
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;size)
&#x00A0;<br />&#x00A0;&#x00A0;()&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;%&#x00A0;A&#x00A0;flavor&#x00A0;with&#x00A0;no&#x00A0;parents
&#x00A0;<br />&#x00A0;&#x00A0;)
&#x00A0;<br />
&#x00A0;<br />(defmethod&#x00A0;(geometric-object&#x00A0;display)&#x00A0;()
&#x00A0;<br />&#x00A0;&#x00A0;(printf&#x00A0;"%w&#x00A0;is&#x00A0;%w&#x00A0;units&#x00A0;big"&#x00A0;name&#x00A0;size))
&#x00A0;<br />
&#x00A0;<br />(defmethod&#x00A0;(geometric-object&#x00A0;set-name)&#x00A0;(new-name)
&#x00A0;<br />&#x00A0;&#x00A0;(setf&#x00A0;name&#x00A0;new-name))
&#x00A0;<br />
&#x00A0;<br />(defflavor&#x00A0;square
&#x00A0;<br />&#x00A0;&#x00A0;(side-length)
&#x00A0;<br />&#x00A0;&#x00A0;(geometric-object)&#x00A0;&#x00A0;&#x00A0;&#x00A0;%&#x00A0;A&#x00A0;flavor&#x00A0;with&#x00A0;one&#x00A0;parent,&#x00A0;geometric-object
&#x00A0;<br />&#x00A0;&#x00A0;)
&#x00A0;<br />
&#x00A0;<br />%&#x00A0;Overriding&#x00A0;for&#x00A0;square&#x00A0;the&#x00A0;inherited&#x00A0;method&#x00A0;display
&#x00A0;<br />
&#x00A0;<br />(defmethod&#x00A0;(square&#x00A0;display)&#x00A0;()
&#x00A0;<br />&#x00A0;&#x00A0;(printf&#x00A0;"%w&#x00A0;is&#x00A0;a&#x00A0;square,&#x00A0;%w&#x00A0;units&#x00A0;long&#x00A0;on&#x00A0;all&#x00A0;sides"&#x00A0;name
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;side-length))
&#x00A0;<br />
&#x00A0;<br />(defmethod&#x00A0;(square&#x00A0;new-length)&#x00A0;(length)
&#x00A0;<br />&#x00A0;&#x00A0;(setf&#x00A0;side-length&#x00A0;length)
&#x00A0;<br />&#x00A0;&#x00A0;(setf&#x00A0;size&#x00A0;(&#x22C6;&#x00A0;length&#x00A0;length)))
&#x00A0;<br />
&#x00A0;<br />(defflavor&#x00A0;colored-square
&#x00A0;<br />&#x00A0;&#x00A0;(color)
&#x00A0;<br />&#x00A0;&#x00A0;(square)
&#x00A0;<br />&#x00A0;&#x00A0;)
&#x00A0;<br />
&#x00A0;<br />(defmethod&#x00A0;(colored-square&#x00A0;get-color)&#x00A0;()
&#x00A0;<br />&#x00A0;&#x00A0;color)
</div>
<!--l. 758--><p class="nopar" >After the definitions, flavor colored-square has the instance variables:

<div class="verbatim" id="verbatim-408">
&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;color
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;side-length
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;name
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;size
</div>
<!--l. 767--><p class="nopar" >and has the methods:
      <ul class="itemize1">
      <li class="itemize">get-color (as defined for flavor colored-square)
      </li>
      <li class="itemize">new-length (as defined for flavor square)
      </li>
      <li class="itemize">display (as defined for flavor square)
      </li>
      <li class="itemize">set-name (as defined for flavor geometric-object)</li></ul>
<!--l. 778--><p class="noindent" >
<h4 class="subsectionHead"><span class="titlemark">19.4.1    </span> <a 
 id="x106-21600019.4.1"></a>Warning on Inheritance Usage</h4>
<!--l. 780--><p class="noindent" >The Common lisp objects package will be incompatible with the existing objects package as far
as inheritance is concerned. In Common lisp, an inherited instance variable cannot be accessed
by simply referring to it within a method. Also, the way variables are initialized is quite
different.
<!--l. 786--><p class="noindent" >To access inherited instance variables, you must do the equivalent of sending the object a
message to get the instance variable&#8217;s value. For example, referring to the instance variable
banana in a method for the flavor fruit, a reference to banana in PSL becomes something like
(=<span 
class="cmmi-12">&#x003E; </span>self banana) in Common lisp. When you reference inherited instance variables in PSL and
performance is important, you should clearly mark them. If performance is not an issue, make
the instance variables gettable and refer to them by their method. This also applies to settable
instance variables.
<!--l. 797--><p class="noindent" >Uses of the INIT method may also have to be changed because the new objects package
performs object initialization in a different way. Avoid the INIT method if you can, if you can&#8217;t
mark it for change for Common lisp objects.
<!--l. 802--><p class="noindent" >In this way, transition to Common lisp will be much easier.
<!--l. 804--><p class="noindent" >
<h4 class="subsectionHead"><span class="titlemark">19.4.2    </span> <a 
 id="x106-21700019.4.2"></a>Using SELF and MYSELF with Inheritance</h4>
<!--l. 806--><p class="noindent" >Suppose an additional method was defined for flavor geometric-object:

<div class="verbatim" id="verbatim-409">
&#x00A0;&#x00A0;(defmethod&#x00A0;(geometric-object&#x00A0;display-me)&#x00A0;()
&#x00A0;<br />&#x00A0;&#x00A0;(=&#x003E;&#x00A0;self&#x00A0;display))
</div>
<!--l. 812--><p class="nopar" >Now suppose a display-me message is sent to an object of type square. Which method for the
message &#8217;display&#8217; should be used by display-me? Should it look up the method in the context of
the flavor where the method was defined (geometric-object) or the context of the flavor that
received the original message (square)? The answer is to provide a new symbol, MYSELF.
MYSELF means to look up messages in the context of the object that received the original
message. SELF looks up methods in the context of the flavor it is defined in. If display-me was
rewritten as:

<div class="verbatim" id="verbatim-410">
(defmethod&#x00A0;(geometric-object&#x00A0;display-me)&#x00A0;()
&#x00A0;<br />&#x00A0;&#x00A0;(=&#x003E;&#x00A0;self&#x00A0;display)
&#x00A0;<br />&#x00A0;&#x00A0;(=&#x003E;&#x00A0;myself&#x00A0;display))
</div>
<!--l. 827--><p class="nopar" >and sent to an object of flavor square, then the first display would be that defined in
geometric-object, and the second would be the one defined for square. If the display-me
message was sent to an object of flavor geometric-object, self and myself would be
identical.
<!--l. 834--><p class="noindent" >
<h4 class="subsectionHead"><span class="titlemark">19.4.3    </span> <a 
 id="x106-21800019.4.3"></a>Inheritance and Initialization</h4>
<!--l. 836--><p class="noindent" >You may have noticed that there is ambiguity in the order a newly created object is initialized
when the object uses inheritance. When inheritance is used, initialization is performed as
describe above with the following additions:
<!--l. 841--><p class="noindent" >When the son flavor&#8217;s (i.e., the flavor given in the make-instance or instantiate-flavor
call) DEFAULT-INIT method is executed, the first thing it does is call its father&#8217;s
DEFAULT-INIT method. The second thing it does is execute its father&#8217;s INIT method, if it
exists.
<!--l. 847--><p class="noindent" >Notice that if the father flavor used inheritance, its DEFAULT-INIT method would first call its
grandfather&#8217;s DEFAULT-INIT and INIT methods, and so on.
<!--l. 851--><p class="noindent" >
<h4 class="subsectionHead"><span class="titlemark">19.4.4    </span> <a 
 id="x106-21900019.4.4"></a>Making Changes to Inherited Code</h4>
<!--l. 853--><p class="noindent" >The inheritance scheme used in this facility is static &#8211; all of the work is done at compile-time.
This has some implications for compiling object definitions that use inheritance:
      <ul class="itemize1">
      <li class="itemize">All of the parents of a flavor must be loaded or compiled before compiling the new
      child&#8217;s definitions. If this is not the case, an error message will be issued.
      </li>
      <li class="itemize">If a change is made to a parent flavor, including the addition of a new method or
      changing instance variables, all of the children will have to be recompiled to use
      it. You do not have to recompile the children, however, if an existing method of a
      parent is redefined.</li></ul>

<!--l. 868--><p class="noindent" ><table cellspacing="5"><tr><td class="clinks"><a 
href="allman1li18.html#allman1se85.html" >Up</a></td><td class="clinks"><a 
href="allman1se86.html" >Next</a></td><td class="clinks"><a 
href="allman1se84.html" >Prev</a></td><td class="clinks"><a 
href="allman1se84.html#tailallman1se84.html" >PrevTail</a></td><td class="clinks"><a 
href="allman1se85.html" >Front</a></td></tr></table><a 
 id="tailallman1se85.html"></a>   
</body></html> 
