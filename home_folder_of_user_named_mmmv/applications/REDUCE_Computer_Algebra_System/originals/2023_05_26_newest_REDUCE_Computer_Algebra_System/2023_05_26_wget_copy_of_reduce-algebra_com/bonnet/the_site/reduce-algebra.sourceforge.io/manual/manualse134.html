<!DOCTYPE html> 
<html lang="en-US" xml:lang="en-US" > 
<head><title>CDIFF: A Package for Computations in Geometry of Diﬀerential Equations</title> 
<meta  charset="utf-8" /> 
<meta name="generator" content="TeX4ht (https://tug.org/tex4ht/)" /> 
<meta name="viewport" content="width=device-width,initial-scale=1" /> 
<link rel="stylesheet" type="text/css" href="manual.css" /> 
<meta name="src" content="manual.tex" /> 
<script>window.MathJax = { tex: { tags: "ams", }, }; </script> 
 <script type="text/javascript" async="async" id="MathJax-script" src="../../cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js"></script>  
<meta name="description" content="The REDUCE Computer Algebra System User's Manual" /> 
</head><body 
>
<header>REDUCE</header><table cellspacing="5"><tr><td class="clinks"><a 
href="../manual-lookup.php%3FUser&#32;Contributed&#32;Packages.html#manualse134.html" >Up</a></td><td class="clinks"><a 
href="manualse135.html" >Next</a></td><td class="clinks"><a 
href="manualse133.html" >Prev</a></td><td class="clinks"><a 
href="manualse133.html#tailmanualse133.html" >PrevTail</a></td><td class="clinks"><a 
href="manualse134.html#tailmanualse134.html">Tail</a></td></tr></table><h3 class="sectionHead"><span class="titlemark">20.11    </span> <a 
 id="x198-47300020.11"></a>CDIFF: A Package for Computations in Geometry of
Diﬀerential Equations</h3>
<a 
 id="dx198-473001"></a>
<a 
 id="dx198-473002"></a>
<!--l. 239--><p class="noindent" >Authors: P. Gragert, P.H.M. Kersten, G. Post and G. Roelofs.
<a 
 id="dx198-473003"></a>
<a 
 id="dx198-473004"></a>
<a 
 id="dx198-473005"></a>
<a 
 id="dx198-473006"></a>
<a 
 id="dx198-473007"></a>
<a 
 id="dx198-473008"></a>
<a 
 id="dx198-473009"></a>
<a 
 id="dx198-473010"></a>
<a 
 id="dx198-473011"></a>
<a 
 id="dx198-473012"></a>
</p><!--l. 41--><p class="noindent" >\( \newcommand {\pd }[2]{\mathchoice {\frac {\partial {#1}}{\partial {#2}}} {\partial {#1}/\partial {#2}}{\partial {#1}/\partial {#2}} {\partial {#1}/\partial {#2}}} \)Author of this Section: R. Vitolo.
</p><!--l. 54--><p class="noindent" >We describe CDIFF, a Reduce package for computations in geometry of Diﬀerential
Equations (DEs, for short) developed by P. Gragert, P.H.M. Kersten, G. Post and
G. Roelofs from the University of Twente, The Netherlands.
</p><!--l. 59--><p class="noindent" >The package is part of the oﬃcial REDUCE distribution at Sourceforge <span class="cite">[<a 
href="manualap2.html#XReduce:Obtaining">Red</a>]</span>,
but it is also distributed on the Geometry of Diﬀerential Equations web site
<a 
href="http://gdeq.org" class="url" ><span 
class="pcrr8t-x-x-109">http://gdeq.org</span></a> (GDEQ for short).
</p><!--l. 63--><p class="noindent" >We start from an installation guide for Linux and Windows. Then we focus on concrete
usage recipes for the computation of higher symmetries, conservation laws, Hamiltonian
and recursion operators for polynomial diﬀerential equations. All programs discussed
here are shipped together with this manual and can be found at the GDEQ website.
The mathematical theory on which computations are based can be found in
refs. <span class="cite">[<a 
href="manualap2.html#XKrasilshchik:99">BCD\(^{+}\)99</a>, <a 
href="manualap2.html#XKerstenKrasilshchikVerboretsky:2004">KKV04</a>]</span>.
</p><!--l. 70--><p class="noindent" ><span 
class="ptmb8t-x-x-109">NOTE: </span>The new REDUCE package <span 
class="ptmrc8t-x-x-109">C<span 
class="small-caps">D</span><span 
class="small-caps">E</span> </span><span class="cite">[<a 
href="manualap2.html#XVitolo:CDE">Vit</a>]</span>, also distributed on <a 
href="http://gdeq.org" class="url" ><span 
class="pcrr8t-x-x-109">http://gdeq.org</span></a>,
simpliﬁes the use of CDIFF and extends its capabilities. Interested users may read the
manual of <span 
class="ptmrc8t-x-x-109">C<span 
class="small-caps">D</span><span 
class="small-caps">E</span> </span>where the same computations described here for CDIFF are done in a
simpler way, and further capabilities allow <span 
class="ptmrc8t-x-x-109">C<span 
class="small-caps">D</span><span 
class="small-caps">E</span> </span>to solve a greater variety of
problems.
                                                                     

                                                                     
</p><!--l. 79--><p class="noindent" >
</p>
<h4 class="subsectionHead"><span class="titlemark">20.11.1    </span> <a 
 id="x198-47400020.11.1"></a>Introduction</h4>
<!--l. 81--><p class="noindent" >This brief guide refers to using CDIFF, a set of symbolic computation programs devoted
to computations in geometry of DEs and developed by P. Gragert, P.H.M. Kersten, G.
Post and G. Roelofs at the University of Twente, The Netherlands.
</p><!--l. 86--><p class="noindent" >Initially, the development of the CDIFF packages was started by Gragert and Kersten for
symmetry computations in DEs, then they have been partly rewritten and extended by
Roelofs and Post. The CDIFF packages consist of 3 program ﬁles plus a utility ﬁle; only
the main three ﬁles are documented <span class="cite">[<a 
href="manualap2.html#XRoelofs:92">Roe92b</a>, <a 
href="manualap2.html#XRoelofs:92a">Roe92a</a>, <a 
href="manualap2.html#XPost:96">Pos96</a>]</span>. The CDIFF
packages, as well as a copy of the documentation (including this manual) and
several example programs, can be found both at Sourceforge in the sources of
REDUCE <span class="cite">[<a 
href="manualap2.html#XReduce:Obtaining">Red</a>]</span> and in the Geometry of Diﬀerential Equations (GDEQ for short)
web site <span class="cite">[<a 
href="manualap2.html#Xgdeq">gde</a>]</span>. The name of the packages, CDIFF, comes from the fact that the
package is aimed at deﬁning diﬀerential operators in total derivatives and do
computations involving them. Such operators are called \(\mathcal {C}\)<span 
class="ptmri8t-x-x-109">-diﬀerential operators </span>(see
<span class="cite">[<a 
href="manualap2.html#XKrasilshchik:99">BCD\(^{+}\)99</a>]</span>).
</p><!--l. 99--><p class="noindent" >The main motivation for writing this manual was that REDUCE 3.8 recently became free
software, and can be downloaded here <span class="cite">[<a 
href="manualap2.html#XReduce:Obtaining">Red</a>]</span>. For this reason, we are able to make
our computations accessible to a wider public, also thanks to the inclusion of
CDIFF in the oﬃcial REDUCE distribution. The readers are warmly invited to
send questions, comments, etc., both on the computations and on the technical
aspects of installation and conﬁguration of REDUCE, to the author of the present
manual.
</p><!--l. 107--><p class="noindent" ><span 
class="ptmb8t-x-x-109">Acknowledgements. </span>My warmest thanks are for Paul H.M. Kersten, who explained to
me how to use the CDIFF packages for several computations of interest in the Geometry
of Diﬀerential Equations. I also would like to thank I.S. Krasil’shchik and A.M.
Verbovetsky for constant support and stimulating discussions which led me to write this
text.
</p><!--l. 113--><p class="noindent" >
</p>
<h4 class="subsectionHead"><span class="titlemark">20.11.2    </span> <a 
 id="x198-47500020.11.2"></a>Computing with CDIFF</h4>
<!--l. 115--><p class="noindent" >In order to use CDIFF it is necessary to load the package by the command
                                                                     

                                                                     
</p>
<pre class="verbatim" id="verbatim-904">
load_package cdiff;
</pre>
<!--l. 118--><p class="nopar" >
</p><!--l. 120--><p class="noindent" >All programs that we will discuss in this manual can be found inside the subfolder
<span 
class="pcrr8t-x-x-109">examples </span>in the folder which contains this manual. In order to run them just
do
                                                                     

                                                                     
</p>
<pre class="verbatim" id="verbatim-905">
in &#x0022;filename.red&#x0022;;
</pre>
<!--l. 125--><p class="nopar" > at the REDUCE command prompt.
</p><!--l. 128--><p class="noindent" >There are some conventions that I adopted on writing programs which use CDIFF.
</p>
     <ul class="itemize1">
     <li class="itemize">
     <!--l. 130--><p class="noindent" >Program  ﬁles  have  the  extension  <span 
class="pcrr8t-x-x-109">.red</span>.  This  will  load  automatically
     the  reduce-ide  mode  in  emacs  (provided  you  made  the  installation  steps
     described in the reduce-ide guides).
     </p></li>
     <li class="itemize">
     <!--l. 133--><p class="noindent" >Program ﬁles have the following names: </p>
     <div class="center" 
>
<!--l. 134--><p class="noindent" >
</p><!--l. 135--><p class="noindent" ><span 
class="pcrr8t-x-x-109">equationname_typeofcomputation_version.red</span></p></div>
     <!--l. 137--><p class="noindent" >where <span 
class="pcrr8t-x-x-109">equationname </span>stands for the shortened name of the equation (<span 
class="ptmri8t-x-x-109">e.g.</span>
     Korteweg–de Vries is always indicated by KdV), <span 
class="pcrr8t-x-x-109">typeofcomputation </span>stands
     for the type of geometric object which is computed with the given ﬁle, for
     example symmetries, Hamiltonian operators, etc., <span 
class="pcrr8t-x-x-109">version </span>is a version
     number.
     </p></li>
     <li class="itemize">
     <!--l. 142--><p class="noindent" >More speciﬁc information, like the date and more details on the computation done
     in each version, are included as comment lines at the very beginning of each
     ﬁle.</p></li></ul>
<!--l. 147--><p class="noindent" >Now we describe some examples of computations with CDIFF. The parts of examples
which are shared between all examples are described only once. We stress that all
computations presented in this document are included in the oﬃcial REDUCE
distribution and can be also downloaded at the GDEQ website <span class="cite">[<a 
href="manualap2.html#Xgdeq">gde</a>]</span>. The examples can
                                                                     

                                                                     
be run with REDUCE by typing <span 
class="pcrr8t-x-x-109">in &#x0022;program.red&#x0022;; </span>at the REDUCE prompt, as
explained above.
</p><!--l. 154--><p class="noindent" ><span 
class="ptmb8t-x-x-109">Remark. </span>The mathematical theories on which the computations are based can be found
in <span class="cite">[<a 
href="manualap2.html#XKrasilshchik:99">BCD\(^{+}\)99</a>, <a 
href="manualap2.html#XKerstenKrasilshchikVerboretsky:2004">KKV04</a>]</span>.
</p><!--l. 157--><p class="noindent" >
</p>
<h5 class="subsubsectionHead"><a 
 id="x198-47600020.11.2"></a>Higher symmetries</h5>
<!--l. 159--><p class="noindent" >In this section we show the computation of (some) higher symmetries of Burgers’
equation \(B=u_t-u_{xx}+2uu_x=0\). The corresponding ﬁle is <span 
class="pcrr8t-x-x-109">Burg_hsym_1.red </span>and the results of the
computation are in <span 
class="pcrr8t-x-x-109">Burg_hsym_1_res.red</span>.
</p><!--l. 164--><p class="noindent" >The idea underlying this computation is that one can use the scale symmetries of
Burgers’ equation to assign “gradings” to each variable appearing in the equation. As a
consequence, one could try diﬀerent ansatz for symmetries with polynomial generating
function. For example, it is possible to require that they are sum of monomials of given
degrees. This ansatz yields a simpliﬁcation of the equations for symmetries, because it is
possible to solve them in a “graded” way, <span 
class="ptmri8t-x-x-109">i.e.</span>, it is possible to split them into several
equations made by the homogeneous components of the equation for symmetries with
respect to gradings.
</p><!--l. 174--><p class="noindent" >In particular, Burgers’ equation translates into the following dimensional equation: \[ [u_t]=[u_{xx}],\quad [u_{xx}=2uu_x]. \] By
the rules \([u_z]=[u]-[z]\) and \([uv]=[u]+[v]\), and choosing \([x]=-1\), we have \([u]=1\) and \([t]=-2\). This will be used to generate the list of
homogeneous monomials of given grading to be used in the ansatz about the structure of
the generating function of the symmetries.
</p><!--l. 184--><p class="noindent" >The following instructions initialize the total derivatives. The ﬁrst string is the name of
the vector ﬁeld, the second item is the list of even variables (note that <span 
class="pcrr8t-x-x-109">u1</span>, <span 
class="pcrr8t-x-x-109">u2</span>, ... are \(u_x\), \(u_{xx}\), …),
the third item is the list of odd (non-commuting) variables (‘ext’ stands for ‘external’
like in external (wedge) product). Note that in this example odd variables are
not strictly needed, but it is better to insert some of them for syntax reasons.
<a 
 id="dx198-476001"></a> <a 
 id="operator:SUPER_VECTORFIELD"></a>
                                                                     

                                                                     
</p>
<pre class="verbatim" id="verbatim-906">
super_vectorfield(ddx,{x,t,u,u1,u2,u3,u4,u5,u6,u7,
u8,u9,u10,u11,u12,u13,u14,u15,u16,u17},
{ext 1,ext 2,ext 3,ext 4,ext 5,ext 6,ext 7,ext 8,ext 9,
ext 10,ext 11,ext 12,ext 13,ext 14,ext 15,ext 16,ext 17,
ext 18,ext 19,ext 20,ext 21,ext 22,ext 23,ext 24,ext 25,
ext 26,ext 27,ext 28,ext 29,ext 30,ext 31,ext 32,ext 33,
ext 34,ext 35,ext 36,ext 37,ext 38,ext 39,ext 40,ext 41,
ext 42,ext 43,ext 44,ext 45,ext 46,ext 47,ext 48,ext 49,
ext 50,ext 51,ext 52,ext 53,ext 54,ext 55,ext 56,ext 57,
ext 58,ext 59,ext 60,ext 61,ext 62,ext 63,ext 64,ext 65,
ext 66,ext 67,ext 68,ext 69,ext 70,ext 71,ext 72,ext 73,
ext 74,ext 75,ext 76,ext 77,ext 78,ext 79,ext 80
});
</pre>
<!--l. 206--><p class="nopar" >
                                                                     

                                                                     
</p>
<pre class="verbatim" id="verbatim-907">
super_vectorfield(ddt,{x,t,u,u1,u2,u3,u4,u5,u6,u7,
u8,u9,u10,u11,u12,u13,u14,u15,u16,u17},
{ext 1,ext 2,ext 3,ext 4,ext 5,ext 6,ext 7,ext 8,ext 9,
ext 10,ext 11,ext 12,ext 13,ext 14,ext 15,ext 16,ext 17,
ext 18,ext 19,ext 20,ext 21,ext 22,ext 23,ext 24,ext 25,
ext 26,ext 27,ext 28,ext 29,ext 30,ext 31,ext 32,ext 33,
ext 34,ext 35,ext 36,ext 37,ext 38,ext 39,ext 40,ext 41,
ext 42,ext 43,ext 44,ext 45,ext 46,ext 47,ext 48,ext 49,
ext 50,ext 51,ext 52,ext 53,ext 54,ext 55,ext 56,ext 57,
ext 58,ext 59,ext 60,ext 61,ext 62,ext 63,ext 64,ext 65,
ext 66,ext 67,ext 68,ext 69,ext 70,ext 71,ext 72,ext 73,
ext 74,ext 75,ext 76,ext 77,ext 78,ext 79,ext 80
});
</pre>
<!--l. 222--><p class="nopar" >
</p><!--l. 224--><p class="noindent" >Speciﬁcation of the vectorﬁeld <span 
class="pcrr8t-x-x-109">ddx</span>. The meaning of the ﬁrst index is the parity of
variables. In particular here we have just even variables. The second index parametrizes
the second item (list) in the <span 
class="pcrr8t-x-x-109">super_vectorfield </span>declaration. More precisely,
<span 
class="pcrr8t-x-x-109">ddx(0,1) </span>stands for \(\pd {}{x}\), <span 
class="pcrr8t-x-x-109">ddx(0,2) </span>stands for \(\pd {}{t}\), <span 
class="pcrr8t-x-x-109">ddx(0,3) </span>stands for \(\pd {}{u}\), <span 
class="pcrr8t-x-x-109">ddx(0,4)</span>
stands for \(\pd {}{u_x}\), …, and all coordinates \(x\), \(t\), \(u_x\), …, are treated as even coordinates. Note that <span 
class="pcrr8t-x-x-109">‘$’</span>
suppresses the output.
                                                                     

                                                                     
</p>
<pre class="verbatim" id="verbatim-908">
ddx(0,1):=1$
ddx(0,2):=0$
ddx(0,3):=u1$
ddx(0,4):=u2$
ddx(0,5):=u3$
ddx(0,6):=u4$
ddx(0,7):=u5$
ddx(0,8):=u6$
ddx(0,9):=u7$
ddx(0,10):=u8$
ddx(0,11):=u9$
ddx(0,12):=u10$
ddx(0,13):=u11$
ddx(0,14):=u12$
ddx(0,15):=u13$
ddx(0,16):=u14$
ddx(0,17):=u15$
ddx(0,18):=u16$
ddx(0,19):=u17$
ddx(0,20):=letop$
</pre>
<!--l. 253--><p class="nopar" > The string <span 
class="pcrr8t-x-x-109">letop </span>is treated as a variable; if it appears during computations it is likely
that we went too close to the highest order variables that we deﬁned in the ﬁle. This
could mean that we need to extend the operators and variable list. In case of
large output, one can search in it the string <span 
class="pcrr8t-x-x-109">letop </span>to check whether errors
occurred.
</p><!--l. 260--><p class="noindent" >Speciﬁcation of the vectorﬁeld <span 
class="pcrr8t-x-x-109">ddt</span>. In the evolutionary case we never have more than
one time derivative, other derivatives are \(u_{txxx\cdots }\).
                                                                     

                                                                     
</p>
<pre class="verbatim" id="verbatim-909">
ddt(0,1):=0$
ddt(0,2):=1$
ddt(0,3):=ut$
ddt(0,4):=ut1$
ddt(0,5):=ut2$
ddt(0,6):=ut3$
ddt(0,7):=ut4$
ddt(0,8):=ut5$
ddt(0,9):=ut6$
ddt(0,10):=ut7$
ddt(0,11):=ut8$
ddt(0,12):=ut9$
ddt(0,13):=ut10$
ddt(0,14):=ut11$
ddt(0,15):=ut12$
ddt(0,16):=ut13$
ddt(0,17):=ut14$
ddt(0,18):=letop$
ddt(0,19):=letop$
sddt(0,20):=letop$
</pre>
<!--l. 284--><p class="nopar" >
</p><!--l. 286--><p class="noindent" >We now give the equation in the form one of the derivatives equated to a right-hand side expression.
The left-hand side derivative is called <span 
class="ptmri8t-x-x-109">principal</span>, and the remaining derivatives are called
<span 
class="ptmri8t-x-x-109">parametric</span><span class="footnote-mark"><a 
href="manual199.html#fn25x20"><sup class="textsuperscript">25</sup></a></span><a 
 id="x198-476002f25"></a> .
For scalar evolutionary equations with two independent variables internal variables are of
the type \((t,x,u,u_x,u_{xx},\ldots )\).
                                                                     

                                                                     
</p>
<pre class="verbatim" id="verbatim-910">
ut:=u2+2*u*u1;
</pre>
<!--l. 295--><p class="nopar" >
                                                                     

                                                                     
</p>
<pre class="verbatim" id="verbatim-911">
ut1:=ddx ut;
ut2:=ddx ut1;
ut3:=ddx ut2;
ut4:=ddx ut3;
ut5:=ddx ut4;
ut6:=ddx ut5;
ut7:=ddx ut6;
ut8:=ddx ut7;
ut9:=ddx ut8;
ut10:=ddx ut9;
ut11:=ddx ut10;
ut12:=ddx ut11;
ut13:=ddx ut12;
ut14:=ddx ut13;
</pre>
<!--l. 312--><p class="nopar" >
</p><!--l. 314--><p class="noindent" >Test for verifying the commutation of total derivatives. Highest order deﬁned terms may
yield some <span 
class="pcrr8t-x-x-109">letop</span>.
                                                                     

                                                                     
</p>
<pre class="verbatim" id="verbatim-912">
operator ev;

for i:=1:17 do write ev(0,i):=ddt(ddx(0,i))-ddx(ddt(0,i));
</pre>
<!--l. 320--><p class="nopar" >
</p><!--l. 322--><p class="noindent" >This is the list of variables with respect to their grading, starting from degree <span 
class="ptmri8t-x-x-109">one</span>.
<a 
 id="dx198-476003"></a> <a 
 id="variable:ALL_GRADED_DER"></a>
                                                                     

                                                                     
</p>
<pre class="verbatim" id="verbatim-913">
all_graded_der:={{u},{u1},{u2},{u3},{u4},{u5},
 {u6},{u7},{u8},{u9},{u10},{u11},{u12},{u13},{u14},{u15},
 {u16},{u17}};
</pre>
<!--l. 330--><p class="nopar" >
</p><!--l. 332--><p class="noindent" >This is the list of all monomials of degree \(0\), \(1\), \(2\), …which can be constructed from the above
list of elementary variables with their grading. <a 
 id="dx198-476004"></a> <a 
 id="operator:MKVARLIST1"></a>
                                                                     

                                                                     
</p>
<pre class="verbatim" id="verbatim-914">
grd0:={1};
grd1:= mkvarlist1(1,1)$
grd2:= mkvarlist1(2,2)$
grd3:= mkvarlist1(3,3)$
grd4:= mkvarlist1(4,4)$
grd5:= mkvarlist1(5,5)$
grd6:= mkvarlist1(6,6)$
grd7:= mkvarlist1(7,7)$
grd8:= mkvarlist1(8,8)$
grd9:= mkvarlist1(9,9)$
grd10:= mkvarlist1(10,10)$
grd11:= mkvarlist1(11,11)$
grd12:= mkvarlist1(12,12)$
grd13:= mkvarlist1(13,13)$
grd14:= mkvarlist1(14,14)$
grd15:= mkvarlist1(15,15)$
grd16:= mkvarlist1(16,16)$
</pre>
<!--l. 354--><p class="nopar" >
</p><!--l. 356--><p class="noindent" >Initialize a counter <span 
class="pcrr8t-x-x-109">ctel </span>for arbitrary constants <span 
class="pcrr8t-x-x-109">c</span>; initialize equations:
                                                                     

                                                                     
</p>
<pre class="verbatim" id="verbatim-915">
operator c,equ;

ctel:=0;
</pre>
<!--l. 362--><p class="nopar" >
</p><!--l. 364--><p class="noindent" >We assume a generating function <span 
class="pcrr8t-x-x-109">sym</span>, <span 
class="ptmri8t-x-x-109">independent of</span> \(x\) <span 
class="ptmri8t-x-x-109">and</span> \(t\), of degree \(\leq 5\).
                                                                     

                                                                     
</p>
<pre class="verbatim" id="verbatim-916">
sym:=
(for each el in grd0 sum (c(ctel:=ctel+1)*el))+
(for each el in grd1 sum (c(ctel:=ctel+1)*el))+
(for each el in grd2 sum (c(ctel:=ctel+1)*el))+
(for each el in grd3 sum (c(ctel:=ctel+1)*el))+
(for each el in grd4 sum (c(ctel:=ctel+1)*el))+
(for each el in grd5 sum (c(ctel:=ctel+1)*el))$
</pre>
<!--l. 374--><p class="nopar" >
</p><!--l. 376--><p class="noindent" >This is the equation \(\bar \ell _B(\mathtt {sym})=0\), where \(B=0\) is Burgers’ equation and <span 
class="pcrr8t-x-x-109">sym </span>is the generating
function. From now on all equations are arranged in a single vector whose name is
<span 
class="pcrr8t-x-x-109">equ</span>.
                                                                     

                                                                     
</p>
<pre class="verbatim" id="verbatim-917">
equ 1:=ddt(sym)-ddx(ddx(sym))-2*u*ddx(sym)-2*u1*sym ;
</pre>
<!--l. 381--><p class="nopar" >
</p><!--l. 383--><p class="noindent" >This is the list of variables, to be passed to the equation solver.
                                                                     

                                                                     
</p>
<pre class="verbatim" id="verbatim-918">
vars:={x,t,u,u1,u2,u3,u4,u5,u6,u7,u8,u9,u10,u11,
u12,u13,u14,u15,u16,u17};
</pre>
<!--l. 387--><p class="nopar" >
</p><!--l. 389--><p class="noindent" >This is the number of initial equation(s)
                                                                     

                                                                     
</p>
<pre class="verbatim" id="verbatim-919">
tel:=1;
</pre>
<!--l. 392--><p class="nopar" >
<a 
 id="dx198-476005"></a>
</p><!--l. 395--><p class="noindent" ><a 
 id="operator:MULTI_COEFF"></a> The following procedure uses <span 
class="pcrr8t-x-x-109">multi_coeff </span>(from the package <span 
class="pcrr8t-x-x-109">tools</span>). It gets all
coeﬃcients of monomials appearing in the initial equation(s). The coeﬃcients are put
into the vector <span 
class="pcrr8t-x-x-109">equ </span>after the initial equations.
                                                                     

                                                                     
</p>
<pre class="verbatim" id="verbatim-920">
procedure splitvars i;
begin;
ll:=multi_coeff(equ i,vars);
equ(tel:=tel+1):=first ll;
ll:=rest ll;
for each el in ll do equ(tel:=tel+1):=second el;
end;
</pre>
<!--l. 408--><p class="nopar" >
</p><!--l. 410--><p class="noindent" >This command initializes the equation solver. It passes </p>
     <ul class="itemize1">
     <li class="itemize">
     <!--l. 412--><p class="noindent" >the equation vector <span 
class="pcrr8t-x-x-109">equ </span>togeher with its length <span 
class="pcrr8t-x-x-109">tel </span>(<span 
class="ptmri8t-x-x-109">i.e.</span>, the total number
     of equations);
     </p></li>
     <li class="itemize">
     <!--l. 414--><p class="noindent" >the  list  of  variables  with  respect  to  which  the  system  <span 
class="ptmri8t-x-x-109">must  not  </span>split  the
     equations,  <span 
class="ptmri8t-x-x-109">i.e.</span>,  variables  with  respect  to  which  the  unknowns  are  not
     polynomial. In this case this list is just \(\{\}\);
     </p></li>
     <li class="itemize">
     <!--l. 417--><p class="noindent" >the constants’vector <span 
class="pcrr8t-x-x-109">c</span>, its length <span 
class="pcrr8t-x-x-109">ctel</span>, and the number of negative indexes
     if any; just \(\texttt {0}\) in our example;
     </p></li>
     <li class="itemize">
     <!--l. 419--><p class="noindent" >the vector of free functions <span 
class="pcrr8t-x-x-109">f </span>that may appear in computations. Note that in
     \(\{\)<span 
class="pcrr8t-x-x-109">f,0,0</span> \(\}\) the second \(\texttt {0}\) stands for the length of the vector of free functions. In
     this example there are no free functions, but the command needs the presence
     of at least a dummy argument, <span 
class="pcrr8t-x-x-109">f </span>in this case. There is also a last zero which
     is the negative length of the vector \(f\), just as for constants.</p></li></ul>
<a 
 id="dx198-476006"></a>
<!--l. 427--><p class="noindent" ><a 
 id="operator:CDIFF_INITIALIZE_EQUATIONS"></a>
                                                                     

                                                                     
</p>
<pre class="verbatim" id="verbatim-921">
initialize_equations(equ,tel,{},{c,ctel,0},{f,0,0});
</pre>
<!--l. 430--><p class="nopar" >
</p><!--l. 432--><p class="noindent" >Run the procedure splitvars in order to obtain equations on coeﬃciens of each
monomial.
                                                                     

                                                                     
</p>
<pre class="verbatim" id="verbatim-922">
splitvars 1;
</pre>
<!--l. 436--><p class="nopar" >
</p><!--l. 438--><p class="noindent" >Next command tells the solver the total number of equations obtained after running
splitvars. <a 
 id="dx198-476007"></a> <a 
 id="operator:CDIFF_PUT_EQUATIONS_USED"></a>
                                                                     

                                                                     
</p>
<pre class="verbatim" id="verbatim-923">
put_equations_used tel;
</pre>
<!--l. 444--><p class="nopar" >
</p><!--l. 446--><p class="noindent" >It is worth to write down the equations for the coeﬃcients.
                                                                     

                                                                     
</p>
<pre class="verbatim" id="verbatim-924">
for i:=2:tel do write equ i;
</pre>
<!--l. 449--><p class="nopar" >
</p><!--l. 451--><p class="noindent" >This command solves the equations for the coeﬃcients. Note that we have to skip the
initial equations! <a 
 id="dx198-476008"></a> <a 
 id="operator:CDIFF_INTEGRATE_EQUATION"></a>
                                                                     

                                                                     
</p>
<pre class="verbatim" id="verbatim-925">
for i:=2:tel do integrate_equation i;
;end;
</pre>
<!--l. 458--><p class="nopar" >
</p><!--l. 460--><p class="noindent" >In the folder <span 
class="pcrr8t-x-x-109">computations/NewTests/Higher_symmetries </span>it is possible to
ﬁnd the following ﬁles:
     </p><dl class="description"><dt class="description">
     <!--l. 463--><p class="noindent" >
<span 
class="ptmb8t-x-x-109">Burg_hsym_1.red</span> </p></dt><dd 
class="description">
     <!--l. 463--><p class="noindent" >The above ﬁle, together with its results ﬁle.
     </p></dd><dt class="description">
     <!--l. 464--><p class="noindent" >
<span 
class="ptmb8t-x-x-109">KdV_hsym_1.red</span> </p></dt><dd 
class="description">
     <!--l. 464--><p class="noindent" >Higher symmetries of KdV, with the ansatz: deg(sym) \(\leq \) 5.
     </p></dd><dt class="description">
     <!--l. 466--><p class="noindent" >
<span 
class="ptmb8t-x-x-109">KdV_hsym_2.red</span> </p></dt><dd 
class="description">
     <!--l. 466--><p class="noindent" >Higher symmetries of KdV, with the ansatz: </p>
     <div class="center" 
>
<!--l. 467--><p class="noindent" >
</p><!--l. 468--><p class="noindent" >sym = x*(something of degree 3) + t*(something of degree 5)<br />
+ (something of degree 2).</p></div>
     <!--l. 471--><p class="noindent" >This yields scale symmetries.
     </p></dd><dt class="description">
     <!--l. 472--><p class="noindent" >
<span 
class="ptmb8t-x-x-109">KdV_hsym_3.red</span> </p></dt><dd 
class="description">
     <!--l. 472--><p class="noindent" >Higher symmetries of KdV, with the ansatz: </p>
                                                                     

                                                                     
     <div class="center" 
>
<!--l. 473--><p class="noindent" >
</p><!--l. 474--><p class="noindent" >sym = x*(something of degree 1) + t*(something of degree 3)<br />
+ (something of degree 0).</p></div>
     <!--l. 477--><p class="noindent" >This yields Galilean boosts.</p></dd></dl>
<h5 class="subsubsectionHead"><a 
 id="x198-47700020.11.2"></a>Local conservation laws</h5>
<!--l. 483--><p class="noindent" >In this section we will ﬁnd (some) local conservation laws for the KdV equation \(F=u_t-u_{xxx}+uu_x=0\).
Concretely, we have to ﬁnd non-trivial \(1\)-forms \(f=f_xdx+f_tdt\) on \(F=0\) such that \(\bar d f=0\) on \(F=0\). “Triviality” of
conservation laws is a delicate matter, for which we invite the reader to have a look in
<span class="cite">[<a 
href="manualap2.html#XKrasilshchik:99">BCD\(^{+}\)99</a>]</span>.
</p><!--l. 489--><p class="noindent" >The ﬁles containing this example is <span 
class="pcrr8t-x-x-109">KdV_loc-cl_1.red, KdV_loc-cl_2.red</span>
and the corresponding results ﬁles.
</p><!--l. 492--><p class="noindent" >We make use of <span 
class="pcrr8t-x-x-109">ddx </span>and <span 
class="pcrr8t-x-x-109">ddt</span>, which in the even part are the same as in the previous
example (subsection <a 
href="manualse134.html#x198-47600020.11.2">20.11.2<!--tex4ht:ref: sec:higher-symmetries --></a>). After deﬁning the total derivatives we prepare the list of
graded variables (recall that in KdV \(u\) is of degree \(2\)):
                                                                     

                                                                     
</p>
<pre class="verbatim" id="verbatim-926">
all_graded_der:={{},{u},{u1},{u2},{u3},{u4},{u5},
 {u6},{u7},{u8},{u9},{u10},{u11},{u12},{u13},{u14},
 {u15},{u16},{u17}};
</pre>
<!--l. 500--><p class="nopar" > We make the ansatz
                                                                     

                                                                     
</p>
<pre class="verbatim" id="verbatim-927">
fx:=
(for each el in grd0 sum (c(ctel:=ctel+1)*el))+
(for each el in grd1 sum (c(ctel:=ctel+1)*el))+
(for each el in grd2 sum (c(ctel:=ctel+1)*el))+
(for each el in grd3 sum (c(ctel:=ctel+1)*el))$
ft:=
(for each el in grd2 sum (c(ctel:=ctel+1)*el))+
(for each el in grd3 sum (c(ctel:=ctel+1)*el))+
(for each el in grd4 sum (c(ctel:=ctel+1)*el))+
(for each el in grd5 sum (c(ctel:=ctel+1)*el))$
</pre>
<!--l. 513--><p class="nopar" > for the components of the conservation law. We have to solve the equation
                                                                     

                                                                     
</p>
<pre class="verbatim" id="verbatim-928">
equ 1:=ddt(fx)-ddx(ft);
</pre>
<!--l. 517--><p class="nopar" > the fact that <span 
class="pcrr8t-x-x-109">ddx </span>and <span 
class="pcrr8t-x-x-109">ddt </span>are expressed in internal coordinates on the equation means
that the objects that we consider are already restricted to the equation.
</p><!--l. 522--><p class="noindent" >We shall split the equation in its graded summands with the procedure <span 
class="pcrr8t-x-x-109">splitvars</span>,
then solve it
                                                                     

                                                                     
</p>
<pre class="verbatim" id="verbatim-929">
initialize_equations(equ,tel,{},{c,ctel,0},{f,0,0});
splitvars 1;
pte tel;
for i:=2:tel do es i;
end;
</pre>
<!--l. 530--><p class="nopar" > As a result we get
                                                                     

                                                                     
</p>
<pre class="verbatim" id="verbatim-930">
fx := c(3)*u1 + c(2)*u + c(1)$
ft := (2*c(3)*u*u1 + 2*c(3)*u3 + c(2)*u**2 + 2*c(2)*u2)/2$
</pre>
<!--l. 535--><p class="nopar" > Unfortunately it is clear that the conservation law corresponding to <span 
class="pcrr8t-x-x-109">c(3) </span>is trivial,
because it is the total \(x\)-derivative of \(F\); its restriction on the inﬁnite prolongation of the
KdV is zero. Here this fact is evident; how to get rid of less evident trivialities by an
‘automatic’ mechanism? We considered this problem in the ﬁle <span 
class="pcrr8t-x-x-109">KdV_loc-cl_2.red</span>,
where we solved the equation
                                                                     

                                                                     
</p>
<pre class="verbatim" id="verbatim-931">
equ 1:=fx-ddx(f0);
equ 2:=ft-ddt(f0);
</pre>
<!--l. 545--><p class="nopar" > after having loaded the values <span 
class="pcrr8t-x-x-109">fx </span>and <span 
class="pcrr8t-x-x-109">ft </span>found by the previous program. We make the
following ansatz on <span 
class="pcrr8t-x-x-109">f0</span>:
                                                                     

                                                                     
</p>
<pre class="verbatim" id="verbatim-932">
f0:=
(for each el in grd0 sum (cc(cctel:=cctel+1)*el))+
(for each el in grd1 sum (cc(cctel:=cctel+1)*el))+
(for each el in grd2 sum (cc(cctel:=cctel+1)*el))+
(for each el in grd3 sum (cc(cctel:=cctel+1)*el))$
</pre>
<!--l. 554--><p class="nopar" > Note that this gives a grading which is compatible with the gradings of <span 
class="pcrr8t-x-x-109">fx </span>and <span 
class="pcrr8t-x-x-109">ft</span>. After
solving the system
                                                                     

                                                                     
</p>
<pre class="verbatim" id="verbatim-933">
initialize_equations(equ,tel,{},{cc,cctel,0},{f,0,0});
for i:=1:2 do begin splitvars i;end;
pte tel;
for i:=3:tel do es i;
end;
</pre>
<!--l. 563--><p class="nopar" > issuing the commands
                                                                     

                                                                     
</p>
<pre class="verbatim" id="verbatim-934">
fxnontriv := fx-ddx(f0);
ftnontriv := ft-ddt(f0);
</pre>
<!--l. 568--><p class="nopar" > we obtain
                                                                     

                                                                     
</p>
<pre class="verbatim" id="verbatim-935">
fxnontriv := c(2)*u + c(1)$
ftnontriv := (c(2)*(u**2 + 2*u2))/2$
</pre>
<!--l. 573--><p class="nopar" > This mechanism can be easily generalized to situations in which the conservation laws
which are found by the program are diﬃcult to treat by pen and paper.
</p><!--l. 579--><p class="noindent" >
</p>
<h5 class="subsubsectionHead"><a 
 id="x198-47800020.11.2"></a>Local Hamiltonian operators</h5>
<!--l. 582--><p class="noindent" >In this section we will ﬁnd local Hamiltonian operators for the KdV equation \(u_t=u_{xxx}+uu_x\).
Concretely, we have to solve \(\bar \ell _{KdV}(\mathtt {phi})=0\) over the equation \[ \left \{\begin {array}{l} u_t=u_{xxx}+uu_x\\ p_t=p_{xxx}+up_x \end {array}\right . \] or, in geometric terminology, ﬁnd the
shadows of symmetries on the \(\ell ^*\)-covering of the KdV equation. The reference paper for
this type of computations is <span class="cite">[<a 
href="manualap2.html#XKerstenKrasilshchikVerboretsky:2004">KKV04</a>]</span>.
</p><!--l. 595--><p class="noindent" >The ﬁle containing this example is <span 
class="pcrr8t-x-x-109">KdV_Ham_1.red</span>.
</p><!--l. 597--><p class="noindent" >We make use of <span 
class="pcrr8t-x-x-109">ddx </span>and <span 
class="pcrr8t-x-x-109">ddt</span>, which in the even part are the same as in the
previous example (subsection <a 
href="manualse134.html#x198-47600020.11.2">20.11.2<!--tex4ht:ref: sec:higher-symmetries --></a>). We stress that the linearization \(\bar \ell _{KdV}(\mathtt {phi})=0\) is the
equation
                                                                     

                                                                     
</p>
<pre class="verbatim" id="verbatim-936">
ddt(phi)-u*ddx(phi)-u1*phi-ddx(ddx(ddx(phi)))=0
</pre>
<!--l. 602--><p class="nopar" > but the total derivatives are lifted to the \(\ell ^*\) covering, hence they must contain also
derivatives with respect to \(p\)’s. This will be achieved by treating \(p\) variables as odd and
introducing the odd parts of <span 
class="pcrr8t-x-x-109">ddx </span>and <span 
class="pcrr8t-x-x-109">ddt</span>,
                                                                     

                                                                     
</p>
<pre class="verbatim" id="verbatim-937">
ddx(1,1):=0$
ddx(1,2):=0$
ddx(1,3):=ext 4$
ddx(1,4):=ext 5$
ddx(1,5):=ext 6$
ddx(1,6):=ext 7$
ddx(1,7):=ext 8$
ddx(1,8):=ext 9$
ddx(1,9):=ext 10$
ddx(1,10):=ext 11$
ddx(1,11):=ext 12$
ddx(1,12):=ext 13$
ddx(1,13):=ext 14$
ddx(1,14):=ext 15$
ddx(1,15):=ext 16$
ddx(1,16):=ext 17$
ddx(1,17):=ext 18$
ddx(1,18):=ext 19$
ddx(1,19):=ext 20$
ddx(1,20):=letop$
</pre>
<!--l. 628--><p class="nopar" > In the above deﬁnition the ﬁrst index ‘1’ says that we are dealing with odd variables,
<span 
class="pcrr8t-x-x-109">ext </span>indicates anticommuting variables. Here, <span 
class="pcrr8t-x-x-109">ext 3 </span>is \(p_0\), <span 
class="pcrr8t-x-x-109">ext 4 </span>is \(p_x\), <span 
class="pcrr8t-x-x-109">ext 5 </span>is \(p_{xx}\), …so
<span 
class="pcrr8t-x-x-109">ddx(1,3):=ext 4 </span>indicates \(p_x\pd {}{p}\), etc..
</p><!--l. 634--><p class="noindent" >Now, remembering that the additional equation is again evolutionary, we can get rid of \(p_t\)
by letting it be equal to <span 
class="pcrr8t-x-x-109">ext 6 + u*ext 4</span>, as follows:
                                                                     

                                                                     
</p>
<pre class="verbatim" id="verbatim-938">
ddt(1,1):=0$
ddt(1,2):=0$
ddt(1,3):=ext 6 + u*ext 4$
ddt(1,4):=ddx(ddt(1,3))$
ddt(1,5):=ddx(ddt(1,4))$
ddt(1,6):=ddx(ddt(1,5))$
ddt(1,7):=ddx(ddt(1,6))$
ddt(1,8):=ddx(ddt(1,7))$
ddt(1,9):=ddx(ddt(1,8))$
ddt(1,10):=ddx(ddt(1,9))$
ddt(1,11):=ddx(ddt(1,10))$
ddt(1,12):=ddx(ddt(1,11))$
ddt(1,13):=ddx(ddt(1,12))$
ddt(1,14):=ddx(ddt(1,13))$
ddt(1,15):=ddx(ddt(1,14))$
ddt(1,16):=ddx(ddt(1,15))$
ddt(1,17):=ddx(ddt(1,16))$
ddt(1,18):=letop$
ddt(1,19):=letop$
ddt(1,20):=letop$
</pre>
<!--l. 657--><p class="nopar" >
</p><!--l. 659--><p class="noindent" >Let us make the following ansatz about the Hamiltonian operators:
                                                                     

                                                                     
</p>
<pre class="verbatim" id="verbatim-939">
phi:=
(for each el in grd0 sum (c(ctel:=ctel+1)*el))*ext 3+
(for each el in grd1 sum (c(ctel:=ctel+1)*el))*ext 3+
(for each el in grd2 sum (c(ctel:=ctel+1)*el))*ext 3+
(for each el in grd3 sum (c(ctel:=ctel+1)*el))*ext 3+

(for each el in grd0 sum (c(ctel:=ctel+1)*el))*ext 4+
(for each el in grd1 sum (c(ctel:=ctel+1)*el))*ext 4+
(for each el in grd2 sum (c(ctel:=ctel+1)*el))*ext 4+

(for each el in grd0 sum (c(ctel:=ctel+1)*el))*ext 5+
(for each el in grd1 sum (c(ctel:=ctel+1)*el))*ext 5+

(for each el in grd0 sum (c(ctel:=ctel+1)*el))*ext 6
$
</pre>
<!--l. 676--><p class="nopar" > Note that we are looking for generating functions of shadows which are <span 
class="ptmri8t-x-x-109">linear </span>with
respect to \(p\)’s. Moreover, having set \([p]=-2\) we will look for solutions of maximal possible degree
\(+1\).
</p><!--l. 681--><p class="noindent" >After having set
                                                                     

                                                                     
</p>
<pre class="verbatim" id="verbatim-940">
equ 1:=ddt(phi)-u*ddx(phi)-u1*phi-ddx(ddx(ddx(phi)));
vars:={x,t,u,u1,u2,u3,u4,u5,u6,u7,u8,u9,u10,u11,u12,
 u13,u14,u15,u16,u17};
tel:=1;
</pre>
<!--l. 687--><p class="nopar" > we deﬁne the procedures <span 
class="pcrr8t-x-x-109">splitvars </span>as in subsection <a 
href="manualse134.html#x198-47600020.11.2">20.11.2<!--tex4ht:ref: sec:higher-symmetries --></a> and <span 
class="pcrr8t-x-x-109">splitext </span>as
follows:
                                                                     

                                                                     
</p>
<pre class="verbatim" id="verbatim-941">
procedure splitext i;
begin;
ll:=operator_coeff(equ i,ext);
equ(tel:=tel+1):=first ll;
ll:=rest ll;
for each el in ll do equ(tel:=tel+1):=second el;
end;
</pre>
<!--l. 698--><p class="nopar" > Then we initialize the equations:
                                                                     

                                                                     
</p>
<pre class="verbatim" id="verbatim-942">
initialize_equations(equ,tel,{},{c,ctel,0},{f,0,0});
</pre>
<!--l. 702--><p class="nopar" > do <span 
class="pcrr8t-x-x-109">splitext</span>
                                                                     

                                                                     
</p>
<pre class="verbatim" id="verbatim-943">
splitext 1;
</pre>
<!--l. 706--><p class="nopar" > then <span 
class="pcrr8t-x-x-109">splitvars</span>
                                                                     

                                                                     
</p>
<pre class="verbatim" id="verbatim-944">
tel1:=tel;
for i:=2:tel1 do begin splitvars i;equ i:=0;end;
</pre>
<!--l. 711--><p class="nopar" > Now we are ready to solve all equations:
                                                                     

                                                                     
</p>
<pre class="verbatim" id="verbatim-945">
put_equations_used tel;
for i:=2:tel do write equ i:=equ i;
pause;
for i:=2:tel do integrate_equation i;
end;
</pre>
<!--l. 719--><p class="nopar" > Note that we want <span 
class="ptmri8t-x-x-109">all </span>equations to be solved!
</p><!--l. 722--><p class="noindent" >The results are the two well-known Hamiltonian operators for the KdV:
                                                                     

                                                                     
</p>
<pre class="verbatim" id="verbatim-946">
phi := c(4)*ext(4) + 3*c(3)*ext(6) + 2*c(3)*ext(4)*u
 + c(3)*ext(3)*u1$
</pre>
<!--l. 726--><p class="nopar" > Of course, the results correspond to the operators </p>
<div class="center" 
>
<!--l. 728--><p class="noindent" >
</p><!--l. 729--><p class="noindent" ><span 
class="pcrr8t-x-x-109">ext(4)</span> \(\to D_x\),<br />
<span 
class="pcrr8t-x-x-109">3*c(3)*ext(6) + 2*c(3)*ext(4)*u + c(3)*ext(3)*u1</span> \(\to \)<br />
\(3D_{xxx} + 2uD_{x} + u_x\).</p></div>
<!--l. 734--><p class="noindent" >Note that each operator is multiplied by one arbitrary real constant, <span 
class="pcrr8t-x-x-109">c(4) </span>and
<span 
class="pcrr8t-x-x-109">c(3)</span>.
</p><!--l. 737--><p class="noindent" >
</p>
<h5 class="subsubsectionHead"><a 
 id="x198-47900020.11.2"></a>Non-local Hamiltonian operators</h5>
<!--l. 740--><p class="noindent" >In this section we will show an experimental way to ﬁnd nonlocal Hamiltonian operators
for the KdV equation. The word ‘experimental’ comes from the lack of a consistent
mathematical theory. The result of the computation (without the details below) has been
published in <span class="cite">[<a 
href="manualap2.html#XKerstenKrasilshchikVerboretsky:2004">KKV04</a>]</span>.
</p><!--l. 745--><p class="noindent" >We have to solve equations of the type <span 
class="pcrr8t-x-x-109">ddx(ft)-ddt(fx) </span>as in <a 
href="manualse134.html#x198-47700020.11.2">20.11.2<!--tex4ht:ref: sec:local-cons-laws --></a>. The main
diﬀerence is that we will attempt a solution on the \(\ell ^*\)-covering (see Subsection <a 
href="manualse134.html#x198-47800020.11.2">20.11.2<!--tex4ht:ref: sec:local-hamilt-oper --></a>).
For this reason, ﬁrst of all we have to determine covering variables with the usual
mechanism of introducing them through conservation laws, this time on the
\(\ell ^*\)-covering.
</p><!--l. 752--><p class="noindent" >As a ﬁrst step, let us compute conservation laws on the \(\ell ^*\)-covering whose components are
linear in the \(p\)’s. This computation can be found in the ﬁle <span 
class="pcrr8t-x-x-109">KdV_nloc-cl_1.red </span>and
related results ﬁle. When specifying odd variables in <span 
class="pcrr8t-x-x-109">ddx </span>and <span 
class="pcrr8t-x-x-109">ddt</span>, we have something
like
                                                                     

                                                                     
</p>
<pre class="verbatim" id="verbatim-947">
ddx(1,1):=0$
ddx(1,2):=0$
ddx(1,3):=ext 4$
ddx(1,4):=ext 5$
ddx(1,5):=ext 6$
ddx(1,6):=ext 7$
ddx(1,7):=ext 8$
ddx(1,8):=ext 9$
ddx(1,9):=ext 10$
ddx(1,10):=ext 11$
ddx(1,11):=ext 12$
ddx(1,12):=ext 13$
ddx(1,13):=ext 14$
ddx(1,14):=ext 15$
ddx(1,15):=ext 16$
ddx(1,16):=ext 17$
ddx(1,17):=ext 18$
ddx(1,18):=ext 19$
ddx(1,19):=ext 20$
ddx(1,20):=letop$
ddx(1,50):=(t*u1+1)*ext 3$ % degree -2
ddx(1,51):=u1*ext 3$ % degree +1
ddx(1,52):=(u*u1+u3)*ext 3$ % degree +3
</pre>
<!--l. 780--><p class="nopar" > and
                                                                     

                                                                     
</p>
<pre class="verbatim" id="verbatim-948">
ddt(1,1):=0$
ddt(1,2):=0$
ddt(1,3):=ext 6 + u*ext 4$
ddt(1,4):=ddx(ddt(1,3))$
ddt(1,5):=ddx(ddt(1,4))$
ddt(1,6):=ddx(ddt(1,5))$
ddt(1,7):=ddx(ddt(1,6))$
ddt(1,8):=ddx(ddt(1,7))$
ddt(1,9):=ddx(ddt(1,8))$
ddt(1,10):=ddx(ddt(1,9))$
ddt(1,11):=ddx(ddt(1,10))$
ddt(1,12):=ddx(ddt(1,11))$
ddt(1,13):=ddx(ddt(1,12))$
ddt(1,14):=ddx(ddt(1,13))$
ddt(1,15):=ddx(ddt(1,14))$
ddt(1,16):=ddx(ddt(1,15))$
ddt(1,17):=ddx(ddt(1,16))$
ddt(1,18):=letop$
ddt(1,19):=letop$
ddt(1,20):=letop$
ddt(1,50):=f1*ext 3+f2*ext 4+f3*ext 5$
ddt(1,51):=f4*ext 3+f5*ext 4+f6*ext 5$
ddt(1,52):=f7*ext 3+f8*ext 4+f9*ext 5$
</pre>
<!--l. 806--><p class="nopar" > The variables corresponding to the numbers <span 
class="pcrr8t-x-x-109">50,51,52 </span>here play a dummy role, the
coeﬃcients of the corresponding vector are the unknown generating functions of
conservation laws on the \(\ell ^*\)-covering. More precisely, we look for conservation laws of the
form
                                                                     

                                                                     
</p>
<pre class="verbatim" id="verbatim-949">
fx= phi*ext 3
ft= f1*ext3+f2*ext4+f3*ext5
</pre>
<!--l. 815--><p class="nopar" > The ansatz is chosen because, ﬁrst of all, <span 
class="pcrr8t-x-x-109">ext 4 </span>and <span 
class="pcrr8t-x-x-109">ext 5 </span>can be removed from fx by
adding a suitable total divergence (trivial conservation law); moreover it can be proved
that <span 
class="pcrr8t-x-x-109">phi </span>is a symmetry of KdV. We can write down the equations
                                                                     

                                                                     
</p>
<pre class="verbatim" id="verbatim-950">
equ 1:=ddx(ddt(1,50))-ddt(ddx(1,50));
equ 2:=ddx(ddt(1,51))-ddt(ddx(1,51));
equ 3:=ddx(ddt(1,52))-ddt(ddx(1,52));
</pre>
<!--l. 824--><p class="nopar" > However, the above choices make use of a symmetry which contains <span 
class="pcrr8t-x-x-109">‘t’ </span>in the
generator. This would make automatic computations more tricky, but still possible.
In this case the solution of <span 
class="pcrr8t-x-x-109">equ 1 </span>has been found by hand and passed to the
program:
                                                                     

                                                                     
</p>
<pre class="verbatim" id="verbatim-951">
f3:=t*u1+1$
f1:=u*f3+ddx(ddx(f3))$
f2:=-ddx(f3)$
</pre>
<!--l. 833--><p class="nopar" > together with the ansatz on the coeﬃcients for the other equations
                                                                     

                                                                     
</p>
<pre class="verbatim" id="verbatim-952">
f4:=(for each el in grd5 sum (c(ctel:=ctel+1)*el))$
f5:=(for each el in grd4 sum (c(ctel:=ctel+1)*el))$
f6:=(for each el in grd3 sum (c(ctel:=ctel+1)*el))$

f7:=(for each el in grd7 sum (c(ctel:=ctel+1)*el))$
f8:=(for each el in grd6 sum (c(ctel:=ctel+1)*el))$
f9:=(for each el in grd5 sum (c(ctel:=ctel+1)*el))$
</pre>
<!--l. 843--><p class="nopar" > The previous ansatz keep into account the grading of the starting symmetry in
<span 
class="pcrr8t-x-x-109">phi*ext 3</span>. The resulting equations are solved in the usual way (see the example
ﬁle).
</p><!--l. 848--><p class="noindent" >Now, we solve the equation for shadows of nonlocal symmetries in a covering of the
\(\ell ^*\)-covering. We can choose between three new nonlocal variables <span 
class="pcrr8t-x-x-109">ra,rb,rc</span>. We are
going to look for non-local Hamiltonian operators depending linearly on one of these
variables. Higher non-local Hamiltonian operators could be found by introducing
total derivatives of the r’s. As usual, the new variables are speciﬁed through
the components of the previously found conservation laws according with the
rule
                                                                     

                                                                     
</p>
<pre class="verbatim" id="verbatim-953">
ra_x=fx, ra_t=ft,
</pre>
<!--l. 857--><p class="nopar" > and analogously for the others. We deﬁne
                                                                     

                                                                     
</p>
<pre class="verbatim" id="verbatim-954">
ddx(1,50):=(t*u1+1)*ext 3$ % degree -2
ddx(1,51):=u1*ext 3$ % degree +1
ddx(1,52):=(u*u1+u3)*ext 3$ % degree +3
</pre>
<!--l. 863--><p class="nopar" > and
                                                                     

                                                                     
</p>
<pre class="verbatim" id="verbatim-955">
ddt(1,50) := ext(5)*t*u1 + ext(5) - ext(4)*t*u2
 + ext(3)*t*u*u1 + ext(3)*t*u3 + ext(3)*u$
ddt(1,51) := ext(5)*u1 - ext(4)*u2 + ext(3)*u*u1
 + ext(3)*u3$
ddt(1,52) := ext(5)*u*u1 + ext(5)*u3 - ext(4)*u*u2
 - ext(4)*u1**2 - ext(4)*u4 + ext(3)*u**2*u1
 + 2*ext(3)*u*u3 + 3*ext(3)*u1*u2 + ext(3)*u5$
</pre>
<!--l. 873--><p class="nopar" > as it results from the computation of the conservation laws. The following ansatz for the
nonlocal Hamiltonian operator comes from the fact that local Hamiltonian operators have
gradings \(-1\) and \(+1\) when written in terms of \(p\)’s. So we are looking for a nonlocal Hamiltonian
operator of degree \(3\).
                                                                     

                                                                     
</p>
<pre class="verbatim" id="verbatim-956">
phi:=
(for each el in grd6 sum (c(ctel:=ctel+1)*el))*ext 50+
(for each el in grd3 sum (c(ctel:=ctel+1)*el))*ext 51+
(for each el in grd1 sum (c(ctel:=ctel+1)*el))*ext 52+

(for each el in grd5 sum (c(ctel:=ctel+1)*el))*ext 3+
(for each el in grd4 sum (c(ctel:=ctel+1)*el))*ext 4+
(for each el in grd3 sum (c(ctel:=ctel+1)*el))*ext 5+
(for each el in grd2 sum (c(ctel:=ctel+1)*el))*ext 6+
(for each el in grd1 sum (c(ctel:=ctel+1)*el))*ext 7+
(for each el in grd0 sum (c(ctel:=ctel+1)*el))*ext 8
$
</pre>
<!--l. 892--><p class="nopar" > As a solution, we obtain
                                                                     

                                                                     
</p>
<pre class="verbatim" id="verbatim-957">
phi := c(1)*(ext(51)*u1 - 9*ext(8) - 12*ext(6)*u
 - 18*ext(5)*u1 - 4*ext(4)*u**2 - 12*ext(4)*u2
 - 4*ext(3)*u*u1 - 3*ext(3)*u3)$
</pre>
<!--l. 898--><p class="nopar" > where <span 
class="pcrr8t-x-x-109">ext51 </span>stands for the nonlocal variable <span 
class="pcrr8t-x-x-109">rb </span>fulﬁlling
                                                                     

                                                                     
</p>
<pre class="verbatim" id="verbatim-958">
rb_x:=u1*ext 3$
rb_t:=ext(5)*u1 - ext(4)*u2 + ext(3)*u*u1 + ext(3)*u3$
</pre>
<!--l. 903--><p class="nopar" >
</p><!--l. 905--><p class="noindent" ><span 
class="ptmb8t-x-x-109">Remark. </span>In the ﬁle <span 
class="pcrr8t-x-x-109">KdV_nloc-Ham_2.red </span>it is possible to ﬁnd another ansatz for a
non-local Hamiltonian operator of degree \(+5\).
</p><!--l. 908--><p class="noindent" >
</p>
<h5 class="subsubsectionHead"><a 
 id="x198-48000020.11.2"></a>Computations for systems of PDEs</h5>
<!--l. 911--><p class="noindent" >There is no conceptual diﬀerence when computing for systems of PDEs. We
will look for Hamiltonian structures for the following Boussinesq equation:
\begin {equation}  \label {cdiffeq:1} \left \{ \begin {array}{l} u_t-u_xv-uv_x-\sigma v_{xxx}=0\\ v_t-u_x-vv_x=0 \end {array} \right .  \end {equation}
where \(\sigma \) is a constant. This example also shows how to deal with jet spaces with more than
one dependent variable. Here gradings can be taken as \[ [t]=-2,\quad [x]=-1,\quad [v]=1,\quad [u]=2,\quad [p]=[\pd {}{u}]=-2,\quad [q]=[\pd {}{v}]=-1 \] where \(p\), \(q\) are the two coordinates
in the space of generating functions of conservation laws.
</p><!--l. 931--><p class="noindent" >The linearization of the above system and its adjoint are, respectively \[ \ell _{\text {Bou}}= \begin {pmatrix} D_t-vD_x-v_x &amp; -u_x-uD_x-\sigma D_{xxx}\\ -D_x &amp; D_t-v_x-vD_x \end {pmatrix},\\ell ^*_{\text {Bou}}= \begin {pmatrix} -D_t+vD_x &amp; D_x\\ uD_x+\sigma D_{xxx} &amp; -D_t+vD_x \end {pmatrix} \] and lead to the \(\ell ^*_{\text {Bou}}\)
covering equation \[ \label {cdiffeq:2} \left \{ \begin {array}{l} -p_t+vp_x+q_x=0\\ up_x+\sigma p_{xxx}-q_t+vq_x=0\\ u_t-u_xv-uv_x-\sigma v_{xxx}=0\\ v_t-u_x-vv_x=0 \end {array} \right . \] We have to ﬁnd shadows of symmetries on the above covering. Total
derivatives must be deﬁned as follows:
                                                                     

                                                                     
</p>
<pre class="verbatim" id="verbatim-959">
super_vectorfield(ddx,{x,t,u,v,u1,v1,u2,v2,u3,v3,u4,v4,
u5,v5,u6,v6,u7,v7,u8,v8,u9,v9,u10,v10,u11,v11,u12,v12,
u13,v13,u14,v14,u15,v15,u16,v16,u17,v17},
{ext 1,ext 2,ext 3,ext 4,ext 5,ext 6,ext 7,ext 8,ext 9,
ext 10,ext 11,ext 12,ext 13,ext 14,ext 15,ext 16,ext 17,
ext 18,ext 19,ext 20,ext 21,ext 22,ext 23,ext 24,ext 25,
ext 26,ext 27,ext 28,ext 29,ext 30,ext 31,ext 32,ext 33,
ext 34,ext 35,ext 36,ext 37,ext 38,ext 39,ext 40,ext 41,
ext 42,ext 43,ext 44,ext 45,ext 46,ext 47,ext 48,ext 49,
ext 50,ext 51,ext 52,ext 53,ext 54,ext 55,ext 56,ext 57,
ext 58,ext 59,ext 60,ext 61,ext 62,ext 63,ext 64,ext 65,
ext 66,ext 67,ext 68,ext 69,ext 70,ext 71,ext 72,ext 73,
ext 74,ext 75,ext 76,ext 77,ext 78,ext 79,ext 80
});

super_vectorfield(ddt,{x,t,u,v,u1,v1,u2,v2,u3,v3,u4,v4,
u5,v5,u6,v6,u7,v7,u8,v8,u9,v9,u10,v10,u11,v11,u12,v12,
u13,v13,u14,v14,u15,v15,u16,v16,u17,v17},
{ext 1,ext 2,ext 3,ext 4,ext 5,ext 6,ext 7,ext 8,ext 9,
ext 10,ext 11,ext 12,ext 13,ext 14,ext 15,ext 16,ext 17,
ext 18,ext 19,ext 20,ext 21,ext 22,ext 23,ext 24,ext 25,
ext 26,ext 27,ext 28,ext 29,ext 30,ext 31,ext 32,ext 33,
ext 34,ext 35,ext 36,ext 37,ext 38,ext 39,ext 40,ext 41,
ext 42,ext 43,ext 44,ext 45,ext 46,ext 47,ext 48,ext 49,
ext 50,ext 51,ext 52,ext 53,ext 54,ext 55,ext 56,ext 57,
ext 58,ext 59,ext 60,ext 61,ext 62,ext 63,ext 64,ext 65,
ext 66,ext 67,ext 68,ext 69,ext 70,ext 71,ext 72,ext 73,
ext 74,ext 75,ext 76,ext 77,ext 78,ext 79,ext 80
});
</pre>
<!--l. 988--><p class="nopar" > In the list of coordinates we alternate derivatives of \(u\) and derivatives of \(v\). The same must
be done for coeﬃcients; for example,
                                                                     

                                                                     
</p>
<pre class="verbatim" id="verbatim-960">
ddx(0,1):=1$
ddx(0,2):=0$
ddx(0,3):=u1$
ddx(0,4):=v1$
ddx(0,5):=u2$
ddx(0,6):=v2$
...
</pre>
<!--l. 999--><p class="nopar" > After specifying the equation
                                                                     

                                                                     
</p>
<pre class="verbatim" id="verbatim-961">
ut:=u1*v+u*v1+sig*v3;
vt:=u1+v*v1;
</pre>
<!--l. 1004--><p class="nopar" > we deﬁne the (already introduced) time derivatives:
                                                                     

                                                                     
</p>
<pre class="verbatim" id="verbatim-962">
ut1:=ddx ut;
ut2:=ddx ut1;
ut3:=ddx ut2;
...
vt1:=ddx vt;
vt2:=ddx vt1;
vt3:=ddx vt2;
...
</pre>
<!--l. 1015--><p class="nopar" > up to the required order (here the order can be stopped at \(15\)). Odd variables \(p\) and \(q\) must be
speciﬁed with an appropriate length (here it is OK to stop at <span 
class="pcrr8t-x-x-109">ddx(1,36)</span>). Recall to
replace \(p_t\), \(q_t\) with the internal coordinates of the covering:
                                                                     

                                                                     
</p>
<pre class="verbatim" id="verbatim-963">
ddt(1,1):=0$
ddt(1,2):=0$
ddt(1,3):=+v*ext 5+ext 6$
ddt(1,4):=u*ext 5+sig*ext 9+v*ext 6$
ddt(1,5):=ddx(ddt(1,3))$
...
</pre>
<!--l. 1027--><p class="nopar" > The list of graded variables:
                                                                     

                                                                     
</p>
<pre class="verbatim" id="verbatim-964">
all_graded_der:={{v},{u,v1},{u1,v2},{u2,v3},{u3,v4},{u4,v5},
 {u5,v6},{u6,v7},{u7,v8},{u8,v9},{u9,v10},{u10,v11},
 {u11,v12},{u12,v13},{u13,v14},{u14,v15},{u15,v16},
 {u16,v17},{u17}};
</pre>
<!--l. 1034--><p class="nopar" > The ansatz for the components of the Hamiltonian operator is
                                                                     

                                                                     
</p>
<pre class="verbatim" id="verbatim-965">
phi1:=
(for each el in grd2 sum (c(ctel:=ctel+1)*el))*ext 3+
(for each el in grd1 sum (c(ctel:=ctel+1)*el))*ext 5+
(for each el in grd1 sum (c(ctel:=ctel+1)*el))*ext 4+
(for each el in grd0 sum (c(ctel:=ctel+1)*el))*ext 6
$

phi2:=
(for each el in grd1 sum (c(ctel:=ctel+1)*el))*ext 3+
(for each el in grd0 sum (c(ctel:=ctel+1)*el))*ext 5+
(for each el in grd0 sum (c(ctel:=ctel+1)*el))*ext 4
$
</pre>
<!--l. 1049--><p class="nopar" > and the equation for shadows of symmetries is
                                                                     

                                                                     
</p>
<pre class="verbatim" id="verbatim-966">
equ 1:=ddt(phi1)-v*ddx(phi1)-v1*phi1-u1*phi2-u*ddx(phi2)
-sig*ddx(ddx(ddx(phi2)));
equ 2:=-ddx(phi1)-v*ddx(phi2)-v1*phi2+ddt(phi2);
</pre>
<!--l. 1055--><p class="nopar" > After the usual procedures for decomposing polynomials we obtain the following
result:
                                                                     

                                                                     
</p>
<pre class="verbatim" id="verbatim-967">
phi1 := c(6)*ext(6)$
phi2 := c(6)*ext(5)$
</pre>
<!--l. 1061--><p class="nopar" > which corresponds to the vector \((D_x,D_x)\). Extending the ansatz to
                                                                     

                                                                     
</p>
<pre class="verbatim" id="verbatim-968">
phi1:=
(for each el in grd3 sum (c(ctel:=ctel+1)*el))*ext 3+
(for each el in grd2 sum (c(ctel:=ctel+1)*el))*ext 5+
(for each el in grd1 sum (c(ctel:=ctel+1)*el))*ext 7+
(for each el in grd0 sum (c(ctel:=ctel+1)*el))*ext 9+
(for each el in grd2 sum (c(ctel:=ctel+1)*el))*ext 4+
(for each el in grd1 sum (c(ctel:=ctel+1)*el))*ext 6+
(for each el in grd0 sum (c(ctel:=ctel+1)*el))*ext 8
$

phi2:=
(for each el in grd2 sum (c(ctel:=ctel+1)*el))*ext 3+
(for each el in grd1 sum (c(ctel:=ctel+1)*el))*ext 5+
(for each el in grd0 sum (c(ctel:=ctel+1)*el))*ext 7+
(for each el in grd1 sum (c(ctel:=ctel+1)*el))*ext 4+
(for each el in grd0 sum (c(ctel:=ctel+1)*el))*ext 6
$
</pre>
<!--l. 1081--><p class="nopar" > allows us to ﬁnd a second (local) Hamiltonian operator
                                                                     

                                                                     
</p>
<pre class="verbatim" id="verbatim-969">
phi1 := (c(3)*(2*ext(9)*sig + ext(6)*v + 2*ext(5)*u
 + ext(3)*u1))/2$
phi2 := (c(3)*(2*ext(6) + ext(5)*v + ext(3)*v1))/2$
</pre>
<!--l. 1087--><p class="nopar" > There is one more higher local Hamiltonian operator, and a whole hierarchy of nonlocal
Hamiltonian operators <span class="cite">[<a 
href="manualap2.html#XKerstenKrasilshchikVerboretsky:2004">KKV04</a>]</span>.
</p><!--l. 1092--><p class="noindent" >
</p>
<h5 class="subsubsectionHead"><a 
 id="x198-48100020.11.2"></a>Explosion of denominators and how to avoid it</h5>
<!--l. 1094--><p class="noindent" >Here we propose the computation of the repeated total derivative of a denominator. This
computation ﬁlls up the whole memory after some time, and can be used as a kind of
speed test for the system. The ﬁle is <span 
class="pcrr8t-x-x-109">KdV_denom_1.red</span>.
</p><!--l. 1099--><p class="noindent" >After having deﬁned total derivatives on the KdV equation, run the following
iteration:
                                                                     

                                                                     
</p>
<pre class="verbatim" id="verbatim-970">
phi:=1/(u3+u*u1)$
for i:=1:100 do begin
                phi:=ddx(phi)$
                write i;
end;
</pre>
<!--l. 1107--><p class="nopar" > The program shows the iteration number. At the 18th iteration the program uses about
600MB of RAM, as shown by <span 
class="pcrr8t-x-x-109">top </span>run from another shell, and 100% of one
processor.
</p><!--l. 1112--><p class="noindent" >There is a simple way to avoid denominator explosion. The ﬁle is <span 
class="pcrr8t-x-x-109">KdV_denom_2.red</span>.
</p><!--l. 1115--><p class="noindent" >After having deﬁned total derivatives with respect to \(x\) (on the KdV equation,
for example) consider in the same <span 
class="pcrr8t-x-x-109">ddx </span>a component with a suﬃcently high
index <span 
class="ptmb8t-x-x-109">immediately after ‘letop’ </span>(otherwise <span 
class="pcrr8t-x-x-109">super_vectorfield </span>does not
work!), say <span 
class="pcrr8t-x-x-109">ddx(0,21)</span>, and think of it as being the coeﬃcient to a vector of the
type
                                                                     

                                                                     
</p>
<pre class="verbatim" id="verbatim-971">
aa21:=1/(u3+u*u1);
</pre>
<!--l. 1122--><p class="nopar" > In this case, its coeﬃcient must be
                                                                     

                                                                     
</p>
<pre class="verbatim" id="verbatim-972">
ddx(0,21):=-aa21**2*(u4+u1**2+u*u2)$
</pre>
<!--l. 1126--><p class="nopar" > More particularly, here follows the detailed deﬁnition of <span 
class="pcrr8t-x-x-109">ddx</span>
                                                                     

                                                                     
</p>
<pre class="verbatim" id="verbatim-973">
ddx(0,1):=1$
ddx(0,2):=0$
ddx(0,3):=u1$
ddx(0,4):=u2$
ddx(0,5):=u3$
ddx(0,6):=u4$
ddx(0,7):=u5$
ddx(0,8):=u6$
ddx(0,9):=u7$
ddx(0,10):=u8$
ddx(0,11):=u9$
ddx(0,12):=u10$
ddx(0,13):=u11$
ddx(0,14):=u12$
ddx(0,15):=u13$
ddx(0,16):=u14$
ddx(0,17):=u15$
ddx(0,18):=u16$
ddx(0,19):=u17$
ddx(0,20):=letop$
ddx(0,21):=-aa21**2*(u4+u1**2+u*u2)$
</pre>
<!--l. 1150--><p class="nopar" >
</p><!--l. 1152--><p class="noindent" >Now, suppose that we want to compute the 5th total derivative of <span 
class="pcrr8t-x-x-109">phi</span>. Write the
following code:
                                                                     

                                                                     
</p>
<pre class="verbatim" id="verbatim-974">
phi:=aa30;
for i:=1:5 do begin
                phi:=ddx(phi)$
                write i;
end;
</pre>
<!--l. 1160--><p class="nopar" > The result is then a polynomial in the additional ‘denominator’ variable
                                                                     

                                                                     
</p>
<pre class="verbatim" id="verbatim-975">
phi := aa21**2*( - 120*aa21**4*u**5*u2**5
 - 600*aa21**4*u**4*u1**2*u2**4 - 600*aa21**4*u**4*u2**4*u4
 - 1200*aa21**4*u**3*u1**4*u2**3 - 2400*aa21**4*u**3*u1**2*u2**3*u4
 - 1200*aa21**4*u**3*u2**3*u4**2 - 1200*aa21**4*u**2*u1**6*u2**2
 - 3600*aa21**4*u**2*u1**4*u2**2*u4 - 3600*aa21**4*u**2*u1**2*u2**2*u4**2
 - 1200*aa21**4*u**2*u2**2*u4**3 - 600*aa21**4*u*u1**8*u2
 - 2400*aa21**4*u*u1**6*u2*u4 - 3600*aa21**4*u*u1**4*u2*u4**2
 - 2400*aa21**4*u*u1**2*u2*u4**3 - 600*aa21**4*u*u2*u4**4
 - 120*aa21**4*u1**10 - 600*aa21**4*u1**8*u4
 - 1200*aa21**4*u1**6*u4**2 - 1200*aa21**4*u1**4*u4**3
 - 600*aa21**4*u1**2*u4**4 - 120*aa21**4*u4**5
 + 240*aa21**3*u**4*u2**3*u3
 + 720*aa21**3*u**3*u1**2*u2**2*u3 + 720*aa21**3*u**3*u1*u2**4
 + 240*aa21**3*u**3*u2**3*u5 + 720*aa21**3*u**3*u2**2*u3*u4
 + 720*aa21**3*u**2*u1**4*u2*u3 + 2160*aa21**3*u**2*u1**3*u2**3
 + 720*aa21**3*u**2*u1**2*u2**2*u5 + 1440*aa21**3*u**2*u1**2*u2*u3*u4
 + 2160*aa21**3*u**2*u1*u2**3*u4 + 720*aa21**3*u**2*u2**2*u4*u5
 + 720*aa21**3*u**2*u2*u3*u4**2 + 240*aa21**3*u*u1**6*u3
 + 2160*aa21**3*u*u1**5*u2**2 + 720*aa21**3*u*u1**4*u2*u5
 + 720*aa21**3*u*u1**4*u3*u4 + 4320*aa21**3*u*u1**3*u2**2*u4
 + 1440*aa21**3*u*u1**2*u2*u4*u5 + 720*aa21**3*u*u1**2*u3*u4**2
 + 2160*aa21**3*u*u1*u2**2*u4**2 + 720*aa21**3*u*u2*u4**2*u5
 + 240*aa21**3*u*u3*u4**3 + 720*aa21**3*u1**7*u2
 + 240*aa21**3*u1**6*u5
 + 2160*aa21**3*u1**5*u2*u4 + 720*aa21**3*u1**4*u4*u5
 + 2160*aa21**3*u1**3*u2*u4**2 + 720*aa21**3*u1**2*u4**2*u5
 + 720*aa21**3*u1*u2*u4**3 + 240*aa21**3*u4**3*u5
 - 60*aa21**2*u**3*u2**2*u4 - 90*aa21**2*u**3*u2*u3**2
 - 120*aa21**2*u**2*u1**2*u2*u4 - 90*aa21**2*u**2*u1**2*u3**2
 - 780*aa21**2*u**2*u1*u2**2*u3 - 180*aa21**2*u**2*u2**4
 - 60*aa21**2*u**2*u2**2*u6 - 180*aa21**2*u**2*u2*u3*u5
 - 120*aa21**2*u**2*u2*u4**2 - 90*aa21**2*u**2*u3**2*u4
 - 60*aa21**2*u*u1**4*u4 - 1020*aa21**2*u*u1**3*u2*u3
 - 1170*aa21**2*u*u1**2*u2**3 - 120*aa21**2*u*u1**2*u2*u6
 - 180*aa21**2*u*u1**2*u3*u5 - 120*aa21**2*u*u1**2*u4**2
 - 540*aa21**2*u*u1*u2**2*u5 - 1020*aa21**2*u*u1*u2*u3*u4
 - 360*aa21**2*u*u2**3*u4 - 120*aa21**2*u*u2*u4*u6
 - 90*aa21**2*u*u2*u5**2 - 180*aa21**2*u*u3*u4*u5
                                                                     

                                                                     
 - 60*aa21**2*u*u4**3 - 240*aa21**2*u1**5*u3
 - 990*aa21**2*u1**4*u2**2 - 60*aa21**2*u1**4*u6
 - 540*aa21**2*u1**3*u2*u5 - 480*aa21**2*u1**3*u3*u4
 - 1170*aa21**2*u1**2*u2**2*u4 - 120*aa21**2*u1**2*u4*u6
 - 90*aa21**2*u1**2*u5**2 - 540*aa21**2*u1*u2*u4*u5
 - 240*aa21**2*u1*u3*u4**2 - 180*aa21**2*u2**2*u4**2
 - 60*aa21**2*u4**2*u6 - 90*aa21**2*u4*u5**2
 + 10*aa21*u**2*u2*u5 + 20*aa21*u**2*u3*u4 + 10*aa21*u*u1**2*u5
 + 110*aa21*u*u1*u2*u4 + 80*aa21*u*u1*u3**2 + 160*aa21*u*u2**2*u3
 + 10*aa21*u*u2*u7 + 20*aa21*u*u3*u6 + 30*aa21*u*u4*u5
 + 50*aa21*u1**3*u4 + 340*aa21*u1**2*u2*u3 + 10*aa21*u1**2*u7
 + 180*aa21*u1*u2**3 + 60*aa21*u1*u2*u6 + 80*aa21*u1*u3*u5
 + 50*aa21*u1*u4**2 + 60*aa21*u2**2*u5 + 100*aa21*u2*u3*u4
 + 10*aa21*u4*u7 + 20*aa21*u5*u6 - u*u6 - 6*u1*u5 - 15*u2*u4
 - 10*u3**2 - u8)$
</pre>
<!--l. 1216--><p class="nopar" > where the value of <span 
class="pcrr8t-x-x-109">aa21 </span>can be replaced back in the expression.
</p><!--l. 243--><p class="noindent" >
                                                                     

                                                                     
                                                                     

                                                                     
</p><!--l. 245--><p class="noindent" ><table cellspacing="5"><tr><td class="clinks"><a 
href="../manual-lookup.php%3FUser&#32;Contributed&#32;Packages.html#manualse134.html" >Up</a></td><td class="clinks"><a 
href="manualse135.html" >Next</a></td><td class="clinks"><a 
href="manualse133.html" >Prev</a></td><td class="clinks"><a 
href="manualse133.html#tailmanualse133.html" >PrevTail</a></td><td class="clinks"><a 
href="manualse134.html" >Front</a></td></tr></table><a 
 id="tailmanualse134.html"></a>   <hr> <p style="font-family:sans-serif">Hosted by <a href="https://sourceforge.net/p/reduce-algebra/"> <img title="Download REDUCE" alt="Download REDUCE" style="vertical-align:middle" src="https://sourceforge.net/sflogo.php?type=16&amp;group_id=248416"/></a> <a href="https://www.mathjax.org"> <img title="Powered by MathJax" alt="Powered by MathJax" style="float:right" src="https://www.mathjax.org/badge/badge.gif"/></a></p></p> 
</body> 
</html>