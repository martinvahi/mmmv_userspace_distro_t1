<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"  
  "http://www.w3.org/TR/html4/loose.dtd">  
<html > 
<head><title>Common LISP String Functions</title> 
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1"> 
<meta name="generator" content="TeX4ht (http://www.cse.ohio-state.edu/~gurari/TeX4ht/)"> 
<meta name="originator" content="TeX4ht (http://www.cse.ohio-state.edu/~gurari/TeX4ht/)"> 
<!-- 3,html --> 
<meta name="src" content="allman1.tex"> 
<meta name="date" content="2014-05-02 18:10:00"> 
<link rel="stylesheet" type="text/css" href="allman1.css"> 
</head><body 
>
<p align="centre"><img src="https://reduce-algebra.sourceforge.io/lisp-docs/redlogo.png" width=621 height=60 border=0 alt="REDUCE"></p><table cellspacing="5"><tr><td class="clinks"><a 
href="allman1li5.html#allman1se20.html" >Up</a></td><td class="clinks"><a 
href="allman1se19.html" >Prev</a></td><td class="clinks"><a 
href="allman1se19.html#tailallman1se19.html" >PrevTail</a></td><td class="clinks"><a 
href="allman1se20.html#tailallman1se20.html">Tail</a></td></tr></table><h3 class="sectionHead"><span class="titlemark">6.3    </span> <a 
 id="x28-660006.3"></a>Common LISP String Functions</h3>
<!--l. 367--><p class="noindent" >A Common LISP compatible package of string functions has been implemented in PSL,
obtained by loading the <span 
class="ptmb7t-x-x-120">strings </span>module. This section describes the <span 
class="ptmb7t-x-x-120">strings </span>module, including a
few functions in it that are not Common LISP functions.
<!--l. 372--><p class="noindent" >
<h4 class="subsectionHead"><span class="titlemark">6.3.1    </span> <a 
 id="x28-670006.3.1"></a>String comparison:</h4>
<!--l. 376--><p class="noindent" ><div class="minipage"><a 
 id="dx28-67001"></a>
<span 
class="ptmb7t-x-x-120">(string= S1:string S2:string): boolean                                                                        </span><span 
class="ptmri7t-x-x-120">expr</span>
<br 
class="newline" /><div class="minipage">Compares two strings S1 and S2, case sensitive.
</div></div>
<!--l. 380--><p class="noindent" ><div class="minipage"><a 
 id="dx28-67002"></a>
<span 
class="ptmb7t-x-x-120">(string-equal S1:string S2:string): boolean                                                               </span><span 
class="ptmri7t-x-x-120">expr</span>
<br 
class="newline" /><div class="minipage">Compare two strings S1 and S2, ignoring case, bits and font.
</div></div>
<!--l. 382--><p class="noindent" >The following string comparison functions are extra-boolean. If the comparison results in a
value of t, the index of the first character position at which the strings fail to match is
returned. The result can also be thought of as the longest common prefix of the two
strings.
<!--l. 390--><p class="noindent" ><div class="minipage"><a 
 id="dx28-67003"></a>
<span 
class="ptmb7t-x-x-120">(string</span><span 
class="cmmi-12">&#x003C; </span><span 
class="ptmb7t-x-x-120">S1:string S2:string): extra-boolean                                                             </span><span 
class="ptmri7t-x-x-120">expr</span>
<br 
class="newline" /><div class="minipage">Lexicographic comparison of strings. Case sensitive.
</div></div>
<!--l. 394--><p class="noindent" ><div class="minipage"><a 
 id="dx28-67004"></a>
<span 
class="ptmb7t-x-x-120">(string</span><span 
class="cmmi-12">&#x003E; </span><span 
class="ptmb7t-x-x-120">S1:string S2:string): extra-boolean                                                             </span><span 
class="ptmri7t-x-x-120">expr</span>
<br 
class="newline" /><div class="minipage">Lexicographic comparison of strings. Case sensitive.
</div></div>

<!--l. 398--><p class="noindent" ><div class="minipage"><a 
 id="dx28-67005"></a>
<span 
class="ptmb7t-x-x-120">(string</span><span 
class="cmmi-12">&#x003C;</span><span 
class="ptmb7t-x-x-120">= S1:string S2:string): extra-boolean                                                          </span><span 
class="ptmri7t-x-x-120">expr</span>
<br 
class="newline" /><div class="minipage">Lexicographic comparison of strings. Case sensitive.
</div></div>
<!--l. 402--><p class="noindent" ><div class="minipage"><a 
 id="dx28-67006"></a>
<span 
class="ptmb7t-x-x-120">(string</span><span 
class="cmmi-12">&#x003E;</span><span 
class="ptmb7t-x-x-120">= S1:string S2:string): extra-boolean                                                          </span><span 
class="ptmri7t-x-x-120">expr</span>
<br 
class="newline" /><div class="minipage">Lexicographic comparison of strings. Case sensitive.
</div></div>
<!--l. 408--><p class="noindent" ><div class="minipage"><a 
 id="dx28-67007"></a>
<span 
class="ptmb7t-x-x-120">(string</span><span 
class="cmmi-12">&#x003C;&#x003E; </span><span 
class="ptmb7t-x-x-120">S1:string S2:string): extra-boolean                                                         </span><span 
class="ptmri7t-x-x-120">expr</span>
<br 
class="newline" />&#x00A0;      <div class="minipage">Lexicographic comparison of strings. Case sensitive. In Common LISP the
function is named string/=.</div>
</div>
<!--l. 412--><p class="noindent" ><div class="minipage"><a 
 id="dx28-67008"></a>
<span 
class="ptmb7t-x-x-120">(string-lessp S1:string S2:string): extra-boolean                                                      </span><span 
class="ptmri7t-x-x-120">expr</span>
<br 
class="newline" />&#x00A0;      <div class="minipage">Lexicographic comparison of strings. Case differences are ignored.
</div></div>
<!--l. 417--><p class="noindent" ><div class="minipage"><a 
 id="dx28-67009"></a>
<span 
class="ptmb7t-x-x-120">(string-greaterp S1:string S2:string): extra-boolean                                                </span><span 
class="ptmri7t-x-x-120">expr</span>
<br 
class="newline" />&#x00A0;      <div class="minipage">Lexicographic comparison of strings. Case differences are ignored.
</div></div>
<!--l. 422--><p class="noindent" ><div class="minipage"><a 
 id="dx28-67010"></a>
<span 
class="ptmb7t-x-x-120">(string-not-greaterp S1:string S2:string): extra-boolean                                         </span><span 
class="ptmri7t-x-x-120">expr</span>
<br 
class="newline" />&#x00A0;      <div class="minipage">Lexicographic comparison of strings. Case differences are ignored.
</div></div>
<!--l. 427--><p class="noindent" ><div class="minipage"><a 
 id="dx28-67011"></a>
<span 
class="ptmb7t-x-x-120">(string-not-lessp S1:string S2:string): extra-boolean                                               </span><span 
class="ptmri7t-x-x-120">expr</span>
<br 
class="newline" /><div class="minipage">Lexicographic comparison of strings. Case differences are ignored.
</div></div>

<!--l. 432--><p class="noindent" ><div class="minipage"><a 
 id="dx28-67012"></a>
<span 
class="ptmb7t-x-x-120">(string-not-equal S1:string S2:string): extra-boolean                                              </span><span 
class="ptmri7t-x-x-120">expr</span>
<br 
class="newline" /><div class="minipage">Lexicographic comparison of strings. Case differences are ignored.
</div></div>
<!--l. 434--><p class="noindent" >
<h4 class="subsectionHead"><span class="titlemark">6.3.2    </span> <a 
 id="x28-680006.3.2"></a>String Concatenation:</h4>
<!--l. 439--><p class="noindent" ><div class="minipage"><a 
 id="dx28-68001"></a>
<span 
class="ptmb7t-x-x-120">(string-concat [S:string]): string                                                                              </span><span 
class="ptmri7t-x-x-120">macro</span>
<br 
class="newline" /><div class="minipage">Concatenates all of its string arguments, returning the newly created string.
Not in Common LISP.</div></div>
<!--l. 443--><p class="noindent" ><div class="minipage"><a 
 id="dx28-68002"></a>
<span 
class="ptmb7t-x-x-120">(string-repeat S:string I:integer): string                                                                    </span><span 
class="ptmri7t-x-x-120">expr</span>
<br 
class="newline" /><div class="minipage">Appends copy of S to itself total of I-1 times. Not in Common LISP.
</div></div><br 
class="newline" />
<!--l. 445--><p class="noindent" >
<h4 class="subsectionHead"><span class="titlemark">6.3.3    </span> <a 
 id="x28-690006.3.3"></a>Transformation of Strings:</h4>
<!--l. 452--><p class="noindent" ><div class="minipage"><a 
 id="dx28-69001"></a>
<span 
class="ptmb7t-x-x-120">(substring S:string LO:integer HI:integer): string                                                   </span><span 
class="ptmri7t-x-x-120">expr</span>
<br 
class="newline" /><div class="minipage">Same as subseq, but the first argument must be a string. Returns a substring
of S of size (sub1 (- HI LO)), beginning with the element with index LO.
Not in Common LISP.</div></div>
<!--l. 457--><p class="noindent" ><div class="minipage"><a 
 id="dx28-69002"></a>
<span 
class="ptmb7t-x-x-120">(string-trim BAG:</span><span 
class="cmsy-10x-x-120">{</span><span 
class="ptmb7t-x-x-120">list, string</span><span 
class="cmsy-10x-x-120">} </span><span 
class="ptmb7t-x-x-120">S:string): string                                                       </span><span 
class="ptmri7t-x-x-120">expr</span>
<br 
class="newline" />&#x00A0;      <div class="minipage">Remove leading and trailing characters in BAG from a string S.
</div></div>

<div class="verbatim" id="verbatim-140">
&#x00A0;&#x00A0;&#x00A0;&#x00A0;1&#x00A0;lisp&#x003E;&#x00A0;(string-trim&#x00A0;"ABC"&#x00A0;"AABAXYZCB")
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;"XYZ"
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;2&#x00A0;lisp&#x003E;&#x00A0;(string-trim&#x00A0;(list&#x00A0;(char&#x00A0;a)
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;2&#x00A0;lisp&#x003E;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;(char&#x00A0;b)
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;2&#x00A0;lisp&#x003E;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;(char&#x00A0;c))
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;2&#x00A0;lisp&#x003E;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;"AABAXYZCB")
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;"XYZ"
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;3&#x00A0;lisp&#x003E;&#x00A0;(string-trim&#x00A0;'(65&#x00A0;66&#x00A0;67)&#x00A0;"ABCBAVXZCC")
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;"VXZ"
</div>
<!--l. 468--><p class="nopar" >
<!--l. 473--><p class="noindent" ><div class="minipage"><a 
 id="dx28-69003"></a>
<span 
class="ptmb7t-x-x-120">(string-left-trim BAG:</span><span 
class="cmsy-10x-x-120">{</span><span 
class="ptmb7t-x-x-120">list, string</span><span 
class="cmsy-10x-x-120">} </span><span 
class="ptmb7t-x-x-120">S:string): string                                                </span><span 
class="ptmri7t-x-x-120">expr</span>
<br 
class="newline" />&#x00A0;      <div class="minipage">Remove leading characters from string.
</div></div>
<!--l. 478--><p class="noindent" ><div class="minipage"><a 
 id="dx28-69004"></a>
<span 
class="ptmb7t-x-x-120">(string-right-trim BAG:</span><span 
class="cmsy-10x-x-120">{</span><span 
class="ptmb7t-x-x-120">list, string</span><span 
class="cmsy-10x-x-120">} </span><span 
class="ptmb7t-x-x-120">S:string): string                                             </span><span 
class="ptmri7t-x-x-120">expr</span>
<br 
class="newline" /><div class="minipage">Remove trailing characters from string.
</div></div>
<!--l. 482--><p class="noindent" ><div class="minipage"><a 
 id="dx28-69005"></a>
<span 
class="ptmb7t-x-x-120">(string-upcase S:string): string                                                                                   </span><span 
class="ptmri7t-x-x-120">expr</span>
<br 
class="newline" /><div class="minipage">Copy and raise all alphabetic characters in string.
</div></div>
<!--l. 486--><p class="noindent" ><div class="minipage"><a 
 id="dx28-69006"></a>
<span 
class="ptmb7t-x-x-120">(nstring-upcase S:string): string                                                                                 </span><span 
class="ptmri7t-x-x-120">expr</span>
<br 
class="newline" /><div class="minipage">Destructively raise all alphabetic characters in string.
</div></div>
<!--l. 490--><p class="noindent" ><div class="minipage"><a 
 id="dx28-69007"></a>
<span 
class="ptmb7t-x-x-120">(string-downcase S:string): string                                                                              </span><span 
class="ptmri7t-x-x-120">expr</span>
<br 
class="newline" /><div class="minipage">Copy and lower all alphabetic characters in string.
</div></div>

<!--l. 494--><p class="noindent" ><div class="minipage"><a 
 id="dx28-69008"></a>
<span 
class="ptmb7t-x-x-120">(nstring-downcase S:string): string                                                                            </span><span 
class="ptmri7t-x-x-120">expr</span>
<br 
class="newline" /><div class="minipage">Destructively lower all alphabetic characters in string.
</div></div>
<!--l. 499--><p class="noindent" ><div class="minipage"><a 
 id="dx28-69009"></a>
<span 
class="ptmb7t-x-x-120">(string-capitalize S:string): string                                                                              </span><span 
class="ptmri7t-x-x-120">expr</span>
<br 
class="newline" /><div class="minipage">Copy and raise first letter of all words in string; other letters in lower case.
</div></div>
<!--l. 504--><p class="noindent" ><div class="minipage"><a 
 id="dx28-69010"></a>
<span 
class="ptmb7t-x-x-120">(nstring-capitalize S:string): string                                                                            </span><span 
class="ptmri7t-x-x-120">expr</span>
<br 
class="newline" /><div class="minipage">Destructively raise first letter of all words; other letters in lower case.
</div></div><br 
class="newline" />
<!--l. 506--><p class="noindent" >
<h4 class="subsectionHead"><span class="titlemark">6.3.4    </span> <a 
 id="x28-700006.3.4"></a>Type Conversion:</h4>
<!--l. 510--><p class="noindent" ><div class="minipage"><a 
 id="dx28-70001"></a>
<span 
class="ptmb7t-x-x-120">(string-to-list S:string): list                                                                                         </span><span 
class="ptmri7t-x-x-120">expr</span>
<br 
class="newline" /><div class="minipage">Unpack string characters into a list. Not in Common LISP.
</div></div>
<!--l. 514--><p class="noindent" ><div class="minipage"><a 
 id="dx28-70002"></a>
<span 
class="ptmb7t-x-x-120">(string-to-vector S:string): vector                                                                              </span><span 
class="ptmri7t-x-x-120">expr</span>
<br 
class="newline" /><div class="minipage">Unpack string characters into a vector. Not in Common LISP.
</div></div><br 
class="newline" />
<!--l. 516--><p class="noindent" >
<h4 class="subsectionHead"><span class="titlemark">6.3.5    </span> <a 
 id="x28-710006.3.5"></a>Other:</h4>
<!--l. 521--><p class="noindent" ><div class="minipage"><a 
 id="dx28-71001"></a>
<span 
class="ptmb7t-x-x-120">(string-length S:string): integer                                                                                  </span><span 
class="ptmri7t-x-x-120">expr</span>
<br 
class="newline" /><div class="minipage">Last index of a string, plus one. Not in Common LISP. Use string-size.
</div>

</div>
<!--l. 525--><p class="noindent" ><div class="minipage"><a 
 id="dx28-71002"></a>
<span 
class="ptmb7t-x-x-120">(rplachar S:string I:integer C:character): character                                               </span><span 
class="ptmri7t-x-x-120">expr</span>
<br 
class="newline" /><div class="minipage">Store a character C in a string S at position I.
</div></div>
<!--l. 527--><p class="noindent" >
<h4 class="subsectionHead"><span class="titlemark">6.3.6    </span> <a 
 id="x28-720006.3.6"></a>Substring Comparison</h4>
<!--l. 529--><p class="noindent" >The library module STRING-SEARCH provides efficient functions for comparing a string
against a substring of another string.
<!--l. 534--><p class="noindent" ><div class="minipage"><a 
 id="dx28-72001"></a>
<span 
class="ptmb7t-x-x-120">(substring= S1:string S2:string START:integer): boolean                                       </span><span 
class="ptmri7t-x-x-120">expr</span>
<br 
class="newline" /><div class="minipage">Returns true if there is a substring of S2 starting at START and string= to
S1, otherwise returns nil.</div>
</div>
<!--l. 536--><p class="noindent" >Similar to

<div class="verbatim" id="verbatim-141">
(string=&#x00A0;S1&#x00A0;(substring&#x00A0;S2&#x00A0;START&#x00A0;(+&#x00A0;START&#x00A0;(string-length&#x00A0;S1))))
</div>
<!--l. 540--><p class="nopar" >but note that this returns nil (no error is signalled) if there are fewer than

<div class="verbatim" id="verbatim-142">
&#x00A0;&#x00A0;&#x00A0;&#x00A0;(string-length&#x00A0;S1)
</div>
<!--l. 546--><p class="nopar" >characters from position START through the end of S2.
<!--l. 554--><p class="noindent" ><div class="minipage"><a 
 id="dx28-72002"></a>
<span 
class="ptmb7t-x-x-120">(substring-equal S1:string S2:string START:integer): boolean                              </span><span 
class="ptmri7t-x-x-120">expr</span>
<br 
class="newline" />&#x00A0;      <div class="minipage">Returns true if there is a substring of S2 starting at START and string-equal
to S1, otherwise returns nil.</div>
</div>
<!--l. 556--><p class="noindent" >Similar to

<div class="verbatim" id="verbatim-143">
(string-equal&#x00A0;S1&#x00A0;(substring&#x00A0;S2&#x00A0;START&#x00A0;(+&#x00A0;START&#x00A0;(string-length&#x00A0;S1))))
</div>
<!--l. 560--><p class="nopar" >but note that this returns nil (no error is signalled) if there are fewer than

<div class="verbatim" id="verbatim-144">
(string-length&#x00A0;S1)
</div>
<!--l. 566--><p class="nopar" >characters from position START through the end of S2.
<!--l. 569--><p class="noindent" >
<h4 class="subsectionHead"><span class="titlemark">6.3.7    </span> <a 
 id="x28-730006.3.7"></a>Searching for Strings</h4>
<!--l. 571--><p class="noindent" >The library module <span 
class="ptmb7t-x-x-120">str-search </span>provides functions for searching for a string within another
string. These functions are efficiently implemented.
<!--l. 575--><p class="noindent" >The two strings involved in these searching operations are referred to as the &#8221;domain&#8221; and the
&#8221;target&#8221;. These functions search for an occurrence of the &#8221;target&#8221; string within the &#8221;domain&#8221;
string.
<!--l. 580--><p class="noindent" >The operations for string searching return the index of the leftmost character in the first
matching part of the domain string that is found, starting from the left. If no match is found, nil
is returned.
<!--l. 590--><p class="noindent" ><div class="minipage"><a 
 id="dx28-73001"></a>
<span 
class="ptmb7t-x-x-120">(string-search TARG:string DOM:string):</span><span 
class="cmsy-10x-x-120">{</span><span 
class="ptmb7t-x-x-120">integer, nil</span><span 
class="cmsy-10x-x-120">}             </span><span 
class="ptmri7t-x-x-120">expr</span>
<br 
class="newline" />&#x00A0;      <div class="minipage">Searches  for  the  leftmost  occurrence  of  the  target  in  the  domain.  This
function  is  case-sensitive.  If  passed  two  strings,  Common  LISP  &#8221;search&#8221;
will give the same results.</div>
</div>
<!--l. 597--><p class="noindent" ><div class="minipage"><a 
 id="dx28-73002"></a>
<span 
class="ptmb7t-x-x-120">(string-search-from TARG:string DOM:string START:integer):</span><br 
class="newline" /><span 
class="cmsy-10x-x-120">{</span><span 
class="ptmb7t-x-x-120">integer, nil</span><span 
class="cmsy-10x-x-120">}                                     </span><span 
class="ptmri7t-x-x-120">expr</span>
<br 
class="newline" />&#x00A0;      <div class="minipage">Like string-search, but the search effectively starts at index START in the
domain.</div></div>
<!--l. 602--><p class="noindent" ><div class="minipage"><a 
 id="dx28-73003"></a>
<span 
class="ptmb7t-x-x-120">(string-search-equal TARG:string DOM:string):</span><span 
class="cmsy-10x-x-120">{</span><span 
class="ptmb7t-x-x-120">integer, nil</span><span 
class="cmsy-10x-x-120">}          </span><span 
class="ptmri7t-x-x-120">expr</span>
<br 
class="newline" />&#x00A0;      <div class="minipage">Like string-search except that the comparisons are case-insensitive.
</div></div>
<!--l. 610--><p class="noindent" ><div class="minipage"><a 
 id="dx28-73004"></a>
<span 
class="ptmb7t-x-x-120">(string-search-from-equal TA:string D:string ST:integer):</span><br 
class="newline" /><span 
class="cmsy-10x-x-120">{</span><span 
class="ptmb7t-x-x-120">integer, nil</span><span 
class="cmsy-10x-x-120">}                                     </span><span 
class="ptmri7t-x-x-120">expr</span>
<br 
class="newline" />&#x00A0;      <div class="minipage">Like string-search-from except that the comparisons are case-insensitive.
</div></div>

<!--l. 612--><p class="noindent" >
<h4 class="subsectionHead"><span class="titlemark">6.3.8    </span> <a 
 id="x28-740006.3.8"></a>Reading and Writing Strings</h4>
<!--l. 614--><p class="noindent" >The library module <span 
class="ptmb7t-x-x-120">str-input </span>provides some facilities to support taking input from strings.
Among other things, this permits a user to obtain a number from its printed representation using
the PSL number parser.
<!--l. 634--><p class="noindent" ><div class="minipage"><a 
 id="dx28-74001"></a>
<span 
class="ptmb7t-x-x-120">(with-input-from-string HEADER:list [BODY:form]):any                                  </span><span 
class="ptmri7t-x-x-120">macro</span>
<br 
class="newline" /><div class="minipage">The argument HEADER should be a two element list. <br 
class="newline" />The   first   element   should   be   an   identifier,   the   second   a   string.   <span 
class="pcrr7t-x-x-120">(</span><span 
class="cmmi-12">&#x003C;</span>
<span 
class="cmmi-12">channel &#x003E;&#x003C; string &#x003E;</span><span 
class="pcrr7t-x-x-120">)</span>. The argument <span 
class="cmmi-12">&#x003C; string &#x003E; </span>is treated as if it were
the text of a file. The argument <span 
class="cmmi-12">&#x003C; channel &#x003E; </span>is bound to an input channel
which is opened to give access to <span 
class="cmmi-12">&#x003C; string &#x003E;</span>. Once the channel has been
opened, each form BODY is evaluated (the forms are evaluated in a left to
right order). It is expected that these forms will be used to read and process
input from <span 
class="cmmi-12">&#x003C; string &#x003E;</span>. The value of the last form is returned. Once the
application of with-input-from-string is complete the input channel will be
closed.</div></div>

<div class="verbatim" id="verbatim-145">
&#x00A0;&#x00A0;&#x00A0;&#x00A0;(de&#x00A0;string-to-words&#x00A0;(string)
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;(with-input-from-string
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;(channel&#x00A0;string)
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;(do&#x00A0;((result&#x00A0;nil&#x00A0;(aconc&#x00A0;result&#x00A0;item))
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;(item&#x00A0;(channelread&#x00A0;channel)&#x00A0;(channelread&#x00A0;channel)))
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;((eq&#x00A0;item&#x00A0;$eof$)&#x00A0;result))))
</div>
<!--l. 643--><p class="nopar" >

<div class="verbatim" id="verbatim-146">
&#x00A0;&#x00A0;&#x00A0;&#x00A0;1&#x00A0;lisp&#x003E;&#x00A0;(string-to-words&#x00A0;"DOCUMENTATION&#x00A0;IS&#x00A0;FUN")
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;(DOCUMENTATION&#x00A0;IS&#x00A0;FUN)
</div>
<!--l. 647--><p class="nopar" >
<!--l. 655--><p class="noindent" ><div class="minipage"><a 
 id="dx28-74002"></a>
<span 
class="ptmb7t-x-x-120">(string-read STR:string): any                                                                                     </span><span 
class="ptmri7t-x-x-120">expr</span>
<br 
class="newline" /><div class="minipage">Reads one s-expression from the string STR. The function channelread is
used to do this. Note that it is not necessary to terminate the string with
a delimiter  character.  An  end  of  file  character  is  also  considered  to  be  a
delimiter character.</div></div>

<div class="verbatim" id="verbatim-147">
&#x00A0;&#x00A0;&#x00A0;&#x00A0;1&#x00A0;lisp&#x003E;&#x00A0;(string-read&#x00A0;"TOKEN")
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;TOKEN
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;2&#x00A0;lisp&#x003E;&#x00A0;(string-read&#x00A0;"TWO&#x00A0;TOKENS")
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;TWO
</div>
<!--l. 661--><p class="nopar" >Notice that characters beyond the first s-expression are ignored. This function is defined in
terms of with-input-from-string.

<div class="verbatim" id="verbatim-148">
&#x00A0;&#x00A0;&#x00A0;&#x00A0;(de&#x00A0;string-read&#x00A0;(string)
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;(with-input-from-string
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;(ch&#x00A0;string)
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;(channelread&#x00A0;ch)))
</div>
<!--l. 671--><p class="nopar" >The library module <span 
class="ptmb7t-x-x-120">string-output </span>provides a facility for writing to strings. The function bldmsg
provides the capability to construct a string using formatting directives. However,
complicated strings can be constructed more easily using the macro with-output-to-string.
For example, longer strings can be constructed by including the channellinelength
function; items can be printed to the string incrementally (in a stream-like fashion) from a
loop
<!--l. 689--><p class="noindent" ><div class="minipage"><a 
 id="dx28-74003"></a>
<span 
class="ptmb7t-x-x-120">(with-output-to-string HEADER:list [BODY:form]): string                                </span><span 
class="ptmri7t-x-x-120">macro</span>
<br 
class="newline" /><div class="minipage">The argument HEADER should be a two element list. The first element
should be an identifier. The second element can be either a string or nil (in
which case a default initial string is allocated) &#8211; in either case, the initial
string is extened as necessary.</div>
</div>The written string is return as a result (this is a substring copy of the string used for writing).
For example,

<div class="verbatim" id="verbatim-149">
&#x00A0;&#x00A0;&#x00A0;&#x00A0;(setf&#x00A0;row
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;(with-output-to-string&#x00A0;(wchan&#x00A0;nil)
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;(channellinelength&#x00A0;wchan&#x00A0;350)
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;(for&#x00A0;(in&#x00A0;tab&#x00A0;'(0&#x00A0;100&#x00A0;200&#x00A0;300))
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;(in&#x00A0;str&#x00A0;'("A"&#x00A0;"B"&#x00A0;"C"&#x00A0;"D"))
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;(do&#x00A0;(channelprintf&#x00A0;wchan&#x00A0;"%t%w"&#x00A0;tab&#x00A0;str))
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;)))
</div>
<!--l. 701--><p class="nopar" >

<!--l. 1--><p class="noindent" ><table cellspacing="5"><tr><td class="clinks"><a 
href="allman1li5.html#allman1se20.html" >Up</a></td><td class="clinks"><a 
href="allman1se19.html" >Prev</a></td><td class="clinks"><a 
href="allman1se19.html#tailallman1se19.html" >PrevTail</a></td><td class="clinks"><a 
href="allman1se20.html" >Front</a></td></tr></table><a 
 id="tailallman1se20.html"></a>   
</body></html> 
