<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"  
  "http://www.w3.org/TR/html4/loose.dtd">  
<html > 
<head><title>Value Cell Functions</title> 
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1"> 
<meta name="generator" content="TeX4ht (http://www.cse.ohio-state.edu/~gurari/TeX4ht/)"> 
<meta name="originator" content="TeX4ht (http://www.cse.ohio-state.edu/~gurari/TeX4ht/)"> 
<!-- 3,html --> 
<meta name="src" content="allman1.tex"> 
<meta name="date" content="2014-05-02 18:10:00"> 
<link rel="stylesheet" type="text/css" href="allman1.css"> 
</head><body 
>
<p align="centre"><img src="https://reduce-algebra.sourceforge.io/lisp-docs/redlogo.png" width=621 height=60 border=0 alt="REDUCE"></p><table cellspacing="5"><tr><td class="clinks"><a 
href="allman1li3.html#allman1se11.html" >Up</a></td><td class="clinks"><a 
href="allman1se12.html" >Next</a></td><td class="clinks"><a 
href="allman1se10.html" >Prev</a></td><td class="clinks"><a 
href="allman1se10.html#tailallman1se10.html" >PrevTail</a></td><td class="clinks"><a 
href="allman1se11.html#tailallman1se11.html">Tail</a></td></tr></table><h3 class="sectionHead"><span class="titlemark">4.4    </span> <a 
 id="x17-390004.4"></a>Value Cell Functions</h3>
<!--l. 409--><p class="noindent" >The contents of the value cell of an id is usually accessed by eval (Chapter 11) or valuecell
(below) and changed by setq, setf or sometimes set.
<!--l. 417--><p class="noindent" ><div class="minipage"><a 
 id="dx17-39001"></a>
<span 
class="ptmb7t-x-x-120">(setq [VARIABLE:id VALUE:any]): any                                                                 </span><span 
class="ptmri7t-x-x-120">fexpr</span>
<br 
class="newline" /><div class="minipage">The value of each VARIABLE is set to the corresponding value of VALUE.
Each  argument  VALUE  is  evaluated,  each  argument  VARIABLE  is  not
evaluated. It is not true that</div></div>

<div class="verbatim" id="verbatim-76">
&#x00A0;&#x00A0;&#x00A0;&#x00A0;(setq&#x00A0;variable&#x00A0;value)
</div>
<!--l. 420--><p class="nopar" >is equivalent to

<div class="verbatim" id="verbatim-77">
&#x00A0;&#x00A0;&#x00A0;&#x00A0;(set&#x00A0;'variable&#x00A0;value)
</div>
<!--l. 425--><p class="nopar" >
<!--l. 427--><p class="noindent" >Where setq may be used to set any type of variable (fluid, global or local) the function set is
restricted to fluid and global variables.
<!--l. 436--><p class="noindent" ><div class="minipage"><a 
 id="dx17-39002"></a>
<span 
class="ptmb7t-x-x-120">(set EXP:id VALUE:any): any                                                                                    </span><span 
class="ptmri7t-x-x-120">expr</span>
<br 
class="newline" /><div class="minipage">Set is used to define the value cell of fluid and global identifiers. An error
occurs if EXP does not evaluate to an identifier.</div></div>

<div class="verbatim" id="verbatim-78">
&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x22C6;&#x22C6;&#x22C6;&#x22C6;&#x22C6;&#x00A0;An&#x00A0;attempt&#x00A0;was&#x00A0;made&#x00A0;to&#x00A0;do&#x00A0;SET&#x00A0;on&#x00A0;&#8216;EXP',&#x00A0;which&#x00A0;&#x00A0;is&#x00A0;&#x00A0;not
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;an&#x00A0;identifier
</div>
<!--l. 440--><p class="nopar" >If EXP evaluates to t or nil an error occurs.

<div class="verbatim" id="verbatim-79">
&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x22C6;&#x22C6;&#x22C6;&#x22C6;&#x22C6;&#x00A0;Cannot&#x00A0;change&#x00A0;T&#x00A0;or&#x00A0;NIL
</div>
<!--l. 445--><p class="nopar" ><div class="minipage"><a 
 id="dx17-39003"></a>
<span 
class="ptmb7t-x-x-120">(desetq U:any V:any): V:any                                                                                    </span><span 
class="ptmri7t-x-x-120">macro</span>
<br 
class="newline" /><div class="minipage">This function is part of the USEFUL package. Desetq is a destructuring
setq. That is, the first argument is a list whose elements are ids. The value
of each id is set to the corresponding element in the second argument. For
example, evaluation of</div>
</div>

<div class="verbatim" id="verbatim-80">
&#x00A0;&#x00A0;&#x00A0;&#x00A0;(desetq&#x00A0;(A&#x00A0;(B)&#x00A0;.&#x00A0;C)&#x00A0;'((1)&#x00A0;(2)&#x00A0;(3)&#x00A0;4))
</div>
<!--l. 454--><p class="nopar" >defines the value of A to be (1), B to be 2, and C to ((3) 4).
<!--l. 461--><p class="noindent" ><div class="minipage"><a 
 id="dx17-39004"></a>
<span 
class="ptmb7t-x-x-120">(psetq [VARIABLE:id VALUE:any]): Undefined                                                  </span><span 
class="ptmri7t-x-x-120">macro</span>
<br 
class="newline" /><div class="minipage">This function is defined in the USEFUL package. Psetq is very similar to
setq. The difference is that with psetq each VALUE is evaluated before any
assignment is made.</div>
</div>

<div class="verbatim" id="verbatim-81">
&#x00A0;&#x00A0;&#x00A0;&#x00A0;1&#x00A0;lisp&#x003E;&#x00A0;(setq&#x00A0;a&#x00A0;'same&#x00A0;&#x00A0;b&#x00A0;a)
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;SAME
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;2&#x00A0;lisp&#x003E;&#x00A0;(eq&#x00A0;a&#x00A0;b)
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;T
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;3&#x00A0;lisp&#x003E;&#x00A0;(psetq&#x00A0;a&#x00A0;'other&#x00A0;&#x00A0;b&#x00A0;a)
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;OTHER
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;4&#x00A0;lisp&#x003E;&#x00A0;(eq&#x00A0;a&#x00A0;b)
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;NIL
</div>
<!--l. 471--><p class="nopar" >
<!--l. 489--><p class="noindent" ><div class="minipage"><a 
 id="dx17-39005"></a>
<span 
class="ptmb7t-x-x-120">(setf [LHS:form RHS:any]): RHS:any                                                                   </span><span 
class="ptmri7t-x-x-120">macro</span>
<br 
class="newline" /><div class="minipage">The ability to assign values to ids allows us to think of ids as variables. We
can generalize this notion of variable. For example, a list can be thought of
as a collection of anonymous variables. Usually there are seperate access
and  update  functions  for  each  kind  of  generalized  variable.  For  example
the function cdr accesses the cdr of a pair, the function rplacd updates it.
However, we can think of a call on an access function as a reference to a
storage location. Just as we consider the mention of an id to be a reference to
its value, (cdr pair) can be thought of as the name for the cdr for some pair.
Rather than having to remember two functions for each kind of generalized
variable  (rplacd  corresponds  to  cdr),  we  can  adopt  a  uniform  syntax  for
updating storage locations using the setf macro.</div>
</div><br 
class="newline" />
<!--l. 491--><p class="noindent" >The application of setf can take on any one of the following forms:<br 
class="newline" />
<!--l. 495--><p class="noindent" ><span 
class="pcrr7t-x-x-120">(setf id data)    </span>expands into        <span 
class="pcrr7t-x-x-120">(setq id data)</span>
<!--l. 499--><p class="noindent" ><span 
class="pcrr7t-x-x-120">(setf (eval form) data)    </span>expands into        <span 
class="pcrr7t-x-x-120">(set form data)</span><br 
class="newline" />
<!--l. 503--><p class="noindent" >The same effect is obtained by substituting value in place of eval.<br 
class="newline" />
<!--l. 506--><p class="noindent" ><span 
class="pcrr7t-x-x-120">(setf (car pair) data)    </span>expands into        <span 
class="pcrr7t-x-x-120">(rplaca pair data)</span>
<!--l. 510--><p class="noindent" ><span 
class="pcrr7t-x-x-120">(setf (cdr pair) data)    </span>expands into        <span 
class="pcrr7t-x-x-120">(rplacd pair data)</span>
<!--l. 514--><p class="noindent" ><span 
class="pcrr7t-x-x-120">(setf (getv vector index) data)    </span>expands into        <br 
class="newline" />         <span 
class="pcrr7t-x-x-120">(putv vector index data)</span>
<!--l. 518--><p class="noindent" ><span 
class="pcrr7t-x-x-120">(setf (indx form index) data)    </span>expands into        <br 
class="newline" />         <span 
class="pcrr7t-x-x-120">(setindx form index data)</span>
<!--l. 522--><p class="noindent" ><span 
class="pcrr7t-x-x-120">(setf (sub form start size) data)    </span>expands into        <br 
class="newline" />         <span 
class="pcrr7t-x-x-120">(setsub form start size data)</span>
<!--l. 526--><p class="noindent" ><span 
class="pcrr7t-x-x-120">(setf (nth pair index) data)    </span>expands into an expression similar to
<br 
class="newline" />         <span 
class="pcrr7t-x-x-120">(rplaca (pnth pair index) data)</span><br 
class="newline" />
<!--l. 531--><p class="noindent" >If the first argument to setf is a macro then it will be expanded before setf is. For example, if first
is defined as<br 
class="newline" />
<!--l. 534--><p class="noindent" ><span 
class="pcrr7t-x-x-120">(ds first (p) (car p)) </span>then<br 
class="newline" />
<!--l. 536--><p class="noindent" ><span 
class="pcrr7t-x-x-120">(setf (first p) data)    </span>is equivalent to        <span 
class="pcrr7t-x-x-120">(setf (car p) data)</span><br 
class="newline" />
<!--l. 540--><p class="noindent" >The USEFUL module contains an expanded version of setf. The basic definition of setf is not
consistent with that of setq. The value returned from an application of setq is always the value
assigned. For example, the expression<br 
class="newline" />
<!--l. 547--><p class="noindent" ><span 
class="pcrr7t-x-x-120">(setf (car '(a b)) 'd)    </span>expands into        <span 
class="pcrr7t-x-x-120">(rplaca '(a b) 'd)</span><br 
class="newline" />
<!--l. 551--><p class="noindent" >The value returned after evaluating this second expression is (d b). The extended version of setf
will always return the value assigned.<br 
class="newline" />
<!--l. 556--><p class="noindent" >An application of the extended version of setf will accept the additional following
forms:<br 
class="newline" />
<!--l. 561--><p class="noindent" ><span 
class="pcrr7t-x-x-120">(setf (cons left right) pair)    </span>will expand into an expression similar to
<br 
class="newline" />     <span 
class="pcrr7t-x-x-120">(progn (setf left (car pair)) (setf right (cdr pair)))</span><br 
class="newline" />
<!--l. 566--><p class="noindent" ><span 
class="pcrr7t-x-x-120">(setf (cXYr pair) data)    </span>expands into an expression similar to        <br 
class="newline" />         <span 
class="pcrr7t-x-x-120">(rplacX (cYr pair) data)</span><br 
class="newline" />
<!--l. 571--><p class="noindent" >where X is either a or d and Y is either a, d, aa, ..., or ddd<br 
class="newline" />
<!--l. 574--><p class="noindent" ><span 
class="pcrr7t-x-x-120">(setf (flagp id name) data)    </span>expands into an expression similar to
<br 
class="newline" />         <span 
class="pcrr7t-x-x-120">(flag (list id) name)</span>, if data is non-nil otherwise<br 
class="newline" />         <span 
class="pcrr7t-x-x-120">(remflag (list id) name)</span>
<!--l. 579--><p class="noindent" ><span 
class="pcrr7t-x-x-120">(setf (get id name) data)    </span>expands into        <span 
class="pcrr7t-x-x-120">(put id name data)</span>
<!--l. 583--><p class="noindent" ><span 
class="pcrr7t-x-x-120">(setf (getd name) data)    </span>expands into an expression similar to        <br 
class="newline" />         <span 
class="pcrr7t-x-x-120">(putd name (car data) (cdr data))</span><br 
class="newline" />
<!--l. 588--><p class="noindent" >This expansion assumes that data is similar to an expression which would be returned by a call
on getd. If data is a code-pointer or a lambda expression then &#8217;expr is used in place of (car
data).<br 
class="newline" />
<!--l. 593--><p class="noindent" ><span 
class="pcrr7t-x-x-120">(setf (lastcar pair) data)    </span>expands into an expression similar to
<br 
class="newline" />         <span 
class="pcrr7t-x-x-120">(rplaca (lastpair pair) data).</span>
<!--l. 597--><p class="noindent" ><span 
class="pcrr7t-x-x-120">(setf (list a b c ...) pair)</span><br 
class="newline" />     the expansion of this expression is very similar to the expansion of        <br 
class="newline" />         <span 
class="pcrr7t-x-x-120">(desetq (a b c ...) pair)</span>
<!--l. 602--><p class="noindent" ><span 
class="pcrr7t-x-x-120">(setf (pnth pair index) data)    </span>expands into an expression similar to
<br 
class="newline" />         <span 
class="pcrr7t-x-x-120">(rplacd (pnth pair (sub1 index)) data)</span>
<!--l. 606--><p class="noindent" ><span 
class="pcrr7t-x-x-120">(setf (vector al bl cl ...) [ar br cr ...])</span><br 
class="newline" />     expands into an expression similar to<br 
class="newline" />         <span 
class="pcrr7t-x-x-120">(progn (setf al ar)(setf bl br)(setf cl cr)...)</span>
<!--l. 610--><p class="noindent" >The setf function is extensible to permit additional operators on the left hand side. If there is an
assign-op property on the property list of the operator then the value of that property (either a
lambda expression or the name of a function) is used to build the expansion of the macro. The
effect is similar to

<div class="verbatim" id="verbatim-82">
&#x00A0;&#x00A0;&#x00A0;&#x00A0;(apply&#x00A0;(get&#x00A0;op&#x00A0;'assign-op)&#x00A0;(append&#x00A0;(cdr&#x00A0;lhs)&#x00A0;(list&#x00A0;rhs)))
</div>
<!--l. 617--><p class="nopar" >The property setf-expand is searched for when their is no assign-op property. If there is such a
property its value is applied to the two arguments passed to setf. The effect is similar
to

<div class="verbatim" id="verbatim-83">
&#x00A0;&#x00A0;&#x00A0;&#x00A0;(apply&#x00A0;op&#x00A0;(list&#x00A0;lhs&#x00A0;rhs))
</div>
<!--l. 624--><p class="nopar" >If the left hand side operator is flagged as setf-safe, then it is assumed that the expansion of the
macro will yeild an expression which will return the value of the right hand side. Otherwise
the expansion will take one of the forms listed below. Within the second expansion,
references to RHS are replaced with references to VAR. The second form is used when
RHS is a list, the assumption being that it is effecient to evaluate an application only
once.

<div class="verbatim" id="verbatim-84">
&#x00A0;&#x00A0;&#x00A0;&#x00A0;(progn&#x00A0;expansion&#x00A0;rhs)
&#x00A0;<br />
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;(let&#x00A0;((var&#x00A0;rhs))
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;expansion
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;var)
</div>
<!--l. 640--><p class="nopar" ><div class="minipage"><a 
 id="dx17-39006"></a>
<span 
class="ptmb7t-x-x-120">(psetf [LHS:form RHS:any]): Undefined                                                               </span><span 
class="ptmri7t-x-x-120">macro</span>
<br 
class="newline" /><div class="minipage">This function is defined in the USEFUL package. Psetf is very similar to
setf.  The  difference  is  that  with  psetf  each  RHS  is  evaluated  before  any
assignment is made.</div>
</div>
<!--l. 651--><p class="noindent" ><div class="minipage"><a 
 id="dx17-39007"></a>
<span 
class="ptmb7t-x-x-120">(makeunbound U:id): Undefined                                                                               </span><span 
class="ptmri7t-x-x-120">expr</span>
<br 
class="newline" /><div class="minipage">U is made an unbound identifier, that is to say it will no longer have a value.
This function should be applied to fluid identifiers only.</div>
</div>
<!--l. 659--><p class="noindent" ><div class="minipage"><a 
 id="dx17-39008"></a>
<span 
class="ptmb7t-x-x-120">(valuecell U:id): any                                                                                                     </span><span 
class="ptmri7t-x-x-120">expr</span>
<br 
class="newline" /><div class="minipage">Safe access to the value cell of an id. If U is not an id a type mismatch
error occurs. If U is an unbound id, an unbound id error occurs. Otherwise
the current value of U is returned. This function should be applied to fluid
identifiers only.</div>
</div>
<!--l. 664--><p class="noindent" ><div class="minipage"><a 
 id="dx17-39009"></a>
<span 
class="ptmb7t-x-x-120">(unboundp U:id): boolean                                                                                           </span><span 
class="ptmri7t-x-x-120">expr</span>
<br 
class="newline" /><div class="minipage">Returns  t  is  U  is  unbound.  This  function  should  be  applied  to  fluid
identifiers only.</div>
</div>

<table cellspacing="5"><tr><td class="clinks"><a 
href="allman1li3.html#allman1se11.html" >Up</a></td><td class="clinks"><a 
href="allman1se12.html" >Next</a></td><td class="clinks"><a 
href="allman1se10.html" >Prev</a></td><td class="clinks"><a 
href="allman1se10.html#tailallman1se10.html" >PrevTail</a></td><td class="clinks"><a 
href="allman1se11.html" >Front</a></td></tr></table><a 
 id="tailallman1se11.html"></a>  
</body></html> 
