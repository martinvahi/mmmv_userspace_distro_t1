<!DOCTYPE html> 
<html lang="en-US" xml:lang="en-US" > 
<head><title>MRVLIMIT: A New Exp-Log Limits Package</title> 
<meta  charset="utf-8" /> 
<meta name="generator" content="TeX4ht (https://tug.org/tex4ht/)" /> 
<meta name="viewport" content="width=device-width,initial-scale=1" /> 
<link rel="stylesheet" type="text/css" href="manual.css" /> 
<meta name="src" content="manual.tex" /> 
<script>window.MathJax = { tex: { tags: "ams", }, }; </script> 
 <script type="text/javascript" async="async" id="MathJax-script" src="../../cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js"></script>  
<meta name="description" content="The REDUCE Computer Algebra System User's Manual" /> 
</head><body 
>
<header>REDUCE</header><table cellspacing="5"><tr><td class="clinks"><a 
href="../manual-lookup.php%3FUser&#32;Contributed&#32;Packages.html#manualse158.html" >Up</a></td><td class="clinks"><a 
href="manualse159.html" >Next</a></td><td class="clinks"><a 
href="manualse157.html" >Prev</a></td><td class="clinks"><a 
href="manualse157.html#tailmanualse157.html" >PrevTail</a></td><td class="clinks"><a 
href="manualse158.html#tailmanualse158.html">Tail</a></td></tr></table><h3 class="sectionHead"><span class="titlemark">20.35    </span> <a 
 id="x233-92700020.35"></a>MRVLIMIT: A New Exp-Log Limits Package</h3>
<a 
 id="dx233-927001"></a>
<a 
 id="dx233-927002"></a>
<!--l. 690--><p class="noindent" >Author: Neil Langmead
</p><!--l. 692--><p class="noindent" >This package was written when the author was a placement student at ZIB Berlin.
</p><!--l. 3--><p class="noindent" >
</p>
<h4 class="subsectionHead"><span class="titlemark">20.35.1    </span> <a 
 id="x233-92800020.35.1"></a>The Exp-Log Limits package</h4>
<!--l. 4--><p class="noindent" >This package arises from the PhD thesis of Dominik Gruntz, of the ETH Zürich. He
developed a new algorithm to compute limits of &#x0022;exp-log&#x0022; functions. Many of the
examples he gave were unable to be computed by the present limits package in
REDUCE, the simplest example being the following, whose limit is obviously
\(0\):
                                                                     

                                                                     
</p>
<pre class="verbatim" id="verbatim-1205">
load limits;

limit(x^7/e^x,x,infinity);

        7
       x
limit(----,x,infinity)
        x
       e
</pre>
<!--l. 15--><p class="nopar" >
</p><!--l. 17--><p class="noindent" >This particular problem arises, because L’Hôpital’s rule for the computation of
indeﬁnite forms (such as \(0/0\), or \(\frac {\infty }{\infty }\)) can only be applied in a CAS a ﬁnite number of times, and
in REDUCE, this number is 3. Applied 7 times to the above problem would have yielded
the correct answer 0. The new algorithm solves this particular problem, and enables the
computation of many more limit calculations in REDUCE. We ﬁrst deﬁne the domain in
which we work, and then give a statement of the main algorithm that is used in this
package.<br 
class="newline" /> Deﬁnition: <br 
class="newline" />Let \(\Re [x]\) be the ring of polynomials in \(x\) with real coeﬃcients, and let \(f\) be an element in this
ring. The ﬁeld which is obtained from \(\Re [x]\) by closing it under the operations \(f\rightarrow \exp (f)\) and \(f\rightarrow \log |f|\) is called
the \(L\)- ﬁeld (or logarithmico-exponential ﬁeld, or ﬁeld of exp-log functions for
short).<br 
class="newline" /> Hardy proved that every \(L\) function is ultimately continuous, of constant sign, monotonic,
and tends to \(\pm \infty \) or to a ﬁnite real constant as \(x\rightarrow +\infty .\)
</p><!--l. 24--><p class="noindent" >Here are some examples of exp-log functions, which the package is able to deal with: \begin {align*}  f(x) &amp;=e^{x}*\log (\log (x)) \\[2mm] f(x) &amp;=\frac {\log (\log (x+e^{-x}))}{e^{x^{2}}+\log (\log (x))} \\[2mm] f(x) &amp;=\log (x)^{\log (x)} \\[2mm] f(x) &amp;=e^{x*\log (x)}  \end {align*}
</p><!--l. 32--><p class="noindent" >
</p>
                                                                     

                                                                     
<h4 class="subsectionHead"><span class="titlemark">20.35.2    </span> <a 
 id="x233-92900020.35.2"></a>The Algorithm</h4>
<!--l. 33--><p class="noindent" >A complete statement of the algorithm now follows: Let \(f\) be a log-exp function in \(x\), whose
limit we wish to compute as \(x\rightarrow x_0.\) The main steps of the algorithm to do this are as follows:
</p>
     <ul class="itemize1">
     <li class="itemize">
     <!--l. 37--><p class="noindent" >Determine the set \(\Omega \) of the most rapidly varying subexpressions of \(f(x)\). Limits
     may have to be computed recursively at this stage.
     </p></li>
     <li class="itemize">
     <!--l. 38--><p class="noindent" >Choose an expression \(\omega \) such that \(\omega &gt;0\), \(\lim _{x \rightarrow \infty } \omega =0 \) and \(\omega \) is in the same comparability class as
     any element of \(\Omega \). Rewrite the other expressions in \(\Omega \) as \(A(x)\omega ^{c}\), where \(A(x)\) only contains
     subexpressions in lower comparability classes than \(\Omega \).
     </p></li>
     <li class="itemize">
     <!--l. 39--><p class="noindent" >Let \(f(\omega )\) be the function obtained from \(f(x)\) by replacing all elements of \(\Omega \) by their
     representation  in  terms  of  \(\omega \).  Consider  all  expressions  independent  of  \(\omega \)  as
     constants and compute the leading term of the power series of f(\(\omega \)) around \(\omega =0^{+}\)
     </p></li>
     <li class="itemize">
     <!--l. 40--><p class="noindent" >If  the  leading  exponent  \(e_0&gt;0\),  then  the  limit  is  0,  and  we  stop.  If  the  leading
     exponent \(e_0&lt;0\) then the limit is \(\pm \infty \). The sign is deﬁned by the sign of the leading
     coeﬃcient \(c_0\). If the leading exponent \(e_0=0\) then the limit is the limit of the leading
     coeﬁcient  \(c_0\).  If  \(c_0\not \in C\),  where  \(C=\text {Const}(L)\),  the  set  of  exp-log  constants,  we  apply  the  same
     algorithm recursively on \(c_0\).</p></li></ul>
<!--l. 43--><p class="noindent" >The algorithm to compute the most rapidly varying subset (the mrv set) of a function f is
given below:
</p>
<div class="flushleft" 
>
<!--l. 45--><p class="noindent" >
 procedure mrv(f)<br />
% f an exp log function in \(x\)<br />
if (not (depend(f,\(x\)))) \(\rightarrow \) return ({})<br />
                            else if \(f=x \rightarrow \) return({\(x\)})<br />
                            else if \(f=gh \rightarrow \) return(max(mrv(g),mrv(h)))<br />
                                                                     

                                                                     
else if \(f=g+h \rightarrow \) return(max(mrv(g),mrv(h)))<br />
else if \(f=g^{c}\) and c \(\in C \rightarrow \) return(mrv(g))<br />
else if \(f=\log (g) \rightarrow \) return(mrv(g))<br />
else if \(f=e^{g} \rightarrow \)<br />
           if \(\lim _{x \rightarrow \infty } g=\pm \infty \rightarrow \)<br />
           return(max({\(e^{g}\)}, mrv(g)))<br />
           else \(\rightarrow \) return mrv(g)<br />
<span 
class="ptmb8t-x-x-109">end</span></p></div>
<!--l. 62--><p class="noindent" >The function max() computes the maximum of the two sets of expressions. Max()
compares two elements of its argument sets and returns the set which is in the
higher comparability class or the union of both if they have the same order of
variation.<br 
class="newline" /> For further details, proofs and explanations of the algorithm, please consult <span class="cite">[<a 
href="manualap2.html#XGruntz:96">Gru96</a>]</span>.
</p><!--l. 66--><p class="noindent" >For example, we have \begin {align*}  &amp;\text {mrv}(e^{x})=\{e^x\} \\ &amp;\text {mrv}(\log (\log (\log (x+x^2+x^3))))=\{x\} \\ &amp;\text {mrv}(x)=\{x\} \\ &amp;\text {mrv}(e^x+e^{-x}+x^2+x \log (x))= \{e^x,e^{-x} \} \\ &amp;\text {mrv}(e^{e^{-x}})=\{e^{-x} \}  \end {align*}
</p><!--l. 75--><p class="noindent" >
</p>
<h5 class="subsubsectionHead"><span class="titlemark">20.35.2.1    </span> <a 
 id="x233-93000020.35.2.1"></a>Mrv_limit Examples</h5>
<a 
 id="dx233-930001"></a>
<!--l. 77--><p class="noindent" >Consider the following in REDUCE:
                                                                     

                                                                     
</p>
<pre class="verbatim" id="verbatim-1206">
mrv_limit(e^x,x,infinity);

infinity

mrv_limit(1/log(x),x,infinity);

0

b:=e^x*(e^(1/x-e^-x)-e^(1/x));


           -1        - x
      x + x      - e
b := e       *(e         - 1)


mrv_limit(b,x,infinity);


-1


                                       -1
  ex:=  - log(log(log(log(x))) + log(x))  *log(x)

                       *(log(log(x)) - log(log(log(x)) + log(x)));


            - log(x)*(log(log(x)) - log(log(log(x)) + log(x)))
ex:=     -----------------------------------------------------
                    log(log(log(log(x))) + log(x))

off mcd;

mrv_limit(ex,x,infinity);

1

                                                                     

                                                                     

(log(x+e^-x)+log(1/x))/(log(x)*e^x);

  - x       -1       -1          - x
e    *log(x)  *(log(x  ) + log(e     + x));

mrv_limit(ws,x,infinity);

0

mrv_limit((log(x)*e^-x)/e^(log(x)+e^(x^2)),x,infinity);

0

</pre>
<!--l. 131--><p class="nopar" >
</p>
<h4 class="subsectionHead"><span class="titlemark">20.35.3    </span> <a 
 id="x233-93100020.35.3"></a>The tracing facility</h4>
<!--l. 134--><p class="noindent" >The package provides a means of tracing the \(mrv\_limit\) function at its main steps, and is intended
to help the user if he encounters problems. Messages are displayed informing the
user which Taylor expansion is being computed, all recursive calls are listed,
and the value returned by the \(mrv\) function is given. This information is displayed
when a switch \(tracelimit\) is on. This is oﬀ by default, but can be switched on with the
command
                                                                     

                                                                     
</p>
<pre class="verbatim" id="verbatim-1207">
on tracelimit;
</pre>
<!--l. 137--><p class="nopar" > For a more complete examination of the workings of the algorithm, the user could also
try the command
                                                                     

                                                                     
</p>
<pre class="verbatim" id="verbatim-1208">
tr mrv_limit;
</pre>
<!--l. 141--><p class="nopar" > This is not recommended, as the amount of information returned is often huge and
diﬃcult to wade through. Here is a simple example in REDUCE:
                                                                     

                                                                     
</p>
<pre class="verbatim" id="verbatim-1209">

Loading image file: /silo/cons/reduce35/Alpha/binary/redu37a.img
REDUCE Development Version,  4-Nov-96 ...

1: load mrvlimit;

2: on tracelimit;

3: mrv_limit(e^x,x,infinity);

mrv_f is {x}

                     x
After move_up, f is e

                        -1
performing taylor on: ww

                      -1
series expansion is ww

            -1
series is ww

exponent list is {expt,-1}

leading exponent e0 is {expt,-1}

           x
mrv_f is {e }

h is x

mrv_f is {x}

                     x
After move_up, f is e

                                                                     

                                                                     
                        -1
performing taylor on: ww

                      -1
series expansion is ww

            -1
series is ww

exponent list is {expt,-1}

leading exponent e0 is {expt,-1}

                            - x
small has been changed to e

                                 -1
After substitution to ww, f is ww

                        -1
performing taylor on: ww

                      -1
series expansion is ww

            -1
series is ww

exponent list is {expt,-1}

leading exponent e0 is {expt,-1}

infinity
</pre>
<!--l. 216--><p class="nopar" > Note that, due to the recursiveness of the functions \(mrv\) and \(mrv\_limit\), many calls to each function are
made, and information is given on all calls when the <span 
class="pcrr8t-x-x-109">tracelimit </span>switch is
on.
</p><!--l. 696--><p class="noindent" >
                                                                     

                                                                     
                                                                     

                                                                     
</p><!--l. 698--><p class="noindent" ><table cellspacing="5"><tr><td class="clinks"><a 
href="../manual-lookup.php%3FUser&#32;Contributed&#32;Packages.html#manualse158.html" >Up</a></td><td class="clinks"><a 
href="manualse159.html" >Next</a></td><td class="clinks"><a 
href="manualse157.html" >Prev</a></td><td class="clinks"><a 
href="manualse157.html#tailmanualse157.html" >PrevTail</a></td><td class="clinks"><a 
href="manualse158.html" >Front</a></td></tr></table><a 
 id="tailmanualse158.html"></a>  <hr> <p style="font-family:sans-serif">Hosted by <a href="https://sourceforge.net/p/reduce-algebra/"> <img title="Download REDUCE" alt="Download REDUCE" style="vertical-align:middle" src="https://sourceforge.net/sflogo.php?type=16&amp;group_id=248416"/></a> <a href="https://www.mathjax.org"> <img title="Powered by MathJax" alt="Powered by MathJax" style="float:right" src="https://www.mathjax.org/badge/badge.gif"/></a></p></p> 
</body> 
</html>