<!DOCTYPE html> 
<html lang="en-US" xml:lang="en-US" > 
<head><title>LPDO: Linear Partial Diﬀerential Operators</title> 
<meta  charset="utf-8" /> 
<meta name="generator" content="TeX4ht (https://tug.org/tex4ht/)" /> 
<meta name="viewport" content="width=device-width,initial-scale=1" /> 
<link rel="stylesheet" type="text/css" href="manual.css" /> 
<meta name="src" content="manual.tex" /> 
<script>window.MathJax = { tex: { tags: "ams", }, }; </script> 
 <script type="text/javascript" async="async" id="MathJax-script" src="../../cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js"></script>  
<meta name="description" content="The REDUCE Computer Algebra System User's Manual" /> 
</head><body 
>
<header>REDUCE</header><table cellspacing="5"><tr><td class="clinks"><a 
href="../manual-lookup.php%3FUser&#32;Contributed&#32;Packages.html#manualse157.html" >Up</a></td><td class="clinks"><a 
href="manualse158.html" >Next</a></td><td class="clinks"><a 
href="manualse156.html" >Prev</a></td><td class="clinks"><a 
href="manualse156.html#tailmanualse156.html" >PrevTail</a></td><td class="clinks"><a 
href="manualse157.html#tailmanualse157.html">Tail</a></td></tr></table><h3 class="sectionHead"><span class="titlemark">20.34    </span> <a 
 id="x232-90000020.34"></a>LPDO: Linear Partial Diﬀerential Operators</h3>
<a 
 id="dx232-900001"></a>
<a 
 id="dx232-900002"></a>
<!--l. 681--><p class="noindent" >Author: Thomas Sturm
<a 
 id="dx232-900003"></a>
<a 
 id="dx232-900004"></a>
</p><!--l. 27--><p class="noindent" >
</p>
<h4 class="subsectionHead"><span class="titlemark">20.34.1    </span> <a 
 id="x232-90100020.34.1"></a>Introduction</h4>
<!--l. 30--><p class="noindent" >\( \newcommand {\Sym }{\operatorname {Sym}} \)Consider the ﬁeld \(F = \mathbb {Q}(x_1,\dots ,x_n)\) of rational functions and a set \(\Delta = \{\partial _{x_1}\),…, \(\partial _{x_n}\}\) of <span 
class="ptmri8t-x-x-109">commuting derivations</span>
acting on \(F\). That is, for all \(\partial _{x_i}\), \(\partial _{x_j} \in \Delta \) and all \(f\), \(g\in F\) the following properties are satisﬁed: \begin {align}  \partial _{x_i}(f + g) &amp;= \partial _{x_i}(f) + \partial _{x_i}(g),\nonumber \\ \partial _{x_i}(f\cdot g) &amp;= f\cdot \partial _{x_i}(g) + \partial _{x_i}(f)\cdot g,\label {EQ:leibnitz}\\ \partial _{x_i}(\partial _{x_j}(f)) &amp;= \partial _{x_j}(\partial _{x_i}(f)).\label {EQ:comm}  \end {align}
</p><!--l. 49--><p class="noindent" >Consider now the set \(F[\partial _{x_1},\dots ,\partial _{x_n}]\), where the derivations are used as variables. This set
forms a non-commutative <span 
class="ptmri8t-x-x-109">linear partial diﬀerential operator ring </span>with pointwise
addition, and multiplication deﬁned as follows: For \(f\in F\) and \(\partial _{x_i}\), \(\partial _{x_j} \in \Delta \) we have for any \(g\in F\) that \begin {align}  (f \partial _{x_i})(g) &amp;= f \cdot \partial _{x_i}(g),\nonumber \\ (\partial _{x_i} f)(g) &amp;= \partial _{x_i}(f \cdot g),\label {EQ:mult2}\\ (\partial _{x_i} \partial _{x_j})(g) &amp;= \partial _{x_i}(\partial _{x_j}(g)).\label {EQ:mult3}  \end {align}
</p><!--l. 60--><p class="noindent" >Here “\({}\cdot {}\)” denotes the multiplication in \(F\). From (\ref {EQ:mult3}) and (\ref {EQ:comm}) it follows that \(\partial _{x_i} \partial _{x_j}=\partial _{x_j} \partial _{x_i}\), and using (\ref {EQ:mult2}) and (\ref {EQ:leibnitz})
the following <span 
class="ptmri8t-x-x-109">commutator </span>can be proved: \[ \partial _{x_i} f = f \partial _{x_i} + \partial _{x_i}(f). \]
</p><!--l. 69--><p class="noindent" >A <span 
class="ptmri8t-x-x-109">linear partial diﬀerential operator </span>(LPDO) of order \(k\) is an element \[ D = \sum _{|j| \leq k} a_j \partial ^j\in F[\partial _{x_1},\dots ,\partial _{x_n}] \] in canonical form.
Here the expression \(|j| \leq k\) speciﬁes the set of all tuples of the form \(j = (j_1,\dots ,j_n) \in \mathbb {N}^n\) with \(\sum _{i=1}^n j_i \leq k\), and we deﬁne
\(\partial ^j = \partial _{x_1}^{j_1} \cdots \partial _{x_n}^{j_n}\).
</p><!--l. 80--><p class="noindent" >A <span 
class="ptmri8t-x-x-109">factorization </span>of \(D\) is a non-trivial decomposition \[ D = D_1 \cdots D_r\in F[\partial _{x_1},\dots ,\partial _{x_n}] \] into multiplicative factors, each of
which is an LPDO \(D_i\) of order greater than \(0\) and less than \(k\). If such a factorization exists,
then \(D\) is called <span 
class="ptmri8t-x-x-109">reducible </span>or <span 
class="ptmri8t-x-x-109">factorable</span>, else <span 
class="ptmri8t-x-x-109">irreducible</span>.
</p><!--l. 89--><p class="noindent" >For the purpose of factorization it is helpful to temporarily consider as regular
commutative polynomials certain summands of the LPDO under consideration. Consider
a commutative polynomial ring over \(F\) in new indeterminates \(y_1\), …, \(y_n\). Adopting the
notational conventions above, for \(m\leq k\) the <span 
class="ptmri8t-x-x-109">symbol of</span> \(D\) <span 
class="ptmri8t-x-x-109">of order</span> \(m\) is deﬁned as \[ \Sym _m(D) = \sum _{|j| = m} a_j y^j\in F[y_1,\dots ,y_n]. \] For \(m=k\) we obtain as
a special case the <span 
class="ptmri8t-x-x-109">symbol</span> \(\Sym (D)\) <span 
class="ptmri8t-x-x-109">of</span> \(D\).
                                                                     

                                                                     
</p><!--l. 101--><p class="noindent" >
</p>
<h4 class="subsectionHead"><span class="titlemark">20.34.2    </span> <a 
 id="x232-90200020.34.2"></a>Operators</h4>
<!--l. 103--><p class="noindent" >
</p>
<h5 class="subsubsectionHead"><span class="titlemark">20.34.2.1    </span> <a 
 id="x232-90300020.34.2.1"></a><span 
class="pcrr8t-x-x-109">partial</span></h5>
<a 
 id="dx232-903001"></a>
<!--l. 105--><p class="noindent" ><a 
 id="operator:PARTIAL"></a> There is a unary operator <span 
class="pcrr8t-x-x-109">partial(</span>\(\cdot \)<span 
class="pcrr8t-x-x-109">) </span>denoting \(\partial \).
</p>
<div class="center" 
>
<!--l. 109--><p class="noindent" >
</p>
<div class="tabular"> <table id="TBL-139" class="tabular" 
 
><colgroup id="TBL-139-1g"><col 
id="TBL-139-1" /><col 
id="TBL-139-2" /><col 
id="TBL-139-3" /><col 
id="TBL-139-4" /></colgroup><tr  
 style="vertical-align:baseline;" id="TBL-139-1-"><td  style="white-space:nowrap; text-align:right;" id="TBL-139-1-1"  
class="td11">\(\langle \)<span 
class="ptmri8t-x-x-109">partial-term</span>\(\rangle \)  </td><td  style="white-space:nowrap; text-align:center;" id="TBL-139-1-2"  
class="td11">\(\ \ \rightarrow \ \ \)</td><td  style="white-space:nowrap; text-align:left;" id="TBL-139-1-3"  
class="td11"><span 
class="pcrb8t-x-x-109">partial</span>  <span 
class="pcrb8t-x-x-109">(</span>  \(\langle \)<span 
class="ptmri8t-x-x-109">id</span>\(\rangle \)  <span 
class="pcrb8t-x-x-109">)</span>  </td><td  style="white-space:nowrap; text-align:left;" id="TBL-139-1-4"  
class="td11"></td>
</tr><tr  
 style="vertical-align:baseline;" id="TBL-139-2-"><td  style="white-space:nowrap; text-align:right;" id="TBL-139-2-1"  
class="td11">          </td>
</tr></table>
</div>
</div>
<!--l. 115--><p class="noindent" >
</p>
<h5 class="subsubsectionHead"><span class="titlemark">20.34.2.2    </span> <a 
 id="x232-90400020.34.2.2"></a><span 
class="pcrr8t-x-x-109">***</span></h5>
<a 
 id="dx232-904001"></a>
<!--l. 117--><p class="noindent" ><a 
 id="operator:lpdotimes"></a> There is a binary operator <span 
class="pcrr8t-x-x-109">*** </span>for the non-commutative multiplication involving
partials \(\partial _x\). All expressions involving <span 
class="pcrr8t-x-x-109">*** </span>are implicitly transformed into LPDOs, i.e., into
the following normal form: </p>
<div class="center" 
>
<!--l. 122--><p class="noindent" >
</p>
                                                                     

                                                                     
<div class="tabular"> <table id="TBL-140" class="tabular" 
 
><colgroup id="TBL-140-1g"><col 
id="TBL-140-1" /><col 
id="TBL-140-2" /><col 
id="TBL-140-3" /><col 
id="TBL-140-4" /></colgroup><tr  
 style="vertical-align:baseline;" id="TBL-140-1-"><td  style="white-space:nowrap; text-align:right;" id="TBL-140-1-1"  
class="td11">\(\langle \)<span 
class="ptmri8t-x-x-109">normalized-lpdo</span>\(\rangle \)  </td><td  style="white-space:nowrap; text-align:center;" id="TBL-140-1-2"  
class="td11">\(\ \ \rightarrow \ \ \)</td><td  style="white-space:nowrap; text-align:left;" id="TBL-140-1-3"  
class="td11">\(\langle \)<span 
class="ptmri8t-x-x-109">normalized-mon</span>\(\rangle \)  \([\;\)<span 
class="pcrb8t-x-x-109">+</span>  \(\langle \)<span 
class="ptmri8t-x-x-109">normalized-lpdo</span>\(\rangle \)  \(\;]\)  </td><td  style="white-space:nowrap; text-align:left;" id="TBL-140-1-4"  
class="td11"></td>
</tr><tr  
 style="vertical-align:baseline;" id="TBL-140-2-"><td  style="white-space:nowrap; text-align:right;" id="TBL-140-2-1"  
class="td11"> \(\langle \)<span 
class="ptmri8t-x-x-109">normalized-mon</span>\(\rangle \)  </td><td  style="white-space:nowrap; text-align:center;" id="TBL-140-2-2"  
class="td11">\(\ \ \rightarrow \ \ \)</td><td  style="white-space:nowrap; text-align:left;" id="TBL-140-2-3"  
class="td11">\(\langle \)<span 
class="ptmri8t-x-x-109">F-element</span>\(\rangle \)  \([\;\)<span 
class="pcrb8t-x-x-109">***</span>  \(\langle \)<span 
class="ptmri8t-x-x-109">partial-termprod</span>\(\rangle \)  \(\;]\)       </td><td  style="white-space:nowrap; text-align:left;" id="TBL-140-2-4"  
class="td11"></td>
</tr><tr  
 style="vertical-align:baseline;" id="TBL-140-3-"><td  style="white-space:nowrap; text-align:right;" id="TBL-140-3-1"  
class="td11">\(\langle \)<span 
class="ptmri8t-x-x-109">partial-termprod</span>\(\rangle \)  </td><td  style="white-space:nowrap; text-align:center;" id="TBL-140-3-2"  
class="td11">\(\ \ \rightarrow \ \ \)</td><td  style="white-space:nowrap; text-align:left;" id="TBL-140-3-3"  
class="td11">\(\langle \)<span 
class="ptmri8t-x-x-109">partial-term</span>\(\rangle \)  \([\;\)<span 
class="pcrb8t-x-x-109">***</span>  \(\langle \)<span 
class="ptmri8t-x-x-109">partial-termprod</span>\(\rangle \)  \(\;]\)   </td><td  style="white-space:nowrap; text-align:left;" id="TBL-140-3-4"  
class="td11"></td>
</tr><tr  
 style="vertical-align:baseline;" id="TBL-140-4-"><td  style="white-space:nowrap; text-align:right;" id="TBL-140-4-1"  
class="td11">             </td>
</tr></table></div>
</div>
<!--l. 130--><p class="noindent" >The summands of the <span 
class="ptmri8t-x-x-109">normalized-lpdo </span>are ordered in some canonical way. As an
example consider
                                                                     

                                                                     
</p>
<pre class="verbatim" id="verbatim-1189">
input: a()***partial(y)***b()***partial(x);

(a()*b()) *** partial(x) *** partial(y) + (a()*diff(b(),y,1)) *** partial(x)
</pre>
<!--l. 138--><p class="nopar" >
Here the <span 
class="ptmri8t-x-x-109">F-elements </span>are polynomials, where the unknowns are of the type <span 
class="ptmri8t-x-x-109">constant-operator</span>
denoting functions from \(F\):
</p>
<div class="center" 
>
<!--l. 143--><p class="noindent" >
</p>
<div class="tabular"> <table id="TBL-141" class="tabular" 
 
><colgroup id="TBL-141-1g"><col 
id="TBL-141-1" /><col 
id="TBL-141-2" /><col 
id="TBL-141-3" /><col 
id="TBL-141-4" /></colgroup><tr  
 style="vertical-align:baseline;" id="TBL-141-1-"><td  style="white-space:nowrap; text-align:right;" id="TBL-141-1-1"  
class="td11">\(\langle \)<span 
class="ptmri8t-x-x-109">constant-operator</span>\(\rangle \)  </td><td  style="white-space:nowrap; text-align:center;" id="TBL-141-1-2"  
class="td11">\(\ \ \rightarrow \ \ \)</td><td  style="white-space:nowrap; text-align:left;" id="TBL-141-1-3"  
class="td11">\(\langle \)<span 
class="ptmri8t-x-x-109">id</span>\(\rangle \)  <span 
class="pcrb8t-x-x-109">(</span>  <span 
class="pcrb8t-x-x-109">)</span>  </td><td  style="white-space:nowrap; text-align:left;" id="TBL-141-1-4"  
class="td11"></td>
</tr><tr  
 style="vertical-align:baseline;" id="TBL-141-2-"><td  style="white-space:nowrap; text-align:right;" id="TBL-141-2-1"  
class="td11">              </td>
</tr></table>
</div>
</div>
<!--l. 148--><p class="noindent" >We do not admit division of such constant operators since we cannot exclude that such a
constant operator denotes \(0\).
</p><!--l. 151--><p class="noindent" >The operator notation on the one hand emphasizes the fact that the denoted elements are
functions. On the other hand it distinguishes <span 
class="pcrr8t-x-x-109">a() </span>from the variable <span 
class="pcrr8t-x-x-109">a </span>of a rational
function, which speciﬁcally denotes the corresponding projection. Consider
e.g.
                                                                     

                                                                     
</p>
<pre class="verbatim" id="verbatim-1190">
input: (x+y)***partial(y)***(x-y)***partial(x);

  2    2
(x  - y ) *** partial(x) *** partial(y) + ( - x - y) *** partial(x)
</pre>
<!--l. 162--><p class="nopar" >
Here we use as <span 
class="ptmri8t-x-x-109">F-elements </span>speciﬁc elements from \(F=\mathbb {Q}(x,y)\).
</p><!--l. 166--><p class="noindent" >
</p>
<h5 class="subsubsectionHead"><span class="titlemark">20.34.2.3    </span> <a 
 id="x232-90500020.34.2.3"></a><span 
class="pcrr8t-x-x-109">diff</span></h5>
<a 
 id="dx232-905001"></a>
<!--l. 168--><p class="noindent" ><a 
 id="operator:DIFF"></a> In our example with constant operators, the transformation into normal form introduces
a formal derivative operation <span 
class="pcrr8t-x-x-109">diff(</span>\(\cdot \)<span 
class="pcrr8t-x-x-109">,</span>\(\cdot \)<span 
class="pcrr8t-x-x-109">,</span>\(\cdot \)<span 
class="pcrr8t-x-x-109">)</span>, which cannot be evaluated. Notice that we do
not use the Reduce operator <span 
class="pcrr8t-x-x-109">df(</span>\(\cdot \)<span 
class="pcrr8t-x-x-109">,</span>\(\cdot \)<span 
class="pcrr8t-x-x-109">,</span>\(\cdot \)<span 
class="pcrr8t-x-x-109">) </span>here, which for technical reasons cannot smoothly
handle our constant operators.
</p><!--l. 176--><p class="noindent" >In our second example with rational functions as <span 
class="ptmri8t-x-x-109">F-elements</span>, derivative occurring with
commutation can be computed such that <span 
class="pcrr8t-x-x-109">diff </span>does not occur in the output.
</p><!--l. 180--><p class="noindent" >
</p>
<h4 class="subsectionHead"><span class="titlemark">20.34.3    </span> <a 
 id="x232-90600020.34.3"></a>Shapes of F-elements</h4>
<!--l. 181--><p class="noindent" >Besides the generic computations with constant operators, we provide a mechanism to
globally ﬁx a certain <span 
class="ptmri8t-x-x-109">shape </span>for <span 
class="ptmri8t-x-x-109">F-elements </span>and to expand constant operators according to
that shape.
</p>
<h5 class="subsubsectionHead"><span class="titlemark">20.34.3.1    </span> <a 
 id="x232-90700020.34.3.1"></a><span 
class="pcrr8t-x-x-109">lpdoset</span></h5>
<a 
 id="dx232-907001"></a>
<!--l. 187--><p class="noindent" ><a 
 id="operator:LPDOSET"></a>We give an example for a shape that ﬁxes all constant operators to denote generic
                                                                     

                                                                     
bivariate aﬃne linear functions:
                                                                     

                                                                     
</p>
<pre class="verbatim" id="verbatim-1191">
input: d := (a()+b())***partial(x1)***partial(x2)**2;

                                                2
d := (a() + b()) *** partial(x1) *** partial(x2)

input: lpdoset {!#10*x1+!#01*x2+!#00,x1,x2};

{-1}

input: d;

                                                                               2
(a00 + a01*x2 + a10*x1 + b00 + b01*x2 + b10*x1) *** partial(x1) *** partial(x2)
</pre>
<!--l. 206--><p class="nopar" >
Notice that the placeholder <span 
class="pcrr8t-x-x-109"># </span>must be escaped with <span 
class="pcrr8t-x-x-109">!</span>, which is a general convention for
Rlisp/Reduce. Notice that <span 
class="pcrr8t-x-x-109">lpdoset </span>returns the old shape and that <span 
class="pcrr8t-x-x-109">{-1} </span>denotes the
default state that there is no shape selected.
</p><!--l. 213--><p class="noindent" >
</p>
<h5 class="subsubsectionHead"><span class="titlemark">20.34.3.2    </span> <a 
 id="x232-90800020.34.3.2"></a><span 
class="pcrr8t-x-x-109">lpdoweyl</span></h5>
<a 
 id="dx232-908001"></a>
<!--l. 215--><p class="noindent" ><a 
 id="operator:LPDOWEYL"></a>The command <span 
class="pcrr8t-x-x-109">lpdoweyl {n,x1,x2,...} </span>creates a shape for generic polynomials
of total degree <span 
class="pcrr8t-x-x-109">n </span>in variables \(\texttt {x1}\), \(\texttt {x2}\), ….
                                                                     

                                                                     
</p>
<pre class="verbatim" id="verbatim-1192">
input: lpdoweyl(2,x1,x2);

                            2                                    2
{#_00_ + #_01_*x2 + #_02_*x2  + #_10_*x1 + #_11_*x1*x2 + #_20_*x1 ,x1,x2}

input: lpdoset ws;

{#10*x1 + #01*x2 + #00,x1,x2}

input: d;

                            2                                    2
(a_00_ + a_01_*x2 + a_02_*x2  + a_10_*x1 + a_11_*x1*x2 + a_20_*x1  + b_00_

                       2                                    2
  + b_01_*x2 + b_02_*x2  + b_10_*x1 + b_11_*x1*x2 + b_20_*x1 ) *** partial(x1)

                2
 *** partial(x2)
</pre>
<!--l. 241--><p class="nopar" >
</p><!--l. 244--><p class="noindent" >
</p>
<h4 class="subsectionHead"><span class="titlemark">20.34.4    </span> <a 
 id="x232-90900020.34.4"></a>Commands</h4>
<!--l. 246--><p class="noindent" >
</p>
<h5 class="subsubsectionHead"><span class="titlemark">20.34.4.1    </span> <a 
 id="x232-91000020.34.4.1"></a>General</h5>
<!--l. 247--><p class="noindent" >
</p>
<h5 class="likesubsubsectionHead"><a 
 id="x232-91100020.34.4.1"></a><span 
class="pcrr8t-x-x-109">lpdoord</span></h5>
<a 
 id="dx232-911001"></a>
                                                                     

                                                                     
<!--l. 249--><p class="noindent" ><a 
 id="operator:LPDOORD"></a>The <span 
class="ptmri8t-x-x-109">order </span>of an lpdo:
                                                                     

                                                                     
</p>
<pre class="verbatim" id="verbatim-1193">
input: lpdoord((a()+b())***partial(x1)***partial(x2)**2+3***partial(x1));

3
</pre>
<!--l. 256--><p class="nopar" >
</p>
<h5 class="likesubsubsectionHead"><a 
 id="x232-91200020.34.4.1"></a><span 
class="pcrr8t-x-x-109">lpdoptl</span></h5>
<a 
 id="dx232-912001"></a>
<!--l. 261--><p class="noindent" ><a 
 id="operator:LPDOPTL"></a>Returns the list of derivations (partials) occurring in its argument LPDO \(d\).
                                                                     

                                                                     
</p>
<pre class="verbatim" id="verbatim-1194">
input: lpdoptl(a()***partial(x1)***partial(x2)+partial(x4)+diff(a(),x3,1));

{partial(x1),partial(x2),partial(x4)}
</pre>
<!--l. 270--><p class="nopar" >
That is the smallest set \(\{\dots ,\partial _{x_i},\dots \}\) such that \(d\) is deﬁned in \(F[\dots ,\partial _{x_i},\dots ]\). Notice that formal derivatives are not
derivations in that sense.
</p><!--l. 276--><p class="noindent" >
</p>
<h5 class="likesubsubsectionHead"><a 
 id="x232-91300020.34.4.1"></a><span 
class="pcrr8t-x-x-109">lpdogp</span></h5>
<a 
 id="dx232-913001"></a>
<!--l. 278--><p class="noindent" ><a 
 id="operator:LPDOGP"></a>Given a starting symbol \(a\), a list of variables \(l\), and a degree \(n\), <span 
class="pcrr8t-x-x-109">lpdogp(</span>\(a\)<span 
class="pcrr8t-x-x-109">,</span>\(l\)<span 
class="pcrr8t-x-x-109">,</span>\(n\)<span 
class="pcrr8t-x-x-109">) </span>generates a
generic (commutative) polynomial of degree \(n\) in variables \(l\) with coeﬃcients generated
from the starting symbol \(a\):
                                                                     

                                                                     
</p>
<pre class="verbatim" id="verbatim-1195">
input: lpdogp(a,{x1,x2},2);

                           2                                    2
a_00_ + a_01_*x2 + a_02_*x2  + a_10_*x1 + a_11_*x1*x2 + a_20_*x1
</pre>
<!--l. 290--><p class="nopar" >
</p><!--l. 293--><p class="noindent" >
</p>
<h5 class="likesubsubsectionHead"><a 
 id="x232-91400020.34.4.1"></a><span 
class="pcrr8t-x-x-109">lpdogdp</span></h5>
<a 
 id="dx232-914001"></a>
<!--l. 295--><p class="noindent" ><a 
 id="operator:LPDOGDP"></a>Given a starting symbol \(a\), a list of variables \(l\), and a degree \(n\), <span 
class="pcrr8t-x-x-109">lpdogp(</span>\(a\)<span 
class="pcrr8t-x-x-109">,</span>\(l\)<span 
class="pcrr8t-x-x-109">,</span>\(n\)<span 
class="pcrr8t-x-x-109">) </span>generates a
generic diﬀerential polynomial of degree \(n\) in variables \(l\) with coeﬃcients generated from
the starting symbol \(a\):
                                                                     

                                                                     
</p>
<pre class="verbatim" id="verbatim-1196">
input: lpdogdp(a,{x1,x2},2);

                     2                        2
a_20_ *** partial(x1)  + a_02_ *** partial(x2)

 + a_11_ *** partial(x1) *** partial(x2) + a_10_ *** partial(x1)

 + a_01_ *** partial(x2) + a_00_
</pre>
<!--l. 311--><p class="nopar" >
</p><!--l. 314--><p class="noindent" >
</p>
<h5 class="subsubsectionHead"><span class="titlemark">20.34.4.2    </span> <a 
 id="x232-91500020.34.4.2"></a>Symbols</h5>
<!--l. 315--><p class="noindent" >
</p>
<h5 class="likesubsubsectionHead"><a 
 id="x232-91600020.34.4.2"></a><span 
class="pcrr8t-x-x-109">lpdosym</span></h5>
<a 
 id="dx232-916001"></a>
<!--l. 317--><p class="noindent" ><a 
 id="operator:LPDOSYM"></a>The <span 
class="ptmri8t-x-x-109">symbol </span>of an lpdo. That is the diﬀerential monomial of highest order with the
partials replaced by corresponding commutative variables:
                                                                     

                                                                     
</p>
<pre class="verbatim" id="verbatim-1197">
input: lpdosym((a()+b())***partial(x1)***partial(x2)**2+3***partial(x1));

           2
y_x1_*y_x2_ *(a() + b())
</pre>
<!--l. 328--><p class="nopar" >
More generally, one can use a second optional arguments to specify a the order of a
diﬀerent diﬀerential monomial to form the symbol of:
                                                                     

                                                                     
</p>
<pre class="verbatim" id="verbatim-1198">
input: lpdosym((a()+b())***partial(x1)***partial(x2)**2+3***partial(x1),1);

3*y_x1_
</pre>
<!--l. 338--><p class="nopar" >
Finally, a third optional argument can be used to specify an alternative starting symbol
for the commutative variable, which is <span 
class="pcrr8t-x-x-109">y </span>by default. Altogether, the optional arguments
default like <span 
class="pcrr8t-x-x-109">lpdosym(</span>\(\cdot \)<span 
class="pcrr8t-x-x-109">)</span>=<span 
class="pcrr8t-x-x-109">lpdosym(</span>\(\cdot \)<span 
class="pcrr8t-x-x-109">,lpdoord(</span>\(\cdot \)<span 
class="pcrr8t-x-x-109">),y)</span>.
</p><!--l. 345--><p class="noindent" >
</p>
<h5 class="likesubsubsectionHead"><a 
 id="x232-91700020.34.4.2"></a><span 
class="pcrr8t-x-x-109">lpdosym2dp</span></h5>
<a 
 id="dx232-917001"></a>
<!--l. 347--><p class="noindent" ><a 
 id="operator:LPDOSYM2DP"></a>This converts a symbol obtained via <span 
class="pcrr8t-x-x-109">lpdosym </span>back into an LPDO resulting in the
corresponding diﬀerential monomial of the original LPDO.
                                                                     

                                                                     
</p>
<pre class="verbatim" id="verbatim-1199">
input: d := a()***partial(x1)***partial(x2)+partial(x3)$

input: s := lpdosym d;

s := a()*y_x1_*y_x2_

input: lpdosym2dp s;

a() *** partial(x1) *** partial(x2)
</pre>
<!--l. 363--><p class="nopar" >
In analogy to <span 
class="pcrr8t-x-x-109">lpdosym </span>there is an optional argument for specifying an alternative
starting symbol for the commutative variable, which is <span 
class="pcrr8t-x-x-109">y </span>by default.
</p><!--l. 369--><p class="noindent" >
</p>
<h5 class="likesubsubsectionHead"><a 
 id="x232-91800020.34.4.2"></a><span 
class="pcrr8t-x-x-109">lpdos</span></h5>
<a 
 id="dx232-918001"></a>
<!--l. 371--><p class="noindent" ><a 
 id="operator:LPDOS"></a>Given LPDOs \(p\), \(q\) and \(m\in \mathbb {N}\) the function <span 
class="pcrr8t-x-x-109">lpdos(</span>\(p\)<span 
class="pcrr8t-x-x-109">,</span>\(q\)<span 
class="pcrr8t-x-x-109">,</span>\(m\)<span 
class="pcrr8t-x-x-109">) </span>computes the commutative polynomial \[S_m = \sum _{\substack {|j| = m\\ |j| &lt; k}} \left (\sum _{i = 1}^n p_i \partial _i(q_j) + p_0 q_j\right )y^{j}.\]
This is useful for the factorization of LPDOs.
                                                                     

                                                                     
</p>
<pre class="verbatim" id="verbatim-1200">
input: p := a()***partial(x1)+b()$

input: q := c()***partial(x1)+d()***partial(x2)$

input: lpdos(p,q,1);

a()*diff(c(),x1,1)*y_x1_ + a()*diff(d(),x1,1)*y_x2_ + b()*c()*y_x1_

 + b()*d()*y_x2_
</pre>
<!--l. 388--><p class="nopar" >
</p><!--l. 392--><p class="noindent" >
</p>
<h5 class="subsubsectionHead"><span class="titlemark">20.34.4.3    </span> <a 
 id="x232-91900020.34.4.3"></a>Factorization</h5>
<!--l. 394--><p class="noindent" >
</p>
<h5 class="likesubsubsectionHead"><a 
 id="x232-92000020.34.4.3"></a><span 
class="pcrr8t-x-x-109">lpdofactorize</span></h5>
<a 
 id="dx232-920001"></a>
<!--l. 396--><p class="noindent" ><a 
 id="operator:LPDOFACTORIZE"></a>Factorize the argument LPDO \(d\). The ground ﬁeld \(F\) must be ﬁxed via <span 
class="pcrr8t-x-x-109">lpdoset</span>. The result
is a list of lists \(\{\dots ,(A_i,L_i),\dots \}\). \(A_i\) is is genrally the identiﬁers <span 
class="pcrr8t-x-x-109">true</span>, which indicates reducibility. The
respective \(L_i\) is a list of two diﬀerential polynomial factors, the ﬁrst of which has order
1.
                                                                     

                                                                     
</p>
<pre class="verbatim" id="verbatim-1201">
input: bk := (partial(x)+partial(y)+(a10-a01)/2) ***
       (partial(x)-partial(y)+(a10+a01)/2);

                2             2
bk := partial(x)  - partial(y)  + a10 *** partial(x) + a01 *** partial(y)

          2      2
     - a01  + a10
 + ----------------
          4

input: lpdoset lpdoweyl(1,x,y);

{#_00_ + #_01_*y + #_10_*x,x,y}

input: lpdofactorize bk;

{{true,

                                 a01 - a10
  { - partial(x) - partial(y) + -----------,
                                     2

                                  - a01 - a10
    - partial(x) + partial(y) + --------------}}}
                                      2
</pre>
<!--l. 432--><p class="nopar" >
If the result is the empty list, then this guarantees that there is no approximate
factorization possible. In general it is possible to obtain several sample factorizations.
Note, however, that the result does not provide a complete list of possible factorizations
with a left factor of order 1 but only at least one such sample factorization in case of
reducibility.
</p><!--l. 441--><p class="noindent" >Furthermore, the procedure might fail due to polynomial degrees exceeding certain
bounds for the extended quantiﬁer elimination by virtual substitution used internally. In
this case there is the identiﬁer <span 
class="pcrr8t-x-x-109">failed </span>returned. This must not be confused with the
empty list indicating irreducibility as described above.
</p><!--l. 447--><p class="noindent" >Besides
     </p><ol  class="enumerate1" >
<li 
  class="enumerate" id="x232-920003x1">
                                                                     

                                                                     
     <!--l. 449--><p class="noindent" >the LPDO \(d\),</p></li></ol>
<!--l. 451--><p class="noindent" ><span 
class="pcrr8t-x-x-109">lpdofactorize </span>accepts several optional arguments:
     </p><ol  class="enumerate1" >
<li 
  class="enumerate" id="x232-920005x2">
     <!--l. 454--><p class="noindent" >An LPDO of order 1, which serves as a template for the left (linear) factor.
     The  default  is  a  generic  linear  LPDO  with  generic  coeﬃcient  functions
     according from the ground ﬁeld speciﬁed via <span 
class="pcrr8t-x-x-109">lpdoset</span>. The principle idea
     is to support the factorization by guessing that certain diﬀerential monomials
     are not present.
     </p></li>
<li 
  class="enumerate" id="x232-920007x3">
     <!--l. 459--><p class="noindent" >An LPDO of order \(\operatorname {ord}(d)-1\), which serves as a template for the right factor. Similarly
     to the previous argument the default is fully generic.</p></li></ol>
<!--l. 464--><p class="noindent" >
</p>
<h5 class="likesubsubsectionHead"><a 
 id="x232-92100020.34.4.3"></a><span 
class="pcrr8t-x-x-109">lpdofac</span></h5>
<a 
 id="dx232-921001"></a>
<!--l. 466--><p class="noindent" ><a 
 id="operator:LPDOFAC"></a>This is a low-level entry point to the factorization <span 
class="pcrr8t-x-x-109">lpdofactorize</span>. It accepts the
same arguments as <span 
class="pcrr8t-x-x-109">lpdofactorize</span>. It generates factorization conditions as a quite
large ﬁrst-order formula over the reals. This can be passed to extended quantiﬁer
elimination. For example, consider <span 
class="pcrr8t-x-x-109">bk </span>as in the example for <span 
class="pcrr8t-x-x-109">lpdofactorize</span>
above:
                                                                     

                                                                     
</p>
<pre class="verbatim" id="verbatim-1202">
input: faccond := lpdofac bk$

input: rlqea faccond;

{{true,

               a01 - a10
  {p_00_00_ = -----------,
                   2

   p_00_01_ = 0, p_00_10_ = 0, p_01_00_ = -1, p_01_01_ = 0, p_01_10_ = 0,

   p_10_00_ = -1, p_10_01_ = 0, p_10_10_ = 0,

                - a01 - a10
   q_00_00_ = --------------,
                    2

   q_00_01_ = 0, q_00_10_ = 0, q_01_00_ = 1, q_01_01_ = 0, q_01_10_ = 0,

   q_10_00_ = -1, q_10_01_ = 0, q_10_10_ = 0}}}
</pre>
<!--l. 498--><p class="nopar" >
The result of the extended quantiﬁer elimination provides coeﬃcient values for generic
factor polynomials \(p\) and \(q\). These are automatically interpreted and converted into
diﬀerential polynomials by <span 
class="pcrr8t-x-x-109">lpdofactorize</span>.
</p><!--l. 506--><p class="noindent" >
</p>
<h5 class="subsubsectionHead"><span class="titlemark">20.34.4.4    </span> <a 
 id="x232-92200020.34.4.4"></a>Approximate Factorization</h5>
<!--l. 508--><p class="noindent" >
</p>
<h5 class="likesubsubsectionHead"><a 
 id="x232-92300020.34.4.4"></a><span 
class="pcrr8t-x-x-109">lpdofactorizex</span></h5>
<a 
 id="dx232-923001"></a>
<!--l. 510--><p class="noindent" ><a 
 id="operator:LPDOFACTORIZEX"></a>Approximately factorize the argument LPDO \(d\). The ground ﬁeld \(F\) must be ﬁxed via
<span 
class="pcrr8t-x-x-109">lpdoset</span>. The result is a list of lists \(\{\dots ,(A_i,L_i),\dots \}\). Each \(A_i\) is quantiﬁer-free formula possibly
                                                                     

                                                                     
containing a variable \(\texttt {epsilon}\), which describes the precision of corresponding factorization \(L_i\). \(L_i\) is a
list containing two factors, the ﬁrst of which is linear.
                                                                     

                                                                     
</p>
<pre class="verbatim" id="verbatim-1203">
input: off lpdocoeffnorm$

input: lpdoset lpdoweyl(0,x1,x2)$

input: f2 := partial(x1)***partial(x2) + 1$

input: lpdofactorizex f2;

{{epsilon - 1 &#x003E;= 0,{partial(x1),partial(x2)}},

 {epsilon - 1 &#x003E;= 0,{partial(x2),partial(x1)}}}
</pre>
<!--l. 531--><p class="nopar" >
If the result is the empty list, then this guarantees that there is no approximate
factorization possible. In our example we happen to obtain two possible factorizations.
Note, however, that the result in general does not provide a complete list of
factorizations with a left factor of order 1 but only at least one such sample
factorization.
</p><!--l. 539--><p class="noindent" >Furthermore, the procedure might fail due to polynomial degrees exceeding certain
bounds for the extended quantiﬁer elimination by virtual substitution used internally. If
this happens, the corresponding \(A_i\) will contain existential quantiﬁers <span 
class="pcrr8t-x-x-109">ex</span>, and \(L_i\) will be
meaningless.<br 
class="newline" /><span class="obeylines-h"><span class="verb"><span 
class="pcrr8t-x-x-109">Da</span><span 
class="pcrr8t-x-x-109"> sollte</span><span 
class="pcrr8t-x-x-109"> besser</span><span 
class="pcrr8t-x-x-109"> ein</span><span 
class="pcrr8t-x-x-109"> failed</span><span 
class="pcrr8t-x-x-109"> kommen</span><span 
class="pcrr8t-x-x-109"> ...</span></span></span>
</p><!--l. 546--><p class="noindent" >The ﬁrst of the two subresults above has the semantics that \(\partial _{x_1}\partial _{x_2}\) is an approximate
factorization of \(f_2\) for all \(\varepsilon \geq 1\). Formally, \(||f_2-\partial _{x_1}\partial _{x_2}||\leq \varepsilon \) for all \(\varepsilon \geq 1\), which is equivalent to \(||f_2-\partial _{x_1}\partial _{x_2}||\leq 1\). That is, \(1\) is an upper
bound for the approximation error over \(\mathbb {R}^2\). Where there are two possible choices for the
seminorm \(||\cdot ||\):
     </p><ol  class="enumerate1" >
<li 
  class="enumerate" id="x232-923003x1">
     <!--l. 555--><p class="noindent" >...
     </p></li>
<li 
  class="enumerate" id="x232-923005x2">
     <!--l. 556--><p class="noindent" >...</p></li></ol>
<!--l. 558--><p class="noindent" ><span class="obeylines-h"><span class="verb"><span 
class="pcrr8t-x-x-109">explain</span><span 
class="pcrr8t-x-x-109"> switch</span><span 
class="pcrr8t-x-x-109"> lpdocoeffnorm</span><span 
class="pcrr8t-x-x-109"> ...</span></span></span>
                                                                     

                                                                     
</p><!--l. 560--><p class="noindent" >Besides
     </p><ol  class="enumerate1" >
<li 
  class="enumerate" id="x232-923007x1">
     <!--l. 562--><p class="noindent" >the LPDO \(d\),</p></li></ol>
<!--l. 564--><p class="noindent" ><span 
class="pcrr8t-x-x-109">lpdofactorizex </span>accepts several optional arguments:
     </p><ol  class="enumerate1" >
<li 
  class="enumerate" id="x232-923009x2">
     <!--l. 567--><p class="noindent" >A  Boolean  combination  \(\psi \)  of  equations,  negated  equations,  and  (possibly
     strict)  ordering  constraints.  This  \(\psi \)  describes  a  (semialgebraic)  region  over
     which to factorize approximately. The default is <span 
class="pcrr8t-x-x-109">true </span>specifying the entire
     \(\mathbb {R}^n\). It is possible to choose \(\psi \) parametrically. Then the parameters will in general
     occur in the conditions \(A_i\) in the result.
     </p></li>
<li 
  class="enumerate" id="x232-923010x2">
     <!--l. 573--><p class="noindent" >An LPDO of order 1, which serves as a template for the left (linear) factor,
     and an LPDO of order \(\operatorname {ord}(d)-1\), which serves as a template for the right factor. See
     the documentation of <span 
class="pcrr8t-x-x-109">lpdofactorize </span>for defaults and details.
     </p></li>
<li 
  class="enumerate" id="x232-923011x2">
     <!--l. 577--><p class="noindent" >A bound \(\varepsilon \) for describing the desired precision for approximate factorization.
     The  default  is  the  symbol  <span 
class="pcrr8t-x-x-109">epsilon</span>,  i.e.,  a  symbolic  choice  such  that
     the  optimal  choice  (with  respect  to  parameters  in  \(\psi \))  is  obtained  during
     factorization.  It  is  possible  to  ﬁx  \(\varepsilon \in \mathbb {Q}\).  This  does,  however,  not  considerably
     simplify the factorization process in most cases.</p></li></ol>
                                                                     

                                                                     
<pre class="verbatim" id="verbatim-1204">
input: f3 := partial(x1) *** partial(x2) + x1$

input: psi1 := 0&#x003C;=x1&#x003C;=1 and 0&#x003C;=x2&#x003C;=1$

input: lpdofactorizex(f3,psi1,a()***partial(x1),b()***partial(x2));

{{epsilon - 1 &#x003E;= 0,{partial(x1),partial(x2)}}}
</pre>
<!--l. 594--><p class="nopar" >
</p><!--l. 597--><p class="noindent" >
</p>
<h5 class="likesubsubsectionHead"><a 
 id="x232-92400020.34.4.4"></a><span 
class="pcrr8t-x-x-109">lpdofacx</span></h5>
<a 
 id="dx232-924001"></a>
<!--l. 599--><p class="noindent" ><a 
 id="operator:LPDOFACX"></a>This is a low-level entry point to the factorization <span 
class="pcrr8t-x-x-109">lpdofactorizex</span>. It is
analogous to <span 
class="pcrr8t-x-x-109">lpdofac </span>for <span 
class="pcrr8t-x-x-109">lpdofactorize</span>; see the documentation there for
details.
</p><!--l. 604--><p class="noindent" >
</p>
<h5 class="likesubsubsectionHead"><a 
 id="x232-92500020.34.4.4"></a><span 
class="pcrr8t-x-x-109">lpdohrect</span></h5>
<!--l. 606--><p class="noindent" >
</p>
<h5 class="likesubsubsectionHead"><a 
 id="x232-92600020.34.4.4"></a><span 
class="pcrr8t-x-x-109">lpdohcirc</span></h5>
<!--l. 685--><p class="noindent" >
                                                                     

                                                                     
                                                                     

                                                                     
</p><!--l. 687--><p class="noindent" ><table cellspacing="5"><tr><td class="clinks"><a 
href="../manual-lookup.php%3FUser&#32;Contributed&#32;Packages.html#manualse157.html" >Up</a></td><td class="clinks"><a 
href="manualse158.html" >Next</a></td><td class="clinks"><a 
href="manualse156.html" >Prev</a></td><td class="clinks"><a 
href="manualse156.html#tailmanualse156.html" >PrevTail</a></td><td class="clinks"><a 
href="manualse157.html" >Front</a></td></tr></table><a 
 id="tailmanualse157.html"></a>   <hr> <p style="font-family:sans-serif">Hosted by <a href="https://sourceforge.net/p/reduce-algebra/"> <img title="Download REDUCE" alt="Download REDUCE" style="vertical-align:middle" src="https://sourceforge.net/sflogo.php?type=16&amp;group_id=248416"/></a> <a href="https://www.mathjax.org"> <img title="Powered by MathJax" alt="Powered by MathJax" style="float:right" src="https://www.mathjax.org/badge/badge.gif"/></a></p></p> 
</body> 
</html>