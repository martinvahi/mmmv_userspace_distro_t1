<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"  
  "http://www.w3.org/TR/html4/loose.dtd">  
<html > 
<head><title>Functions for Manipulating Lists</title> 
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1"> 
<meta name="generator" content="TeX4ht (http://www.cse.ohio-state.edu/~gurari/TeX4ht/)"> 
<meta name="originator" content="TeX4ht (http://www.cse.ohio-state.edu/~gurari/TeX4ht/)"> 
<!-- 3,html --> 
<meta name="src" content="allman1.tex"> 
<meta name="date" content="2014-05-02 18:10:00"> 
<link rel="stylesheet" type="text/css" href="allman1.css"> 
</head><body 
>
<p align="centre"><img src="http://www.reduce-algebra.com/lisp-docs/redlogo.png" width=621 height=60 border=0 alt="REDUCE"></p><table cellspacing="5"><tr><td class="clinks"><a 
href="allman1li4.html#allman1se15.html" >Up</a></td><td class="clinks"><a 
href="allman1se16.html" >Next</a></td><td class="clinks"><a 
href="allman1se14.html" >Prev</a></td><td class="clinks"><a 
href="allman1se14.html#tailallman1se14.html" >PrevTail</a></td><td class="clinks"><a 
href="allman1se15.html#tailallman1se15.html">Tail</a></td></tr></table><h3 class="sectionHead"><span class="titlemark">5.3    </span> <a 
 id="x22-490005.3"></a>Functions for Manipulating Lists</h3>
<!--l. 217--><p class="noindent" >The following functions are meant for the special pairs which are lists, as described in Section
5.1. An argument which is not a list could give unexpected results. For example, length is used
to determine the number of top level elements in a list.

<div class="verbatim" id="verbatim-101">
1&#x00A0;lisp&#x003E;&#x00A0;(length&#x00A0;'(a&#x00A0;b&#x00A0;c))
&#x00A0;<br />3
&#x00A0;<br />2&#x00A0;lisp&#x003E;&#x00A0;(length&#x00A0;'(a&#x00A0;b&#x00A0;.&#x00A0;c))
&#x00A0;<br />2
</div>
<!--l. 227--><p class="nopar" >
<h5 class="subsubsectionHead"><a 
 id="x22-500005.3"></a>Selecting List Elements</h5>
<!--l. 233--><p class="noindent" ><div class="minipage"><a 
 id="dx22-50001"></a>
<span 
class="ptmb7t-x-x-120">(first L:pair): any                                                                                                      </span><span 
class="ptmri7t-x-x-120">macro</span>
<br 
class="newline" /><div class="minipage">A synonym for car.
</div></div>
<!--l. 237--><p class="noindent" ><div class="minipage"><a 
 id="dx22-50002"></a>
<span 
class="ptmb7t-x-x-120">(second L:pair): any                                                                                                 </span><span 
class="ptmri7t-x-x-120">macro</span>
<br 
class="newline" /><div class="minipage">A synonym for cadr.
</div></div>
<!--l. 241--><p class="noindent" ><div class="minipage"><a 
 id="dx22-50003"></a>
<span 
class="ptmb7t-x-x-120">(third L:pair): any                                                                                                    </span><span 
class="ptmri7t-x-x-120">macro</span>
<br 
class="newline" /><div class="minipage">A synonym for caddr.
</div></div>
<!--l. 245--><p class="noindent" ><div class="minipage"><a 
 id="dx22-50004"></a>
<span 
class="ptmb7t-x-x-120">(fourth L:pair): any                                                                                                  </span><span 
class="ptmri7t-x-x-120">macro</span>
<br 
class="newline" /><div class="minipage">A synonym for cadddr.
</div></div>
<!--l. 249--><p class="noindent" ><div class="minipage"><a 
 id="dx22-50005"></a>
<span 
class="ptmb7t-x-x-120">(rest L:pair): any                                                                                                       </span><span 
class="ptmri7t-x-x-120">macro</span>
<br 
class="newline" /><div class="minipage">A synonym for cdr.
</div></div>

<!--l. 256--><p class="noindent" ><div class="minipage"><a 
 id="dx22-50006"></a>
<span 
class="ptmb7t-x-x-120">(lastpair L:pair): any                                                                                                   </span><span 
class="ptmri7t-x-x-120">expr</span>
<br 
class="newline" /><div class="minipage">Returns the last pair of a L. It is often useful to think of this as a pointer to
the last element for use with destructive functions such as rplaca. If L is not
a pair then a type mismatch error occurs.</div>
</div>

<div class="verbatim" id="verbatim-102">
&#x00A0;&#x00A0;&#x00A0;&#x00A0;(de&#x00A0;lastpair&#x00A0;(l)
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;(if&#x00A0;(or&#x00A0;(atom&#x00A0;l)&#x00A0;(atom&#x00A0;(cdr&#x00A0;l)))
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;l
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;(lastpair&#x00A0;(cdr&#x00A0;l))))
</div>
<!--l. 262--><p class="nopar" >
<!--l. 267--><p class="noindent" ><div class="minipage"><a 
 id="dx22-50007"></a>
<span 
class="ptmb7t-x-x-120">(lastcar L:pair): any                                                                                                    </span><span 
class="ptmri7t-x-x-120">expr</span>
<br 
class="newline" /><div class="minipage">Returns the last element of the pair L. A type mismatch error results if L is
not a pair.</div>
</div>

<div class="verbatim" id="verbatim-103">
&#x00A0;&#x00A0;&#x00A0;&#x00A0;(de&#x00A0;lastcar&#x00A0;(l)
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;(if&#x00A0;(atom&#x00A0;l)&#x00A0;l&#x00A0;(car&#x00A0;(lastpair&#x00A0;l))))
</div>
<!--l. 271--><p class="nopar" >
<!--l. 277--><p class="noindent" ><div class="minipage"><a 
 id="dx22-50008"></a>
<span 
class="ptmb7t-x-x-120">(nth L:pair N:integer): any                                                                                         </span><span 
class="ptmri7t-x-x-120">expr</span>
<br 
class="newline" /><div class="minipage">Returns the Nth element of the list L. If L is atomic or contains fewer than
N elements, an out of range error occurs.</div>
</div>

<div class="verbatim" id="verbatim-104">
&#x00A0;&#x00A0;&#x00A0;&#x00A0;(de&#x00A0;nth&#x00A0;(l&#x00A0;n)
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;(cond&#x00A0;((null&#x00A0;l)&#x00A0;(range-error))
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;((onep&#x00A0;n)&#x00A0;(first&#x00A0;l))
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;(t&#x00A0;(nth&#x00A0;(rest&#x00A0;l)&#x00A0;(sub1&#x00A0;n)))))
</div>
<!--l. 283--><p class="nopar" >Note that this definition is not compatible with Common LISP. The Common LISP definition
reverses the arguments and defines the car of a list to be the &#8221;zeroth&#8221; element.
<!--l. 295--><p class="noindent" ><div class="minipage"><a 
 id="dx22-50009"></a>
<span 
class="ptmb7t-x-x-120">(pnth L:list N:integer): any                                                                                         </span><span 
class="ptmri7t-x-x-120">expr</span>
<br 
class="newline" /><div class="minipage">Returns a list starting with the nth element of the list L. Note that the result
is a pointer to the nth element of L, a destructive function like rplaca can be
used to modify the structure of L. If L is atomic or contains fewer than N
elements, an out of range error occurs.</div>
</div>

<div class="verbatim" id="verbatim-105">
&#x00A0;&#x00A0;&#x00A0;&#x00A0;(de&#x00A0;pnth&#x00A0;(l&#x00A0;n)
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;(cond&#x00A0;((onep&#x00A0;n)&#x00A0;l)
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;((not&#x00A0;(pairp&#x00A0;l))&#x00A0;(range-error))
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;(t&#x00A0;(pnth&#x00A0;(rest&#x00A0;l)&#x00A0;(sub1&#x00A0;n)))))
</div>
<!--l. 301--><p class="nopar" >
<h4 class="subsectionHead"><span class="titlemark">5.3.1    </span> <a 
 id="x22-510005.3.1"></a>Membership and Length of Lists</h4>
<!--l. 309--><p class="noindent" ><div class="minipage"><a 
 id="dx22-51001"></a>
<span 
class="ptmb7t-x-x-120">(member A:any L:list): extra-boolean                                                                       </span><span 
class="ptmri7t-x-x-120">expr</span>
<br 
class="newline" /><div class="minipage">Returns  nil  if  A  is  not  equal  to  some  top  level  element  of  the  list  L;
otherwise it returns the remainder of L whose first element is equal to A.</div>
</div>

<div class="verbatim" id="verbatim-106">
&#x00A0;&#x00A0;&#x00A0;&#x00A0;(de&#x00A0;member&#x00A0;(a&#x00A0;l)
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;(cond&#x00A0;((not&#x00A0;(pairp&#x00A0;l))&#x00A0;nil)
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;((equal&#x00A0;a&#x00A0;(car&#x00A0;l))&#x00A0;l)
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;(t&#x00A0;(member&#x00A0;a&#x00A0;(cdr&#x00A0;l)))))
</div>
<!--l. 315--><p class="nopar" >
<!--l. 322--><p class="noindent" ><div class="minipage"><a 
 id="dx22-51002"></a>
<span 
class="ptmb7t-x-x-120">(memq A:any B:list): extra-boolean                                                                          </span><span 
class="ptmri7t-x-x-120">expr</span>
<br 
class="newline" /><div class="minipage">The same as member except that eq is used for comparison instead of equal.
Note that the value returned by either member or memq is eq to the portion
of the list which begins with A. Thus a function like rplaca may be used to
alter A.</div></div>

<div class="verbatim" id="verbatim-107">
1&#x00A0;lisp&#x003E;&#x00A0;(setq&#x00A0;sequence&#x00A0;'(1&#x00A0;3&#x00A0;3))
&#x00A0;<br />(1&#x00A0;3&#x00A0;3)
&#x00A0;<br />2&#x00A0;lisp&#x003E;&#x00A0;(rplaca&#x00A0;(memq&#x00A0;3&#x00A0;sequence)&#x00A0;2)
&#x00A0;<br />(2&#x00A0;3)
&#x00A0;<br />3&#x00A0;lisp&#x003E;&#x00A0;sequence
&#x00A0;<br />(1&#x00A0;2&#x00A0;3)
</div>
<!--l. 330--><p class="nopar" >
<!--l. 334--><p class="noindent" ><div class="minipage"><a 
 id="dx22-51003"></a>
<span 
class="ptmb7t-x-x-120">(length X:any): integer                                                                                                </span><span 
class="ptmri7t-x-x-120">expr</span>
<br 
class="newline" /><div class="minipage">The top level length of the list X is returned.
</div></div>

<div class="verbatim" id="verbatim-108">
&#x00A0;&#x00A0;&#x00A0;&#x00A0;(de&#x00A0;length&#x00A0;(l)
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;(if&#x00A0;(atom&#x00A0;l)&#x00A0;0&#x00A0;(add1&#x00A0;(length&#x00A0;(cdr&#x00A0;l)))))
</div>
<!--l. 338--><p class="nopar" >
<h5 class="subsubsectionHead"><a 
 id="x22-520005.3.1"></a>Constructing, Appending, and Concatenating Lists</h5>
<!--l. 344--><p class="noindent" ><div class="minipage"><a 
 id="dx22-52001"></a>
<span 
class="ptmb7t-x-x-120">(list [U:any]): list                                                                                                         </span><span 
class="ptmri7t-x-x-120">fexpr</span>
<br 
class="newline" /><div class="minipage">Construct a list of the arguments.
</div></div>

<div class="verbatim" id="verbatim-109">
&#x00A0;&#x00A0;&#x00A0;&#x00A0;1&#x00A0;lisp&#x003E;&#x00A0;(list&#x00A0;(car&#x00A0;'(left&#x00A0;.&#x00A0;right))&#x00A0;(list&#x00A0;'next))
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;(LEFT&#x00A0;(NEXT))
</div>
<!--l. 348--><p class="nopar" >
<!--l. 354--><p class="noindent" ><div class="minipage"><a 
 id="dx22-52002"></a>
<span 
class="ptmb7t-x-x-120">(append U:list V:list): list                                                                                            </span><span 
class="ptmri7t-x-x-120">expr</span>
<br 
class="newline" /><div class="minipage">Returns a constructed list in which the last element of U is followed by the
first element of V. The list U is copied, but V is not.</div>
</div>

<div class="verbatim" id="verbatim-110">
&#x00A0;&#x00A0;&#x00A0;&#x00A0;(de&#x00A0;append&#x00A0;(u&#x00A0;v)
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;(cond&#x00A0;((not&#x00A0;(pairp&#x00A0;u))&#x00A0;v)
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;(t&#x00A0;(cons&#x00A0;(first&#x00A0;u)&#x00A0;(append&#x00A0;(rest&#x00A0;u)&#x00A0;v)))))
</div>
<!--l. 359--><p class="nopar" >
<!--l. 365--><p class="noindent" ><div class="minipage"><a 
 id="dx22-52003"></a>
<span 
class="ptmb7t-x-x-120">(nconc U:list V:list): list                                                                                               </span><span 
class="ptmri7t-x-x-120">expr</span>
<br 
class="newline" /><div class="minipage">Destructive  version  of  append,  the  cdr  of  the  last  pair  of  U  is  modified
to reference V. While append creates a copy of U, nconc uses U itself in
constructing the result.</div>
</div>

<div class="verbatim" id="verbatim-111">
&#x00A0;&#x00A0;&#x00A0;&#x00A0;(de&#x00A0;nconc&#x00A0;(u&#x00A0;v)
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;(if&#x00A0;(not&#x00A0;(pairp&#x00A0;u))
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;v
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;(rplacd&#x00A0;(lastpair&#x00A0;u)&#x00A0;v)))
</div>
<!--l. 371--><p class="nopar" >

<div class="verbatim" id="verbatim-112">
&#x00A0;&#x00A0;&#x00A0;&#x00A0;1&#x00A0;lisp&#x003E;&#x00A0;(setq&#x00A0;a&#x00A0;'(swan))
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;(SWAN)
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;3&#x00A0;lisp&#x003E;&#x00A0;(nconc&#x00A0;a&#x00A0;'(giles))
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;(SWAN&#x00A0;GILES)
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;4&#x00A0;lisp&#x003E;&#x00A0;a
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;(SWAN&#x00A0;GILES)
</div>
<!--l. 379--><p class="nopar" >
<!--l. 383--><p class="noindent" ><div class="minipage"><a 
 id="dx22-52004"></a>
<span 
class="ptmb7t-x-x-120">(aconc U:list V:any): list                                                                                              </span><span 
class="ptmri7t-x-x-120">expr</span>
<br 
class="newline" /><div class="minipage">Destructively adds element V to the tail of list U.
</div></div>

<div class="verbatim" id="verbatim-113">
&#x00A0;&#x00A0;&#x00A0;&#x00A0;1&#x00A0;lisp&#x003E;&#x00A0;(setq&#x00A0;a&#x00A0;'(phillips))
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;(PHILLIPS)
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;2&#x00A0;lisp&#x003E;&#x00A0;(progn&#x00A0;(aconc&#x00A0;a&#x00A0;'posner)&#x00A0;a)
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;(PHILLIPS&#x00A0;POSNER)
</div>
<!--l. 389--><p class="nopar" >
<!--l. 397--><p class="noindent" ><div class="minipage"><a 
 id="dx22-52005"></a>
<span 
class="ptmb7t-x-x-120">(lconc PTR:list LST:list): list                                                                                      </span><span 
class="ptmri7t-x-x-120">expr</span>
<br 
class="newline" /><div class="minipage">Effectively nconc, but avoids scanning from the front to the end of the first
list by maintaining a pointer. PTR is a pair whose car is a list L and whose
cdr is a reference to the last pair of L. The value returned is the updated pair
PTR.</div></div>

<div class="verbatim" id="verbatim-114">
&#x00A0;&#x00A0;&#x00A0;&#x00A0;(progn&#x00A0;(rplacd&#x00A0;(cdr&#x00A0;ptr)&#x00A0;lst)
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;(rplacd&#x00A0;ptr&#x00A0;(lastpair&#x00A0;lst)))
</div>
<!--l. 401--><p class="nopar" >This function is useful for building lists from left to right, PTR should be initialized to (nil . nil)
before the first call on lconc.
<!--l. 413--><p class="noindent" ><div class="minipage"><a 
 id="dx22-52006"></a>
<span 
class="ptmb7t-x-x-120">(tconc PTR:list ELM:any): list                                                                                   </span><span 
class="ptmri7t-x-x-120">expr</span>
<br 
class="newline" /><div class="minipage">Effectively aconc, but avoids scanning from the front to the end of the first
list by maintaining a pointer. PTR is a pair whose car is a list L and whose
cdr is a reference to the last pair of L. The value returned is the updated pair
PTR.</div></div>

<div class="verbatim" id="verbatim-115">
&#x00A0;&#x00A0;&#x00A0;&#x00A0;(progn&#x00A0;(setq&#x00A0;elm&#x00A0;(ncons&#x00A0;elm))
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;(rplacd&#x00A0;(cdr&#x00A0;ptr)&#x00A0;elm)
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;(rplacd&#x00A0;ptr&#x00A0;elm))
</div>
<!--l. 418--><p class="nopar" >This function is useful for building lists from left to right. PTR should be initialized to (nil . nil)
before the first call on tconc.
<!--l. 423--><p class="noindent" >
<h5 class="subsubsectionHead"><a 
 id="x22-530005.3.1"></a>Lists as Sets</h5>
<!--l. 425--><p class="noindent" >A set is a list in which each element occurs only once. Since the order of elements in a set does
not matter, these functions may not preserve order.
<!--l. 432--><p class="noindent" ><div class="minipage"><a 
 id="dx22-53001"></a>
<span 
class="ptmb7t-x-x-120">(adjoin ELEMENT:any SET:list): list                                                                       </span><span 
class="ptmri7t-x-x-120">expr</span>
<br 
class="newline" /><div class="minipage">Add Element to SET if it is not already a member.
</div></div>

<div class="verbatim" id="verbatim-116">
&#x00A0;&#x00A0;&#x00A0;&#x00A0;(de&#x00A0;adjoin&#x00A0;(elm&#x00A0;set)
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;(if&#x00A0;(member&#x00A0;elm&#x00A0;set)&#x00A0;set&#x00A0;(cons&#x00A0;elm&#x00A0;set)))
</div>
<!--l. 436--><p class="nopar" >Recall that member uses equal to test for equality.
<!--l. 443--><p class="noindent" ><div class="minipage"><a 
 id="dx22-53002"></a>
<span 
class="ptmb7t-x-x-120">(adjoinq ELEMENT:any SET:list): list                                                                     </span><span 
class="ptmri7t-x-x-120">expr</span>
<br 
class="newline" /><div class="minipage">Similar to adjoin except that eq is used to test for set membership.
</div></div>
<!--l. 447--><p class="noindent" ><div class="minipage"><a 
 id="dx22-53003"></a>
<span 
class="ptmb7t-x-x-120">(union X:list Y:list): list                                                                                               </span><span 
class="ptmri7t-x-x-120">expr</span>
<br 
class="newline" /><div class="minipage">Returns the union of sets X and Y.
</div></div>

<div class="verbatim" id="verbatim-117">
&#x00A0;&#x00A0;&#x00A0;&#x00A0;(de&#x00A0;union&#x00A0;(x&#x00A0;y)
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;(if&#x00A0;(not&#x00A0;(pairp&#x00A0;x))
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;y
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;(union&#x00A0;(rest&#x00A0;x)
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;(if&#x00A0;(member&#x00A0;(first&#x00A0;x)&#x00A0;y)
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;y
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;(cons&#x00A0;(first&#x00A0;x)&#x00A0;y)))))
</div>
<!--l. 456--><p class="nopar" >Notice that the two arguments to union are assumed to be sets, if either contains duplicates then
the result may contain duplicates as well.

<div class="verbatim" id="verbatim-118">
&#x00A0;&#x00A0;&#x00A0;&#x00A0;1&#x00A0;lisp&#x003E;&#x00A0;(union&#x00A0;'(1&#x00A0;2&#x00A0;2)&#x00A0;'(3))
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;(2&#x00A0;1&#x00A0;3)
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;2&#x00A0;lisp&#x003E;&#x00A0;(union&#x00A0;'(3)&#x00A0;'(1&#x00A0;2&#x00A0;2))
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;(3&#x00A0;1&#x00A0;2&#x00A0;2)
</div>
<!--l. 466--><p class="nopar" >
<!--l. 471--><p class="noindent" ><div class="minipage"><a 
 id="dx22-53004"></a>
<span 
class="ptmb7t-x-x-120">(unionq X:list Y:list): list                                                                                             </span><span 
class="ptmri7t-x-x-120">expr</span>
<br 
class="newline" /><div class="minipage">Similar to union except that eq is used to test for set membership.
</div></div>
<!--l. 475--><p class="noindent" ><div class="minipage"><a 
 id="dx22-53005"></a>
<span 
class="ptmb7t-x-x-120">(intersection U:list V:list): list                                                                                     </span><span 
class="ptmri7t-x-x-120">expr</span>
<br 
class="newline" /><div class="minipage">Returns the intersection of sets U and V.
</div></div>

<div class="verbatim" id="verbatim-119">
&#x00A0;&#x00A0;&#x00A0;&#x00A0;(de&#x00A0;intersection&#x00A0;(u&#x00A0;v)
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;(cond&#x00A0;((not&#x00A0;(pairp&#x00A0;u))&#x00A0;nil)
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;((member&#x00A0;(car&#x00A0;u)&#x00A0;v)
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;(cons&#x00A0;(car&#x00A0;u)
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;(intersection&#x00A0;(cdr&#x00A0;u)&#x00A0;(delete&#x00A0;(car&#x00A0;u)&#x00A0;v))))
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;(t&#x00A0;(intersection&#x00A0;(cdr&#x00A0;u)&#x00A0;v))))
</div>
<!--l. 483--><p class="nopar" >Notice that the two arguments to intersection are assumed to be sets, if either contains
duplicates then the result may contain duplicates as well.

<div class="verbatim" id="verbatim-120">
&#x00A0;&#x00A0;&#x00A0;&#x00A0;1&#x00A0;lisp&#x003E;&#x00A0;(intersection&#x00A0;'(1&#x00A0;2)&#x00A0;'(2))
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;(2)
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;2&#x00A0;lisp&#x003E;&#x00A0;(intersection&#x00A0;'(2&#x00A0;2)&#x00A0;'(1&#x00A0;2&#x00A0;2))
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;(2&#x00A0;2)
</div>
<!--l. 493--><p class="nopar" >
<!--l. 498--><p class="noindent" ><div class="minipage"><a 
 id="dx22-53006"></a>
<span 
class="ptmb7t-x-x-120">(intersectionq U:list V:list): list                                                                                   </span><span 
class="ptmri7t-x-x-120">expr</span>
<br 
class="newline" /><div class="minipage">Similar to intersection except that eq is used to test for set membership.
</div></div>
<!--l. 503--><p class="noindent" ><div class="minipage"><a 
 id="dx22-53007"></a>
<span 
class="ptmb7t-x-x-120">(list2set SET:list): list                                                                                                   </span><span 
class="ptmri7t-x-x-120">expr</span>
<br 
class="newline" /><div class="minipage">Remove redundant elements from the top level of SET using equal.
</div></div>
<!--l. 508--><p class="noindent" ><div class="minipage"><a 
 id="dx22-53008"></a>
<span 
class="ptmb7t-x-x-120">(list2setq SET:list): list                                                                                                </span><span 
class="ptmri7t-x-x-120">expr</span>
<br 
class="newline" /><div class="minipage">Remove redundant elements from the top level of SET using eq.
</div></div>
<h4 class="subsectionHead"><span class="titlemark">5.3.2    </span> <a 
 id="x22-540005.3.2"></a>Deleting Elements of Lists</h4>
<!--l. 511--><p class="noindent" >Note that the functions suffixed by IP will destructively modify the list from which elements are
being deleted. If you use such a function do not rely on the result being eq to the
argument. The value returned will have all of the elements removed, but the modifications
which have been made to the argument may not reflect this. In particular, the leading
elements which are equal to the element being deleted will not be spliced out of the
list.

<div class="verbatim" id="verbatim-121">
1&#x00A0;lisp&#x003E;&#x00A0;(setq&#x00A0;this&#x00A0;'(a&#x00A0;b&#x00A0;c))
&#x00A0;<br />(a&#x00A0;b&#x00A0;c)
&#x00A0;<br />2&#x00A0;lisp&#x003E;&#x00A0;(deletip&#x00A0;'a&#x00A0;this)
&#x00A0;<br />(b&#x00A0;c)
&#x00A0;<br />3&#x00A0;lisp&#x003E;&#x00A0;this
&#x00A0;<br />(a&#x00A0;b&#x00A0;c)
&#x00A0;<br />2&#x00A0;lisp&#x003E;&#x00A0;(reversip&#x00A0;this)
&#x00A0;<br />(c&#x00A0;b&#x00A0;a)
&#x00A0;<br />3&#x00A0;lisp&#x003E;&#x00A0;this
&#x00A0;<br />(a)
</div>
<!--l. 531--><p class="nopar" >
<!--l. 539--><p class="noindent" ><div class="minipage"><a 
 id="dx22-54001"></a>
<span 
class="ptmb7t-x-x-120">(delete U:any V:list): list                                                                                              </span><span 
class="ptmri7t-x-x-120">expr</span>
<br 
class="newline" /><div class="minipage">Returns V with the first top level occurrence of U removed from it. Equal
is used for comparing elements. The result consists of a copy of the portion
of U which comes before the deleted element, and the portion of U which
follows the deleted element.</div></div>

<div class="verbatim" id="verbatim-122">
&#x00A0;&#x00A0;&#x00A0;&#x00A0;(de&#x00A0;delete&#x00A0;(u&#x00A0;v)
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;(cond&#x00A0;((not&#x00A0;(pairp&#x00A0;v))&#x00A0;v)
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;((equal&#x00A0;(car&#x00A0;v)&#x00A0;u)&#x00A0;(cdr&#x00A0;v))
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;(t&#x00A0;(cons&#x00A0;(car&#x00A0;v)&#x00A0;(delete&#x00A0;u&#x00A0;(cdr&#x00A0;v))))))
</div>
<!--l. 545--><p class="nopar" >
<!--l. 550--><p class="noindent" ><div class="minipage"><a 
 id="dx22-54002"></a>
<span 
class="ptmb7t-x-x-120">(del F:function U:any V:list): list                                                                                </span><span 
class="ptmri7t-x-x-120">expr</span>
<br 
class="newline" /><div class="minipage">Generalized delete function with F as the comparison function.
</div></div>

<div class="verbatim" id="verbatim-123">
&#x00A0;&#x00A0;&#x00A0;&#x00A0;1&#x00A0;lisp&#x003E;&#x00A0;(del&#x00A0;'(lambda&#x00A0;(i&#x00A0;e)&#x00A0;(&#x003E;&#x00A0;i&#x00A0;e))&#x00A0;0&#x00A0;'(-2&#x00A0;3&#x00A0;-1))
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;(-2&#x00A0;-1)
</div>
<!--l. 554--><p class="nopar" >
<!--l. 558--><p class="noindent" ><div class="minipage"><a 
 id="dx22-54003"></a>
<span 
class="ptmb7t-x-x-120">(deletip U:any V:list): list                                                                                            </span><span 
class="ptmri7t-x-x-120">expr</span>
<br 
class="newline" /><div class="minipage">The destructive version of delete, V may be modified.
</div></div>
<!--l. 566--><p class="noindent" ><div class="minipage"><a 
 id="dx22-54004"></a>
<span 
class="ptmb7t-x-x-120">(delq U:any V:list): list                                                                                                </span><span 
class="ptmri7t-x-x-120">expr</span>
<br 
class="newline" /><div class="minipage">Returns V with the first top level occurrence of U removed from it. Eq is
used for comparing elements. The result consists of a copy of the portion
of U which comes before the deleted element, and the portion of U which
follows the deleted element.</div></div>
<!--l. 570--><p class="noindent" ><div class="minipage"><a 
 id="dx22-54005"></a>
<span 
class="ptmb7t-x-x-120">(delqip U:any V:list): list                                                                                             </span><span 
class="ptmri7t-x-x-120">expr</span>
<br 
class="newline" /><div class="minipage">The destructive version of delq, V may be modified.
</div></div>
<!--l. 578--><p class="noindent" ><div class="minipage"><a 
 id="dx22-54006"></a>
<span 
class="ptmb7t-x-x-120">(delasc U:any V:a-list): a-list                                                                                       </span><span 
class="ptmri7t-x-x-120">expr</span>
<br 
class="newline" /><div class="minipage">Returns V with the first top level occurrence of (U . ANY) removed from it.
Equal is used for comparisons. The result consists of a copy of the portion
of U which comes before the deleted element, and the portion of U which
follows the deleted element.</div></div>
<!--l. 582--><p class="noindent" ><div class="minipage"><a 
 id="dx22-54007"></a>
<span 
class="ptmb7t-x-x-120">(delascip U:any V:a-list): a-list                                                                                   </span><span 
class="ptmri7t-x-x-120">expr</span>
<br 
class="newline" /><div class="minipage">The destructive version of delasc, V may be modified.
</div></div>

<!--l. 590--><p class="noindent" ><div class="minipage"><a 
 id="dx22-54008"></a>
<span 
class="ptmb7t-x-x-120">(delatq U:any V:a-list): a-list                                                                                      </span><span 
class="ptmri7t-x-x-120">expr</span>
<br 
class="newline" /><div class="minipage">Returns V with the first top level occurrence of (U . ANY) removed from
it. Eq is used for comparisons. The result consists of a copy of the portion
of U which comes before the deleted element, and the portion of U which
follows the deleted element.</div></div>
<!--l. 594--><p class="noindent" ><div class="minipage"><a 
 id="dx22-54009"></a>
<span 
class="ptmb7t-x-x-120">(delatqip U:any V:a-list): a-list                                                                                   </span><span 
class="ptmri7t-x-x-120">expr</span>
<br 
class="newline" /><div class="minipage">The destructive version of delatq, V may be modified.
</div></div>
<h4 class="subsectionHead"><span class="titlemark">5.3.3    </span> <a 
 id="x22-550005.3.3"></a>List Reversal</h4>
<!--l. 600--><p class="noindent" ><div class="minipage"><a 
 id="dx22-55001"></a>
<span 
class="ptmb7t-x-x-120">(reverse U:list): list                                                                                                       </span><span 
class="ptmri7t-x-x-120">expr</span>
<br 
class="newline" /><div class="minipage">Returns a copy of the top level of U in reverse order.
</div></div>

<div class="verbatim" id="verbatim-124">
&#x00A0;&#x00A0;&#x00A0;&#x00A0;(de&#x00A0;reverse&#x00A0;(l)
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;(do&#x00A0;((result&#x00A0;nil&#x00A0;(cons&#x00A0;(car&#x00A0;pointer)&#x00A0;result))
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;(pointer&#x00A0;l&#x00A0;(cdr&#x00A0;pointer)))
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;((not&#x00A0;(pairp&#x00A0;pointer))&#x00A0;result)))
</div>
<!--l. 607--><p class="nopar" >
<!--l. 613--><p class="noindent" ><div class="minipage"><a 
 id="dx22-55002"></a>
<span 
class="ptmb7t-x-x-120">(reversip U:list): list                                                                                                     </span><span 
class="ptmri7t-x-x-120">expr</span>
<br 
class="newline" /><div class="minipage">The  destructive  version  of  reverse.  The  argument  may  be  destructively
modified to produce the result. Note also that the result may not be eq to the
argument.</div>
</div>

<div class="verbatim" id="verbatim-125">
&#x00A0;&#x00A0;&#x00A0;&#x00A0;(de&#x00A0;reversip&#x00A0;(l)
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;(prog&#x00A0;(next&#x00A0;result)
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;(while&#x00A0;(pairp&#x00A0;l)
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;(setq&#x00A0;next&#x00A0;(cdr&#x00A0;l))
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;(setq&#x00A0;result&#x00A0;(rplacd&#x00A0;l&#x00A0;result))
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;(setq&#x00A0;l&#x00A0;next))
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;(return&#x00A0;result)))
</div>
<!--l. 623--><p class="nopar" >
<h4 class="subsectionHead"><span class="titlemark">5.3.4    </span> <a 
 id="x22-560005.3.4"></a>Functions for Sorting</h4>
<!--l. 626--><p class="noindent" >The <span 
class="ptmb7t-x-x-120">gsort </span>module provides functions for sorting lists. Some of the functions take a comparison
function as an argument. The comparison function takes two arguments and should return nil if
the second argument should come before the first in the sorted result. A lambda expression is
acceptable as a comparison function. Note that since sorting requires many comparisons, and
thus many calls on the comparison function, the sort will be much faster if the comparison
function is compiled.
<!--l. 642--><p class="noindent" ><div class="minipage"><a 
 id="dx22-56001"></a>
<span 
class="ptmb7t-x-x-120">(gsort TABLE:list LEQ-FN:id,function): list                                                            </span><span 
class="ptmri7t-x-x-120">expr</span>
<br 
class="newline" /><div class="minipage">Returns a sorted list. LEQ-FN is the comparison function used to determine
the sorting order. The original TABLE is unchanged. Gsort uses a stable
sorting algorithm. In other words, if X appears before Y in TABLE then X
will appear before Y in the result unless X and Y are out of order.</div>
</div>
<!--l. 649--><p class="noindent" ><div class="minipage"><a 
 id="dx22-56002"></a>
<span 
class="ptmb7t-x-x-120">(gmergesort TABLE:list LEQ-FN:id,function): list                                                 </span><span 
class="ptmri7t-x-x-120">expr</span>
<br 
class="newline" /><div class="minipage">The destructive version of gsort, this function is somewhat faster than gsort.
Note that you should use the value returned by the function, don&#8217;t depend
on the modified argument to give the right answer.</div>
</div>
<!--l. 655--><p class="noindent" ><div class="minipage"><a 
 id="dx22-56003"></a>
<span 
class="ptmb7t-x-x-120">(idsort TABLE:list): list                                                                                              </span><span 
class="ptmri7t-x-x-120">expr</span>
<br 
class="newline" /><div class="minipage">Returns  a  list  of  the  ids  in  TABLE,  sorted  into  alphabetical  order.  The
original  list  is  unchanged.  Case  is  not  significant  in  determining  the
alphabetical order.</div>
</div>

<div class="verbatim" id="verbatim-126">
1&#x00A0;lisp&#x003E;&#x00A0;(setq&#x00A0;x&#x00A0;'(3&#x00A0;8&#x00A0;-7&#x00A0;2&#x00A0;1&#x00A0;5))
&#x00A0;<br />(3&#x00A0;8&#x00A0;-7&#x00A0;2&#x00A0;1&#x00A0;5)
&#x00A0;<br />2&#x00A0;lisp&#x003E;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;%&#x00A0;sort&#x00A0;from&#x00A0;smallest&#x00A0;to&#x00A0;largest
&#x00A0;<br />2&#x00A0;lisp&#x003E;&#x00A0;(gsort&#x00A0;x&#x00A0;'leq)
&#x00A0;<br />(-7&#x00A0;1&#x00A0;2&#x00A0;3&#x00A0;5&#x00A0;8)
&#x00A0;<br />3&#x00A0;lisp&#x003E;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;%&#x00A0;sort&#x00A0;from&#x00A0;largest&#x00A0;to&#x00A0;smallest
&#x00A0;<br />3&#x00A0;lisp&#x003E;&#x00A0;(gmergesort&#x00A0;x&#x00A0;'geq)
&#x00A0;<br />(8&#x00A0;5&#x00A0;3&#x00A0;2&#x00A0;1&#x00A0;-7)
&#x00A0;<br />4&#x00A0;lisp&#x003E;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;%&#x00A0;note&#x00A0;that&#x00A0;the&#x00A0;value&#x00A0;of&#x00A0;x&#x00A0;has&#x00A0;been&#x00A0;modified
&#x00A0;<br />4&#x00A0;lisp&#x003E;&#x00A0;x
&#x00A0;<br />(3&#x00A0;2&#x00A0;1&#x00A0;-7)
&#x00A0;<br />5&#x00A0;lisp&#x003E;&#x00A0;(idsort&#x00A0;'(the&#x00A0;quick&#x00A0;brown&#x00A0;fox&#x00A0;jumped&#x00A0;over&#x00A0;the&#x00A0;lazy&#x00A0;dog))
&#x00A0;<br />(brown&#x00A0;dog&#x00A0;fox&#x00A0;jumped&#x00A0;lazy&#x00A0;over&#x00A0;quick&#x00A0;the&#x00A0;the)
</div>
<!--l. 670--><p class="nopar" >

<table cellspacing="5"><tr><td class="clinks"><a 
href="allman1li4.html#allman1se15.html" >Up</a></td><td class="clinks"><a 
href="allman1se16.html" >Next</a></td><td class="clinks"><a 
href="allman1se14.html" >Prev</a></td><td class="clinks"><a 
href="allman1se14.html#tailallman1se14.html" >PrevTail</a></td><td class="clinks"><a 
href="allman1se15.html" >Front</a></td></tr></table><a 
 id="tailallman1se15.html"></a>   
</body></html> 
