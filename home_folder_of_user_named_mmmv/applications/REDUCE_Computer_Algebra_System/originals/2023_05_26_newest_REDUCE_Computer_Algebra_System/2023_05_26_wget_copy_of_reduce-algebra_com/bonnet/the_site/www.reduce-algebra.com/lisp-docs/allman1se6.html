<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"  
  "http://www.w3.org/TR/html4/loose.dtd">  
<html > 
<head><title>Data Types</title> 
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1"> 
<meta name="generator" content="TeX4ht (http://www.cse.ohio-state.edu/~gurari/TeX4ht/)"> 
<meta name="originator" content="TeX4ht (http://www.cse.ohio-state.edu/~gurari/TeX4ht/)"> 
<!-- 3,html --> 
<meta name="src" content="allman1.tex"> 
<meta name="date" content="2014-05-02 18:10:00"> 
<link rel="stylesheet" type="text/css" href="allman1.css"> 
</head><body 
>
<p align="centre"><img src="http://www.reduce-algebra.com/lisp-docs/redlogo.png" width=621 height=60 border=0 alt="REDUCE"></p><table cellspacing="5"><tr><td class="clinks"><a 
href="allman1li2.html#allman1se6.html" >Up</a></td><td class="clinks"><a 
href="allman1se7.html" >Next</a></td><td class="clinks"><a 
href="allman1se5.html" >Prev</a></td><td class="clinks"><a 
href="allman1se5.html#tailallman1se5.html" >PrevTail</a></td><td class="clinks"><a 
href="allman1se6.html#tailallman1se6.html">Tail</a></td></tr></table><h3 class="sectionHead"><span class="titlemark">2.1    </span> <a 
 id="x11-110002.1"></a>Data Types</h3>
<!--l. 3--><p class="noindent" >
<h4 class="subsectionHead"><span class="titlemark">2.1.1    </span> <a 
 id="x11-120002.1.1"></a>Data Types and Structures Supported in PSL</h4>
<!--l. 5--><p class="noindent" >
<h5 class="subsubsectionHead"><a 
 id="x11-130002.1.1"></a>Data Types</h5>
<!--l. 7--><p class="noindent" >In contrast to many programming languages, type declarations are not needed in PSL. Data
objects contain information about their type. Some functions, like equal, are &#8221;generic&#8221; in that the
result they return depends on the types of the arguments.

<div class="verbatim" id="verbatim-8">
1&#x00A0;lisp&#x003E;&#x00A0;(equal&#x00A0;"sextuped"&#x00A0;"sextuped")
&#x00A0;<br />T
&#x00A0;<br />2&#x00A0;lisp&#x003E;&#x00A0;(equal&#x00A0;[bencolin&#x00A0;beef]&#x00A0;[bencolin&#x00A0;beef])
&#x00A0;<br />T
</div>
<!--l. 17--><p class="nopar" >For the purposes of input and output, an appropriate notation is used for each type of data object
used in PSL. For example, double quotes are used to delimit the characters of a string. For a full
discussion on syntax see Chapter 12.
<!--l. 23--><p class="noindent" >The basic data types supported in PSL and a brief indication of their representations are
described below.
<!--l. 26--><p class="noindent" >
             <dl class="list1"><dt class="list">
<span 
class="ptmb7t-x-x-120">integer</span>       </dt><dd 
class="list">
             <!--l. 27--><p class="noindent" >The integers are also called &#8221;fixed&#8221; numbers. The magnitude of integers is
             essentially unrestricted if the &#8221;big number&#8221; module, <span 
class="ptmb7t-x-x-120">zbig</span>, is loaded. The
             notation for integers is a sequence of digits in an appropriate radix (radix
             10 is the default, which can be overridden by a radi prefix, such as 2#, 8#,
             16# etc). There are three internal representations of integers, chosen to suit
             the implementation:
             </dd><dt class="list">
<span 
class="ptmb7t-x-x-120">inum</span>        </dt><dd 
class="list">
             <!--l. 36--><p class="noindent" >A signed number fitting into info. Inums do not require dynamic storage
             and are represented in the same form as machine integers.
             </dd><dt class="list">
<span 
class="ptmb7t-x-x-120">fixnum</span>       </dt><dd 
class="list">
             <!--l. 41--><p class="noindent" >A full-word signed integer, allocated in the heap.
             </dd><dt class="list">
<span 
class="ptmb7t-x-x-120">bignum</span>      </dt><dd 
class="list">
             <!--l. 44--><p class="noindent" >A  signed  integer  of  arbitrary  precision,  allocated  as  a  vector  of  system
             integers. These integers may be not integers for PSL, because they do not
             fit into info. Beware. Bignums are currently not installed by default, to use
             them load the ZBIG module.
             </dd><dt class="list">
<span 
class="ptmb7t-x-x-120">float</span>         </dt><dd 
class="list">
             <!--l. 52--><p class="noindent" >A floating point number, allocated in the heap. The precision of floats is
             determined  solely  by  the  implementation.  Usually,  the  floating  numbers
             are  equivalent  to  system  &#8217;doubles&#8217;,  (64  bits).  The  notation  for  a  float  is
             a sequence of digits with the addition of a single floating point ( . ) and
             an optional exponent (E <span class="verb"><span 
class="pcrr7t-x-x-120">&#x003C;</span>integer<span class="verb"><span 
class="pcrr7t-x-x-120">&#x003E;</span>). (No spaces may occur between the

           point and the digits). Radix 10 is used for representing the mantissa and
           the exponent of floating point numbers.
           </dd><dt class="list">
<span 
class="ptmb7t-x-x-120">id</span>           </dt><dd 
class="list">
           <!--l. 66--><p class="noindent" >An  identifier  (or  id)  is  an  item  whose  info  field  points  to  a  five-item
           structure containing the print name, property cell, value cell, function cell,
           and package cell. This structure is contained in the id space. The notation
           for an id is its print name, an alphanumeric character sequence. One always
           refers to a particular id by giving its print name. When presented with an
           appropriate print name, the PSL reader will find a unique id to associate
           with it. See Chapters 4 and 12 for more information on ids and their syntax.
           The ids t and nil are considered special in that it is not possible for the user
           to redefine their value cells.
           </dd><dt class="list">
<span 
class="ptmb7t-x-x-120">pair</span>         </dt><dd 
class="list">
           <!--l. 81--><p class="noindent" >A primitive two-item structure which has a left and right part. A notation
           called dot-notation is used, with the form: (<span 
class="cmmi-12">&#x003C;</span>left-part<span 
class="cmmi-12">&#x003E; </span>. <span 
class="cmmi-12">&#x003C;</span>right-part<span 
class="cmmi-12">&#x003E;</span>).
           The <span 
class="cmmi-12">&#x003C;</span>left-part<span 
class="cmmi-12">&#x003E; </span>is known as the car portion and the <span 
class="cmmi-12">&#x003C;</span>right-part<span 
class="cmmi-12">&#x003E; </span>as the cdr
           portion. The parts may be any item. (Spaces are used to resolve ambiguity
           with floats; see Chapter 12).
           </dd><dt class="list">
<span 
class="ptmb7t-x-x-120">vector</span>       </dt><dd 
class="list">
           <!--l. 90--><p class="noindent" >A primitive uniform structure of items; an integer index is used to access
           random values in the structure. The individual elements of a vector may
           be  any  item.  Access  to  vectors  is  by  means  of  functions  for  indexing,
           sub-vector  extraction  and  concatenation,  defined  in  Section  7.1.  In  the
           notation  for  vectors,  the  elements  of  a  vector  are  surrounded  by  square
           brackets: [item-0 item-1 ... item-n].
           </dd><dt class="list">
<span 
class="ptmb7t-x-x-120">string</span>        </dt><dd 
class="list">
           <!--l. 100--><p class="noindent" >A  packed  vector  (or  byte  vector)  of  characters;  the  elements  are  small
           integers representing the ASCII codes for the characters (usually inums).
           The elements may be accessed by indexing, substring and concatenation
           functions,  defined  in  Chapter  6.  String  notation  consists  of  a  series  of
           characters enclosed in double quotes, as in &#8221;THIS IS A STRING&#8221;. A quote
           is included by doubling it, as in &#8221;HE SAID, &#8221;&#8221;LISP&#8221;&#8221;&#8221;. A string may be
           input across the end of a line but a warning will be given unless the switch
           <span 
class="ptmb7t-x-x-120">eolinstringok</span><a 
 id="dx11-13001"></a> <a 
 id="dx11-13002"></a>is non-nil (see Chapter 12).
           </dd><dt class="list">
<span 
class="ptmb7t-x-x-120">w-vector</span>     </dt><dd 
class="list">
           <!--l. 114--><p class="noindent" >A  vector  of  machine-sized  words,  used  to  implement  such  things  as
           fixnums, bignums, etc. The elements are not considered to be items, and
           are not examined by the garbage collector.

           </dd><dt class="list">
<span 
class="ptmb7t-x-x-120">byte-vector</span>  </dt><dd 
class="list">
           <!--l. 119--><p class="noindent" >A vector of bytes. Internally a byte-vector is the same as a string, but it is
           printed differently as a vector of integers instead of characters.
           </dd><dt class="list">
<span 
class="ptmb7t-x-x-120">code-pointer</span> </dt><dd 
class="list">
           <!--l. 124--><p class="noindent" >This item is used to refer to the entry point of compiled functions (exprs,
           fexprs, macros, etc.), permitting compiled functions to be renamed, passed
           around anonymously, etc. New code-pointers are created by the loader (lap,
           fasl) and associated functions. They can be printed; the printing function
           prints the number of arguments expected as well as the entry point. The
           value appears in the convention of the implementation (e.g. #<span 
class="cmmi-12">&#x003C;</span>Code A N<span 
class="cmmi-12">&#x003E;</span>,
           where A is the number of arguments and N is the entry point).</dd></dl>
<!--l. 137--><p class="noindent" >
<h5 class="subsubsectionHead"><a 
 id="x11-140002.1.1"></a>Other Notational Conventions</h5>
<!--l. 139--><p class="noindent" >Certain functional arguments can be any of a number of types. For convenience, we give these
commonly used sets a name. We refer to these sets as &#8221;classes&#8221; of primitive data types. In
addition to the types described above and the names for classes of types given below, we use the
following conventions in the manual. <span 
class="cmsy-10x-x-120">{</span>XXX, YYY<span 
class="cmsy-10x-x-120">} </span>indicates that either data type XXX or data
type YYY will do. <span 
class="cmsy-10x-x-120">{</span>XXX<span 
class="cmsy-10x-x-120">}</span>-<span 
class="cmsy-10x-x-120">{</span>YYY<span 
class="cmsy-10x-x-120">} </span>indicates that any object of type XXX can be used except
those of type YYY; in this case, YYY is a subset of XXX. For example, <span 
class="cmsy-10x-x-120">{</span>integer, float<span 
class="cmsy-10x-x-120">} </span>indicates
that either an integer or a float is acceptable; <span 
class="cmsy-10x-x-120">{</span>any<span 
class="cmsy-10x-x-120">}</span>-<span 
class="cmsy-10x-x-120">{</span>vector<span 
class="cmsy-10x-x-120">} </span>means any type except a
vector.
<!--l. 151--><p class="noindent" >
             <dl class="list1"><dt class="list">
<span 
class="ptmb7t-x-x-120">any</span>            </dt><dd 
class="list">
             <!--l. 152--><p class="noindent" >Any of the types given above. S-expression is another term for any. All
             PSL entities have some value unless an error occurs during evaluation.
             </dd><dt class="list">
<span 
class="ptmb7t-x-x-120">atom</span>           </dt><dd 
class="list">
             <!--l. 156--><p class="noindent" >The class any-pair.
             </dd><dt class="list">
<span 
class="ptmb7t-x-x-120">boolean</span>        </dt><dd 
class="list">
             <!--l. 158--><p class="noindent" >The class of global variables t, nil, or their respective values, t, nil. (See
             Section 4.6).
             </dd><dt class="list">
<span 
class="ptmb7t-x-x-120">character</span>       </dt><dd 
class="list">
             <!--l. 162--><p class="noindent" >Integers  in  the  range  of  0  to  255  without  128  representing  ASCII
             character codes. These are distinct from single-character ids.

             </dd><dt class="list">
<span 
class="ptmb7t-x-x-120">constant</span>        </dt><dd 
class="list">
             <!--l. 166--><p class="noindent" >The  class  of  integer,  float,  string,  vector,  code-pointer.  A  constant
             evaluates to itself (see the definition of eval in Chapter 11).
             </dd><dt class="list">
<span 
class="ptmb7t-x-x-120">extra-boolean</span>   </dt><dd 
class="list">
             <!--l. 170--><p class="noindent" >Any  value  in  the  system.  Anything  that  is  not  nil  has  the  boolean
             interpretation t.
             </dd><dt class="list">
<span 
class="ptmb7t-x-x-120">ftype</span>           </dt><dd 
class="list">
             <!--l. 173--><p class="noindent" >The set of ids (expr, fexpr, macro, and nexpr), which represent definable
             function  types.  The  ftype  is  only  an  attribute  of  identifiers,  and  is
             not  associated  with  either  executable  code  code-pointers  or  lambda
             expressions.
             </dd><dt class="list">
<span 
class="ptmb7t-x-x-120">io-channel</span>      </dt><dd 
class="list">
             <!--l. 179--><p class="noindent" >A  small  integer  representing  an  io  channel  (see  Chapter  12  for  a
             complete discussion of io-channels).
             </dd><dt class="list">
<span 
class="ptmb7t-x-x-120">number</span>        </dt><dd 
class="list">
             <!--l. 183--><p class="noindent" >The class of integer, float.
             </dd><dt class="list">
<span 
class="ptmb7t-x-x-120">x-vector</span>        </dt><dd 
class="list">
             <!--l. 185--><p class="noindent" >Any kind of vector; i.e. a string, vector, w-vector, or word.
             </dd><dt class="list">
<span 
class="ptmb7t-x-x-120">Undefined</span>      </dt><dd 
class="list">
             <!--l. 188--><p class="noindent" >An   implementation-dependent   value   returned   by   some   low-level
             functions; i.e. the user should not depend on this value.
             </dd><dt class="list">
<span 
class="ptmb7t-x-x-120">None Returned</span> </dt><dd 
class="list">
             <!--l. 192--><p class="noindent" >A notational convenience used to indicate control functions that do not
             return directly to the calling point, and hence do not return a value (for
             example, see the function go in Chapter 8).</dd></dl>

<!--l. 198--><p class="noindent" >
<h5 class="subsubsectionHead"><a 
 id="x11-150002.1.1"></a>Structures</h5>
<!--l. 200--><p class="noindent" >Structures are entities created using pairs. Lists are structures very commonly required as
parameters to functions. If a list of homogeneous entities is required by a function,
this class is denoted by xxx-list, in which xxx is the name of a class of primitives or
structures. Thus a list of ids is an id-list, a list of integers is an integer-list, and so
on.
<!--l. 207--><p class="noindent" >
       <dl class="list1"><dt class="list">
<span 
class="ptmb7t-x-x-120">list</span>      </dt><dd 
class="list">
       <!--l. 208--><p class="noindent" >A list is recursively defined as nil or the pair (any . list). A special notation
       called  list-notation  is  used  to  represent  lists.  List-notation  eliminates  the
       extra  parentheses  and  dots  required  by  dot-notation,  as  illustrated  below.
       List-notation and dot-notation may be mixed, as shown in the second example.</dd></dl>

<div class="verbatim" id="verbatim-9">
&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;DOT&#x00A0;NOTATION&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;LIST&#x00A0;NOTATION
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;(A&#x00A0;.&#x00A0;(B&#x00A0;.&#x00A0;(C&#x00A0;.&#x00A0;NIL)))&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;(A&#x00A0;B&#x00A0;C)
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;((A&#x00A0;.&#x00A0;(B))&#x00A0;.&#x00A0;C)&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;((A&#x00A0;B)&#x00A0;.&#x00A0;C)
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;
</div>
<!--l. 221--><p class="nopar" >
<!--l. 223--><p class="noindent" >Note: () is an alternate input representation of nil.
<!--l. 226--><p class="noindent" >
         <dl class="list1"><dt class="list">
<span 
class="ptmb7t-x-x-120">a-list</span>    </dt><dd 
class="list">
         <!--l. 227--><p class="noindent" >An a-list, or association list, is a list in which each element is a pair, the car part
         being a key associated with the value in the cdr part.
         </dd><dt class="list">
<span 
class="ptmb7t-x-x-120">form</span>    </dt><dd 
class="list">
         <!--l. 232--><p class="noindent" >A form is an S-expression (any) which is legally acceptable to eval; that is, it is
         syntactically and semantically accepted by the interpreter or the compiler.
         </dd><dt class="list">
<span 
class="ptmb7t-x-x-120">lambda</span>  </dt><dd 
class="list">
         <!--l. 238--><p class="noindent" >A lambda expression must be of the following form, the square brackets are
         used to indicate zero or more occurances of an expression.

       <div class="verbatim" id="verbatim-10">
       &#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;(LAMBDA&#x00A0;&#x003C;parameters&#x003E;&#x00A0;[&#x003C;form&#x003E;])
       &#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;
</div>
         <!--l. 244--><p class="nopar" > The expression <span class="verb"><span 
class="pcrr7t-x-x-120">&#x003C;parameters&#x003E; </span>is a list of ids which represents the formal
         parameters or the body (the sequence of <span class="verb"><span 
class="pcrr7t-x-x-120">&#x003C;form&#x003E;</span>s). The evaluation of the body takes
         place as if the <span class="verb"><span 
class="pcrr7t-x-x-120">&#x003C;form&#x003E;</span>s were enclosed within a progn.
         </dd><dt class="list">
<span 
class="ptmb7t-x-x-120">function</span> </dt><dd 
class="list">
         <!--l. 251--><p class="noindent" >A lambda expression or a code-pointer, the function type is assumed to be expr. This
         means that the arguments will be evaluated, and that the number of arguments must
         agree with the number of parameters.</dd></dl>
<!--l. 259--><p class="noindent" >
<h4 class="subsectionHead"><span class="titlemark">2.1.2    </span> <a 
 id="x11-160002.1.2"></a>Predicates Useful with Data Types</h4>
<!--l. 261--><p class="noindent" >Most functions in this Section return t if the condition defined is met and nil if it is not.
Exceptions are noted. Defined are type-checking functions and elementary comparisons.
<!--l. 265--><p class="noindent" >
<h5 class="subsubsectionHead"><a 
 id="x11-170002.1.2"></a>Functions for Testing Equality</h5>
<!--l. 267--><p class="noindent" >Functions for testing equality are listed below. For other functions comparing arithmetic values
see Chapter 3.
<!--l. 277--><p class="noindent" ><div class="minipage"><a 
 id="dx11-17001"></a>
<span 
class="ptmb7t-x-x-120">(eq U:any V:any): boolean                                                                  </span><span 
class="ptmri7t-x-x-120">open-compiled expr</span>
<br 
class="newline" /><div class="minipage">Returns t if U points to the same object as V, i.e. if they are identical items.
Eq is not a reliable comparison between numeric arguments. This function
should only be used in special circumstances. Normally, equality should be
tested with equal, described below.</div>
</div>
<!--l. 282--><p class="noindent" ><div class="minipage"><a 
 id="dx11-17002"></a>
<span 
class="ptmb7t-x-x-120">(eqn U:any V:any): boolean                                                                                        </span><span 
class="ptmri7t-x-x-120">expr</span>
<br 
class="newline" /><div class="minipage">Returns t if U and V are eq or if U and V are numbers and have the same
value and type.</div>
</div>

<!--l. 289--><p class="noindent" ><div class="minipage"><a 
 id="dx11-17003"></a>
<span 
class="ptmb7t-x-x-120">(equal U:any V:any): boolean                                                                                     </span><span 
class="ptmri7t-x-x-120">expr</span>
<br 
class="newline" /><div class="minipage">Returns t if U and V are the same. A usually valid heuristic is that if two
objects look the same if printed with the function print, they are equal. Equal
is open-compiled as eq if one argument is known to be an atom.</div>
</div>

<div class="verbatim" id="verbatim-11">
&#x00A0;&#x00A0;&#x00A0;&#x00A0;(de&#x00A0;equal&#x00A0;(u&#x00A0;v)
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;(cond&#x00A0;((and&#x00A0;(pairp&#x00A0;u)&#x00A0;(pairp&#x00A0;v))
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;(and&#x00A0;(equal&#x00A0;(car&#x00A0;u)&#x00A0;(car&#x00A0;v))
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;(equal&#x00A0;(cdr&#x00A0;u)&#x00A0;(cdr&#x00A0;v))))
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;((and&#x00A0;(stringp&#x00A0;u)&#x00A0;(stringp&#x00A0;v))
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;(string=&#x00A0;u&#x00A0;v))
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;((and&#x00A0;(vectorp&#x00A0;u)&#x00A0;(vectorp&#x00A0;v))
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;(vector-equal&#x00A0;u&#x00A0;v))
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;(t&#x00A0;(eqn&#x00A0;u&#x00A0;v))))
</div>
<!--l. 300--><p class="nopar" >

<div class="verbatim" id="verbatim-12">
&#x00A0;&#x00A0;&#x00A0;&#x00A0;1&#x00A0;lisp&#x003E;&#x00A0;(setq&#x00A0;x&#x00A0;'(lisa)&#x00A0;y&#x00A0;x)
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;(LISA)
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;2&#x00A0;lisp&#x003E;&#x00A0;(eq&#x00A0;x&#x00A0;y)
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;T
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;3&#x00A0;lisp&#x003E;&#x00A0;(eq&#x00A0;x&#x00A0;'(lisa))
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;NIL
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;4&#x00A0;lisp&#x003E;&#x00A0;(equal&#x00A0;x&#x00A0;'(lisa))
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;T
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;5&#x00A0;lisp&#x003E;&#x00A0;(eq&#x00A0;1.0&#x00A0;1.0)
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;NIL
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;6&#x00A0;lisp&#x003E;&#x00A0;(eqn&#x00A0;1.0&#x00A0;1.0)
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;T
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;7&#x00A0;lisp&#x003E;&#x00A0;(equal&#x00A0;0&#x00A0;0.0)
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;NIL
</div>
<!--l. 316--><p class="nopar" ><div class="minipage"><a 
 id="dx11-17004"></a>
<span 
class="ptmb7t-x-x-120">(neq U:any V:any): boolean                                                                                     </span><span 
class="ptmri7t-x-x-120">macro</span>
<br 
class="newline" /><div class="minipage">(not (equal U V)).
</div>
</div>
<!--l. 321--><p class="noindent" ><div class="minipage"><a 
 id="dx11-17005"></a>
<span 
class="ptmb7t-x-x-120">(ne U:any V:any): boolean                                                                  </span><span 
class="ptmri7t-x-x-120">open-compiled expr</span>
<br 
class="newline" /><div class="minipage">(not (eq U V)).
</div></div>
<!--l. 327--><p class="noindent" ><div class="minipage"><a 
 id="dx11-17006"></a>
<span 
class="ptmb7t-x-x-120">(eqstr U:any V:any): boolean                                                                                      </span><span 
class="ptmri7t-x-x-120">expr</span>
<br 
class="newline" /><div class="minipage">Compare  two  strings,  for  exact  (case  sensitive)  equality.  The  function
string-equal (which is defined in the STRINGS module), is not sensitive to
case. Eqstr returns t if U and V are eq or if U and V are equal strings.</div>
</div>
<!--l. 331--><p class="noindent" ><div class="minipage"><a 
 id="dx11-17007"></a>
<span 
class="ptmb7t-x-x-120">(eqcar U:any V:any): boolean                                                                                     </span><span 
class="ptmri7t-x-x-120">expr</span>
<br 
class="newline" /><div class="minipage">Tests  whether  (eq  (car  U)  V)).  If  the  first  argument  is  not  a  pair,  eqcar
returns nil.</div></div>

<!--l. 333--><p class="noindent" >
<h5 class="subsubsectionHead"><a 
 id="x11-180002.1.2"></a>Predicates for Testing the Type of an Object</h5>
<!--l. 337--><p class="noindent" ><div class="minipage"><a 
 id="dx11-18001"></a>
<span 
class="ptmb7t-x-x-120">(atom U:any): boolean                                                                        </span><span 
class="ptmri7t-x-x-120">open-compiled expr</span>
<br 
class="newline" /><div class="minipage">Returns t if U is not a pair.
</div></div>
<!--l. 341--><p class="noindent" ><div class="minipage"><a 
 id="dx11-18002"></a>
<span 
class="ptmb7t-x-x-120">(codep U:any): boolean                                                                       </span><span 
class="ptmri7t-x-x-120">open-compiled expr</span>
<br 
class="newline" /><div class="minipage">Returns t if U is a code-pointer.
</div></div><div class="minipage"><a 
 id="dx11-18003"></a>
<span 
class="ptmb7t-x-x-120">(constantp U:any): boolean                                                                                         </span><span 
class="ptmri7t-x-x-120">expr</span>
<br 
class="newline" /><div class="minipage">Returns t if U is a constant (that is, neither a pair nor an id). Note that
vectors are considered constants.</div>
</div><div class="minipage"><a 
 id="dx11-18004"></a>
<span 
class="ptmb7t-x-x-120">(fixp U:any): boolean                                                                          </span><span 
class="ptmri7t-x-x-120">open-compiled expr</span>
<br 
class="newline" /><div class="minipage">Returns t if U is an integer. If BIG is loaded, this function also returns t for
bignums.</div>
</div><div class="minipage"><a 
 id="dx11-18005"></a>
<span 
class="ptmb7t-x-x-120">(floatp U:any): boolean                                                                       </span><span 
class="ptmri7t-x-x-120">open-compiled expr</span>
<br 
class="newline" /><div class="minipage">Returns t if U is a float.
</div>
</div><div class="minipage"><a 
 id="dx11-18006"></a>
<span 
class="ptmb7t-x-x-120">(idp U:any): boolean                                                                           </span><span 
class="ptmri7t-x-x-120">open-compiled expr</span>
<br 
class="newline" /><div class="minipage">Returns t if U is an id.
</div>
</div><div class="minipage"><a 
 id="dx11-18007"></a>
<span 
class="ptmb7t-x-x-120">(null U:any): boolean                                                                          </span><span 
class="ptmri7t-x-x-120">open-compiled expr</span>
<br 
class="newline" /><div class="minipage">Returns t if U is nil. This is exactly the same function as not, defined in
Section 2.2.3. Both are available solely to increase readability.</div>
</div><div class="minipage"><a 
 id="dx11-18008"></a>
<span 
class="ptmb7t-x-x-120">(numberp U:any): boolean                                                                 </span><span 
class="ptmri7t-x-x-120">open-compiled expr</span>
<br 
class="newline" /><div class="minipage">Returns t if U is a number (integer or float).
</div>

</div><div class="minipage"><a 
 id="dx11-18009"></a>
<span 
class="ptmb7t-x-x-120">(pairp U:any): boolean                                                                       </span><span 
class="ptmri7t-x-x-120">open-compiled expr</span>
<br 
class="newline" /><div class="minipage">Returns t if U is a pair.
</div>
</div><div class="minipage"><a 
 id="dx11-18010"></a>
<span 
class="ptmb7t-x-x-120">(stringp U:any): boolean                                                                    </span><span 
class="ptmri7t-x-x-120">open-compiled expr</span>
<br 
class="newline" /><div class="minipage">Returns t if U is a string.
</div>
</div><div class="minipage"><a 
 id="dx11-18011"></a>
<span 
class="ptmb7t-x-x-120">(vectorp U:any): boolean                                                                    </span><span 
class="ptmri7t-x-x-120">open-compiled expr</span>
<br 
class="newline" /><div class="minipage">Returns t if U is a vector.
</div>
</div>
<h5 class="subsubsectionHead"><a 
 id="x11-190002.1.2"></a>Boolean Functions</h5>
<!--l. 375--><p class="noindent" >Boolean functions return nil for false; anything non-nil is taken to be true, although a
conventional way of representing truth is as t. Note that t always evaluates to itself, its value
cannot be redefined. Nil may also be represented as (). As a matter of style, () should be used to
refer to an empty list. The Boolean functions and, or, and not can be applied to an object of any
type. And and or may also be used as control structures (see Section 8.2 for more
information).
<!--l. 384--><p class="noindent" >Since PSL treats any value which is non-nil as a representation for true, there is no clear
distinction between an arbitrary function and a boolean function. However, the three functions
presented here are by far the most useful in constructing more complex tests from simple
predicates.
<!--l. 396--><p class="noindent" ><div class="minipage"><a 
 id="dx11-19001"></a>
<span 
class="ptmb7t-x-x-120">(not U:any): boolean                                                                           </span><span 
class="ptmri7t-x-x-120">open-compiled expr</span>
<br 
class="newline" /><div class="minipage">Returns t if U is nil. This is exactly the same function as null, defined in
Section 2.2.2. Both are available solely to increase readability.</div>
</div>
<!--l. 406--><p class="noindent" ><div class="minipage"><a 
 id="dx11-19002"></a>
<span 
class="ptmb7t-x-x-120">(and [U:form]): extra-boolean                                                          </span><span 
class="ptmri7t-x-x-120">open-compiled fexpr</span>
<br 
class="newline" /><div class="minipage">And evaluates each U until a value of nil is found or the end of the list
is encountered. If a non-nil value is the last value, it is returned; otherwise
nil is returned. Note that and called with zero arguments returns t. In the
example which follows and is used to select the first element of a list, if the
call on pairp returns nil then car will not be applied.</div>
</div>

<div class="verbatim" id="verbatim-13">
&#x00A0;&#x00A0;&#x00A0;&#x00A0;1&#x00A0;lisp&#x003E;&#x00A0;((lambda&#x00A0;(p)&#x00A0;(and&#x00A0;(pairp&#x00A0;p)&#x00A0;(car&#x00A0;p)))&#x00A0;&#x00A0;'(robin))
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;robin
</div>
<!--l. 410--><p class="nopar" ><div class="minipage"><a 
 id="dx11-19003"></a>
<span 
class="ptmb7t-x-x-120">(or [U:form]): extra-boolean                                                             </span><span 
class="ptmri7t-x-x-120">open-compiled fexpr</span>
<br 
class="newline" /><div class="minipage">U  is  any  number  of  expressions  which  are  evaluated  in  order  of  their
appearance. If one is found to be non-nil, it is returned as the value of or.
If all are nil, nil is returned. Note that if or is called with zero arguments, it
returns nil. The following function defines a predicate for numbers.</div>
</div>

<div class="verbatim" id="verbatim-14">
&#x00A0;&#x00A0;&#x00A0;&#x00A0;(de&#x00A0;number-p&#x00A0;(n)
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;(or&#x00A0;(fixp&#x00A0;n)&#x00A0;(floatp&#x00A0;n)))
</div>
<!--l. 422--><p class="nopar" >
<h4 class="subsectionHead"><span class="titlemark">2.1.3    </span> <a 
 id="x11-200002.1.3"></a>Converting Data Types</h4>
<!--l. 425--><p class="noindent" >The following functions are used in converting data items from one type to another. They are
grouped according to the type returned. Numeric types may be converted using functions such as
fix and float, described in Section 3.2.
<!--l. 443--><p class="noindent" ><div class="minipage"><a 
 id="dx11-20001"></a>
<span 
class="ptmb7t-x-x-120">(intern U:id,string): id                                                                                                 </span><span 
class="ptmri7t-x-x-120">expr</span>
<br 
class="newline" /><div class="minipage">Returns an identifier from the symbol table (also called the id-hash-table).
When the PSL reader reads a sequence of characters which notate an id, it
will apply intern to the string of characters. Therefore, it generally does not
make sense to apply intern to an id. Intern will search the symbol table for an
id whose print name matches U. If the search is successful then the matching
id is returned. Otherwise a new id will be entered into the symbol table and
a reference to it will be returned. If U has more than the maximum number
of characters permitted by the implementation, an error will be signalled.</div>
</div>

<div class="verbatim" id="verbatim-15">
&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x22C6;&#x22C6;&#x22C6;&#x22C6;&#x22C6;&#x00A0;Too&#x00A0;many&#x00A0;characters&#x00A0;to&#x00A0;INTERN
</div>
<!--l. 446--><p class="nopar" >The id which is returned from an application of intern to a string will have the string as
its print name. Most identifiers have lowercase print names (even though you may
type in lower case letters), but interning &#8221;ABC&#8221; yields an id with a lower case print
name.

<div class="verbatim" id="verbatim-16">
&#x00A0;&#x00A0;&#x00A0;&#x00A0;1&#x00A0;lisp&#x003E;&#x00A0;(eq&#x00A0;(intern&#x00A0;"abc")&#x00A0;'abc)
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;NIL
</div>
<!--l. 456--><p class="nopar" >The maximum number of characters in any token is system dependent, around 5000 can be
expected to be allowed.
<!--l. 466--><p class="noindent" ><div class="minipage"><a 
 id="dx11-20002"></a>
<span 
class="ptmb7t-x-x-120">(newid S:string): id                                                                                                      </span><span 
class="ptmri7t-x-x-120">expr</span>
<br 
class="newline" /><div class="minipage">Allocates  a  new  identifier  and  sets  its  print  name  to  the  string  S.  The
identifier  is  not  added  to  the  symbol  table  (an  identifier  which  does  not
appear in the symbol table is said to be uninterned). The string is not copied.</div>
</div>

<div class="verbatim" id="verbatim-17">
&#x00A0;&#x00A0;&#x00A0;&#x00A0;1&#x00A0;lisp&#x003E;&#x00A0;(setq&#x00A0;new&#x00A0;(newid&#x00A0;"NEWONE"))
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;NEWONE
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;2&#x00A0;lisp&#x003E;&#x00A0;(eq&#x00A0;new&#x00A0;'newone)
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;nil
</div>
<!--l. 472--><p class="nopar" >If one refers directly to an identifier (for example &#8217;newone), the reader will apply intern
to the string of characters it has read (&#8221;NEWONE&#8221;). In the example, the identifier
created by the call on newid is different from the one created by the reader when it read
&#8217;newone.
<!--l. 484--><p class="noindent" ><div class="minipage"><a 
 id="dx11-20003"></a>
<span 
class="ptmb7t-x-x-120">(int2id I:integer): id                                                                                                     </span><span 
class="ptmri7t-x-x-120">expr</span>
<br 
class="newline" /><div class="minipage">Converts an integer to an id; this refers to the I&#8217;th id in the id space. Since
0 ... 255 correspond to ASCII characters, int2id with an argument in this
range converts an ASCII code to the corresponding single character id. The
id NIL is always found by <span 
class="pcrr7t-x-x-120">(int2id 128)</span>.</div>
</div>
<!--l. 487--><p class="noindent" ><div class="minipage"><a 
 id="dx11-20004"></a>
<span 
class="ptmb7t-x-x-120">(id2int D:id): integer                                                                                                    </span><span 
class="ptmri7t-x-x-120">expr</span>
<br 
class="newline" /><div class="minipage">Returns the id space position of D as a LISP integer.
</div></div>
<!--l. 497--><p class="noindent" ><div class="minipage"><a 
 id="dx11-20005"></a>
<span 
class="ptmb7t-x-x-120">(id2string D:id): string                                                                                                </span><span 
class="ptmri7t-x-x-120">expr</span>
<br 
class="newline" /><div class="minipage">Get name from id space. Id2string returns the print name of its argument
as  a  string.  This  is  not  a  copy,  so  destructive  operations  should  not  be
performed  on  the  result.  PSL  uses  an  escape  convention  for  notating
identifiers which contain special characters. Any character which follows
the character ! is considered to be an alphabetic character. In the example,
notice that the character ! does not appear in the result.</div>
</div>

<div class="verbatim" id="verbatim-18">
&#x00A0;&#x00A0;&#x00A0;&#x00A0;1&#x00A0;lisp&#x003E;&#x00A0;(id2string&#x00A0;'is-!%)
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;"is-%"
</div>
<!--l. 501--><p class="nopar" ><div class="minipage"><a 
 id="dx11-20006"></a>
<span 
class="ptmb7t-x-x-120">(string2list S:string): inum-list                                                                                   </span><span 
class="ptmri7t-x-x-120">expr</span>
<br 
class="newline" /><div class="minipage">Creates a list of length (add1 (size S)), converting the ASCII characters into
small integers.</div>
</div>

<div class="verbatim" id="verbatim-19">
&#x00A0;&#x00A0;&#x00A0;&#x00A0;1&#x00A0;lisp&#x003E;&#x00A0;(string2list&#x00A0;"STRING")
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;(83&#x00A0;84&#x00A0;82&#x00A0;73&#x00A0;78&#x00A0;71)
</div>
<!--l. 509--><p class="nopar" >
<!--l. 516--><p class="noindent" ><div class="minipage"><a 
 id="dx11-20007"></a>
<span 
class="ptmb7t-x-x-120">(list2string L:inum-list): string                                                                                   </span><span 
class="ptmri7t-x-x-120">expr</span>
<br 
class="newline" /><div class="minipage">Allocates a string of the same size as L, and converts small integers into
characters according to their ASCII code. An integer outside the range of 0
... 127 will result in an error.</div></div>

<div class="verbatim" id="verbatim-20">
&#x22C6;&#x22C6;&#x22C6;&#x22C6;&#x22C6;&#x00A0;An&#x00A0;attempt&#x00A0;was&#x00A0;made&#x00A0;to&#x00A0;do&#x00A0;LISP2CHAR&#x00A0;on&#x00A0;&#8216;N'&#x00A0;which&#x00A0;is&#x00A0;not&#x00A0;a&#x00A0;character
&#x00A0;<br />
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;1&#x00A0;lisp&#x003E;&#x00A0;(list2string&#x00A0;'(83&#x00A0;84&#x00A0;82&#x00A0;73&#x00A0;78&#x00A0;71))
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;"STRING"
</div>
<!--l. 522--><p class="nopar" ><div class="minipage"><a 
 id="dx11-20008"></a>
<span 
class="ptmb7t-x-x-120">(string [I:inum]): string                                                                                             </span><span 
class="ptmri7t-x-x-120">nexpr</span>
<br 
class="newline" /><div class="minipage">Creates and returns a string containing each of the small integers
</div>
</div>

<div class="verbatim" id="verbatim-21">
&#x00A0;&#x00A0;&#x00A0;&#x00A0;1&#x00A0;lisp&#x003E;&#x00A0;(string&#x00A0;83&#x00A0;84&#x00A0;82&#x00A0;73&#x00A0;78&#x00A0;71)
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;"STRING"
</div>
<!--l. 530--><p class="nopar" ><div class="minipage"><a 
 id="dx11-20009"></a>
<span 
class="ptmb7t-x-x-120">(vector [U:any]): vector                                                                                             </span><span 
class="ptmri7t-x-x-120">nexpr</span>
<br 
class="newline" /><div class="minipage">Creates and returns a vector containing all the Us given.
</div>
</div>

<div class="verbatim" id="verbatim-22">
&#x00A0;&#x00A0;&#x00A0;&#x00A0;1&#x00A0;lisp&#x003E;&#x00A0;(vector&#x00A0;83&#x00A0;84&#x00A0;82&#x00A0;73&#x00A0;78&#x00A0;71)
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;[83&#x00A0;84&#x00A0;82&#x00A0;73&#x00A0;78&#x00A0;71]
</div>
<!--l. 537--><p class="nopar" ><div class="minipage"><a 
 id="dx11-20010"></a>
<span 
class="ptmb7t-x-x-120">(vector2string V:vector): string                                                                                  </span><span 
class="ptmri7t-x-x-120">expr</span>
<br 
class="newline" /><div class="minipage">Pack the small integers in the vector into a string of the same size, using
the integers as ASCII values. An integer outside the range of 0 ... 255 will
result in an error.</div>
</div>

<div class="verbatim" id="verbatim-23">
&#x00A0;&#x00A0;&#x00A0;&#x00A0;1&#x00A0;lisp&#x003E;&#x00A0;(vector2string&#x00A0;[83&#x00A0;84&#x00A0;82&#x00A0;73&#x00A0;78&#x00A0;71])
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;"STRING"
</div>
<!--l. 546--><p class="nopar" ><div class="minipage"><a 
 id="dx11-20011"></a>
<span 
class="ptmb7t-x-x-120">(string2vector S:string): vector                                                                                  </span><span 
class="ptmri7t-x-x-120">expr</span>
<br 
class="newline" /><div class="minipage">Unpack the string into a vector of the same size. The elements of the vector
are small integers, representing the ASCII values of the characters in S.</div>
</div>

<div class="verbatim" id="verbatim-24">
&#x00A0;&#x00A0;&#x00A0;&#x00A0;1&#x00A0;lisp&#x003E;&#x00A0;(string2vector&#x00A0;"VECTOR")
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;[V&#x00A0;E&#x00A0;C&#x00A0;T&#x00A0;O&#x00A0;R]
</div>
<!--l. 555--><p class="nopar" ><div class="minipage"><a 
 id="dx11-20012"></a>
<span 
class="ptmb7t-x-x-120">(vector2list V:vector): list                                                                                            </span><span 
class="ptmri7t-x-x-120">expr</span>
<br 
class="newline" /><div class="minipage">Create a list of the same size as V, the elements are copied in a left to right
order.</div>
</div>

<div class="verbatim" id="verbatim-25">
&#x00A0;&#x00A0;&#x00A0;&#x00A0;1&#x00A0;lisp&#x003E;&#x00A0;(vector2list&#x00A0;[L&#x00A0;I&#x00A0;S&#x00A0;T])
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;(L&#x00A0;I&#x00A0;S&#x00A0;T)
</div>
<!--l. 563--><p class="nopar" ><div class="minipage"><a 
 id="dx11-20013"></a>
<span 
class="ptmb7t-x-x-120">(list2vector L:list): vector                                                                                            </span><span 
class="ptmri7t-x-x-120">expr</span>
<br 
class="newline" /><div class="minipage">Copy the elements of the list into a vector of the same size.
</div>
</div>

<div class="verbatim" id="verbatim-26">
&#x00A0;&#x00A0;&#x00A0;&#x00A0;1&#x00A0;lisp&#x003E;&#x00A0;(list2vector&#x00A0;'(V&#x00A0;E&#x00A0;C&#x00A0;T&#x00A0;O&#x00A0;R))
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;[V&#x00A0;E&#x00A0;C&#x00A0;T&#x00A0;O&#x00A0;R]
</div>
<!--l. 571--><p class="nopar" >

<table cellspacing="5"><tr><td class="clinks"><a 
href="allman1li2.html#allman1se6.html" >Up</a></td><td class="clinks"><a 
href="allman1se7.html" >Next</a></td><td class="clinks"><a 
href="allman1se5.html" >Prev</a></td><td class="clinks"><a 
href="allman1se5.html#tailallman1se5.html" >PrevTail</a></td><td class="clinks"><a 
href="allman1se6.html" >Front</a></td></tr></table><a 
 id="tailallman1se6.html"></a>   
</body></html> 
