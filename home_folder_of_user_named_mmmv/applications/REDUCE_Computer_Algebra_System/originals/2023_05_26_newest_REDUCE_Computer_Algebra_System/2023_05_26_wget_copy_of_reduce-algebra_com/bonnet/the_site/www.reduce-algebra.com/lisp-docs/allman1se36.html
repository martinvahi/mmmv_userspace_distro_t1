<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"  
  "http://www.w3.org/TR/html4/loose.dtd">  
<html > 
<head><title>Functions for Reading</title> 
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1"> 
<meta name="generator" content="TeX4ht (http://www.cse.ohio-state.edu/~gurari/TeX4ht/)"> 
<meta name="originator" content="TeX4ht (http://www.cse.ohio-state.edu/~gurari/TeX4ht/)"> 
<!-- 3,html --> 
<meta name="src" content="allman1.tex"> 
<meta name="date" content="2014-05-02 18:10:00"> 
<link rel="stylesheet" type="text/css" href="allman1.css"> 
</head><body 
>
<p align="centre"><img src="http://www.reduce-algebra.com/lisp-docs/redlogo.png" width=621 height=60 border=0 alt="REDUCE"></p><table cellspacing="5"><tr><td class="clinks"><a 
href="allman1li9.html#allman1se36.html" >Up</a></td><td class="clinks"><a 
href="allman1se37.html" >Next</a></td><td class="clinks"><a 
href="allman1se35.html" >Prev</a></td><td class="clinks"><a 
href="allman1se35.html#tailallman1se35.html" >PrevTail</a></td><td class="clinks"><a 
href="allman1se36.html#tailallman1se36.html">Tail</a></td></tr></table><h3 class="sectionHead"><span class="titlemark">10.4    </span> <a 
 id="x48-12000010.4"></a>Functions for Reading</h3>
<!--l. 466--><p class="noindent" >
<h4 class="subsectionHead"><span class="titlemark">10.4.1    </span> <a 
 id="x48-12100010.4.1"></a>Reading S-Expressions</h4>
<!--l. 468--><p class="noindent" ><div class="minipage"><a 
 id="dx48-121001"></a>
<span 
class="ptmb7t-x-x-120">(read): any                                                                                                                    </span><span 
class="ptmri7t-x-x-120">expr</span>
<br 
class="newline" /><div class="minipage">
</div></div><div class="minipage"><a 
 id="dx48-121002"></a>
<span 
class="ptmb7t-x-x-120">(channelread CHAN:io-channel): any                                                                       </span><span 
class="ptmri7t-x-x-120">expr</span>
<br 
class="newline" /><div class="minipage">Reads  and  returns  the  next  S-expression  from  input  channel  CHAN.
Valid input forms are: vector-notation, dot-notation, list-notation, numbers,
strings, and identifiers. Identifiers are interned (see the intern function in
Chapter 4), unless the fluid variable *compressing is non-nil. Channelread
returns the value of the global variable $eof$ when the end of the currently
selected input channel is reached.</div>
</div>

<div class="verbatim" id="verbatim-295">
&#x00A0;&#x00A0;&#x00A0;&#x00A0;(de&#x00A0;channelread&#x00A0;(ch)
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;(let&#x00A0;((currentscantable&#x22C6;&#x00A0;lispscantable&#x22C6;)
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;(currentreadmacroindicator&#x22C6;&#x00A0;'lispreadmacro))
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;(channelreadtokenwithhooks&#x00A0;ch)))
</div>
<!--l. 485--><p class="nopar" >Channelread uses the function channelreadtokenwithhooks. Tokens are scanned within the
context of the scan table bound to lispscantable*. The scan table is used to recognize special
character types, for example, delimiters like (, ), and space. The read macro mechanism is used
to parse s-expressions (see section 12.4.5 for more information on read macros). PSL uses a
number of read macros which are described below.<br 
class="newline" />
<div class="tabular"><table id="TBL-9" class="tabular" 
cellspacing="0" cellpadding="0"  
><colgroup id="TBL-9-1g"><col 
id="TBL-9-1"><col 
id="TBL-9-2"></colgroup><tr  
 style="vertical-align:baseline;" id="TBL-9-1-"><td  style="white-space:nowrap; text-align:left;" id="TBL-9-1-1"  
class="td11">(             </td><td  style="white-space:wrap; text-align:left;" id="TBL-9-1-2"  
class="td11"><!--l. 496--><p class="noindent" >S-expressions   are   gathered   into   a   list   until   the   matching   right
parenthesis is read. Both list and dot notation are recognized. A pair or
list is returned.                                                                                          </td>
</tr><tr  
 style="vertical-align:baseline;" id="TBL-9-2-"><td  style="white-space:nowrap; text-align:left;" id="TBL-9-2-1"  
class="td11">)              </td><td  style="white-space:wrap; text-align:left;" id="TBL-9-2-2"  
class="td11"><!--l. 500--><p class="noindent" >If a right parenthesis is read and a matching left parenthesis had not
been previously read then it will be ignored.                                           </td>
</tr><tr  
 style="vertical-align:baseline;" id="TBL-9-3-"><td  style="white-space:nowrap; text-align:left;" id="TBL-9-3-1"  
class="td11"><span 
class="cmr-12">[           </span></td><td  style="white-space:wrap; text-align:left;" id="TBL-9-3-2"  
class="td11"><!--l. 503--><p class="noindent" >S-expressions are gathered into a vector until a matching right bracket
is read. A vector is returned.                                                                    </td>
</tr><tr  
 style="vertical-align:baseline;" id="TBL-9-4-"><td  style="white-space:nowrap; text-align:left;" id="TBL-9-4-1"  
class="td11">&#8217;              </td><td  style="white-space:wrap; text-align:left;" id="TBL-9-4-2"  
class="td11"><!--l. 506--><p class="noindent" >The next s-expression read is quoted, the result is of the form (QUOTE
S-EXPRESSION).                                                                                    </td>
</tr><tr  
 style="vertical-align:baseline;" id="TBL-9-5-"><td  style="white-space:nowrap; text-align:left;" id="TBL-9-5-1"  
class="td11">(char eof)</td><td  style="white-space:wrap; text-align:left;" id="TBL-9-5-2"  
class="td11"><!--l. 508--><p class="noindent" >If  an  end  of  file  character  is  read  while  a  list  or  vector  is  being
constructed then the following error will occur. ***** Unexpected EOF
while reading on channel.                                                                        </td>
</tr><tr  
 style="vertical-align:baseline;" id="TBL-9-6-"><td  style="white-space:nowrap; text-align:left;" id="TBL-9-6-1"  
class="td11">&#8216;N&#8217;          </td><td  style="white-space:wrap; text-align:left;" id="TBL-9-6-2"  
class="td11"><!--l. 512--><p class="noindent" >Otherwise the value of <span 
class="cmmi-12">eof </span>is returned.                                                    </td>
</tr><tr  
 style="vertical-align:baseline;" id="TBL-9-7-"><td  style="white-space:nowrap; text-align:left;" id="TBL-9-7-1"  
class="td11">       </td></tr></table></div><br 
class="newline" />
<!--l. 515--><p class="noindent" >The following read macros are defined in the <span 
class="pcrr7t-x-x-120">useful </span>module.
<div class="tabular"><table id="TBL-10" class="tabular" 
cellspacing="0" cellpadding="0"  
><colgroup id="TBL-10-1g"><col 
id="TBL-10-1"><col 
id="TBL-10-2"></colgroup><tr  
 style="vertical-align:baseline;" id="TBL-10-1-"><td  style="white-space:nowrap; text-align:left;" id="TBL-10-1-1"  
class="td11">#<img 
src="allman10x.png" alt="´  "  class="acute" ></td><td  style="white-space:wrap; text-align:left;" id="TBL-10-1-2"  
class="td11"><!--l. 518--><p class="noindent" >this is like the quote mark &#8217; but it is used for function instead of
quote. For example #&#8217;name reads as (FUNCTION NAME).         </td>
</tr><tr  
 style="vertical-align:baseline;" id="TBL-10-2-"><td  style="white-space:nowrap; text-align:left;" id="TBL-10-2-1"  
class="td11">#/   </td><td  style="white-space:wrap; text-align:left;" id="TBL-10-2-2"  
class="td11"><!--l. 521--><p class="noindent" >this  returns  the  numeric  form  of  the  following  character  read
without raising it. For example #/a is 97 while #/A is 65.              </td>
</tr><tr  
 style="vertical-align:baseline;" id="TBL-10-3-"><td  style="white-space:nowrap; text-align:left;" id="TBL-10-3-1"  
class="td11">#<span 
class="cmsy-10x-x-120">\ </span></td><td  style="white-space:wrap; text-align:left;" id="TBL-10-3-2"  
class="td11"><!--l. 524--><p class="noindent" >This is a read macro for char (see Chapter 6 for more information).
Note  that  the  argument  will  be  raised  if  *raise  is  non-nil.  For
example, #<span 
class="cmsy-10x-x-120">\</span>a = #<span 
class="cmsy-10x-x-120">\</span>A = 65.                                                               </td>
</tr><tr  
 style="vertical-align:baseline;" id="TBL-10-4-"><td  style="white-space:nowrap; text-align:left;" id="TBL-10-4-1"  
class="td11">#.   </td><td  style="white-space:wrap; text-align:left;" id="TBL-10-4-2"  
class="td11"><!--l. 528--><p class="noindent" >This causes the following expression to be evaluated at read time.
For example, &#8216;(1 2 #.(plus 1 2) 4) reads as (1 2 3 4).                      </td>
</tr><tr  
 style="vertical-align:baseline;" id="TBL-10-5-"><td  style="white-space:nowrap; text-align:left;" id="TBL-10-5-1"  
class="td11">#+  </td><td  style="white-space:wrap; text-align:left;" id="TBL-10-5-2"  
class="td11"><!--l. 531--><p class="noindent" >The next two expressions are read. If the first is a system name
which is the current system then the second expression is returned.
Otherwise  another  expression  is  read  and  it  becomes  the  value
returned.                                                                                          </td>
</tr><tr  
 style="vertical-align:baseline;" id="TBL-10-6-"><td  style="white-space:nowrap; text-align:left;" id="TBL-10-6-1"  
class="td11">#-   </td><td  style="white-space:wrap; text-align:left;" id="TBL-10-6-2"  
class="td11"><!--l. 536--><p class="noindent" >The next two expressions are read. If the first is a system name
which  is  not  the  current  system  then  the  second  expression  is
returned. Otherwise another expression is read and it becomes the
value returned.                                                                                </td>
</tr><tr  
 style="vertical-align:baseline;" id="TBL-10-7-"><td  style="white-space:nowrap; text-align:left;" id="TBL-10-7-1"  
class="td11">   </td></tr></table></div>

<!--l. 543--><p class="noindent" >
<h4 class="subsectionHead"><span class="titlemark">10.4.2    </span> <a 
 id="x48-12200010.4.2"></a>Reading Single Characters</h4>
<!--l. 546--><p class="noindent" ><div class="minipage"><a 
 id="dx48-122001"></a>
<span 
class="ptmb7t-x-x-120">(readchar): character                                                                                                  </span><span 
class="ptmri7t-x-x-120">expr</span>
<br 
class="newline" /><div class="minipage">
</div></div>
<!--l. 557--><p class="noindent" ><div class="minipage"><a 
 id="dx48-122002"></a>
<span 
class="ptmb7t-x-x-120">(channelreadchar CHANNEL:io-channel): character                                             </span><span 
class="ptmri7t-x-x-120">expr</span>
<br 
class="newline" /><div class="minipage">Reads  one  character  (an  integer)  from  CHANNEL.  All  input  is  defined
in terms of this function. If CHANNEL is not open or is open for writing
only, an error is generated. If there is a non-zero value in the backup buffer
associated with CHANNEL, the buffer is emptied (set to zero) and the value
returned.  Otherwise,  the  reading  function  associated  with  CHANNEL  is
called with CHANNEL as argument, and the value it returns is returned by
channelreadchar.</div></div>

<div class="verbatim" id="verbatim-296">
&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x22C6;&#x22C6;&#x22C6;&#x22C6;&#x22C6;&#x00A0;Channel&#x00A0;not&#x00A0;open
</div>
<!--l. 560--><p class="nopar" >

<div class="verbatim" id="verbatim-297">
&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x22C6;&#x22C6;&#x22C6;&#x22C6;&#x22C6;&#x00A0;Channel&#x00A0;open&#x00A0;for&#x00A0;write&#x00A0;only
</div>
<!--l. 563--><p class="nopar" ><div class="minipage"><a 
 id="dx48-122003"></a>
<span 
class="ptmb7t-x-x-120">(readch): id                                                                                                                   </span><span 
class="ptmri7t-x-x-120">expr</span>
<br 
class="newline" /><div class="minipage">
</div>
</div>
<!--l. 570--><p class="noindent" ><div class="minipage"><a 
 id="dx48-122004"></a>
<span 
class="ptmb7t-x-x-120">(channelreadch CHAN:io-channel): id                                                                      </span><span 
class="ptmri7t-x-x-120">expr</span>
<br 
class="newline" /><div class="minipage">Like channelreadchar, but returns the id for the character rather than its
ASCII code.</div></div>
<!--l. 573--><p class="noindent" ><div class="minipage"><a 
 id="dx48-122005"></a>
<span 
class="ptmb7t-x-x-120">(unreadchar CH:character): Undefined                                                                    </span><span 
class="ptmri7t-x-x-120">expr</span>
<br 
class="newline" /><div class="minipage">
</div></div>
<!--l. 584--><p class="noindent" ><div class="minipage"><a 
 id="dx48-122006"></a>
<span 
class="ptmb7t-x-x-120">(channelunreadchar CHAN:io-channel CH:character): Undefined                       </span><span 
class="ptmri7t-x-x-120">expr</span>
<br 
class="newline" /><div class="minipage">The input backup function. Ch is deposited in the backup buffer associated
with  Chan.  This  function  should  be  only  called  after  channelreadchar  is
called, and before any intervening input operations, since it is used by the
token scanner. The unread buffer only holds one character, so it is generally
useless to unread more than one character.</div></div>
<!--l. 586--><p class="noindent" >
<h4 class="subsectionHead"><span class="titlemark">10.4.3    </span> <a 
 id="x48-12300010.4.3"></a>Reading Tokens</h4>
<!--l. 588--><p class="noindent" >The functions described here pertain to the token scanner and reader. Globals and switches used
by these functions are defined at the end of this section.

<!--l. 602--><p class="noindent" ><div class="minipage"><a 
 id="dx48-123001"></a>
<span 
class="ptmb7t-x-x-120">(channelreadtoken CHANNEL:io-channel): </span><span 
class="cmsy-10x-x-120">{</span><span 
class="ptmb7t-x-x-120">id, number, string</span><span 
class="cmsy-10x-x-120">}        </span><span 
class="ptmri7t-x-x-120">expr</span>
<br 
class="newline" /><div class="minipage">This  is  the  basic  PSL  token  scanner.  The  value  returned  is  an  item
corresponding to the next token from the input stream. An id will be interned
unless the switch <span 
class="ptmb7t-x-x-120">*compressing</span><a 
 id="dx48-123002"></a> is non-nil. If *compressing is t then the
print name of the id is passed to newid, otherwise it is passed to intern.</div>
</div>
<!--l. 604--><p class="noindent" >The global variable toktype* <a 
 id="dx48-123003"></a>is set as follows.
<div class="tabular"><table id="TBL-11" class="tabular" 
cellspacing="0" cellpadding="0"  
><colgroup id="TBL-11-1g"><col 
id="TBL-11-1"><col 
id="TBL-11-2"></colgroup><tr  
 style="vertical-align:baseline;" id="TBL-11-1-"><td  style="white-space:nowrap; text-align:left;" id="TBL-11-1-1"  
class="td11">0</td><td  style="white-space:nowrap; text-align:left;" id="TBL-11-1-2"  
class="td11">if the token is an ordinary id,                          </td>
</tr><tr  
 style="vertical-align:baseline;" id="TBL-11-2-"><td  style="white-space:nowrap; text-align:left;" id="TBL-11-2-1"  
class="td11">1 </td><td  style="white-space:nowrap; text-align:left;" id="TBL-11-2-2"  
class="td11">if the token is a string,                                     </td>
</tr><tr  
 style="vertical-align:baseline;" id="TBL-11-3-"><td  style="white-space:nowrap; text-align:left;" id="TBL-11-3-1"  
class="td11">2 </td><td  style="white-space:nowrap; text-align:left;" id="TBL-11-3-2"  
class="td11">if the token is a number, or                             </td>
</tr><tr  
 style="vertical-align:baseline;" id="TBL-11-4-"><td  style="white-space:nowrap; text-align:left;" id="TBL-11-4-1"  
class="td11">3 </td><td  style="white-space:nowrap; text-align:left;" id="TBL-11-4-2"  
class="td11">if the token is an unescaped delimiter such as</td>
</tr><tr  
 style="vertical-align:baseline;" id="TBL-11-5-"><td  style="white-space:nowrap; text-align:left;" id="TBL-11-5-1"  
class="td11"> </td><td  style="white-space:nowrap; text-align:left;" id="TBL-11-5-2"  
class="td11">&#8221;(&#8221;, but not &#8221;!(&#8221; In this last case, the value     </td>
</tr><tr  
 style="vertical-align:baseline;" id="TBL-11-6-"><td  style="white-space:nowrap; text-align:left;" id="TBL-11-6-1"  
class="td11"> </td><td  style="white-space:nowrap; text-align:left;" id="TBL-11-6-2"  
class="td11">returned is the id whose print name is the      </td>
</tr><tr  
 style="vertical-align:baseline;" id="TBL-11-7-"><td  style="white-space:nowrap; text-align:left;" id="TBL-11-7-1"  
class="td11"> </td><td  style="white-space:nowrap; text-align:left;" id="TBL-11-7-2"  
class="td11">same as the delimiter.                                      </td>
</tr><tr  
 style="vertical-align:baseline;" id="TBL-11-8-"><td  style="white-space:nowrap; text-align:left;" id="TBL-11-8-1"  
class="td11"> </td></tr></table></div>
<!--l. 620--><p class="noindent" >The precise behavior of this function depends on two fluid variables:
<!--l. 623--><p class="noindent" >Currentscantable* is bound to a vector known as a scan table. Described below.
<!--l. 626--><p class="noindent" >Currentreadmacroindicator* is bound to an id known as a read macro indicator. Described
below.
<!--l. 630--><p class="noindent" ><div class="minipage"><a 
 id="dx48-123004"></a>
<span 
class="ptmb7t-x-x-120">(ratom): </span><span 
class="cmsy-10x-x-120">{</span><span 
class="ptmb7t-x-x-120">id, number, string</span><span 
class="cmsy-10x-x-120">}                            </span><span 
class="ptmri7t-x-x-120">expr</span>
<br 
class="newline" /><div class="minipage">Reads a token from the current input channel.
</div></div>
<!--l. 640--><p class="noindent" ><div class="minipage"><a 
 id="dx48-123005"></a>
<span 
class="ptmb7t-x-x-120">(channelreadtokenwithhooks CHANNEL:io-channel):</span><br 
class="newline" /><span 
class="ptmb7t-x-x-120">any                                                                                                                                 </span><span 
class="ptmri7t-x-x-120">expr</span>
<br 
class="newline" /><div class="minipage">This  function  reads  a  token  and  performs  any  action  specified  if  the
token  is  marked  as  a  read  macro  under  the  current  indicator.  Read
uses this function internally. Uses the variable currentreadmacroindicator*
<a 
 id="dx48-123006"></a>urrentreadmacroindicator* to determine the current indicator.</div></div>
<!--l. 642--><p class="noindent" >
<h4 class="subsectionHead"><span class="titlemark">10.4.4    </span> <a 
 id="x48-12400010.4.4"></a>Reading Entire Lines</h4>
<!--l. 645--><p class="noindent" ><div class="minipage"><a 
 id="dx48-124001"></a>
<span 
class="ptmb7t-x-x-120">(readline): string                                                                                                          </span><span 
class="ptmri7t-x-x-120">expr</span>
<br 
class="newline" /><div class="minipage">Same as (channelreadline in*)
</div>

</div><div class="minipage"><a 
 id="dx48-124002"></a>
<span 
class="ptmb7t-x-x-120">(channelreadline CHANNEL:io-channel): string                                                     </span><span 
class="ptmri7t-x-x-120">expr</span>
<br 
class="newline" /><div class="minipage">A string is returned which contains each character from the current position
of the scanner to the next end-of-line or end-of-file character.</div>
</div>
<!--l. 652--><p class="noindent" >
<h4 class="subsectionHead"><span class="titlemark">10.4.5    </span> <a 
 id="x48-12500010.4.5"></a>Read Macros</h4>
<!--l. 654--><p class="noindent" >At the top level of PSL, an expression is read, it is evaluated, and then the result is printed.
Normally a macro is expanded during evaluation. The read macro is a different type of macro,
it is expanded during the reading phase. When the reader encounters a read macro
character, the the macro is executed and the result is inserted in place of the read macro
character.
<!--l. 662--><p class="noindent" >A read macro must be a function of two arguments, the first should represent a IO channel, the
second a character. A character which represents a read macro must be set to one of two types in
the scan table. It may be either a delimiter or a diphthong. Diphthong corresponds to double
character read macros, delimiter to single character read macros. In addition, the id which
corresponds to the character must have a reference to the name of the function on its property
list. For a diphthong the indicator must be lispdiphthong, for a delimiter it must be
lispreadmacro.
<!--l. 673--><p class="noindent" >The quote macro may be defined as follows. Note that we cannot use &#8217;form in place of (quote
form) until we have defined the read macro.

<div class="verbatim" id="verbatim-298">
(de&#x00A0;doquote&#x00A0;(channel&#x00A0;ch)
&#x00A0;<br />&#x00A0;&#x00A0;(list&#x00A0;(quote&#x00A0;quote)&#x00A0;(channelread&#x00A0;channel)))
</div>
<!--l. 680--><p class="nopar" >

<div class="verbatim" id="verbatim-299">
(put&#x00A0;(quote&#x00A0;!')&#x00A0;(quote&#x00A0;lispreadmacro)(function&#x00A0;doquote))
</div>
<!--l. 683--><p class="nopar" >

<div class="verbatim" id="verbatim-300">
(putv&#x00A0;lispscantable&#x22C6;&#x00A0;(char&#x00A0;!')&#x00A0;delimiter)
</div>
<!--l. 686--><p class="nopar" >This says that when a single quote is read, PSL should replace it with a list consisting of quote
and the next expression in the input (obtained by an explicit call to channelread). Since defining
a character as a read macro makes it difficult to use the character in a normal way, read macros
should not be letters or digits.
<!--l. 694--><p class="noindent" >
<h4 class="subsectionHead"><span class="titlemark">10.4.6    </span> <a 
 id="x48-12600010.4.6"></a>Terminal Interaction</h4>
<!--l. 702--><p class="noindent" ><div class="minipage"><a 
 id="dx48-126001"></a>
<span 
class="ptmb7t-x-x-120">(yesp MESSAGE:string): boolean                                                                              </span><span 
class="ptmri7t-x-x-120">expr</span>
<br 
class="newline" /><div class="minipage">If the user responds y or yes, yesp returns a non-nil value. A response of n or
no results in a value of nil. It is possible to enter a break loop by responding
with b. After quitting the break loop, one must still respond y, yes, n, or no.</div>
</div>
<!--l. 704--><p class="noindent" >
<h4 class="subsectionHead"><span class="titlemark">10.4.7    </span> <a 
 id="x48-12700010.4.7"></a>Input Status and Mode</h4>
<!--l. 711--><p class="noindent" ><div class="minipage"><a 
 id="dx48-127001"></a>
<span 
class="ptmb7t-x-x-120">promptstring* </span>=  [Initially: &#8221;x lisp<span 
class="cmmi-12">&#x003E;</span>&#8221;]                                                                     <span 
class="ptmri7t-x-x-120">global</span>
<br 
class="newline" />&#x00A0;       &#x00A0;<div class="minipage">Displayed as a prompt when any input is taken from TTY. Prompts should
therefore  not  be  directly  printed.  Instead  the  value  should  be  bound  to
promptstring*.</div>
</div>
<!--l. 719--><p class="noindent" ><div class="minipage"><a 
 id="dx48-127002"></a>
<span 
class="ptmb7t-x-x-120">*eolinstringok </span>= [Initially: nil]                                                                                  <span 
class="ptmri7t-x-x-120">switch</span>
<br 
class="newline" />&#x00A0;       &#x00A0;<div class="minipage">If *eolinstringok is non-nil, the warning message
<!--l. 719--><p class="noindent" ><span 
class="pcrr7t-x-x-120">&#x22C6;&#x22C6;&#x22C6; String continued over end-of-line </span><br 
class="newline" />is suppressed.</div>
</div>
<!--l. 727--><p class="noindent" ><div class="minipage"><a 
 id="dx48-127003"></a>
<span 
class="ptmb7t-x-x-120">*raise </span>=  [Initially: t]                                                                                                  <span 
class="ptmri7t-x-x-120">switch</span>
<br 
class="newline" />&#x00A0;       &#x00A0;<div class="minipage">If *raise is non-nil, all characters input for ids through PSL input functions
are raised to upper case. If *raise is nil, characters are input as is. A string
is unaffected by *raise.</div>

</div>
<!--l. 733--><p class="noindent" ><div class="minipage"><a 
 id="dx48-127004"></a>
<span 
class="ptmb7t-x-x-120">*compressing </span>= [Initially: nil]                                                                                   <span 
class="ptmri7t-x-x-120">switch</span>
<br 
class="newline" />&#x00A0;       &#x00A0;<div class="minipage">If *compressing is non-nil, channelreadtoken and other functions that call it
do not intern ids.</div></div>
<!--l. 736--><p class="noindent" ><div class="minipage"><a 
 id="dx48-127005"></a>
<span 
class="ptmb7t-x-x-120">currentscantable* </span>= [Initially: NIL]                                                                         <span 
class="ptmri7t-x-x-120">global</span>
<br 
class="newline" />&#x00A0;       &#x00A0;<div class="minipage">This variable is set to lispscantable* by the function read
</div></div>
<!--l. 746--><p class="noindent" ><div class="minipage"><a 
 id="dx48-127006"></a>
<span 
class="ptmb7t-x-x-120">currentreadmacroindicator* </span>=  [Initially: NIL ]                                                     <span 
class="ptmri7t-x-x-120">global</span>
<br 
class="newline" />&#x00A0;       &#x00A0;<div class="minipage">The  function  read  binds  this  variable  to  the  value  LISPREADMACRO.
Its  value  determines  the  property  list  indicator  used  in  looking  up  read
macros. The user may define a set of read macros using some new indicator
and rebind this variable. Ordinary read macros may be added by putting
properties on ids under the LISPREADMACRO indicator.</div>
</div>

<!--l. 748--><p class="noindent" ><table cellspacing="5"><tr><td class="clinks"><a 
href="allman1li9.html#allman1se36.html" >Up</a></td><td class="clinks"><a 
href="allman1se37.html" >Next</a></td><td class="clinks"><a 
href="allman1se35.html" >Prev</a></td><td class="clinks"><a 
href="allman1se35.html#tailallman1se35.html" >PrevTail</a></td><td class="clinks"><a 
href="allman1se36.html" >Front</a></td></tr></table><a 
 id="tailallman1se36.html"></a>   
</body></html> 
