<!DOCTYPE html> 
<html lang="en-US" xml:lang="en-US" > 
<head><title>CANTENS: A Package for Manipulations and Simpliﬁcations of Indexed Objects</title> 
<meta  charset="utf-8" /> 
<meta name="generator" content="TeX4ht (https://tug.org/tex4ht/)" /> 
<meta name="viewport" content="width=device-width,initial-scale=1" /> 
<link rel="stylesheet" type="text/css" href="manual.css" /> 
<meta name="src" content="manual.tex" /> 
<script>window.MathJax = { tex: { tags: "ams", }, }; </script> 
 <script type="text/javascript" async="async" id="MathJax-script" src="../../cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js"></script>  
<meta name="description" content="The REDUCE Computer Algebra System User's Manual" /> 
</head><body 
>
<header>REDUCE</header><table cellspacing="5"><tr><td class="clinks"><a 
href="../manual-lookup.php%3FUser&#32;Contributed&#32;Packages.html#manualse132.html" >Up</a></td><td class="clinks"><a 
href="manualse133.html" >Next</a></td><td class="clinks"><a 
href="manualse131.html" >Prev</a></td><td class="clinks"><a 
href="manualse131.html#tailmanualse131.html" >PrevTail</a></td><td class="clinks"><a 
href="manualse132.html#tailmanualse132.html">Tail</a></td></tr></table><h3 class="sectionHead"><span class="titlemark">20.9    </span> <a 
 id="x188-42100020.9"></a>CANTENS: A Package for Manipulations and
Simpliﬁcations of Indexed Objects</h3>
<a 
 id="dx188-421001"></a>
<a 
 id="dx188-421002"></a>
<!--l. 215--><p class="noindent" >This package creates an environment which allows the user to manipulate and simplify
expressions containing various indexed objects like tensors, spinors, ﬁelds and quantum
ﬁelds.
</p><!--l. 219--><p class="noindent" >Author: Hubert Caprasse.
<a 
 id="dx188-421003"></a>
<a 
 id="dx188-421004"></a>
</p><!--l. 5--><p class="noindent" >
</p>
<h4 class="subsectionHead"><span class="titlemark">20.9.1    </span> <a 
 id="x188-42200020.9.1"></a>Introduction</h4>
<!--l. 6--><p class="noindent" ><span 
class="ptmrc8t-x-x-109">C<span 
class="small-caps">A</span><span 
class="small-caps">N</span><span 
class="small-caps">T</span><span 
class="small-caps">E</span><span 
class="small-caps">N</span><span 
class="small-caps">S</span> </span>is a package that creates an environment inside REDUCE which allows
the user to manipulate and simplify expressions containing various indexed
objects like tensors, spinors, ﬁelds and quantum ﬁelds. Brieﬂy said, it allows him
</p>
     <ul class="itemize1">
     <li class="itemize">
     <!--l. 13--><p class="noindent" >to deﬁne generic indexed quantities which can eventually depend implicitly
     or explicitly on any number of variables;
     </p></li>
     <li class="itemize">
     <!--l. 15--><p class="noindent" >to deﬁne one or several aﬃne or metric (sub-)spaces, and to work within
     them without diﬃculty;
     </p></li>
     <li class="itemize">
     <!--l. 17--><p class="noindent" >to handle dummy indices and simplify adequatly expressions which contain
     them.</p></li></ul>
                                                                     

                                                                     
<!--l. 20--><p class="noindent" >Beside the above features, it oﬀers the user:
     </p><ol  class="enumerate1" >
<li 
  class="enumerate" id="x188-422002x1">
     <!--l. 22--><p class="noindent" >Several   invariant   elementary   tensors   which   are   always   used   in   the
     applications involving the use of indexed objects like <span 
class="pcrr8t-x-x-109">delta</span>, <span 
class="pcrr8t-x-x-109">epsilon</span>,
     <span 
class="pcrr8t-x-x-109">eta</span>, and the generalized delta function.
     </p></li>
<li 
  class="enumerate" id="x188-422004x2">
     <!--l. 26--><p class="noindent" >The possibility to deﬁne any metric and to make it bloc-diagonal if he wishes
     to.
     </p></li>
<li 
  class="enumerate" id="x188-422006x3">
     <!--l. 28--><p class="noindent" >The capability to symmetrize or antisymmetrize any expression.
     </p></li>
<li 
  class="enumerate" id="x188-422008x4">
     <!--l. 29--><p class="noindent" >The possibility to introduce any kind of symmetry (even partial symmetries)
     for the indexed objects.
     </p></li>
<li 
  class="enumerate" id="x188-422010x5">
     <!--l. 31--><p class="noindent" >The choice to work with commutative, non-commutative or anticommutative
     indexed objects.</p></li></ol>
<!--l. 34--><p class="noindent" >In this package, one cannot ﬁnd algorithms or even speciﬁc objects (i.e. like the covariant
derivative or the SU(3) group structure constants) which are of used either in
nuclear and particle physics. The objective of the package is simply to allow
the user to easily formulate <span 
class="ptmri8t-x-x-109">his algorithms </span>in the <span 
class="ptmri8t-x-x-109">notations he likes most</span>. The
package is also conceived so as to minimize the number of new commands.
However, the large number of new capabilities inherently implies that quite
a substantial number of new functions and commands must be used. On the
other hand, in order to avoid too many error or warning messages the package
assumes, in many cases, that the user is reponsible of the consistency of its
inputs. The author is aware that the package is still perfectible and he will be
grateful to all people who shall spare some time to communicate bugs or suggest
improvements.
                                                                     

                                                                     
</p><!--l. 52--><p class="noindent" >The documentation below is separated into four sections. In the ﬁrst one, the space(s)
properties and deﬁnitions are described.
</p><!--l. 55--><p class="noindent" >In the second one, the commands to geberate and handle generic indexed quantities
(called abusively tensors) are illustrated. The manipulation and control of free and
dummy indices is discussed.
</p><!--l. 59--><p class="noindent" >In the third one, the special tensors are introduced and their properties discussed
especially with respect to their ability to work simultaneously within several
subspaces.
</p><!--l. 63--><p class="noindent" >The last section, which is also the most important, is devoted entirely to the
simpliﬁcation function <a 
 id="dx188-422011"></a><span 
class="pcrr8t-x-x-109">canonical</span>. This function originates from the package <span 
class="ptmrc8t-x-x-109">D<span 
class="small-caps">U</span><span 
class="small-caps">M</span><span 
class="small-caps">M</span><span 
class="small-caps">Y</span></span><a 
 id="dx188-422012"></a>
and has been substantially extended . It takes account of all symmetries, make dummy
summations and seeks a “canonical” form for any tensorial expression. Without it, the
present package would be much less useful.
</p><!--l. 82--><p class="noindent" >When <span 
class="ptmrc8t-x-x-109">C<span 
class="small-caps">A</span><span 
class="small-caps">N</span><span 
class="small-caps">T</span><span 
class="small-caps">E</span><span 
class="small-caps">N</span><span 
class="small-caps">S</span></span><a 
 id="dx188-422013"></a> is loaded, the packages <span 
class="ptmrc8t-x-x-109">A<span 
class="small-caps">S</span><span 
class="small-caps">S</span><span 
class="small-caps">I</span><span 
class="small-caps">S</span><span 
class="small-caps">T</span></span><a 
 id="dx188-422014"></a> and <span 
class="ptmrc8t-x-x-109">D<span 
class="small-caps">U</span><span 
class="small-caps">M</span><span 
class="small-caps">M</span><span 
class="small-caps">Y</span></span><a 
 id="dx188-422015"></a> are also loaded.
</p><!--l. 87--><p class="noindent" >
</p>
<h4 class="subsectionHead"><span class="titlemark">20.9.2    </span> <a 
 id="x188-42300020.9.2"></a>Handling of space(s)</h4>
<a 
 id="dx188-423001"></a>
<!--l. 89--><p class="noindent" ><a 
 id="switch:ONESPACE"></a> One can work either in a <span 
class="ptmri8t-x-x-109">single </span>space environment or in a multiple space environment.
After the package is loaded, the single space environment is set and a unique space is
deﬁned. It is euclidian, and has a symbolic dimension equal to <span 
class="pcrr8t-x-x-109">dim</span>. The single space
environment is determined by the switch <span 
class="pcrr8t-x-x-109">onespace</span><a 
 id="dx188-423002"></a><a 
 id="dx188-423003"></a><a 
 id="dx188-423004"></a> which is turned on. One can verify
the above assertions as follows <span 
class="pcrr8t-x-x-109">wholespace_dim</span>:
                                                                     

                                                                     
</p>
<pre class="verbatim" id="verbatim-705">
      onespace ?; =&#x003E; yes

      wholespace_dim ?; =&#x003E; dim

      signature ?; =&#x003E; 0
</pre>
<!--l. 104--><p class="nopar" > One can introduce a pseudoeuclidian metric for the above space by the command
<span 
class="pcrr8t-x-x-109">signature</span><a 
 id="dx188-423005"></a> and verify that the signature is indeed \(1\): <a 
 id="command:SIGNATURE"></a>
                                                                     

                                                                     
</p>
<pre class="verbatim" id="verbatim-706">
      signature 1;

      signature ?; =&#x003E; 1
</pre>
<!--l. 113--><p class="nopar" > In principle the signature may be set to any positive integer. However, presently, the
package cannot handle signatures larger than 1. One gets the Minkowski-like space
metric<a 
 id="dx188-423006"></a> \[ \left (\begin {array}{cccc} 1 &amp; 0 &amp; 0 &amp; 0 \\ 0 &amp; -1 &amp; 0 &amp; 0 \\ 0 &amp; 0 &amp; -1 &amp; 0 \\ 0 &amp; 0 &amp; 0 &amp; -1 \end {array} \right ) \] which corresponds to the convention of high energy physicists. <a 
 id="command:GLOBAL_SIGN"></a> It is
possible to change it into the astrophysicists convention using the command
<span 
class="pcrr8t-x-x-109">global_sign</span><a 
 id="dx188-423007"></a>:
                                                                     

                                                                     
</p>
<pre class="verbatim" id="verbatim-707">
      global_sign ?; =&#x003E; 1

      global_sign (-1);

      global_sign ?; =&#x003E; -1
</pre>
<!--l. 137--><p class="nopar" > This means that the actual metric is now \((-1,1,1,1)\). The space dimension may, of course, be
assigned at will using the function <span 
class="pcrr8t-x-x-109">wholespace_dim</span><a 
 id="dx188-423008"></a>. <a 
 id="operator:WHOLESPACE_DIM"></a> Below, it is assigned to
4:
                                                                     

                                                                     
</p>
<pre class="verbatim" id="verbatim-708">
      wholespace_dim 4; ==&#x003E; 4
</pre>
<!--l. 145--><p class="nopar" > When the switch <span 
class="pcrr8t-x-x-109">onespace </span>is turned oﬀ, the system <span 
class="ptmri8t-x-x-109">assumes </span>that this default space is
non-existent and, therefore, that the user is going to deﬁne the space(s) in which he wants
to work. Unexpected error messages will occur if it is not done. Once the switch is turned
oﬀ many more functions become active. A few of them are available in the algebraic
mode to allow the user to properly conctruct and control the properties of the various
(sub-)spaces he is going to deﬁne and, also, to assign symbolic indices to some of
them.
</p><!--l. 155--><p class="noindent" ><a 
 id="command:DEFINE_SPACES"></a> <a 
 id="reserved:WHOLESPACE"></a> <a 
 id="reserved:SIGNATURE"></a> <a 
 id="reserved:INDEXRANGE"></a> <a 
 id="dx188-423009"></a><span 
class="pcrr8t-x-x-109">define_spaces </span>is the space constructor and <a 
 id="dx188-423010"></a><span 
class="pcrr8t-x-x-109">wholespace </span>is a reserved identiﬁer
which is meant to be the name of the global space if subspaces are introduced. Suppose
we want to deﬁne a unique space, we can choose for its any name but choosing
<span 
class="pcrr8t-x-x-109">wholespace </span>will be more eﬃcient. On the other hand, it leaves open the possibility to
introduce subspaces in a more transparent way. So one writes, for instance,:
<a 
 id="dx188-423011"></a><a 
 id="dx188-423012"></a>
                                                                     

                                                                     
</p>
<pre class="verbatim" id="verbatim-709">
      define_spaces wholespace=

             {6,signature=1,indexrange=0 .. 5}; ==&#x003E;t
</pre>
<!--l. 172--><p class="nopar" > The arguments inside the list, assign respectively the dimension, the signature and the
range of the numeric indices which is allowed. Notice that the range starts from 0 and not
from 1. This is made to conform with the usual convention for spaces of signature equal
to 1. However, this is not compulsory. Notice that the declaration of the indexrange may
be omitted if this is the only deﬁned space. <a 
 id="reserved:EUCLIDIAN"></a> <a 
 id="reserved:AFFINE"></a> There are two other options which may
replace the signature option, namely <a 
 id="dx188-423013"></a><span 
class="pcrr8t-x-x-109">euclidian </span>and <a 
 id="dx188-423014"></a><span 
class="pcrr8t-x-x-109">affine</span>. They have both an
obvious signiﬁcance.
</p><!--l. 186--><p class="noindent" >In the subsequent example, an eleven dimension global space is deﬁned and two
subspaces of this space are speciﬁed. Notice that no indexrange has been declared
for the entire space. However, the indexrange declaration is compulsory for
subspaces otherwise the package will improperly work when dealing with numeric
indices.
                                                                     

                                                                     
</p>
<pre class="verbatim" id="verbatim-710">
      define_spaces wholespace={11,signature=1}; ==&#x003E; t

      define_spaces mink=

               {4,signature=1,indexrange=0 .. 3}; ==&#x003E; t

      define_spaces eucl=

               {6,euclidian,indexrange=4 .. 9}; ==&#x003E; t
</pre>
<!--l. 201--><p class="nopar" > <a 
 id="operator:SHOW_SPACES"></a>To remind ones the space context in which one is working, the use of the function
<a 
 id="dx188-423015"></a><span 
class="pcrr8t-x-x-109">show_spaces </span>is required. Its output is an <span 
class="ptmri8t-x-x-109">algebraic value </span>from which the user can
retrieve all the informations displayed. After the declarations above, this function
gives:
                                                                     

                                                                     
</p>
<pre class="verbatim" id="verbatim-711">
      show_spaces(); ==&#x003E;

               {{wholespace,11,signature=1}

                {mink,4,signature=1,indexrange=0..3},

                {eucl,6,euclidian,indexrange=4..9}}
</pre>
<!--l. 215--><p class="nopar" > If an input error is made or if one wants to change the space framework, one cannot
directly redeﬁne the relevant space(s). For instance, the input
                                                                     

                                                                     
</p>
<pre class="verbatim" id="verbatim-712">
      define_spaces eucl=

                {7,euclidian,indexrange=4 .. 9}; ==&#x003E;

          *** Warning: eucl cannot be (or is already)
                       defined as space identifier
             t
</pre>
<!--l. 226--><p class="nopar" > which aims to ﬁll all dimensions present in <span 
class="pcrr8t-x-x-109">wholespace </span>tells that the space <span 
class="pcrr8t-x-x-109">eucl</span>
cannot be redeﬁned. To redeﬁne it eﬀectively, one is to <span 
class="ptmri8t-x-x-109">remove </span>the existing deﬁnition ﬁrst
using the function <a 
 id="dx188-423016"></a><a 
 id="command:REM_SPACES"></a><span 
class="pcrr8t-x-x-109">rem_spaces </span>which takes any number of space-names as its
argument. Here is the illustration:
                                                                     

                                                                     
</p>
<pre class="verbatim" id="verbatim-713">
      rem_spaces eucl; ==&#x003E; t

      show_spaces(); ==&#x003E;

                 {{wholespace,11,signature=1},

                   {mink,4,signature=1,indexrange=0..3}}

      define_spaces eucl=

                 {7,euclidian,indexrange=4 .. 10}; ==&#x003E; t

      show_spaces(); ==&#x003E;

                  {{wholespace,11,signature=1},

                    {mink,4,signature=1,indexrange=0..3},

                    {eucl,7,euclidian,indexrange=4..10}}
</pre>
<!--l. 253--><p class="nopar" > Here, the user is entirely responsible of the coherence of his construction. The
system does <span 
class="ptmri8t-x-x-109">NOT </span>verify it but will incorrectly run if there is a mistake at this
level.
</p><!--l. 258--><p class="noindent" >When two spaces are direct product of each other (as the color and Minkowski spaces in
quantum chromodynamics), it is not necessary to introduce the global space
<span 
class="pcrr8t-x-x-109">wholespace</span><a 
 id="dx188-423017"></a>.
</p><!--l. 262--><p class="noindent" >“Tensors” and symbolic indices can be declared to belong to a speciﬁc space or subspace.
It is in fact an essential ingredient of the package and make it able to handle
expressions which involve quantities belonging to several (sub-)spaces or to handle
bloc-diagonal “tensors”. This will be discussed in the next section. Here, we just
mention how to declare that some set of symbolic indices belong to a speciﬁc
(sub-)space<a 
 id="dx188-423018"></a> or how to declare them to belong to any space<a 
 id="dx188-423019"></a>. The relevant command is
<a 
 id="dx188-423020"></a><span 
class="pcrr8t-x-x-109">mk_ids_belong_space </span>whose syntax is
  </p><div class="syntax">
   <span 
class="pcrr8t-x-x-109">mk_ids_belong_space</span>(\(\langle \)<span 
class="ptmri8t-x-x-109">list of indices</span>\(\rangle \),\(\langle \)<span 
class="ptmri8t-x-x-109">space</span>\(\rangle \) \(\ \mid \ \) \(\langle \)<span 
class="ptmri8t-x-x-109">subspace identiﬁer</span>\(\rangle \))</div>
                                                                     

                                                                     
<!--l. 276--><p class="noindent" >For example, within the above declared spaces one could write:
                                                                     

                                                                     
</p>
<pre class="verbatim" id="verbatim-714">
      mk_ids_belong_space({a0,a1,a2,a3},mink); ==&#x003E; t

      mk_ids_belong_space({x,y,z,u,v},eucl); ==&#x003E; t
</pre>
<!--l. 281--><p class="nopar" > The command <a 
 id="dx188-423021"></a> <a 
 id="command:MK_IDS_BELONG_ANYSPACE"></a><span 
class="pcrr8t-x-x-109">mk_ids_belong_anyspace </span>allows to remake them usable either in
<span 
class="pcrr8t-x-x-109">wholespace</span><a 
 id="dx188-423022"></a> if it is deﬁned or in anyone among the deﬁned spaces. For instance, the
declaration:
                                                                     

                                                                     
</p>
<pre class="verbatim" id="verbatim-715">
 mk_ids_belong_anyspace a1,a2; ==&#x003E; t
</pre>
<!--l. 289--><p class="nopar" > tells that a1 and a2 belong either to <span 
class="pcrr8t-x-x-109">mink </span>or to <span 
class="pcrr8t-x-x-109">eucl </span>or to <span 
class="pcrr8t-x-x-109">wholespace</span>.
</p><!--l. 293--><p class="noindent" >
</p>
<h4 class="subsectionHead"><span class="titlemark">20.9.3    </span> <a 
 id="x188-42400020.9.3"></a>Generic tensors and their manipulation</h4>
<a 
 id="dx188-424001"></a>
<!--l. 296--><p class="noindent" >
</p>
<h5 class="subsubsectionHead"><a 
 id="x188-42500020.9.3"></a>Deﬁnition</h5>
<!--l. 297--><p class="noindent" >The generic tensors handled by <span 
class="ptmrc8t-x-x-109">C<span 
class="small-caps">A</span><span 
class="small-caps">N</span><span 
class="small-caps">T</span><span 
class="small-caps">E</span><span 
class="small-caps">N</span><span 
class="small-caps">S</span> </span>are objects much more general than
usual tensors. The reason is that they are not supposed to obey well deﬁned
transformation properties under a change of coordinates. They are only indexed
quantities. The indices are either contravariantly (upper indices) or covariantly (lower
indices) placed. They can be symbolic or numeric. When a given index is found
both in one upper and in one lower place, it is supposed to be summed over all
space-coordinates it belongs to viz. it is a <span 
class="ptmri8t-x-x-109">dummy</span><a 
 id="dx188-425001"></a> index and <span 
class="ptmri8t-x-x-109">automatically recognized </span>as
such. So they are supposed to obey the summation rules of tensor calculus. This
why and only why they are called tensors. Moreover, aside from indices they
may also depend implicitly or explicitly on any number of <span 
class="ptmri8t-x-x-109">variables</span><a 
 id="dx188-425002"></a>. Within
this deﬁnition, tensors may also be spinors, they can be non-commutative or
anticommutative, they may also be algebra generators and represent ﬁelds or quantum
ﬁelds.
</p><!--l. 314--><p class="noindent" >
</p>
<h5 class="subsubsectionHead"><a 
 id="x188-42600020.9.3"></a>Implications of <span 
class="pcrr8t-x-x-109">TENSOR </span>declaration</h5>
<a 
 id="dx188-426001"></a>
                                                                     

                                                                     
<!--l. 316--><p class="noindent" ><a 
 id="command:TENSOR"></a>
</p><!--l. 318--><p class="noindent" >The procedure <span 
class="pcrr8t-x-x-109">tensor </span>which takes an arbitrary number of identiﬁers as argument
deﬁnes them as operator-like objects which admit an arbitrary number of indices. Each
component has a formal character and may or may not belong to a speciﬁc (sub-)space.
Numeric indices are also allowed. The way to distinguish upper and lower indices is the
same as the one in the package <a 
 id="dx188-426002"></a><span 
class="ptmrc8t-x-x-109">E<span 
class="small-caps">X</span><span 
class="small-caps">C</span><span 
class="small-caps">A</span><span 
class="small-caps">L</span><span 
class="small-caps">C</span> </span>e.g. \(-a\) is a lower index and \(a\) is an upper index. A
special printing function has been created so as to mimic as much as possible
the way of writing such objects on a sheet of paper. Let us illustrate the use of
<span 
class="pcrr8t-x-x-109">tensor</span>:
                                                                     

                                                                     
</p>
<pre class="verbatim" id="verbatim-716">
   tensor te; ==&#x003E; t

   te(3,a,-4,b,-c,7); ==&#x003E;
                            3 a   b   7
                        te
                                4   c



  te(3,a,{x,y},-4,b,-c,7); ==&#x003E;

             3 a   b   7
          te            (x,y)
                 4   c



   te(3,a,-4,b,{u,v},-c,7); ==&#x003E;

             3 a   b   7
          te            (u,v)
                 4   c


   te({x,y}); ==&#x003E;  te(x,y)
</pre>
<!--l. 354--><p class="nopar" > Notice that the system distinguishes indices from variables on input solely on the basis
that the user puts variables <span 
class="ptmri8t-x-x-109">inside a list</span>.
</p><!--l. 358--><p class="noindent" >The dependence can also be declared implicit through the REDUCE command
<a 
 id="dx188-426003"></a> <a 
 id="dx188-426004"></a><span 
class="pcrr8t-x-x-109">depend </span>which is generalized so as to allow to declare a tensor to depend on another
tensor irrespective of its components. It means that only <span 
class="ptmri8t-x-x-109">one </span>declaration is enough to
express the dependence with respect to <span 
class="ptmri8t-x-x-109">all its components</span>. A simple example:
<a 
 id="dx188-426005"></a>
                                                                     

                                                                     
</p>
<pre class="verbatim" id="verbatim-717">
      tensor te,x;

      depend te,x;

      df(te(a,-b),x(c)); ==&#x003E;

                  a    c
             df(te   ,x )
                    b
</pre>
<!--l. 377--><p class="nopar" > Therefore, when <span 
class="ptmri8t-x-x-109">all </span>objects are tensors, the dependence declaration is valid for all
indices.
</p><!--l. 381--><p class="noindent" >One can also avoid the trouble to place the explicit variables inside a list if one declare
them as variables through the command <a 
 id="command:MAKE_VARIABLES"></a> <a 
 id="command:REMOVE_VARIABLES"></a> <span 
class="pcrr8t-x-x-109">make_variables</span><a 
 id="dx188-426006"></a>. This property can also be
removed<span class="footnote-mark"><a 
href="manual189.html#fn17x20"><sup class="textsuperscript">17</sup></a></span><a 
 id="x188-426007f17"></a> 
using <a 
 id="dx188-426008"></a><span 
class="pcrr8t-x-x-109">remove_variables</span>:
                                                                     

                                                                     
</p>
<pre class="verbatim" id="verbatim-718">
      make_variables x,y; ==&#x003E; t

      te(x,y); ==&#x003E; te(x,y)


      te(x,y,a); ==&#x003E;

                a
             te  (x,y)


      remove_variables x; ==&#x003E; t


      te(x,y,a); ==&#x003E;

                x a
             te    (y)
</pre>
<!--l. 411--><p class="nopar" > If one does that one must be careful not to substitute a number to such declared variables
because this number would be considered as an index and no longer as a variable. So it is
only useful for <span 
class="ptmri8t-x-x-109">formal </span>variables<a 
 id="dx188-426009"></a>.
</p><!--l. 417--><p class="noindent" ><a 
 id="command:REM_TENSOR"></a> A tensor can be easily eliminated using the function <a 
 id="dx188-426010"></a><span 
class="pcrr8t-x-x-109">rem_tensor</span>. It has the
syntax
                                                                     

                                                                     
</p>
<pre class="verbatim" id="verbatim-719">
      rem_tensor t1,t2,t3 ....;
</pre>
<!--l. 422--><p class="nopar" >
</p>
<h5 class="likesubsubsectionHead"><a 
 id="x188-42700020.9.3"></a>Dummy indices recognition</h5>
<a 
 id="dx188-427001"></a>
<!--l. 427--><p class="noindent" ><a 
 id="operator:DUMMY_INDICES"></a> <a 
 id="command:REM_DUMMY_INDICES"></a> For all individual tensors met by the evaluator, the system will analyse the written
indices and will detect those which must be considered dummy according to the usual
rules of tensor calculus. Those indices will be given the <span 
class="pcrr8t-x-x-109">dummy </span>property and will no
longer be allowed to play the role of <span 
class="ptmri8t-x-x-109">free </span>indices unless the user removes this dummy
property. In that way, the system checks immediately the consistency of an input. Three
functions are at the disposal of the user to control dummy indices. They are
<a 
 id="dx188-427002"></a><span 
class="pcrr8t-x-x-109">dummy_indices</span>, <a 
 id="dx188-427003"></a><span 
class="pcrr8t-x-x-109">rem_dummy_indices </span>The following illustrates their use as well
as the behaviour of the system:
                                                                     

                                                                     
</p>
<pre class="verbatim" id="verbatim-720">
      dummy_indices(); ==&#x003E; {} % In a fresh environment

      te(a,b,-c,-a); ==&#x003E;

               a b
             te
                   c a

      dummy_indices(); ==&#x003E; {a}

      te(a,b,-c,a); ==&#x003E;

      ***** ((c)(a b a)) are inconsistent lists of indices

               % a cannot be found twice as an upper index

      te(a,b,-b,-a); ==&#x003E;

               a b
            te
                   b a

      dummy_indices(); ==&#x003E; {b,a}

      te(d,-d,d); ==&#x003E;

        ***** ((d)(d d)) are inconsistent lists of indices

      dummy_indices(); ==&#x003E; {d,b,a}

      rem_dummy_indices d; ==&#x003E; t

     dummy_indices(); ==&#x003E; {b,a}

      te(d,d); ==&#x003E;

               d d
            te              %  This is allowed again.
                                                                     

                                                                     

     dummy_indices(); ==&#x003E; {b,a}

      rem_dummy_indices(); ==&#x003E; t

      dummy_indices(); ==&#x003E; {}
</pre>
<!--l. 485--><p class="nopar" > Other veriﬁcations of coherence are made when space speciﬁcations are introduced both
in the ON and OFF <span 
class="pcrr8t-x-x-109">onespace </span>environment. We shall discuss them later<a 
 id="dx188-427004"></a><a 
 id="dx188-427005"></a><a 
 id="dx188-427006"></a>.
</p><!--l. 490--><p class="noindent" >
</p>
<h5 class="likesubsubsectionHead"><a 
 id="x188-42800020.9.3"></a>Substitutions, assignements and rewriting rules</h5>
<a 
 id="dx188-428001"></a>
<a 
 id="dx188-428002"></a>
<a 
 id="dx188-428003"></a>
<!--l. 495--><p class="noindent" >The user must be able to manipulate and give speciﬁc characteristics to the generic
tensors he has introduced. Since tensors are essentially REDUCE operators, the
usual commands of the system are available. However, some limitations are
implied by the fact that indices and, especially numeric indices, must always be
properly recognized before any substitution or manipulation is done. We have
gathered below a set of examples which illustrate all the “delicate” points. First, the
substitutions<a 
 id="dx188-428004"></a>:
                                                                     

                                                                     
</p>
<pre class="verbatim" id="verbatim-721">
      sub(a=-c,te(a,b)); ==&#x003E;

                 b
             te
               c

      sub(a=-1,te(a,b)); ==&#x003E;

                 b
             te
               1

      sub(a=-0,te(a,b)); ==&#x003E;

               0 b
             te    % sub has replaced -0 by 0. wrong!

      sub(a=-!0,te(a,b)); ==&#x003E;

                 b
             te    % right
               0
</pre>
<!--l. 527--><p class="nopar" > The substitution of an index by -0 is the <span 
class="ptmri8t-x-x-109">only one </span>case where there is a problem. The
operator <span 
class="pcrr8t-x-x-109">sub </span>replaces -0 by 0 because it does not recognize 0 as an index of course.
Such a recognition is context dependent and implies a modiﬁcation of <span 
class="pcrr8t-x-x-109">sub </span>for this <span 
class="ptmri8t-x-x-109">single</span>
exceptional case. Therefore,we have opted, not do do so and to use the index 0 which is
simply !0 instead of 0.
</p><!--l. 535--><p class="noindent" >Second, the assignments. Here, we advise the user to rely on the
operator<a 
 id="dx188-428005"></a><span 
class="pcrr8t-x-x-109">==</span><a 
 id="dx188-428006"></a><span class="footnote-mark"><a 
href="manual190.html#fn18x20"><sup class="textsuperscript">18</sup></a></span><a 
 id="x188-428007f18"></a> 
instead of the operator <a 
 id="dx188-428008"></a><span 
class="pcrr8t-x-x-109">:=</span>. Again, the reason is to avoid the problem raised above in the
case of substitutions. <span 
class="pcrr8t-x-x-109">:= </span>does not evaluate its left hand side so that -0 is not recognized
as an index and simpliﬁed to 0 while the <span 
class="pcrr8t-x-x-109">== </span>operator evaluates both its left
and right hand sides and does recognize it. The disadvantage of <span 
class="pcrr8t-x-x-109">== </span>is that it
                                                                     

                                                                     
demands that a second assignement on a given component be made only after
having suppressed <span 
class="ptmri8t-x-x-109">explicitly </span>the ﬁrst assignement. This is done by the function
<a 
 id="dx188-428009"></a><span 
class="pcrr8t-x-x-109">rem_value_tens </span>which can be applied on any component. We stress, however, that if
one is willing to use -!0 instead of -0 as the lower 0 index, the use of \(:=\) is perfectly
legitimate:
                                                                     

                                                                     
</p>
<pre class="verbatim" id="verbatim-722">
      te({x,y},a,-0)==x*y*te(a,-0); ==&#x003E;

               a
             te   *x*y
                 0

      te({x,y},a,-0); ==&#x003E;

               a
             te   *x*y
                 0

      te({x,y},a,0); ==&#x003E;


                a 0
             te    (x,y)


      te({x,y},a,-0)==x*y*te(a,-0); ==&#x003E;

                   a
          ***** te    *x*y invalid as setvalue kernel
                     0

      rem_value_tens te({x,y},a,-0);

      te({x,y},a,-0); ==&#x003E;

                a
             te    (x,y)
                  0

      te({x,y},a,-0)==(x+y)*te(a,-0); ==&#x003E;

            a
          te   *(x + y)
              0
                                                                     

                                                                     
</pre>
<!--l. 591--><p class="nopar" > In the elementary application below, the use of a tensor avoids the introduction of two
diﬀerent operators and makes the calculation more readable.
                                                                     

                                                                     
</p>
<pre class="verbatim" id="verbatim-723">
      te(1)==sin th * cos phi; ==&#x003E; cos(phi)*sin(th)

      te(-1)==sin th * cos phi; ==&#x003E; cos(phi)*sin(th)

      te(2)==sin th * sin phi; ==&#x003E; sin(phi)*sin(th)

      te(-2)==sin th * sin phi; ==&#x003E; sin(phi)*sin(th)

      te(3)==cos th ; ==&#x003E; cos(th)

      te(-3)==cos th ; ==&#x003E; cos(th)

      for i:=1:3 sum te(i)*te(-i); ==&#x003E;

           2        2          2           2        2
   cos(phi) *sin(th)  + cos(th)  + sin(phi) *sin(th)

      rem_value_tens te;

      te(2); ==&#x003E;

               2
            te
</pre>
<!--l. 619--><p class="nopar" > There is no diﬀerence in the manipulation of numeric indices and numeric <span 
class="ptmri8t-x-x-109">tensor</span>
indices. The function <a 
 id="dx188-428010"></a><span 
class="pcrr8t-x-x-109">rem_value_tens </span>when applied to a tensor preﬁx suppresses the
value of <span 
class="ptmri8t-x-x-109">all its components</span>. Finally, there is no “interference” with i as a dummy index
and i as a numeric index in a loop.
</p><!--l. 626--><p class="noindent" >Third, rewriting rules. They are either global or local and can be used as in REDUCE.
Again, here, the -0 index problem exists each time a substitution by the index -0 must be
made in a template. <a 
 id="dx188-428011"></a><a 
 id="dx188-428012"></a>
                                                                     

                                                                     
</p>
<pre class="verbatim" id="verbatim-724">
  % LET:

      let te({x,y},-0)=x*y;

      te({x,y},-0); ==&#x003E; x*y

      te({x,y},+0); ==&#x003E;

                0
             te  (x,y)


      te({x,u},-0); ==&#x003E;

             te  (x,u)
                0

  % FOR ALL .. LET:

      for all x,a let te({x},a,-b)=x*te(a,-b);

      te({u},1,-b); ==&#x003E;

               1
             te   *u
                 b

      te({u},c,-b); ==&#x003E;

               c
             te   *u
                 b

      te({u},b,-b); ==&#x003E;

               b
             te   *u
                 b
                                                                     

                                                                     

      te({u},a,-a); ==&#x003E;

                a
             te    (u)
                  a

      for all x,a clear te({x},a,-b);

      te({u},c,-b); ==&#x003E;

                c
             te    (u)
                  b

      for all a,b let te({x},a,-b)=x*te(a,-b);

      te({x},c,-b); ==&#x003E;

               c
             te   *x
                 b

      te({x},a,-a); ==&#x003E;

               a
             te   *x
                 a

   % The index -0 problem:

      te({x},a,-0); ==&#x003E; % -0 becomes +0 in the template

                a
             te    (x)  %  the rule does not apply.
                  0

      te({x},0,-!0); ==&#x003E;

               0
             te   *x      % here it applies.
                 0
</pre>
<!--l. 713--><p class="nopar" >
                                                                     

                                                                     
</p>
<pre class="verbatim" id="verbatim-725">
  % WHERE:

      rul:={te(~a) =&#x003E; sin a}; ==&#x003E;

                        a
             rul := {te  =&#x003E; sin(a)}



      te(1) where rul; ==&#x003E; sin(1)

      te(1); ==&#x003E;

                 1
               te
</pre>
<!--l. 730--><p class="nopar" > <a 
 id="dx188-428013"></a>
                                                                     

                                                                     
</p>
<pre class="verbatim" id="verbatim-726">
  % with variables:

      rul1:={te(~a,{~x,~y}) =&#x003E; x*y*sin(a)}; ==&#x003E;


                        ~a
             rul1 := {te   (~x,~y) =&#x003E; x*y*sin(a)}


      te(a,{x,y}) where rul1; ==&#x003E; sin(a)*x*y



      te({x,y},a) where rul1; ==&#x003E; sin(a)*x*y


      rul2:={te(-~a,{~x,~y}) =&#x003E; x*y*sin(-a)};


            rul2 := {te   (~x,~y) =&#x003E; x*y*sin(-a)}
                       ~a

      te(-a,{x,y}) where rul2; ==&#x003E; -sin(a)*x*y


      te({x,y},-a) where rul2; ==&#x003E; -sin(a)*x*y
</pre>
<!--l. 759--><p class="nopar" > Notice that the position of the list of variables inside the rule may be chosen at will. It is
an irrelevant feature of the template. This may be confusing, so, we advise to write the
rules not as above but placing the list of variables <span 
class="ptmri8t-x-x-109">in front of all indices </span>since it is in that
canonical form which it is written by the simpliﬁcation function of individual
tensors.
</p>
<h5 class="subsubsectionHead"><a 
 id="x188-42900020.9.3"></a>Behaviour under space speciﬁcations</h5>
                                                                     

                                                                     
<a 
 id="dx188-429001"></a>
<!--l. 769--><p class="noindent" >The characteristics and the behaviour of generic tensors described up to now are
independent of all space speciﬁcations. They are complete as long as we conﬁne to the
default space which is active when starting <span 
class="ptmrc8t-x-x-109">C<span 
class="small-caps">A</span><span 
class="small-caps">N</span><span 
class="small-caps">T</span><span 
class="small-caps">E</span><span 
class="small-caps">N</span><span 
class="small-caps">S</span></span>. However, as soon as some space
speciﬁcation is introduced, it has some consequences one the generic tensor properties.
This is true both when <a 
 id="dx188-429002"></a><a 
 id="dx188-429003"></a><a 
 id="dx188-429004"></a><span 
class="pcrr8t-x-x-109">onespace </span>is switched ON or OFF. Here we shall describe how
to deal with these features.
</p><!--l. 777--><p class="noindent" >When <span 
class="pcrr8t-x-x-109">onespace </span>is ON, if the space dimension is set to an integer, numeric indices of
any generic tensors are forced to be less or equal that integer if the signature is 0 or less
than that integer if the signature is equal to 1. The following illustrates what happens.
<a 
 id="dx188-429005"></a>
                                                                     

                                                                     
</p>
<pre class="verbatim" id="verbatim-727">
      on onespace;

      wholespace_dim 4; ==&#x003E; 4

      signature 0; ==&#x003E; 0

      te(3,a,-b,7); ==&#x003E; ***** numeric indices out of range

      te(3,a,-b,3); ==&#x003E;


               3 a   3
             te
                   b



      te(4,a,-b,4); ==&#x003E;


               4 a   4
             te
                   b

      sub(a=5,te(3,a,-b,3));

                   ==&#x003E; ***** numeric indices out of range

      signature 1; ==&#x003E; 1

  % Now indices range from 0 to 3:

      te(4,a,-b,4);

                    ==&#x003E; ***** numeric indices out of range

      te(0,a,-b,3); ==&#x003E;

                                                                     

                                                                     

                0 a   3
              te
                    b
</pre>
<!--l. 825--><p class="nopar" > When <span 
class="pcrr8t-x-x-109">onespace </span>is OFF<a 
 id="dx188-429006"></a>, many more possibilities to control the input or to give
speciﬁc properties to tensors are open. For instance, it is possible to declare that a tensor
belongs to one of them. It is also possible to declare that some indices belongs to one of
them. It is even possible to do that for <span 
class="ptmri8t-x-x-109">numeric </span>indices thanks to the declaration
<a 
 id="dx188-429007"></a>indexrange included optionally in the space deﬁnition generated by <a 
 id="dx188-429008"></a><span 
class="pcrr8t-x-x-109">define_spaces</span>.
First, when <span 
class="pcrr8t-x-x-109">onespace </span>is OFF, the run equivalent to the previous one is like the
following: <a 
 id="dx188-429009"></a><a 
 id="dx188-429010"></a> <a 
 id="dx188-429011"></a>
                                                                     

                                                                     
</p>
<pre class="verbatim" id="verbatim-728">
      off onespace;

      define_spaces wholespace={6,signature=1); ==&#x003E; t

      show_spaces(); ==&#x003E; {{wholespace,6,signature=1}}

      make_tensor_belong_space(te,wholespace);

                                        ==&#x003E; wholespace

      te(4,a,-b,6); ==&#x003E;

                     ***** numeric indices out of range

      te(4,a,-b,5); ==&#x003E;


               4 a   5
             te
                   b

      rem_spaces wholespace;

      define_spaces wholespace={4,euclidean}; ==&#x003E; t

      te(a,5,-b); ==&#x003E; ***** numeric indices out of range

      te(a,4,-b); ==&#x003E;


               a 4
             te
                   b

      define_spaces eucl={1,signature=0}; ==&#x003E; t

      show_spaces(); ==&#x003E;

                                                                     

                                                                     
        {{wholespace,5,signature=1},

                {eucl,1,signature=0}}

      make_tensor_belong_space(te,eucl); ==&#x003E; eucl

      te(1); ==&#x003E;

               1
             te

      te(2); ==&#x003E; ***** numeric indices out of range

      te(0); ==&#x003E;

               0
             te
</pre>
<!--l. 896--><p class="nopar" > In the run, the new function <a 
 id="dx188-429012"></a> <span 
class="pcrr8t-x-x-109">make_tensor_belong_space </span>has been used. One
may be surprised that <span 
class="pcrr8t-x-x-109">te(0) </span>is allowed in the end of the previous run and, indeed, it is
incorrect that the system allows <span 
class="ptmri8t-x-x-109">two </span>diﬀerent components to <span 
class="pcrr8t-x-x-109">te</span>. This is due to an
incomplete deﬁnition of the space. When one deals with spaces of integer dimensions, if
one wants to control numeric indices correctly <span 
class="ptmri8t-x-x-109">when </span><span 
class="pcrr8t-x-x-109">onespace </span>is switched
oﬀ <span 
class="ptmri8t-x-x-109">one must also give the indexrange</span><a 
 id="dx188-429013"></a>. So the previous run must be corrected
to
                                                                     

                                                                     
</p>
<pre class="verbatim" id="verbatim-729">
      define_spaces eucl=

                 {1,signature=0,indexrange=1 .. 1}; ==&#x003E; t

      make_tensor_belong_space(te,eucl); ==&#x003E; eucl

      te(0); ==&#x003E;

        ***** numeric indices do not belong to (sub)-space

      te(1); ==&#x003E;

               1
             te

      te(2); ==&#x003E;

        ***** numeric indices do not belong to (sub)-space
</pre>
<!--l. 928--><p class="nopar" > Notice that the error message has also changed accordingly. So, now one can even
constrain the 0 component to belong to an euclidian space.
</p><!--l. 933--><p class="noindent" ><a 
 id="operator:MK_IDS_BELONG_SPACE"></a> <a 
 id="operator:MK_IDS_BELONG_ANYSPACE"></a> Let us go back to symbolic indices. <a 
 id="dx188-429014"></a>By default, any symbolic index belongs to the
global space or to all deﬁned partial spaces. In many cases, this is, of course, not
consistent. So, the possibility exists to declare that one or several indices belong to a
speciﬁc (sub-)space. To this end, one is to use the function <a 
 id="dx188-429015"></a><span 
class="pcrr8t-x-x-109">mk_ids_belong_space</span>.
Its syntax is
  </p><div class="syntax">
   <span 
class="pcrr8t-x-x-109">mk_ids_belong_space</span>(\(\langle \)<span 
class="ptmri8t-x-x-109">list of indices</span>\(\rangle \), \(\langle \)<span 
class="ptmri8t-x-x-109">(sub-)space identiﬁer</span>\(\rangle \))</div>
<!--l. 947--><p class="noindent" >The function <a 
 id="dx188-429016"></a><span 
class="pcrr8t-x-x-109">mk_ids_belong_anyspace </span>whose syntax is the same do the reverse
operation.
</p><!--l. 950--><p class="noindent" >Combined with the declaration <a 
 id="dx188-429017"></a><span 
class="pcrr8t-x-x-109">make_tensor_belong_space</span>, it allows to
express all problems which involve tensors belonging to diﬀerent spaces and do
the dummy summations correctly. One can also deﬁne a tensor which has a
<a 
 id="dx188-429018"></a>“bloc-diagonal” structure. All these features are illustrated in the next sections
which describe speciﬁc tensors and the properties of the extended function
                                                                     

                                                                     
<a 
 id="dx188-429019"></a><span 
class="pcrr8t-x-x-109">canonical</span>.
</p><!--l. 960--><p class="noindent" >
</p>
<h4 class="subsectionHead"><span class="titlemark">20.9.4    </span> <a 
 id="x188-43000020.9.4"></a>Speciﬁc tensors</h4>
<!--l. 961--><p class="noindent" >The means provided in the two previous subsection to handle generic tensors already
allow to construct any speciﬁc tensor we may need. That the package contains a certain
number of them is already justiﬁed on the level of conviviality. However, a more
important justiﬁcation is that some basic tensors are so universaly and frequently used
that a careful programming of these improves considerably the robustness and the
eﬃciency of most calculations. The choice of the set of speciﬁc tensors is not
clearcut. We have tried to keep their number to a minimum but, experience, may
lead us extend it without diﬁculty. So, up to now, the list of speciﬁc tensors
is:
     </p><dl class="list1"><dt class="list">
   - </dt><dd 
class="list">
     <!--l. 971--><p class="noindent" ><span 
class="pcrr8t-x-x-109">delta </span>tensor<a 
 id="dx188-430001"></a>,
     </p></dd><dt class="list">
   - </dt><dd 
class="list">
     <!--l. 972--><p class="noindent" ><span 
class="pcrr8t-x-x-109">eta </span>Minkowski tensor<a 
 id="dx188-430002"></a><a 
 id="dx188-430003"></a>,
     </p></dd><dt class="list">
   - </dt><dd 
class="list">
     <!--l. 973--><p class="noindent" ><span 
class="pcrr8t-x-x-109">epsilon </span>tensor,<a 
 id="dx188-430004"></a>
     </p></dd><dt class="list">
   - </dt><dd 
class="list">
     <!--l. 974--><p class="noindent" ><span 
class="pcrr8t-x-x-109">del </span>generalised delta tensor,<a 
 id="dx188-430005"></a>
     </p></dd><dt class="list">
   - </dt><dd 
class="list">
     <!--l. 975--><p class="noindent" ><span 
class="pcrr8t-x-x-109">metric </span>generic tensor metric.<a 
 id="dx188-430006"></a></p></dd></dl>
                                                                     

                                                                     
<!--l. 977--><p class="noindent" >It is important to realize that the typewriter font names in the list are <span 
class="ptmri8t-x-x-109">keywords </span>for
the corresponding tensors and do not necessarily correspond to their <span 
class="ptmri8t-x-x-109">actual</span>
<span 
class="ptmri8t-x-x-109">names</span>. Indeed, the choice of the names of particular tensors is left to the user.
When startting <span 
class="ptmrc8t-x-x-109">C<span 
class="small-caps">A</span><span 
class="small-caps">N</span><span 
class="small-caps">T</span><span 
class="small-caps">E</span><span 
class="small-caps">N</span><span 
class="small-caps">S</span> </span>speciﬁc tensors are NOT available. They must be
activated by the user using the function <a 
 id="dx188-430007"></a><a 
 id="operator:MAKE_PARTIC_TENS"></a><span 
class="pcrr8t-x-x-109">make_partic_tens </span>whose syntax
is:
  </p><div class="syntax">
   <span 
class="pcrr8t-x-x-109">make_partic_tens</span>(\(\langle \)<span 
class="ptmri8t-x-x-109">tensor name</span>\(\rangle \) , \(\langle \)<span 
class="ptmri8t-x-x-109">keyword</span>\(\rangle \));</div>
<!--l. 989--><p class="noindent" >The name chosen may be the same as the keyword. As we shall see, it is never needed to
deﬁne more than one <span 
class="pcrr8t-x-x-109">delta </span>tensor but it is often needed to deﬁne several <span 
class="pcrr8t-x-x-109">epsilon</span>
tensors. Hereunder, we describe each of the above tensors especially their behaviour in a
multi-space environment.
</p><!--l. 995--><p class="noindent" >
</p>
<h5 class="subsubsectionHead"><a 
 id="x188-43100020.9.4"></a>DELTA tensor</h5>
<a 
 id="dx188-431001"></a>
<!--l. 997--><p class="noindent" >It is the simplest example of a bloc-diagonal<a 
 id="dx188-431002"></a> tensor we mentioned in the previous section.
It can also work in a space which is a direct product of two spaces. Therefore, one never
needs to introduce more than one such tensor. If one is working in a graphic
environment, it is advantageous to choose the keyword as its name. Here we choose
<span 
class="pcrr8t-x-x-109">delt</span>. We illustrate how it works when the switch <a 
 id="dx188-431003"></a><a 
 id="dx188-431004"></a><a 
 id="dx188-431005"></a><span 
class="pcrr8t-x-x-109">onespace </span>is successively switched
ON and OFF. <a 
 id="dx188-431006"></a>
                                                                     

                                                                     
</p>
<pre class="verbatim" id="verbatim-730">
      on onespace;

      make_partic_tens(delt,delta); ==&#x003E; t

      delt(a,b); ==&#x003E;

          ***** bad choice of indices for DELTA tensor

  % order of upper and lower indices irrelevant:

      delt(a,-b); ==&#x003E;

                 a
             delt
                 b

      delt(-b,a); ==&#x003E;

                 a
             delt
                 b

      delt(-a,b); ==&#x003E;

                 b
             delt
                 a


      wholespace_dim ?; ==&#x003E; dim

      delt(1,-5); ==&#x003E; 0

  % dummy summation done:

      delt(-a,a); ==&#x003E; dim


                                                                     

                                                                     
      wholespace_dim 4; ==&#x003E; 4

      delt(1,-5); ==&#x003E; ***** numeric indices out of range


      wholespace_dim 3; ==&#x003E; 3

      delt(-a,a); ==&#x003E; 3
</pre>
<!--l. 1053--><p class="nopar" > There is a peculiarity of this tensor, viz. it can serve to represent the Dirac
<span 
class="ptmri8t-x-x-109">delta function</span><a 
 id="dx188-431007"></a> when it has no indices and an explicit variable dependency as
hereunder
                                                                     

                                                                     
</p>
<pre class="verbatim" id="verbatim-731">
      delt({x-y}) ==&#x003E; delt(x-y)
</pre>
<!--l. 1059--><p class="nopar" > Next we work in the context of several spaces: <a 
 id="dx188-431008"></a>
                                                                     

                                                                     
</p>
<pre class="verbatim" id="verbatim-732">
      off onespace;

      define_spaces wholespace={5,signature=1}; ==&#x003E; t

  % we need to assign delta to wholespace when it exists:

      make_tensor_belong_space(delt,wholespace);

      delt(a,-a); ==&#x003E; 5

      delt(0,-0); ==&#x003E;1

      rem_spaces wholespace; ==&#x003E; t

      define_spaces wholespace={5,signature=0}; ==&#x003E; t

      delt(a,-a); ==&#x003E; 5

      delt(0,-a); ==&#x003E;

          ***** bad value of indices for DELTA tensor
</pre>
<!--l. 1084--><p class="nopar" > The checking of consistency of chosen indices is made in the same way as for generic
tensor. In fact, all the previous functions which act on generic tensors may also aﬀect, in
the same way, a speciﬁc tensor. For instance, it was compulsory to explicitly tell that we
want <span 
class="pcrr8t-x-x-109">delt </span>to belong to the wholespace <a 
 id="dx188-431009"></a><span 
class="pcrr8t-x-x-109">make_tensor_belong_space</span>, otherwise
<span 
class="pcrr8t-x-x-109">delt </span>would remain deﬁned on the <span 
class="ptmri8t-x-x-109">default space</span>. In the next sample run, we display the
bloc-diagonal property of the <a 
 id="dx188-431010"></a> delta tensor<a 
 id="dx188-431011"></a>.
                                                                     

                                                                     
</p>
<pre class="verbatim" id="verbatim-733">
      onespace ?; ==&#x003E; no

      rem_spaces wholespace; ==&#x003E; t

      define_spaces wholespace={10,signature=1}$

      define_spaces d1={5,euclidian}$

      define_spaces d2={2,euclidian}$


      mk_ids_belong_space({a},d1); ==&#x003E; t

      mk_ids_belong_space({b},d2); ==&#x003E; t

  % c belongs to wholespace so:

      delt(c,-b); ==&#x003E;

                 c
             delt
                 b

      delt(c,-c); ==&#x003E; 10


      delt(b,-b); ==&#x003E; 2

      delt(a,-a); ==&#x003E; 5

  % this is especially important:

      delt(a,-b); ==&#x003E; 0
</pre>
<!--l. 1127--><p class="nopar" > The bloc-diagonal property of <a 
 id="dx188-431012"></a><span 
class="pcrr8t-x-x-109">delt </span>is made active under two conditions.
The ﬁrst is that the system knows to which space it belongs, the second is that
indices must be declared to belong to a speciﬁc space<a 
 id="dx188-431013"></a>. To enforce the same
property on a generic tensor, we have to make the <a 
 id="dx188-431014"></a><span 
class="pcrr8t-x-x-109">make_bloc_diagonal</span>
                                                                     

                                                                     
declaration:
                                                                     

                                                                     
</p>
<pre class="verbatim" id="verbatim-734">
      make_bloc_diagonal t1,t2, ...;
</pre>
<!--l. 1136--><p class="nopar" > and to make it active, one proceeds as in the above run. Starting from a fresh
environment, the following sample run is illustrative<a 
 id="dx188-431015"></a>:
                                                                     

                                                                     
</p>
<pre class="verbatim" id="verbatim-735">
      off onespace;

      define_spaces wholespace={6,signature=1}$

      define_spaces mink={4,signature=1,indexrange=0 .. 3}$

      define_spaces eucl={3,euclidian,indexrange=4 .. 6}$

      tensor te;

      make_tensor_belong_space(te,eucl); ==&#x003E; eucl


  % the key declaration:

      make_bloc_diagonal te; ==&#x003E; t


  % bloc-diagonal property activation:

      mk_ids_belong_space({a,b,c},eucl); ==&#x003E; t

      mk_ids_belong_space({m1,m2},mink); ==&#x003E; t


      te(a,b,m1); ==&#x003E; 0

      te(a,b,m2); ==&#x003E; 0

   % bloc-diagonal property suppression:

      mk_ids_belong_anyspace a,b,c,m1,m2; ==&#x003E; t


      te(a,b,m2); ==&#x003E;

               a b m2
             te
                                                                     

                                                                     
</pre>
<!--l. 1179--><p class="nopar" >
</p><!--l. 1181--><p class="noindent" >
</p>
<h5 class="subsubsectionHead"><a 
 id="x188-43200020.9.4"></a>ETA Minkowski tensor</h5>
<a 
 id="dx188-432001"></a>
<a 
 id="dx188-432002"></a>
<!--l. 1183--><p class="noindent" >The use of <a 
 id="dx188-432003"></a><span 
class="pcrr8t-x-x-109">make_partic_tens </span>with the keyword <span 
class="pcrr8t-x-x-109">eta </span>allows to create a Minkowski
diagonal metric tensor in a one or multi-space context either with the convention of high
energy physicists or in the convention of astrophysicists. Any <span 
class="pcrr8t-x-x-109">eta</span>-like tensor is assumed
to work within a space of signature 1. Therefore, if the space whose metric, it is supposed
to describe has a signature 0, an error message follows if one is working in an ON
<span 
class="pcrr8t-x-x-109">onespace</span><a 
 id="dx188-432004"></a><a 
 id="dx188-432005"></a> context and a warning when in an OFF <span 
class="pcrr8t-x-x-109">onespace </span>context. Illustration:
<a 
 id="dx188-432006"></a>
                                                                     

                                                                     
</p>
<pre class="verbatim" id="verbatim-736">
      on onespace;

      make_partic_tens(et,eta); ==&#x003E; t

      signature 0; ==&#x003E; 0;

      et(-b,-a); ==&#x003E;

         *****  signature must be equal to 1 for ETA tensor


      off onespace;

      et(a,b); ==&#x003E;

          ***  ETA tensor not properly assigned to a space

  % it is then evaluated to zero:

          0

      on onespace;

      signature 1; ==&#x003E; 1

      et(-b,-a); ==&#x003E;

             et
               a b
</pre>
<!--l. 1226--><p class="nopar" > Since <span 
class="pcrr8t-x-x-109">et(a,-a) </span>is evaluated to the corresponding <span 
class="pcrr8t-x-x-109">delta </span>tensor, one cannot deﬁne
properly an <span 
class="pcrr8t-x-x-109">eta</span><a 
 id="dx188-432007"></a> tensor without a simultaneous introduction of a <span 
class="pcrr8t-x-x-109">delta </span>tensor.
Otherwise one gets the following message:
                                                                     

                                                                     
</p>
<pre class="verbatim" id="verbatim-737">
      et(a,-a); ==&#x003E; *****  no name found for (delta)
</pre>
<!--l. 1233--><p class="nopar" > So we need to issue, for instance,
                                                                     

                                                                     
</p>
<pre class="verbatim" id="verbatim-738">
      make_partic_tens(delta,delta); ==&#x003E; t
</pre>
<!--l. 1237--><p class="nopar" > The value of its diagonal elements depends on the chosen <a 
 id="dx188-432008"></a>global sign. The next run
illustrates this:
                                                                     

                                                                     
</p>
<pre class="verbatim" id="verbatim-739">
      global_sign ?; ==&#x003E; 1

      et(0,0); ==&#x003E; 1

      et(3,3); ==&#x003E;  - 1

      global_sign(-1); ==&#x003E; -1

      et(0,0); ==&#x003E;  - 1

      et(3,3); ==&#x003E; 1
</pre>
<!--l. 1252--><p class="nopar" > The tensor is of course symmetric <a 
 id="dx188-432009"></a>. Its indices are checked in the same way as for a
generic tensor. In a multi_space context<a 
 id="dx188-432010"></a>, the <span 
class="pcrr8t-x-x-109">eta </span>tensor must belong to a well deﬁned
space of <a 
 id="dx188-432011"></a><a 
 id="dx188-432012"></a>signature 1: <a 
 id="dx188-432013"></a>
                                                                     

                                                                     
</p>
<pre class="verbatim" id="verbatim-740">
      off onespace;

      define_spaces wholespace={4,signature=1}$

      make_tensor_belong_space(et,wholespace)$

      et(a,-a); ==&#x003E; 4
</pre>
<!--l. 1267--><p class="nopar" > If the space to which <span 
class="pcrr8t-x-x-109">et </span>belongs to is a subspace<a 
 id="dx188-432014"></a><a 
 id="dx188-432015"></a>, one must also take care to give a
space-identity to dummy indices which may appear inside it. In the following run, the
index <span 
class="pcrr8t-x-x-109">a </span>belongs to <span 
class="pcrr8t-x-x-109">wholespace</span><a 
 id="dx188-432016"></a>if it is not told to the system that it is a dummy index
of the space <span 
class="pcrr8t-x-x-109">mink</span>:
                                                                     

                                                                     
</p>
<pre class="verbatim" id="verbatim-741">
      make_tensor_belong_anyspace et; ==&#x003E; t

      rem_spaces wholespace; ==&#x003E; t

      define_spaces wholespace={8,signature=1}; ==&#x003E; t

      define_spaces mink={5,signature=1}; ==&#x003E; t

      make_tensor_belong_space(et,mink); ==&#x003E; mink

  % a sits in wholespace:

      et(a,-a); ==&#x003E; 8

      mk_ids_belong_space({a},mink); ==&#x003E; t

  % a sits in mink:

      et(a,-a); ==&#x003E;  5
</pre>
<!--l. 1295--><p class="nopar" >
</p><!--l. 1297--><p class="noindent" >
</p>
<h5 class="subsubsectionHead"><a 
 id="x188-43300020.9.4"></a>EPSILON tensors</h5>
<a 
 id="dx188-433001"></a>
<a 
 id="dx188-433002"></a>
<!--l. 1300--><p class="noindent" >It is an antisymmetric <a 
 id="dx188-433003"></a><a 
 id="dx188-433004"></a> tensor which is the invariant tensor for the unitary group
transformations in n-dimensional complex space which are continuously connected to
the identity transformation. The number of their indices are always stricty equal to the
number of space dimensions. So, to each speciﬁc space is associated a speciﬁc <span 
class="pcrr8t-x-x-109">epsilon</span>
tensor. Its properties are also dependent on the signature of the space. We describe how
to deﬁne and manipulate it in the context of a unique space and, next, in a multi-space
context.
                                                                     

                                                                     
</p><!--l. 1311--><p class="noindent" >
</p>
<h5 class="likesubsubsectionHead"><a 
 id="x188-43400020.9.4"></a>Switch <span 
class="pcrr8t-x-x-109">onespace </span>is on</h5>
<a 
 id="dx188-434001"></a>
<!--l. 1313--><p class="noindent" >The use of <a 
 id="dx188-434002"></a><span 
class="pcrr8t-x-x-109">make_partic_tens </span>places it, by default, in an euclidian space if the
signature is 0 and in a Minkowski-type space if the signature<a 
 id="dx188-434003"></a><a 
 id="dx188-434004"></a> is 1. For higher
signatures it is not constructed. For a space of symbolic dimension, the number of its
indices is not constrained. When it appears inside an expression, its indices are
<span 
class="ptmri8t-x-x-109">all </span>currently upper or lower indices. However, the system allows for mixed
positions of the indices. In that case, the output of the system is changed compared
to the input only to place all contravariant indices to the left of the covariant
ones.
                                                                     

                                                                     
</p>
<pre class="verbatim" id="verbatim-742">
      make_partic_tens(eps,epsilon); ==&#x003E; t

      eps(a,d,b,-g,e,-f); ==&#x003E;

                   a d b e
              - eps
                           g f

      eps(a,d,b,-f,e,-f); ==&#x003E; 0

  % indices have all the same variance:

      eps(-b,-a); ==&#x003E;

              - eps
                   a b


      signature ?; ==&#x003E; 0

      eps(1,2,3,4); ==&#x003E; 1

      eps(-1,-2,-3,-4); ==&#x003E; 1

      wholespace_dim 3; ==&#x003E; 3

      eps(-1,-2,-3); ==&#x003E; 1

      eps(-1,-2,-3,-4); ==&#x003E;

             ***** numeric indices out of range

      eps(-1,-2,-3,-3); ==&#x003E;

             ***** bad number of indices for (eps) tensor

      eps(a,b); ==&#x003E;

                                                                     

                                                                     
             ***** bad number of indices for (eps) tensor

      eps(a,b,c); ==&#x003E;

                a b c
             eps


      eps(a,b,b); ==&#x003E; 0
</pre>
<!--l. 1372--><p class="nopar" > When the signature<a 
 id="dx188-434005"></a><a 
 id="dx188-434006"></a> is equal to 1, it is known that there exists two <span 
class="ptmri8t-x-x-109">conventions </span>which are
linked to the chosen value 1 or -1 of the \((0,1,\ldots ,n)\) component. So, the sytem does evaluate all
components in terms of the \((0,1,\ldots ,n)\) upper index component. It is left to the user to assign it to 1
or -1<a 
 id="dx188-434007"></a>.
                                                                     

                                                                     
</p>
<pre class="verbatim" id="verbatim-743">
      signature 1; ==&#x003E; 1

      eps(0,1,2); ==&#x003E;

                0 1 2
             eps

      eps(-0,-1,-2); ==&#x003E;

                0 1 2
             eps

      wholespace_dim 4; ==&#x003E; 4

      eps(0,1,2,3); ==&#x003E;

                0 1 2 3
             eps

      eps(-0,-1,-2,-3); ==&#x003E;

                   0 1 2 3
              - eps

  % change of the global_sign convention:

      global_sign(-1);

      wholespace_dim 3; ==&#x003E; 3

  % compare with second input:

      eps(-0,-1,-2); ==&#x003E;

                   0 1 2
              - eps
</pre>
<!--l. 1417--><p class="nopar" >
                                                                     

                                                                     
</p><!--l. 1419--><p class="noindent" >
</p>
<h5 class="likesubsubsectionHead"><a 
 id="x188-43500020.9.4"></a>Switch <span 
class="pcrr8t-x-x-109">onespace </span>is oﬀ</h5>
<a 
 id="dx188-435001"></a>
<!--l. 1421--><p class="noindent" >As already said, several epsilon tensors may be deﬁned. They <span 
class="ptmri8t-x-x-109">must </span>be assigned to a well
deﬁned (sub-)space otherwise the simplifying function <a 
 id="dx188-435002"></a><span 
class="pcrr8t-x-x-109">canonical </span>will not properly
work. The set of epsilon tensors deﬁned associated to their space-name may be retrieved
using the function <a 
 id="dx188-435003"></a><a 
 id="operator:SHOW_EPSILONS"></a><span 
class="pcrr8t-x-x-109">show_epsilons</span>. An important word of caution here.
The output of this function does NOT show the epsilon tensor one may have
deﬁned in the ON <span 
class="pcrr8t-x-x-109">onespace </span>context. This is so because the default space has
<span 
class="ptmri8t-x-x-109">NO </span>name. Starting from a fresh environment, the following run illustrates this
point:
                                                                     

                                                                     
</p>
<pre class="verbatim" id="verbatim-744">
      show_epsilons(); ==&#x003E; {}

      onespace ?; ==&#x003E; yes

      make_partic_tens(eps,epsilon); ==&#x003E; t

      show_epsilons(); ==&#x003E; {}
</pre>
<!--l. 1440--><p class="nopar" > To make the <span 
class="pcrr8t-x-x-109">epsilon </span>tensor deﬁned in the single space environment visible in the
multi-space environment, one needs to associate it to a space. For example:
                                                                     

                                                                     
</p>
<pre class="verbatim" id="verbatim-745">
      off onespace;

      define_spaces wholespace={7,signature=1}; ==&#x003E; t

      show_epsilons(); ==&#x003E; {}   % still invisible

      make_tensor_belong_space(eps,wholespace); ==&#x003E;

                                            wholespace

      show_epsilons(); ==&#x003E; {{eps,wholespace}}
</pre>
<!--l. 1457--><p class="nopar" > Next, let us deﬁne an <span 
class="ptmri8t-x-x-109">additional </span><span 
class="pcrr8t-x-x-109">epsilon</span>-type tensor:
                                                                     

                                                                     
</p>
<pre class="verbatim" id="verbatim-746">
      define_spaces eucl={3,euclidian}; ==&#x003E; t

      make_partic_tens(ep,epsilon); ==&#x003E;

              *** Warning: ep MUST belong to a space
                t

      make_tensor_belong_space(ep,eucl); ==&#x003E; eucl


      show_epsilons(); ==&#x003E; {{ep,eucl},{eps,wholespace}}

  % We show that it is indeed working inside eucl:

      ep(-1,-2,-3); ==&#x003E; 1

      ep(1,2,3); ==&#x003E; 1

      ep(a,b,c,d); ==&#x003E;

            ***** bad number of indices for  (ep)  tensor

      ep(1,2,4); ==&#x003E;

            ***** numeric indices out of range
</pre>
<!--l. 1485--><p class="nopar" > As previously, the discrimation between symbolic indices <a 
 id="dx188-435004"></a><a 
 id="dx188-435005"></a> <a 
 id="dx188-435006"></a>may be introduced by
assigning them to one or another space<a 
 id="dx188-435007"></a> <a 
 id="dx188-435008"></a>:
                                                                     

                                                                     
</p>
<pre class="verbatim" id="verbatim-747">
      rem_spaces wholespace;

      define_spaces wholespace={dim,signature=1}; ==&#x003E; t

      mk_ids_belong_space({e1,e2,e3},eucl); ==&#x003E; t

      mk_ids_belong_space({a,b,c},wholespace); ==&#x003E; t

      ep(e1,e2,e3); ==&#x003E;

               e1 e2 e3
             ep           % accepted

      ep(e1,e2,z); ==&#x003E;

               e1 e2 z
             ep            % accepted because z
                           % not attached to a space.

      ep(e1,e2,a);==&#x003E;

          ***** some indices are not in the space of ep


      eps(a,b,c); ==&#x003E;

                a b c
             eps           % accepted because *symbolic*
                           % space dimension.
</pre>
<!--l. 1524--><p class="nopar" > <span 
class="pcrr8t-x-x-109">epsilon</span>-like tensors can also be deﬁned on disjoint spaces. The subsequent sample
run starts from the environment of the previous one. It suppresses the space
<span 
class="pcrr8t-x-x-109">wholespace</span><a 
 id="dx188-435009"></a> as well as the space-assignment of the indices <span 
class="pcrr8t-x-x-109">a,b,c</span>. It deﬁnes the
new space <span 
class="pcrr8t-x-x-109">mink</span>. Next, the previously deﬁned <span 
class="pcrr8t-x-x-109">eps </span>tensor is attached to this
space. <span 
class="pcrr8t-x-x-109">ep </span>remains unchanged and <span 
class="pcrr8t-x-x-109">e1,e2,e3 </span>still belong to the space <span 
class="pcrr8t-x-x-109">eucl</span>.
<a 
 id="dx188-435010"></a><a 
 id="dx188-435011"></a>
                                                                     

                                                                     
</p>
<pre class="verbatim" id="verbatim-748">
      rem_spaces wholespace; ==&#x003E; t

      make_tensor_belong_anyspace eps; ==&#x003E; t

      show_epsilons(); ==&#x003E; {{ep,eucl}}

      show_spaces(); ==&#x003E; {{eucl,3,signature=0}}

      mk_ids_belong_anyspace a,b,c; ==&#x003E; t

      define_spaces mink={4,signature=1}; ==&#x003E; t

      show_spaces(); ==&#x003E;

             {{eucl,3,signature=0},

              {mink,4,signature=1}}

      make_tensor_belong_space(eps,mink); ==&#x003E; mink

      show_epsilons(); ==&#x003E; {{eps,mink},{ep,eucl}}

      eps(a,b,c,d); ==&#x003E;

             a b c d
          eps

      eps(e1,b,c,d); ==&#x003E;

         ***** some indices are not in the space of eps

      ep(e1,b,c,d); ==&#x003E;

         ***** bad number of indices for  (ep)  tensor

      ep(e1,b,c); ==&#x003E;

               b c e1
                                                                     

                                                                     
             ep


      ep(e1,e2,e3); ==&#x003E;

               e1 e2 e3
             ep
</pre>
<!--l. 1579--><p class="nopar" >
</p><!--l. 1581--><p class="noindent" >
</p>
<h5 class="subsubsectionHead"><a 
 id="x188-43600020.9.4"></a><span 
class="pcrr8t-x-x-109">DEL </span>generalized delta tensor</h5>
<a 
 id="dx188-436001"></a>
<!--l. 1583--><p class="noindent" >The generalized delta function comes from the contraction of two epsilons. It is totally
antisymmetric. Suppose its name has been chosen to be \(\mathrm {gd}\), that the space to which it is
attached has dimension n while the name of the chosen delta tensor is \(\delta \), then one can
deﬁne it as follows: \[ \mathrm {gd}^{a_1,a_2,\ldots ,a_n}_{b_1,b_2,\ldots , b_n}= \left |\begin {array}{cccc} \delta ^{a_1}_{b_1} &amp; \delta ^{a_1}_{b_2} &amp; \ldots &amp; \delta ^{a_1}_{b_n} \\ \delta ^{a_2}_{b_1} &amp; \delta ^{a_2}_{b_2} &amp; \ldots &amp; \delta ^{a_2}_{b_n} \\ \vdots &amp; \vdots &amp; \ddots &amp; \vdots \\ \delta ^{a_n}_{b_1} &amp; \delta ^{a_n}_{b_1} &amp; \ldots &amp; \delta ^{a_n}_{b_1} \end {array} \right | \] It is, in general uneconomical to explicitly write that determinant
except for particular <span 
class="ptmri8t-x-x-109">numeric </span>values of the indices <a 
 id="dx188-436002"></a><a 
 id="dx188-436003"></a><a 
 id="dx188-436004"></a> or when almost all upper
and lower indices are recognized as dummy indices. In the sample run below,
<span 
class="pcrr8t-x-x-109">gd </span>is deﬁned as the generalized delta function in the default space. The main
automatic evaluations are illustrated. The indices which are summed over are always
simpliﬁed:
                                                                     

                                                                     
</p>
<pre class="verbatim" id="verbatim-749">
      onespace ? ==&#x003E; yes

      make_partic_tens(delta,delta); ==&#x003E; t

      make_partic_tens(gd,del); ==&#x003E; t

  % immediate simplifications:

      gd(1,2,-3,-4); ==&#x003E; 0

      gd(1,2,-1,-2); ==&#x003E; 1

      gd(1,2,-2,-1); ==&#x003E; -1   % antisymmetric

      gd(a,b,-a,-b);

             ==&#x003E; dim*(dim - 1) % summed over dummy indices

      gd(a,b,c,-a,-d,-e); ==&#x003E;

                    b c
                  gd    *(dim - 2)
                    d e

      gd(a,b,c,-a,-d,-c); ==&#x003E;

                       b      2
                  delta  *(dim  - 3*dim + 2)
                       d

  % no simplification:

      gd(a,b,c,-d,-e,-f); ==&#x003E;

                    a b c
                  gd
                    d e f
</pre>
                                                                     

                                                                     
<!--l. 1646--><p class="nopar" > One can force evaluation in terms of the determinant in all cases. <a 
 id="switch:EXDELT"></a> To this end, the switch
<a 
 id="dx188-436005"></a><a 
 id="dx188-436006"></a><a 
 id="dx188-436007"></a><span 
class="pcrr8t-x-x-109">exdelt </span>is provided. It is initially <span 
class="pcrr8t-x-x-109">OFF</span>. Switching it <span 
class="pcrr8t-x-x-109">ON </span>will most often give
inconveniently large outputs:
                                                                     

                                                                     
</p>
<pre class="verbatim" id="verbatim-750">
      on exdelt;

      gd(a,b,c,-d,-e,-f); ==&#x003E;

           a       b       c         a       b       c
      delta  *delta  *delta   - delta  *delta  *delta
           d       e       f         d       f       e

              a       b       c         a       b       c
       - delta  *delta  *delta   + delta  *delta  *delta
              e       d       f         e       f       d

              a       b       c         a       b       c
       + delta  *delta  *delta   - delta  *delta  *delta
              f       d       e         f       e       d
</pre>
<!--l. 1667--><p class="nopar" > In a multi-space environment, it is never necessary to deﬁne several such tensor. The
reason is that <a 
 id="dx188-436008"></a><span 
class="pcrr8t-x-x-109">canonical </span>uses it always from the contraction of a pair of
<span 
class="pcrr8t-x-x-109">epsilon</span>-like tensors. Therefore the control of indices is already done, the
space-dimension in which <span 
class="pcrr8t-x-x-109">del </span>is working is also well deﬁned.
</p><!--l. 1674--><p class="noindent" >
</p>
<h5 class="subsubsectionHead"><a 
 id="x188-43700020.9.4"></a><span 
class="pcrr8t-x-x-109">METRIC </span>tensors</h5>
<a 
 id="dx188-437001"></a>
<!--l. 1676--><p class="noindent" >Very often, one has to deﬁne a speciﬁc metric. The <span 
class="pcrr8t-x-x-109">metric</span>-type of tensors include all
generic properties. The ﬁrst one is their symmetry, the second one is their equality to
the <span 
class="pcrr8t-x-x-109">delta</span><a 
 id="dx188-437002"></a> tensor when they get mixed indices, the third one is their optional
bloc-diagonality. So, a metric (generic) tensor is generated by the declaration
<a 
 id="dx188-437003"></a>
  </p><div class="syntax">
   <span 
class="pcrr8t-x-x-109">make_partic_tens</span>(\(\langle \)<span 
class="ptmri8t-x-x-109">tensor-name</span>\(\rangle \),metric);</div>
<!--l. 1685--><p class="noindent" >By default, when one is working in a multi-space environment, it is deﬁned in
                                                                     

                                                                     
<span 
class="pcrr8t-x-x-109">wholespace</span><a 
 id="dx188-437004"></a> One uses the usual means of REDUCE to give it speciﬁc values. In
particular, the metric ’delta’ tensor of the euclidian space can be deﬁned that way.
Implicit or explicit dependences on variables are allowed. Here is an illustration in the
single space environment:
                                                                     

                                                                     
</p>
<pre class="verbatim" id="verbatim-751">
      make_partic_tens(g,metric); ==&#x003E; t

      make_partic_tens(delt,delta); ==&#x003E; t

      onespace ?; ==&#x003E; yes

      g(a,b); ==&#x003E;

                 a b
                g

      g(b,a); ==&#x003E;

                 a b
                g

      g(a,b,c); ==&#x003E;

        ***** bad choice of indices for a METRIC tensor


      g(a,b,{x,y}); ==&#x003E;

                  a b
                g    (x,y)

      g(a,-b,{x,z}); ==&#x003E;

                    a
                delt
                    b


      let g({x,y},1,1)=1/2(x+y);


      g({x,y},1,1); ==&#x003E;

                                                                     

                                                                     
                 x + y
                -------
                   2


      rem_value_tens g({x,y},1,1);


      g({x,y},1,1); ==&#x003E;

                 1 1
               g    (x,y)
</pre>
<!--l. 1743--><p class="nopar" >
</p><!--l. 1745--><p class="noindent" >
</p>
<h4 class="subsectionHead"><span class="titlemark">20.9.5    </span> <a 
 id="x188-43800020.9.5"></a>The simpliﬁcation function <span 
class="pcrr8t-x-x-109">canonical</span></h4>
<a 
 id="dx188-438001"></a>
<!--l. 1748--><p class="noindent" >
</p>
<h5 class="subsubsectionHead"><a 
 id="x188-43900020.9.5"></a>Tensor expressions</h5>
<a 
 id="dx188-439001"></a>
<a 
 id="dx188-439002"></a>
<!--l. 1751--><p class="noindent" >Up to now, we have described the behaviour of individual tensors and how they simplify
themselves whenever possible. However, this is far from being suﬃcient. In general, one
is to deal with objects which involve several tensors together with various dummy
summations between them. We deﬁne a tensor expression as an arbitrary multivariate
polynomial. The indeterminates of such a polynomial may be either an indexed object, an
operator, a variable or a rational number. A tensor-type indeterminate cannot
appear to a degree larger than one except if it is a trace<a 
 id="dx188-439003"></a><a 
 id="dx188-439004"></a>. The following is a tensor
expression:
                                                                     

                                                                     
</p>
<pre class="verbatim" id="verbatim-752">
   aa:= delt({x - y})*delt(a, - g)*delt(d, - g)*delt(g, -r)

         *eps( - d, - e, - f)*eps(a,b,c)*op(x,y) + 1; ==&#x003E;


                                a      d      g
          aa := delt(x - y)*delt  *delt  *delt  *eps
                                g      g      r     d e f


                    a b c
                *eps     *op(x,y) + 1
</pre>
<!--l. 1776--><p class="nopar" > In the above expression, <span 
class="pcrr8t-x-x-109">delt </span>and <span 
class="pcrr8t-x-x-109">eps </span>are, respectively, the <span 
class="pcrr8t-x-x-109">delta</span><a 
 id="dx188-439005"></a> and the <span 
class="pcrr8t-x-x-109">epsilon</span><a 
 id="dx188-439006"></a>
tensors, <span 
class="pcrr8t-x-x-109">op </span>is an operator<a 
 id="dx188-439007"></a>. and <span 
class="pcrr8t-x-x-109">delt(x-y) </span>is the Dirac delta function.<a 
 id="dx188-439008"></a> Notice that the
above expression is not cohérent since the ﬁrst term has a variance while the
second term is a scalar. Moreover, the dummy index <span 
class="pcrr8t-x-x-109">g </span>appears <span 
class="ptmri8t-x-x-109">three </span>times in the
ﬁrst term. In fact, on input, each factor is simpliﬁed and each factor is checked
for coherence not more. Therefore, if a dummy summation appears inside one
factor, it will be done whenever possible. Hereunder <span 
class="pcrr8t-x-x-109">delt(a,-a) </span>is summed
over:<a 
 id="dx188-439009"></a>
                                                                     

                                                                     
</p>
<pre class="verbatim" id="verbatim-753">
   sub(g=a,aa); ==&#x003E;

                          a      d              a b c
          delt(x - y)*delt  *delt  *eps     *eps
                          r      a     d e f

                    *op(x,y)*dim + 1
</pre>
<!--l. 1797--><p class="nopar" >
</p><!--l. 1799--><p class="noindent" >
</p>
<h5 class="subsubsectionHead"><a 
 id="x188-44000020.9.5"></a>The use of <span 
class="pcrr8t-x-x-109">canonical</span></h5>
<a 
 id="dx188-440001"></a>
<!--l. 1801--><p class="noindent" ><span 
class="pcrr8t-x-x-109">canonical </span>is an oﬀspring of the function with the same name of the package
<span 
class="ptmrc8t-x-x-109">D<span 
class="small-caps">U</span><span 
class="small-caps">M</span><span 
class="small-caps">M</span><span 
class="small-caps">Y</span></span><a 
 id="dx188-440002"></a>. It applies to tensor expressions as deﬁned above. When it acts, this functions
has several features which are worth to realise:
     </p><ol  class="enumerate1" >
<li 
  class="enumerate" id="x188-440004x1">
     <!--l. 1807--><p class="noindent" >It tracks the free indices in each term and checks their identity. It identiﬁes
     and verify the coherence of the various dummy index summations<a 
 id="dx188-440005"></a>.
     </p></li>
<li 
  class="enumerate" id="x188-440007x2">
     <!--l. 1810--><p class="noindent" >Dummy indices summations are done on tensor products whenever possible
     since it recognises the particular tensors deﬁned above or deﬁned by the user.
     </p></li>
<li 
  class="enumerate" id="x188-440009x3">
     <!--l. 1813--><p class="noindent" >It  seeks  a  canonical  form  for  the  various  simpliﬁed  terms,  makes  the
     comparison  between  them.  In  that  way  it  maximises  simpliﬁcations  and
                                                                     

                                                                     
     generates a canonical form for the output polynomial.</p></li></ol>
<!--l. 1818--><p class="noindent" >Its capabilities have been extended in four directions: </p>
     <ul class="itemize1">
     <li class="itemize">
     <!--l. 1820--><p class="noindent" >It is able to work within <span 
class="ptmri8t-x-x-109">several </span>spaces<a 
 id="dx188-440010"></a><a 
 id="dx188-440011"></a>.
     </p></li>
     <li class="itemize">
     <!--l. 1822--><p class="noindent" >It manages correctly expressions where formal tensor <span 
class="ptmri8t-x-x-109">derivatives </span>are present<span class="footnote-mark"><a 
href="manual191.html#fn19x20"><sup class="textsuperscript">19</sup></a></span><a 
 id="x188-440012f19"></a> .
     </p></li>
     <li class="itemize">
     <!--l. 1825--><p class="noindent" >It takes into account all symmetries even if partial.
     </p></li>
     <li class="itemize">
     <!--l. 1826--><p class="noindent" >As          its          parent          function,          it          can          deal          with
     non-commutative and anticommutative indexed objects<a 
 id="dx188-440014"></a><a 
 id="dx188-440015"></a>. So, Indexed objects
     may be spinors<a 
 id="dx188-440016"></a><a 
 id="dx188-440017"></a> or quantum ﬁelds.</p></li></ul>
<!--l. 1832--><p class="noindent" >We describe most of these features in the rest of this documentation.
</p>
<h5 class="subsubsectionHead"><a 
 id="x188-44100020.9.5"></a>Check of tensor indices</h5>
<a 
 id="dx188-441001"></a>
<a 
 id="dx188-441002"></a>
<!--l. 1838--><p class="noindent" >Dummy indices for individual tensors are kept in the memory of the system. If they are
badly distributed over several tensors, it is <span 
class="pcrr8t-x-x-109">canonical </span>which gives an error
message:
                                                                     

                                                                     
</p>
<pre class="verbatim" id="verbatim-754">
      tensor te,tf; ==&#x003E; t

      bb:=te(a,b,b)*te(-b); ==&#x003E;

                         a b b
             bb := te *te
                     b


      canonical bb; ==&#x003E;

      ***** ((b)(a b b)) are inconsistent lists of indices


      aa:=te(b,-c)*tf(b,-c); ==&#x003E;

                     b     b
             aa := te   *tf     % b and c are free.
                       c     c

      canonical aa; ==&#x003E;

               b     b
             te   *tf
                 c     c

      bb:=te(a,c,b)*te(-b)*tf(a)$


      canonical bb; ==&#x003E;


               a c     b   a
             te     *te *tf
                   b

      delt(a,-a); ==&#x003E; dim  % a is now a dummy index

                                                                     

                                                                     

      canonical bb; ==&#x003E;

             ***** wrong use of indices (a)
</pre>
<!--l. 1884--><p class="nopar" > The message of canonical is clear, the ﬁrst sublist contains the list of all lower indices,
and the second one the list of all upper indices. The index <span 
class="pcrr8t-x-x-109">b </span>is repeated <span 
class="ptmri8t-x-x-109">three </span>times. In
the second example, <span 
class="pcrr8t-x-x-109">b </span>and <span 
class="pcrr8t-x-x-109">c </span>are considered as free indices, so they may be repeated. The
last example shows the interference between the check on individual tensors and the one
of canonical. The use of <span 
class="pcrr8t-x-x-109">a </span>as dummy index inside <span 
class="pcrr8t-x-x-109">delt </span>does no longer allow <span 
class="pcrr8t-x-x-109">a </span>to be
used as a free index in expression <span 
class="pcrr8t-x-x-109">bb</span>. To be usable, one must explicitly remove it as
dummy index using <span 
class="pcrr8t-x-x-109">rem_dummy_indices</span><a 
 id="dx188-441003"></a>. In the fourth example there are no
problems as <span 
class="pcrr8t-x-x-109">b </span>and <span 
class="pcrr8t-x-x-109">c </span>are both <span 
class="ptmri8t-x-x-109">free </span>indices. <span 
class="pcrr8t-x-x-109">canonical</span><a 
 id="dx188-441004"></a> checks that in a tensor
polynomial all do possess the <span 
class="ptmri8t-x-x-109">same </span>variance:
                                                                     

                                                                     
</p>
<pre class="verbatim" id="verbatim-755">
      aa:=te(a,c)+x^2; ==&#x003E;

                     a c    2
             aa := te    + x

      canonical aa; ==&#x003E;

             ***** scalar added with tensor(s)

      aa:=te(a,b)+tf(a,c); ==&#x003E;

                     a b     a c
             aa := te    + tf

      canonical aa; ==&#x003E;

            ***** mismatch in free indices :  ((a c) (a b))
</pre>
<!--l. 1918--><p class="nopar" > In the message the ﬁrst two lists of incompatible indices are explicitly indicated. So, it is
not an exhaustive message and a more complete correction may be needed.
Of course, no message of that kind appears if the indices are inside ordinary
operators<span class="footnote-mark"><a 
href="manual192.html#fn20x20"><sup class="textsuperscript">20</sup></a></span><a 
 id="x188-441005f20"></a> 
                                                                     

                                                                     
</p>
<pre class="verbatim" id="verbatim-756">
      dummy_names b; ==&#x003E; t

      cc:=op(b)*op(a,b,b); ==&#x003E; cc := op(a,b,b)*op(b)

      canonical cc; ==&#x003E; op(a,b,b)*op(b)

      clear_dummy_names; ==&#x003E; t
</pre>
<!--l. 1933--><p class="nopar" >
</p>
<h5 class="subsubsectionHead"><a 
 id="x188-44200020.9.5"></a>Position and renaming of dummy indices</h5>
<a 
 id="dx188-442001"></a>
<a 
 id="dx188-442002"></a>
<a 
 id="dx188-442003"></a>
<!--l. 1939--><p class="noindent" >For a speciﬁc tensor, contravariant dummy indices are place in front of covariant ones.
This already leads to some useful simpliﬁcations. For instance:
                                                                     

                                                                     
</p>
<pre class="verbatim" id="verbatim-757">
      pp:=te(a,-a)+te(-a,a)+1; ==&#x003E;

                    a     a
          pp := te    + te    + 1
                  a         a

      canonical pp; ==&#x003E;

              a
          2*te    + 1
                a

      pp:=te(a,-a)+te(-b,b); ==&#x003E;

                    b     a
          pp := te    + te
                  b         a


      canonical pp; ==&#x003E;

              a
          2*te
                a


        pp:=te(r,a,c,d,-a,f)+te(r,-b,c,d,b,f); ==&#x003E;

                    r   c d b f     r a c d   f
            pp := te            + te
                      b                     a

   canonical pp; ==&#x003E;


              r a c d   f
          2*te
                      a
                                                                     

                                                                     
</pre>
<!--l. 1981--><p class="nopar" > In the second and third example, there is also a renaming of the dummy variable <span 
class="pcrr8t-x-x-109">b </span>whih
becomes <span 
class="pcrr8t-x-x-109">a</span>. There is a loophole at this point. For some expressions one will
never reach a stable expression. This is the case for the following very simple
monom:
                                                                     

                                                                     
</p>
<pre class="verbatim" id="verbatim-758">
      tensor nt; ==&#x003E; t

      a1:=nt(-a,d)*nt(-c,a); ==&#x003E;

                 d     a
             nt   *nt
               a     c

      canonical a1; ==&#x003E;


                     a d
             nt   *nt
               c a

      a12:=a1-canonical a1; ==&#x003E;

                        d     a           a d
             a12 := nt   *nt    - nt   *nt
                      a     c       c a


      canonical a12; ==&#x003E;


                 d     a           a d
           - nt   *nt    + nt   *nt   % changes sign.
               a     c       c a
</pre>
<!--l. 2016--><p class="nopar" > In the above example, no canonical form can be reached. When applied twice on the
tensor monom <span 
class="pcrr8t-x-x-109">a1 </span>it gives back <span 
class="pcrr8t-x-x-109">a1</span>!
</p><!--l. 2020--><p class="noindent" >No change of dummy index position is allowed if a tensor belongs to an <span 
class="pcrr8t-x-x-109">affine</span><a 
 id="dx188-442004"></a><a 
 id="dx188-442005"></a> space.
With the tensor polynomial <span 
class="pcrr8t-x-x-109">pp </span>introduced above one has: <a 
 id="dx188-442006"></a>
                                                                     

                                                                     
</p>
<pre class="verbatim" id="verbatim-759">
      off onespace;

      define_spaces aff={dd,affine}; ==&#x003E; t

      make_tensor_belong_space(te,aff); ==&#x003E; aff

      mk_ids_belong_space({a,b},aff); ==&#x003E; t

      canonical pp; ==&#x003E;

               r   c d a f     r a c d   f
             te            + te
                 a                     a
</pre>
<!--l. 2040--><p class="nopar" > The renaming of <span 
class="pcrr8t-x-x-109">b </span>has been made however.
</p><!--l. 2043--><p class="noindent" >
</p>
<h5 class="subsubsectionHead"><a 
 id="x188-44300020.9.5"></a>Contractions and summations with particular tensors</h5>
<a 
 id="dx188-443001"></a>
<a 
 id="dx188-443002"></a>
<!--l. 2047--><p class="noindent" >This is a central part of the extension of <span 
class="pcrr8t-x-x-109">canonical</span>. The required contractions and
summations can be done in a multi-space environment as well in a single space
environment. </p>
<div class="center" 
>
<!--l. 2050--><p class="noindent" >
</p><!--l. 2051--><p class="noindent" >The case of <span 
class="pcrr8t-x-x-109">delta</span><a 
 id="dx188-443003"></a></p></div>
<!--l. 2053--><p class="noindent" >Dummy indices are recognized contracted and summed over whenever possible:
                                                                     

                                                                     
</p>
<pre class="verbatim" id="verbatim-760">
      aa:=delt(a,-b)*delt(b,-c)*delt(c,-a) + 1; ==&#x003E;

                       a      b      c
             aa := delt  *delt  *delt   + 1
                       b      c      a

      canonical aa; ==&#x003E; dim + 1

      aa:=delt(a,-b)*delt(b,-c)*delt(c,-d)*te(d,e)$

      canonical aa; ==&#x003E;

               a e
             te
</pre>
<!--l. 2069--><p class="nopar" > <span 
class="pcrr8t-x-x-109">canonical </span>will not attempt to make contraction with dummy indices included inside
ordinary operators: <a 
 id="dx188-443004"></a>
                                                                     

                                                                     
</p>
<pre class="verbatim" id="verbatim-761">
      operator op;

      aa:=delt(a,-b)*op(b,b)$


      canonical aa; ==&#x003E;

                a
            delt  *op(b,b)
                b

      dummy_names b; ==&#x003E; t

      canonical aa; ==&#x003E;

               a
          delta  *op(b,b)
               b
</pre>
<!--l. 2092--><p class="nopar" > </p>
<div class="center" 
>
<!--l. 2093--><p class="noindent" >
</p><!--l. 2094--><p class="noindent" >The case of <span 
class="pcrr8t-x-x-109">eta</span><a 
 id="dx188-443005"></a></p></div>
<!--l. 2096--><p class="noindent" >First, we introduce <span 
class="pcrr8t-x-x-109">eta</span>:
                                                                     

                                                                     
</p>
<pre class="verbatim" id="verbatim-762">
      make_partic_tens(eta,eta); ==&#x003E; t

      signature 1; ==&#x003E; 1 % necessary

      aa:=delta(a,-b)*eta(b,c); ==&#x003E;

                       a     b c
             aa := delt  *eta
                       b

      canonical aa; ==&#x003E;

                a c
             eta


      canonical(eta(a,b)*eta(-b,c)); ==&#x003E;

                a c
             eta


      canonical(eta(a,b)*eta(-b,-c)); ==&#x003E;

                 a
             delt
                 c

      canonical(eta(a,b)*eta(-b,-a)); ==&#x003E; dim

      canonical (eta(-a,-b)*te(d,-e,f,b)); ==&#x003E;

               d   f
             te
                 e   a


      aa:=eta(a,b)*eta(-b,-c)*te(-a,c)+1; ==&#x003E;
                                                                     

                                                                     

                             a b     c
             aa := eta   *eta   *te    + 1
                      b c          a

      canonical aa; ==&#x003E;

               a
             te    + 1
                 a

      aa:=eta(a,b)*eta(-b,-c)*delta(-a,c)+

          1+eta(a,b)*eta(-b,-c)*te(-a,c)$


      canonical aa; ==&#x003E;

               a
             te    + dim + 1
                 a
</pre>
<!--l. 2157--><p class="nopar" > Let us add a generic metric <a 
 id="dx188-443006"></a><a 
 id="dx188-443007"></a> tensor:
                                                                     

                                                                     
</p>
<pre class="verbatim" id="verbatim-763">
      aa:=g(a,b)*g(-b,-d); ==&#x003E;

                         a b
             aa := g   *g
                    b d

      canonical aa; ==&#x003E;

                 a
             delt
                 d

      aa:=g(a,b)*g(c,d)*eta(-c,-e)*eta(e,f)*te(-f,g); ==&#x003E;

                             e f  a b  c d     g
             aa := eta   *eta   *g   *g   *te
                      c e                    f

      canonical aa; ==&#x003E;

              a b   d g
             g   *te
</pre>
<!--l. 2183--><p class="nopar" > </p>
<div class="center" 
>
<!--l. 2184--><p class="noindent" >
</p><!--l. 2185--><p class="noindent" >The case of <span 
class="pcrr8t-x-x-109">epsilon</span><a 
 id="dx188-443008"></a><a 
 id="dx188-443009"></a></p></div>
<!--l. 2187--><p class="noindent" >The epsilon tensor plays an important role in many contexts. <span 
class="pcrr8t-x-x-109">canonical </span>realises the
contraction of two epsilons if and only if they belong to the same space. The proper use
of <span 
class="pcrr8t-x-x-109">canonical</span> on expressions which contains it requires a preliminary deﬁnition of the
tensor <span 
class="pcrr8t-x-x-109">DEL</span>. When the signature<a 
 id="dx188-443010"></a> is 0; the contraction of two epsilons gives a <span 
class="pcrr8t-x-x-109">del</span>-like
tensor. When the signature is equal to 1, it is equal to <span 
class="ptmri8t-x-x-109">minus </span>a <span 
class="pcrr8t-x-x-109">del</span>-like tensor. Here we
choose 1 for the signature<a 
 id="dx188-443011"></a><a 
 id="dx188-443012"></a> and we work in a single space<a 
 id="dx188-443013"></a>. <a 
 id="dx188-443014"></a><a 
 id="dx188-443015"></a> We deﬁne the <span 
class="pcrr8t-x-x-109">del</span>
tensor:
                                                                     

                                                                     
</p>
<pre class="verbatim" id="verbatim-764">
      on onespace;

      wholespace_dim dim; ==&#x003E; dim

      make_partic_tens(gd,del); ==&#x003E; t

      signature 1; ==&#x003E; 1
</pre>
<!--l. 2209--><p class="nopar" > We deﬁne the <span 
class="pcrr8t-x-x-109">epsilon </span>tensor and show how <span 
class="pcrr8t-x-x-109">canonical </span>contracts expression containing
<span 
class="ptmri8t-x-x-109">two</span><span class="footnote-mark"><a 
href="manual193.html#fn21x20"><sup class="textsuperscript">21</sup></a></span><a 
 id="x188-443016f21"></a> 
of them:
                                                                     

                                                                     
</p>
<pre class="verbatim" id="verbatim-765">
      aa:=eps(a,b)*eps(-c,-d); ==&#x003E;

                             a b
             aa := eps   *eps
                      c d

      canonical aa; ==&#x003E;

                  a b
              - gd
                  c d


      aa:=eps(a,b)*eps(-a,-b); ==&#x003E;

                             a b
             aa := eps   *eps
                      a b

      canonical aa; ==&#x003E; dim*( - dim + 1)

      on exdelt;

      gd(-a,-b,a,b); ==&#x003E; dim*(dim - 1)

      aa:=eps(a,b,c)*eps(-b,-d,-e)$

      canonical aa; ==&#x003E;

                 a      c              a      c
             delt  *delt  *dim - 2*delt  *delt  -
                 d      e              d      e

                   a      c              a       c
             - delt  *delt  *dim + 2*delt  * delt
                   e      d              e       d
</pre>
<!--l. 2254--><p class="nopar" > Several expressions which contain the epsilon tensor together with other special tensors
                                                                     

                                                                     
are given below as examples to treat with <span 
class="pcrr8t-x-x-109">canonical</span>:
                                                                     

                                                                     
</p>
<pre class="verbatim" id="verbatim-766">
      aa:=eps( - b, - c)*eta(a,b)*eta(a,c); ==&#x003E;

                       a b    a c
             eps   *eta   *eta
                b c

      canonical aa; ==&#x003E; 0

      aa:=eps(a,b,c)*te(-a)*te(-b); ==&#x003E; % te is generic.

                      a b c
             aa := eps     *te *te
                              a   b

      canonical aa; ==&#x003E; 0

      tensor tf,tg;

      aa:=eps(a,b,c)*te(-a)*tf(-b)*tg(-c)

          + eps(d,e,f)*te(-d)*tf(-e)*tg(-f); ==&#x003E;

       canonical aa; ==&#x003E;

                  a b c
             2*eps     *te *tf *tg
                          a   b   c

      aa:=eps(a,b,c)*te(-a)*tf(-c)*tg(-b)

          + eps(d,e,f)*te(-d)*tf(-e)*tg(-f)$

   canonical aa; ==&#x003E; 0
</pre>
<!--l. 2292--><p class="nopar" > Since <a 
 id="dx188-443017"></a><span 
class="pcrr8t-x-x-109">canonical </span>is able to work inside several spaces, we can introduce also several
epsilons and make the relevant simpliﬁcations on each (sub)-spaces. This is the goal of
the next illustration. <a 
 id="dx188-443018"></a><a 
 id="dx188-443019"></a>
                                                                     

                                                                     
</p>
<pre class="verbatim" id="verbatim-767">
      off onespace;

      define_spaces wholespace=

                        {dim,signature=1}; ==&#x003E; t

      define_spaces subspace=

                         {3,signature=0}; ==&#x003E; t

      show_spaces(); ==&#x003E;

             {{wholespace,dim,signature=1},

              {subspace,3,signature=0}}

      make_partic_tens(eps,epsilon); ==&#x003E; t

      make_partic_tens(kap,epsilon); ==&#x003E; t

      make_tensor_belong_space(eps,wholespace);

                              ==&#x003E; wholespace

      make_tensor_belong_space(kap,subspace);

                              ==&#x003E; subspace

      show_epsilons(); ==&#x003E;

                   {{eps,wholespace},{kap,subspace}}

      off exdelt;

      aa:=kap(a,b,c)*kap(-d,-e,-f)*eps(i,j)*eps(-k,-l)$

      canonical aa; ==&#x003E;

                                                                     

                                                                     
                  a b c    i j
              - gd      *gd
                  d e f    k l
</pre>
<!--l. 2340--><p class="nopar" > If there are no index summation, as in the expression above, one can develop both terms
into the delta tensor with <span 
class="pcrr8t-x-x-109">exdelt</span><a 
 id="dx188-443020"></a><a 
 id="dx188-443021"></a><a 
 id="dx188-443022"></a> switched ON. In fact, the previous calculation is
correct <span 
class="ptmri8t-x-x-109">only if there are no dummy index </span>inside the two <span 
class="pcrr8t-x-x-109">gd</span>’s. If some of the indices are
dummy, then we must take care of the respective spaces in which the two <span 
class="pcrr8t-x-x-109">gd </span>tensors are
considered. Since, the tensor themselves do not belong to a given space, the space
identiﬁcation can only be made through the indices. This is enough since the <span 
class="pcrr8t-x-x-109">delta</span>-like
tensor is bloc-diagonal. With <span 
class="pcrr8t-x-x-109">aa </span>the result of the above illustration, one gets, for
example,: <a 
 id="dx188-443023"></a><a 
 id="dx188-443024"></a> <a 
 id="dx188-443025"></a>
                                                                     

                                                                     
</p>
<pre class="verbatim" id="verbatim-768">
      mk_ids_belong_space({a,b,c,d,e,f},wholespace)$

      mk_ids_belong_space({i,j,k,l},subspace)$

      sub(d=a,e=b,k=i,aa); ==&#x003E;

                   c      j         2
             2*delt  *delt  *( - dim  + 3*dim - 2)
                   f      l

      sub(k=i,l=j,aa); ==&#x003E;
                                   a b c
                            - 6*gd
                                   d e f
</pre>
<!--l. 2372--><p class="nopar" >
</p>
<h5 class="subsubsectionHead"><a 
 id="x188-44400020.9.5"></a><span 
class="pcrr8t-x-x-109">canonical </span>and symmetries</h5>
<a 
 id="dx188-444001"></a>
<a 
 id="dx188-444002"></a>
<!--l. 2378--><p class="noindent" >Most of the time, indexed objects have some symmetry property. When this property
is either full symmetry or antisymmetry, there is no diﬃculty to implement
it using the declarations <span 
class="pcrr8t-x-x-109">symmetric</span><a 
 id="dx188-444003"></a> or <a 
 id="dx188-444004"></a><span 
class="pcrr8t-x-x-109">antisymmetric </span>of REDUCE.
However, most often, indexed objects are neither fully symmetric nor fully
antisymmetric: they have <span 
class="ptmri8t-x-x-109">partial </span>or <span 
class="ptmri8t-x-x-109">mixed </span>symmetries<a 
 id="dx188-444005"></a><a 
 id="dx188-444006"></a> <a 
 id="dx188-444007"></a><a 
 id="dx188-444008"></a> . In the <span 
class="ptmrc8t-x-x-109">D<span 
class="small-caps">U</span><span 
class="small-caps">M</span><span 
class="small-caps">M</span><span 
class="small-caps">Y</span></span><a 
 id="dx188-444009"></a> package, the
declaration <a 
 id="dx188-444010"></a><span 
class="pcrr8t-x-x-109">symtree </span>allows to impose such type of symmetries on operators.
This command has been improved and extended to apply to tensors. In order to
illustrate it, we shall take the example of the wellknown Riemann <a 
 id="dx188-444011"></a><a 
 id="dx188-444012"></a> tensor in general
relativity. Let us remind the reader that this tensor has four indices. It is separately
<span 
class="ptmri8t-x-x-109">antisymmetric </span>with respect to the interchange of the ﬁrst two indices and with respect
to the interchange of the last two indices. It is <span 
class="ptmri8t-x-x-109">symmetric </span>with respect to the
interchange of the ﬁrst two and the last two indices. In the illustration below, we
show how to express this and how <span 
class="pcrr8t-x-x-109">canonical </span>is able to recognize mixed
symmetries:
                                                                     

                                                                     
</p>
<pre class="verbatim" id="verbatim-769">
      tensor r; ==&#x003E; t

      symtree(r,{!+,{!-,1,2},{!-,3,4}});

      rem_dummy_indices a,b,c,d; % free indices

      ra:=r(b,a,c,d); ==&#x003E;

                    b a c d
             ra := r

      canonical ra; ==&#x003E;

                 a b c d
              - r

      ra:=r(c,d,a,b); ==&#x003E;
                                    c d a b
                             ra := r

      canonical ra; ==&#x003E;

              a b c d
             r


     canonical r(-c,-d,a,b); ==&#x003E;

              a b
             r
                  c d

      r(-c,-c,a,b); ==&#x003E;  0


      ra:=r(-c,-d,c,b); ==&#x003E;

                        c b
                                                                     

                                                                     
             ra := r
                    c d

      canonical ra; ==&#x003E;

                 b c
              - r
                     c d
</pre>
<!--l. 2453--><p class="nopar" > In the last illustration, contravariant indices are placed in front of covariant indices and
the contravariant indices are transposed. The superposition of the two partial symmetries
gives a minus sign.
</p><!--l. 2458--><p class="noindent" >There exists an important (though natural) restriction on the use of SYMTREE which is
linked to the algorithm itself: Integer used to localize indices must start from 1, be
<span 
class="ptmri8t-x-x-109">contiguous </span>and monotoneously increasing. For instance, one is not allow to
introduce
                                                                     

                                                                     
</p>
<pre class="verbatim" id="verbatim-770">
      symtree(r,{!*,{!+,1,3},{!*,2,4}});

      symtree(r,{!*,{!+,1,2},{!*,4,5}};

      symtree(r,{!*,{!-,1,3},{!*,2}});
</pre>
<!--l. 2468--><p class="nopar" > but the subsequent declarations are allowed:
                                                                     

                                                                     
</p>
<pre class="verbatim" id="verbatim-771">
      symtree(r,{!*,{!+,1,2},{!*,3,4}});

      symtree(r,{!*,{!+,1,2},{!*,3,4,5}});

      symtree(r,{!*,{!-,1,2},{!*,3}});
</pre>
<!--l. 2476--><p class="nopar" > The ﬁrst declaration endows <span 
class="pcrr8t-x-x-109">r </span>with a <span 
class="ptmri8t-x-x-109">partial </span>symmetry with respect to the ﬁrst two
indices.
</p><!--l. 2480--><p class="noindent" >A side eﬀect of <span 
class="pcrr8t-x-x-109">symtree </span>is to restrict the number of indices of a generic tensor. For
instance, the second declaration in the above illustrations makes <span 
class="pcrr8t-x-x-109">r </span>depend on 5 indices as
illustrated below:
                                                                     

                                                                     
</p>
<pre class="verbatim" id="verbatim-772">
      symtree(r,{!*,{!+,1,2},{!*,3,4,5}});

      canonical r(-b,-a,d,c); ==&#x003E;

           ***** Index ‘5’ out of range for

                 ((minus b) (minus a) d c) in nth

      canonical r(-b,-a,d,c,e); ==&#x003E;

               d c e
          r                   % correct
           a b

      canonical r(-b,-a,d,c,e,g); ==&#x003E;

               d c e
          r          % The sixth index is forgotten!
           a b
</pre>
<!--l. 2503--><p class="nopar" > Finally, the function <span 
class="pcrr8t-x-x-109">remsym</span><a 
 id="dx188-444013"></a> applied on any tensor identiﬁer removes all symmetry
properties.
</p><!--l. 2507--><p class="noindent" >Another related question is the frequent need to symmetrize a tensor polynomial. To
fulﬁll it, the function <a 
 id="dx188-444014"></a><span 
class="pcrr8t-x-x-109">symmetrize </span>of the package <span 
class="ptmrc8t-x-x-109">A<span 
class="small-caps">S</span><span 
class="small-caps">S</span><span 
class="small-caps">I</span><span 
class="small-caps">S</span><span 
class="small-caps">T</span></span><a 
 id="dx188-444015"></a> has been improved and
generalised. For any kernel<a 
 id="dx188-444016"></a> (which may be either an operator or a tensor) that function
generates </p>
     <ul class="itemize1">
     <li class="itemize">
     <!--l. 2514--><p class="noindent" >the sum over the cyclic permutations of indices,
     </p></li>
     <li class="itemize">
     <!--l. 2515--><p class="noindent" >the symetric or antisymetric sums over all permutations of the indices.</p></li></ul>
<!--l. 2518--><p class="noindent" >Moreover, if it is given a list of indices, it generates a new list which contains sublists
which contain the relevant permutations of these indices
                                                                     

                                                                     
</p>
<pre class="verbatim" id="verbatim-773">
      symmetrize(te(x,y,z,{v}),te,cyclicpermlist); ==&#x003E;


             x y z         y z x         z x y
          te      (v) + te      (v) + te      (v)

      symmetrize(te(x,y),te,permutations); ==&#x003E;

               x y     y x
             te    + te

      symmetrize(te(x,y),te,permutations,perm_sign); ==&#x003E;

               x y     y x
             te    - te

      symmetrize(te(y,x),te,permutations,perm_sign); ==&#x003E;

               x y     y x
           - te    + te
</pre>
<!--l. 2542--><p class="nopar" > If one wants to symmetrise an expression which is not a kernel, one can also use
<span 
class="pcrr8t-x-x-109">symmetrize </span>to obtain the desired result as the next example shows:
                                                                     

                                                                     
</p>
<pre class="verbatim" id="verbatim-774">
      ex:=te(a,-b,c)*te1(-a,-d,-e); ==&#x003E;

                     a   c
             ex := te     *te1
                      b      a d e

      ll:=list(b,c,d,e)$ % the chosen relevant indices

      lls:=symmetrize(ll,list,cyclicpermlist); ==&#x003E;

         lls := {{b,c,d,e},{c,d,e,b},{d,e,b,c},{e,b,c,d}}

  % The sum over the cyclic permutations is:

   excyc:=for each i in lls sum

                   sub(b=i.1,c=i.2,d=i.3,e=i.4,ex);  ==&#x003E;


                 a   c              a   d
      excyc := te     *te1      + te     *te1
                   b      a d e       c      a e b


                   a   e              a   b
               + te     *te1      + te      *te1
                     d      a b c       e       a c d
</pre>
<!--l. 2574--><p class="nopar" >
</p><!--l. 2576--><p class="noindent" >
</p>
<h5 class="subsubsectionHead"><a 
 id="x188-44500020.9.5"></a><span 
class="pcrr8t-x-x-109">canonical </span>and tensor derivatives</h5>
                                                                     

                                                                     
<a 
 id="dx188-445001"></a>
<a 
 id="dx188-445002"></a>
<!--l. 2580--><p class="noindent" >Only ordinary (partial) derivatives are fully correctly handled by <span 
class="pcrr8t-x-x-109">canonical</span>.
This is enough, to explicitly construct covariant derivatives. We recognize here
that extensions should still be made. The subsequent illustrations show how
<span 
class="pcrr8t-x-x-109">canonical </span>does indeed manage to ﬁnd the canonical form and simplify expressions
which contain derivatives. Notice, the use of the (modiﬁed) <a 
 id="dx188-445003"></a><span 
class="pcrr8t-x-x-109">depend </span>command.
<a 
 id="dx188-445004"></a>
                                                                     

                                                                     
</p>
<pre class="verbatim" id="verbatim-775">
      on onespace;

      tensor te,x; ==&#x003E; t

      depend te,x;


      aa:=df(te(a,-b),x(-b))-df(te(a,-c),x(-c))$

      canonical aa; ==&#x003E; 0

      make_partic_tens(eta,eta); ==&#x003E;  t

      signature 1;

      aa:=df(te(a,-b),x(-b))$

      aa:=aa*eta(-a,-d);

                     a
          aa := df(te   ,x )*eta
                       b  b     a d

    canonical aa; ==&#x003E;

                 a  a
          df(te   ,x )
               d
</pre>
<!--l. 2617--><p class="nopar" > In the last example, after contraction, the covariant dummy index <span 
class="pcrr8t-x-x-109">b </span>has been
changed into the contravariant dummy index <span 
class="pcrr8t-x-x-109">a</span>. This is allowed since the space is
metric.
</p><!--l. 223--><p class="noindent" >
                                                                     

                                                                     
                                                                     

                                                                     
</p><!--l. 225--><p class="noindent" ><table cellspacing="5"><tr><td class="clinks"><a 
href="../manual-lookup.php%3FUser&#32;Contributed&#32;Packages.html#manualse132.html" >Up</a></td><td class="clinks"><a 
href="manualse133.html" >Next</a></td><td class="clinks"><a 
href="manualse131.html" >Prev</a></td><td class="clinks"><a 
href="manualse131.html#tailmanualse131.html" >PrevTail</a></td><td class="clinks"><a 
href="manualse132.html" >Front</a></td></tr></table><a 
 id="tailmanualse132.html"></a>   <hr> <p style="font-family:sans-serif">Hosted by <a href="https://sourceforge.net/p/reduce-algebra/"> <img title="Download REDUCE" alt="Download REDUCE" style="vertical-align:middle" src="https://sourceforge.net/sflogo.php?type=16&amp;group_id=248416"/></a> <a href="https://www.mathjax.org"> <img title="Powered by MathJax" alt="Powered by MathJax" style="float:right" src="https://www.mathjax.org/badge/badge.gif"/></a></p></p> 
</body> 
</html>