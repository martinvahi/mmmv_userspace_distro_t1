<!DOCTYPE html> 
<html lang="en-US" xml:lang="en-US" > 
<head><title>PHYSOP: Operator Calculus in Quantum Theory</title> 
<meta  charset="utf-8" /> 
<meta name="generator" content="TeX4ht (https://tug.org/tex4ht/)" /> 
<meta name="viewport" content="width=device-width,initial-scale=1" /> 
<link rel="stylesheet" type="text/css" href="manual.css" /> 
<meta name="src" content="manual.tex" /> 
<script>window.MathJax = { tex: { tags: "ams", }, }; </script> 
 <script type="text/javascript" async="async" id="MathJax-script" src="../../cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js"></script>  
<meta name="description" content="The REDUCE Computer Algebra System User's Manual" /> 
</head><body 
>
<header>REDUCE</header><table cellspacing="5"><tr><td class="clinks"><a 
href="../manual-lookup.php%3FUser&#32;Contributed&#32;Packages.html#manualse163.html" >Up</a></td><td class="clinks"><a 
href="manualse164.html" >Next</a></td><td class="clinks"><a 
href="manualse162.html" >Prev</a></td><td class="clinks"><a 
href="manualse162.html#tailmanualse162.html" >PrevTail</a></td><td class="clinks"><a 
href="manualse163.html#tailmanualse163.html">Tail</a></td></tr></table><h3 class="sectionHead"><span class="titlemark">20.40    </span> <a 
 id="x239-97800020.40"></a>PHYSOP: Operator Calculus in Quantum
Theory</h3>
<a 
 id="dx239-978001"></a>
<a 
 id="dx239-978002"></a>
<!--l. 829--><p class="noindent" >This package has been designed to meet the requirements of theoretical physicists
looking for a computer algebra tool to perform complicated calculations in quantum
theory with expressions containing operators. These operations consist mainly of the
calculation of commutators between operator expressions and in the evaluations of
operator matrix elements in some abstract space.
</p><!--l. 836--><p class="noindent" >Author: Mathias Warns.
<a 
 id="dx239-978003"></a>
<a 
 id="dx239-978004"></a>
</p><!--l. 4--><p class="noindent" >
</p>
<h4 class="subsectionHead"><span class="titlemark">20.40.1    </span> <a 
 id="x239-97900020.40.1"></a>Introduction</h4>
<!--l. 5--><p class="noindent" >The package <span 
class="ptmrc8t-x-x-109">P<span 
class="small-caps">H</span><span 
class="small-caps">Y</span><span 
class="small-caps">S</span><span 
class="small-caps">O</span><span 
class="small-caps">P</span> </span>has been designed to meet the requirements of theoretical
physicists looking for a computer algebra tool to perform complicated calculations in
quantum theory with expressions containing operators. These operations consist mainly
in the calculation of commutators between operator expressions and in the evaluations
of operator matrix elements in some abstract space. Since the capabilities of
the current REDUCE release to deal with complex expressions containing
noncommutative operators are rather restricted, the ﬁrst step was to enhance
these possibilities in order to achieve a better usability of REDUCE for these
kind of calculations. This has led to the development of a ﬁrst package called
NONCOM2 which is described in section 2. For more complicated expressions
involving both scalar quantities and operators the need for an additional data type
has emerged in order to make a clear separation between the various objects
present in the calculation. The implementation of this new REDUCE data type is
realized by the PHYSOP (for PHYSical OPerator) package described in section
3.
                                                                     

                                                                     
</p><!--l. 25--><p class="noindent" >
</p>
<h4 class="subsectionHead"><span class="titlemark">20.40.2    </span> <a 
 id="x239-98000020.40.2"></a>The NONCOM2 Package</h4>
<!--l. 27--><p class="noindent" >The package <span 
class="ptmrc8t-x-x-109">N<span 
class="small-caps">O</span><span 
class="small-caps">N</span><span 
class="small-caps">C</span><span 
class="small-caps">O</span><span 
class="small-caps">M</span>2 </span>redeﬁnes some standard REDUCE routines in order to
modify the way noncommutative operators are handled by the system. In standard
REDUCE declaring an operator to be noncommutative using the <span 
class="pcrr8t-x-x-109">noncom </span>statement
puts a global ﬂag on the operator. This ﬂag is checked when the system has to
decide whether or not two operators commute during the manipulation of an
expression.
</p><!--l. 35--><p class="noindent" >The <span 
class="ptmrc8t-x-x-109">N<span 
class="small-caps">O</span><span 
class="small-caps">N</span><span 
class="small-caps">C</span><span 
class="small-caps">O</span><span 
class="small-caps">M</span>2 </span>package redeﬁnes the <span 
class="pcrr8t-x-x-109">noncom</span><a 
 id="dx239-980001"></a> statement in a way more suitable for
calculations in physics. Operators have now to be declared noncommutative pairwise, i.e.
coding:
                                                                     

                                                                     
</p>
<pre class="verbatim" id="verbatim-1232">
NONCOM A,B;
</pre>
<!--l. 40--><p class="nopar" > declares the operators <span 
class="pcrr8t-x-x-109">A </span>and <span 
class="pcrr8t-x-x-109">B </span>to be noncommutative but allows them to commute
with any other (noncommutative or not) operator present in the expression. In a
similar way if one wants e.g. <span 
class="pcrr8t-x-x-109">A(X) </span>and <span 
class="pcrr8t-x-x-109">A(Y) </span>not to commute, one has now to
code:
                                                                     

                                                                     
</p>
<pre class="verbatim" id="verbatim-1233">
 NONCOM A,A;
</pre>
<!--l. 48--><p class="nopar" > Each operator gets a new property list containing the operators with which it does not
commute. A ﬁnal example should make the use of the redeﬁned <span 
class="pcrr8t-x-x-109">NONCOM </span>statement
clear:
                                                                     

                                                                     
</p>
<pre class="verbatim" id="verbatim-1234">
NONCOM A,B,C;
</pre>
<!--l. 56--><p class="nopar" > declares <span 
class="pcrr8t-x-x-109">A </span>to be noncommutative with <span 
class="pcrr8t-x-x-109">B </span>and <span 
class="pcrr8t-x-x-109">C</span>, <span 
class="pcrr8t-x-x-109">B </span>to be noncommutative with <span 
class="pcrr8t-x-x-109">A </span>and <span 
class="pcrr8t-x-x-109">C</span>
and <span 
class="pcrr8t-x-x-109">C </span>to be noncommutative with <span 
class="pcrr8t-x-x-109">A </span>and <span 
class="pcrr8t-x-x-109">B</span>. Note that after these declaration e.g. <span 
class="pcrr8t-x-x-109">A(X)</span>
and <span 
class="pcrr8t-x-x-109">A(Y) </span>are still commuting kernels.
</p><!--l. 65--><p class="noindent" >Finally to keep the compatibility with standard REDUCE   declaring a <span class="underline">single</span> identiﬁer
using the <span 
class="pcrr8t-x-x-109">NONCOM </span>statement has the same eﬀect as in standard REDUCE   i.e., the
identiﬁer is ﬂagged with the <span 
class="pcrr8t-x-x-109">NONCOM </span>tag.
</p><!--l. 70--><p class="noindent" >From the user’s point of view there are no other new commands implemented by the
package. Commutation relations have to be declared in the standard way as described in
the manual i.e. using <span 
class="pcrr8t-x-x-109">LET </span>statements. The package itself consists of several redeﬁned
standard REDUCE routines to handle the new deﬁnition of noncommutativity in
multiplications and pattern matching processes.
</p><!--l. 79--><p class="noindent" ><span 
class="ptmb8t-x-x-109">CAVEAT:  </span>Due to its nature, the package is highly version dependent. The current
version has been designed for the 3.3 and 3.4 releases of REDUCE and may not work
with previous versions. Some diﬀerent (but still correct) results may occur by using this
package in conjunction with <span 
class="pcrr8t-x-x-109">let </span>statements since part of the pattern matching routines
have been redesigned. The package has been designed to bridge a deﬁciency
of the current REDUCE version concerning the notion of noncommutativity
and it is the author’s hope that it will be made obsolete by a future release of
REDUCE.
</p><!--l. 91--><p class="noindent" >
</p>
<h4 class="subsectionHead"><span class="titlemark">20.40.3    </span> <a 
 id="x239-98100020.40.3"></a>The PHYSOP package</h4>
<!--l. 93--><p class="noindent" >The package <span 
class="ptmrc8t-x-x-109">P<span 
class="small-caps">H</span><span 
class="small-caps">Y</span><span 
class="small-caps">S</span><span 
class="small-caps">O</span><span 
class="small-caps">P</span> </span>implements a new REDUCE data type to perform calculations
with physical operators. The noncommutativity of operators is implemented
using the <span 
class="ptmrc8t-x-x-109">N<span 
class="small-caps">O</span><span 
class="small-caps">N</span><span 
class="small-caps">C</span><span 
class="small-caps">O</span><span 
class="small-caps">M</span>2 </span>package so this ﬁle should be loaded prior to the use of
<span 
class="ptmrc8t-x-x-109">P<span 
class="small-caps">H</span><span 
class="small-caps">Y</span><span 
class="small-caps">S</span><span 
class="small-caps">O</span><span 
class="small-caps">P</span></span><span class="footnote-mark"><a 
href="manual240.html#fn37x20"><sup class="textsuperscript">37</sup></a></span><a 
 id="x239-981001f37"></a> .
                                                                     

                                                                     
In the following the new commands implemented by the package are described. Beside
these additional commands, the full set of standard REDUCE instructions remains
available for performing any other calculation.
</p>
<h5 class="subsubsectionHead"><span class="titlemark">20.40.3.1    </span> <a 
 id="x239-98200020.40.3.1"></a>Type declaration commands</h5>
<!--l. 108--><p class="noindent" >The new REDUCE data type <span 
class="ptmrc8t-x-x-109">P<span 
class="small-caps">H</span><span 
class="small-caps">Y</span><span 
class="small-caps">S</span><span 
class="small-caps">O</span><span 
class="small-caps">P</span> </span>implemented by the package allows the deﬁnition
of a new kind of operators (i.e. kernels carrying an arbitrary number of arguments).
Throughout this manual, the name “operator” will refer, unless explicitly stated
otherwise, to this new data type. This data type is in turn divided into 5 subtypes. For
each of this subtype, a declaration command has been deﬁned:
     </p><dl class="description"><dt class="description">
     <!--l. 118--><p class="noindent" >
<span 
class="pcrr8t-x-x-109">SCALOP A;</span>  </p></dt><dd 
class="description">
     <!--l. 118--><p class="noindent" ><a 
 id="dx239-982001"></a> declares  <span 
class="pcrr8t-x-x-109">A </span>to  be  a  scalar  operator.  This  operator  may  carry  an  arbitrary
     number of arguments i.e. after the declaration:    <span 
class="pcrr8t-x-x-109">SCALOP A; </span>all kernels
     of  the  form  e.g. <span 
class="pcrr8t-x-x-109">A(J), A(1,N), A(N,L,M) </span>are  recognized  by  the
     system as being scalar operators.
     </p></dd><dt class="description">
     <!--l. 126--><p class="noindent" >
<span 
class="pcrr8t-x-x-109">VECOP V;</span>  </p></dt><dd 
class="description">
     <!--l. 126--><p class="noindent" ><a 
 id="dx239-982002"></a> declares  <span 
class="pcrr8t-x-x-109">V </span>to  be  a  vector  operator.  As  for  scalar  operators,  the  vector
     operators may carry an arbitrary number of arguments. For example <span 
class="pcrr8t-x-x-109">V(3)</span>
     can be used to represent the vector operator \(\vec {V}_{3}\). Note that the dimension of
     space in which this operator lives is <span class="underline">arbitrary</span>. One can however address a
     speciﬁc component of the vector operator by using a special index declared
     as  <span 
class="pcrr8t-x-x-109">PHYSINDEX </span>(see  below).  This  index  must  then  be  the  ﬁrst  in  the
     argument list of the vector operator.
     </p></dd><dt class="description">
     <!--l. 136--><p class="noindent" >
<span 
class="pcrr8t-x-x-109">TENSOP C(3);</span>  </p></dt><dd 
class="description">
     <!--l. 136--><p class="noindent" ><a 
 id="dx239-982003"></a> declares <span 
class="pcrr8t-x-x-109">C </span>to be a tensor operator of rank 3. Tensor operators of any ﬁxed
     integer rank larger than 1 can be declared. Again this operator may carry
     an arbitrary number of arguments and the space dimension is not ﬁxed. The
     tensor components can be addressed by using special <span 
class="pcrr8t-x-x-109">PHYSINDEX </span>indices
     (see below) which have to be placed in front of all other arguments in the
     argument list.
                                                                     

                                                                     
     </p></dd><dt class="description">
     <!--l. 147--><p class="noindent" >
<span 
class="pcrr8t-x-x-109">STATE U;</span>  </p></dt><dd 
class="description">
     <!--l. 147--><p class="noindent" ><a 
 id="dx239-982004"></a> declares <span 
class="pcrr8t-x-x-109">U </span>to be a state, i.e. an object on which operators have a certain
     action. The state U can also carry an arbitrary number of arguments.
     </p></dd><dt class="description">
     <!--l. 152--><p class="noindent" >
<span 
class="pcrr8t-x-x-109">PHYSINDEX X;</span>  </p></dt><dd 
class="description">
     <!--l. 152--><p class="noindent" ><a 
 id="dx239-982005"></a> declares <span 
class="pcrr8t-x-x-109">X </span>to be a special index which will be used to address components
     of vector and tensor operators.</p></dd></dl>
<!--l. 157--><p class="noindent" >It is very important to understand precisely the way how the type declaration commands
work in order to avoid type mismatch errors when using the <span 
class="ptmrc8t-x-x-109">P<span 
class="small-caps">H</span><span 
class="small-caps">Y</span><span 
class="small-caps">S</span><span 
class="small-caps">O</span><span 
class="small-caps">P</span> </span>package.
The following examples should illustrate the way the program interprets type
declarations. Assume that the declarations listed above have been typed in by the user,
then:
     </p><dl class="description"><dt class="description">
     <!--l. 164--><p class="noindent" >
\(\bullet \) </p></dt><dd 
class="description">
     <!--l. 164--><p class="noindent" ><span 
class="pcrr8t-x-x-109">A,A(1,N),A(N,M,K) </span>are SCALAR operators.
     </p></dd><dt class="description">
     <!--l. 165--><p class="noindent" >
\(\bullet \) </p></dt><dd 
class="description">
     <!--l. 165--><p class="noindent" ><span 
class="pcrr8t-x-x-109">V,V(3),V(N,M) </span>are VECTOR operators.
     </p></dd><dt class="description">
     <!--l. 166--><p class="noindent" >
\(\bullet \) </p></dt><dd 
class="description">
     <!--l. 166--><p class="noindent" ><span 
class="pcrr8t-x-x-109">C, C(5),C(Y,Z) </span>are TENSOR operators of rank 3.
     </p></dd><dt class="description">
     <!--l. 168--><p class="noindent" >
\(\bullet \) </p></dt><dd 
class="description">
     <!--l. 168--><p class="noindent" ><span 
class="pcrr8t-x-x-109">U,U(P),U(N,L,M) </span>are STATES.
     </p></dd><dt class="description">
     <!--l. 169--><p class="noindent" >
<span 
class="ptmb8t-x-x-109">BUT:</span> </p></dt><dd 
class="description">
                                                                     

                                                                     
     <!--l. 169--><p class="noindent" ><span 
class="pcrr8t-x-x-109">V(X),V(X,3),V(X,N,M) </span>are all <span class="underline">scalar</span> operators since the <span class="underline">special index</span>
     <span 
class="pcrr8t-x-x-109">X </span>addresses a speciﬁc component of the vector operator (which is a scalar
     operator).  Accordingly,  <span 
class="pcrr8t-x-x-109">C(X,X,X) </span>is  also  a  <span class="underline">scalar</span>  operator  because  the
     diagonal component \(C_{xxx}\) of the tensor operator <span 
class="pcrr8t-x-x-109">C </span>is meant here (C has rank 3 so
     3 special indices must be used for the components).</p></dd></dl>
<!--l. 180--><p class="noindent" >In view of these examples, every time the following text refers to <span class="underline">scalar</span> operators, it
should be understood that this means not only operators deﬁned by the <span 
class="pcrr8t-x-x-109">SCALOP</span>
statement but also components of vector and tensor operators. Depending on the
situation, in some case when dealing only with the components of vector or tensor
operators it may be preferable to use an operator declared with <span 
class="pcrr8t-x-x-109">SCALOP </span>rather than
addressing the components using several special indices (throughout the manual,
indices declared with the <span 
class="pcrr8t-x-x-109">PHYSINDEX </span>command are referred to as special
indices).
</p><!--l. 193--><p class="noindent" >Another important feature of the system is that for each operator declared using the
statements described above, the system generates 2 additional operators of the same
type: the <span class="underline">adjoint</span> and the <span class="underline">inverse</span> operator. These operators are accessible to the
user for subsequent calculations without any new declaration. The syntax is as
following:
</p><!--l. 200--><p class="noindent" >If <span 
class="pcrr8t-x-x-109">A </span>has been declared to be an operator (scalar, vector or tensor) the <span class="underline">adjoint</span> operator is
denoted <span 
class="pcrr8t-x-x-109">A!+ </span>and the <span class="underline">inverse</span> operator is denoted <span 
class="pcrr8t-x-x-109">A!-1 </span>(an inverse adjoint operator
<span 
class="pcrr8t-x-x-109">A!+!-1 </span>is also generated). The exclamation marks do not appear when these operators
are printed out by REDUCE (except when the switch <span 
class="pcrr8t-x-x-109">NAT </span>is set to oﬀ) but have to be
typed in when these operators are used in an input expression. An adjoint (but <span class="underline">no</span>
inverse) state is also generated for every state deﬁned by the user. One may
consider these generated operators as ”placeholders” which means that these
operators are considered by default as being completely independent of the
original operator. Especially if some value is assigned to the original operator,
this value is <span class="underline">not</span> automatically assigned to the generated operators. The user
must code additional assignement statements in order to get the corresponding
values.
</p><!--l. 220--><p class="noindent" >Exceptions from these rules are (i) that inverse operators are <span class="underline">always</span> ordered at the same
place as the original operators and (ii) that the expressions <span 
class="pcrr8t-x-x-109">A!-1*A </span>and <span 
class="pcrr8t-x-x-109">A*A!-1 </span>are
replaced<span class="footnote-mark"><a 
href="manual241.html#fn38x20"><sup class="textsuperscript">38</sup></a></span><a 
 id="x239-982006f38"></a> 
by the unit operator <span 
class="pcrr8t-x-x-109">UNIT</span><a 
 id="dx239-982007"></a>. This operator is deﬁned as a scalar operator during the
initialization of the <span 
class="ptmrc8t-x-x-109">P<span 
class="small-caps">H</span><span 
class="small-caps">Y</span><span 
class="small-caps">S</span><span 
class="small-caps">O</span><span 
class="small-caps">P</span> </span>package. It should be used to indicate the type of an
operator expression whenever no other PHYSOP occur in it. For example, the following
sequence:
                                                                     

                                                                     
</p>
<pre class="verbatim" id="verbatim-1235">
SCALOP A;
A:= 5;
</pre>
<!--l. 235--><p class="nopar" > leads to a type mismatch error and should be replaced by:
                                                                     

                                                                     
</p>
<pre class="verbatim" id="verbatim-1236">
SCALOP A;
A:=5*UNIT;
</pre>
<!--l. 241--><p class="nopar" > The operator <span 
class="pcrr8t-x-x-109">UNIT </span>is a reserved variable of the system and should not be used for other
purposes.
</p><!--l. 245--><p class="noindent" >All other kernels (including standard REDUCE operators) occurring in expressions are
treated as ordinary scalar variables without any <span 
class="ptmrc8t-x-x-109">P<span 
class="small-caps">H</span><span 
class="small-caps">Y</span><span 
class="small-caps">S</span><span 
class="small-caps">O</span><span 
class="small-caps">P</span> </span>type (referred to as <span class="underline">scalars</span> in
the following). Assignement statements are checked to ensure correct operator type
assignement on both sides leading to an error if a type mismatch occurs. However an
assignement statement of the form <span 
class="pcrr8t-x-x-109">A:= 0 </span>or <span 
class="pcrr8t-x-x-109">LET A = 0 </span>is <span class="underline">always</span> valid regardless of
the type of <span 
class="pcrr8t-x-x-109">A</span>.
</p><!--l. 255--><p class="noindent" >Finally a command <span 
class="pcrr8t-x-x-109">CLEARPHYSOP</span><a 
 id="dx239-982008"></a> has been deﬁned to remove the <span 
class="ptmrc8t-x-x-109">P<span 
class="small-caps">H</span><span 
class="small-caps">Y</span><span 
class="small-caps">S</span><span 
class="small-caps">O</span><span 
class="small-caps">P</span> </span>type from
an identiﬁer in order to use it for subsequent calculations (e.g. as an ordinary
REDUCE operator). However it should be remembered that <span class="underline">no</span> substitution rule is
cleared by this function. It is therefore left to the user’s responsibility to clear previously
all substitution rules involving the identiﬁer from which the <span 
class="ptmrc8t-x-x-109">P<span 
class="small-caps">H</span><span 
class="small-caps">Y</span><span 
class="small-caps">S</span><span 
class="small-caps">O</span><span 
class="small-caps">P</span> </span>type is
removed.
</p><!--l. 265--><p class="noindent" >Users should be very careful when deﬁning procedures or statements of the type <span 
class="pcrr8t-x-x-109">FOR</span>
<span 
class="pcrr8t-x-x-109">ALL ... LET ... </span>that the <span 
class="ptmrc8t-x-x-109">P<span 
class="small-caps">H</span><span 
class="small-caps">Y</span><span 
class="small-caps">S</span><span 
class="small-caps">O</span><span 
class="small-caps">P</span> </span>type of all identiﬁers occurring in such
expressions is unambigously ﬁxed. The type analysing procedure is rather restrictive and
will print out a ”PHYSOP type conﬂict” error message if such ambiguities
occur.
</p>
<h5 class="subsubsectionHead"><span class="titlemark">20.40.3.2    </span> <a 
 id="x239-98300020.40.3.2"></a>Ordering of operators in an expression</h5>
<!--l. 273--><p class="noindent" >The ordering of kernels in an expression is performed according to the following rules:
<br 
class="newline" />1. <span class="underline">Scalars</span> are always ordered ahead of PHYSOP <span class="underline">operators</span> in an expression. The
REDUCE statement <span 
class="pcrr8t-x-x-109">korder</span><a 
 id="dx239-983001"></a> can be used to control the ordering of scalars but has <span class="underline">no</span>
eﬀect on the ordering of operators.
</p><!--l. 281--><p class="noindent" >2. The default ordering of <span class="underline">operators</span> follows the order in which they have been declared
(and <span class="underline">not</span> the alphabetical one). This ordering scheme can be changed using the command
<span 
class="pcrr8t-x-x-109">OPORDER</span>. <a 
 id="dx239-983002"></a> Its syntax is similar to the <span 
class="pcrr8t-x-x-109">korder </span>statement, i.e. coding: <span 
class="pcrr8t-x-x-109">OPORDER</span>
<span 
class="pcrr8t-x-x-109">A,V,F; </span>means that all occurrences of the operator <span 
class="pcrr8t-x-x-109">A </span>are ordered ahead of those of <span 
class="pcrr8t-x-x-109">V </span>etc.
                                                                     

                                                                     
It is also possible to include operators carrying indices (both normal and special ones) in
the argument list of <span 
class="pcrr8t-x-x-109">OPORDER</span>. However including objects <span class="underline">not</span> deﬁned as operators (i.e.
scalars or indices) in the argument list of the <span 
class="pcrr8t-x-x-109">OPORDER </span>command leads to an
error.
</p><!--l. 296--><p class="noindent" >3. Adjoint operators are placed by the declaration commands just after the original
operators on the <span 
class="pcrr8t-x-x-109">OPORDER </span>list. Changing the place of an operator on this list means <span class="underline">not</span>
that the adjoint operator is moved accordingly. This adjoint operator can be moved freely
by including it in the argument list of the <span 
class="pcrr8t-x-x-109">OPORDER </span>command.
</p><!--l. 303--><p class="noindent" >
</p>
<h5 class="subsubsectionHead"><span class="titlemark">20.40.3.3    </span> <a 
 id="x239-98400020.40.3.3"></a>Arithmetic operations on operators</h5>
<!--l. 305--><p class="noindent" >The following arithmetic operations are possible with operator expressions:
</p><!--l. 308--><p class="noindent" >1. Multiplication or division of an operator by a scalar.
</p><!--l. 310--><p class="noindent" >2. Addition and subtraction of operators of the <span class="underline">same</span> type.
</p><!--l. 312--><p class="noindent" >3. Multiplication of operators is only deﬁned between two <span class="underline">scalar</span> operators.
</p><!--l. 315--><p class="noindent" >4. The scalar product of two VECTOR operators is implemented with a new function
<span 
class="pcrr8t-x-x-109">DOT</span><a 
 id="dx239-984001"></a>. The system expands the product of two vector operators into an ordinary product
of the components of these operators by inserting a special index generated by the
program. To give an example, if one codes:
                                                                     

                                                                     
</p>
<pre class="verbatim" id="verbatim-1237">
VECOP V,W;
V DOT W;
</pre>
<!--l. 324--><p class="nopar" > the system will transform the product into:
                                                                     

                                                                     
</p>
<pre class="verbatim" id="verbatim-1238">
V(IDX1) * W(IDX1)
</pre>
<!--l. 329--><p class="nopar" > where <span 
class="pcrr8t-x-x-109">IDX1 </span>is a <span 
class="pcrr8t-x-x-109">PHYSINDEX </span>generated by the system (called a DUMMY INDEX in
the following) to express the summation over the components. The identiﬁers <span 
class="pcrr8t-x-x-109">IDXn </span>(<span 
class="pcrr8t-x-x-109">n </span>is
a nonzero integer) are reserved variables for this purpose and should not be used for other
applications. The arithmetic operator <span 
class="pcrr8t-x-x-109">DOT </span>can be used both in inﬁx and preﬁx form with
two arguments.
</p><!--l. 338--><p class="noindent" >5. Operators (but not states) can only be raised to an <span class="underline">integer</span> power. The system
expands this power expression into a product of the corresponding number of
terms inserting dummy indices if necessary. The following examples explain the
transformations occurring on power expressions (system output is indicated with an
<span 
class="pcrr8t-x-x-109">–&#x003E;</span>):
                                                                     

                                                                     
</p>
<pre class="verbatim" id="verbatim-1239">
SCALOP A; A**2;
- --&#x003E; A*A
VECOP V; V**4;
- --&#x003E; V(IDX1)*V(IDX1)*V(IDX2)*V(IDX2)
TENSOP C(2); C**2;
- --&#x003E; C(IDX3,IDX4)*C(IDX3,IDX4)
</pre>
<!--l. 352--><p class="nopar" > Note in particular the way how the system interprets powers of tensor operators which is
diﬀerent from the notation used in matrix algebra.
</p><!--l. 357--><p class="noindent" >6. Quotients of operators are only deﬁned between <span class="underline">scalar</span> operator
expressions. The system transforms the quotient of 2 scalar operators into
the product of the ﬁrst operator times the inverse of the second one.
Example<span class="footnote-mark"><a 
href="manual242.html#fn39x20"><sup class="textsuperscript">39</sup></a></span><a 
 id="x239-984002f39"></a> :
                                                                     

                                                                     
</p>
<pre class="verbatim" id="verbatim-1240">
SCALOP A,B;   A / B;
       -1
 --&#x003E; (B  )*A
</pre>
<!--l. 368--><p class="nopar" >
</p><!--l. 370--><p class="noindent" >7. Combining the last 2 rules explains the way how the system handles negative powers
of operators:
</p><!--l. 373--><p class="noindent" >
                                                                     

                                                                     
</p>
<pre class="verbatim" id="verbatim-1241">
SCALOP B;
B**(-3);
       -1    -1    -1
 --&#x003E; (B  )*(B  )*(B  )
</pre>
<!--l. 379--><p class="nopar" >
</p><!--l. 382--><p class="noindent" >The method of inserting dummy indices and expanding powers of operators has been
chosen to facilitate the handling of complicated operator expressions and particularly
their application on states (see section 3.4.3). However it may be useful to get rid of these
dummy indices in order to enhance the readability of the system’s ﬁnal output. <a 
 id="switch:CONTRACT"></a>For this
purpose the switch <span 
class="pcrr8t-x-x-109">contract</span><a 
 id="dx239-984003"></a><a 
 id="dx239-984004"></a><a 
 id="dx239-984005"></a> has to be turned on (<span 
class="pcrr8t-x-x-109">contract </span>is normally set to
<span 
class="pcrr8t-x-x-109">OFF</span>). The system in this case contracts over dummy indices reinserting the <span 
class="pcrr8t-x-x-109">DOT</span>
operator and reassembling the expanded powers. However due to the predeﬁned
operator ordering the system may not remove all the dummy indices introduced
previously.
</p>
<h5 class="subsubsectionHead"><span class="titlemark">20.40.3.4    </span> <a 
 id="x239-98500020.40.3.4"></a>Special functions</h5>
<!--l. 399--><p class="noindent" >
</p>
<h5 class="likesubsubsectionHead"><a 
 id="x239-98600020.40.3.4"></a>Commutation relations</h5>
<!--l. 401--><p class="noindent" ><a 
 id="operator:COMM"></a> <a 
 id="operator:ANTICOMM"></a> If 2 PHYSOPs have been declared noncommutative using the (redeﬁned) <span 
class="pcrr8t-x-x-109">noncom</span>
statement, it is possible to introduce in the environment <span class="underline">elementary</span> (anti-) commutation
relations between them. For this purpose, 2 <span class="underline">scalar</span> operators <span 
class="pcrr8t-x-x-109">comm</span><a 
 id="dx239-986001"></a> and <span 
class="pcrr8t-x-x-109">anticomm</span>
<a 
 id="dx239-986002"></a> are available. These operators are used in conjunction with <span 
class="pcrr8t-x-x-109">let </span>statements.
Example:
                                                                     

                                                                     
</p>
<pre class="verbatim" id="verbatim-1242">
SCALOP A,B,C,D;
LET COMM(A,B)=C;
FOR ALL N,M LET ANTICOMM(A(N),B(M))=D;
VECOP U,V,W; PHYSINDEX X,Y,Z;
FOR ALL X,Y LET COMM(V(X),W(Y))=U(Z);
</pre>
<!--l. 418--><p class="nopar" >
</p><!--l. 420--><p class="noindent" >Note that if special indices are used as dummy variables in <span 
class="pcrr8t-x-x-109">FOR ALL ... LET</span>
constructs then these indices should have been declared previously using the
<span 
class="pcrr8t-x-x-109">PHYSINDEX </span>command.
</p><!--l. 424--><p class="noindent" >Every time the system encounters a product term involving 2 noncommutative operators
which have to be reordered on account of the given operator ordering, the list of available
(anti-) commutators is checked in the following way: First the system looks for a
<span class="underline">commutation</span> relation which matches the product term. If it fails then the deﬁned
<span class="underline">anticommutation</span> relations are checked. If there is no successful match the product term
<span 
class="pcrr8t-x-x-109">A*B </span>is replaced by:
                                                                     

                                                                     
</p>
<pre class="verbatim" id="verbatim-1243">
A*B;
 --&#x003E; COMM(A,B) + B*A
</pre>
<!--l. 437--><p class="nopar" > so that the user may introduce the commutation relation later on.
</p><!--l. 440--><p class="noindent" ><a 
 id="switch:ANTICOM"></a> The user may want to force the system to look for <span class="underline">anticommutators</span> only; for this
purpose a switch <span 
class="pcrr8t-x-x-109">anticom</span><a 
 id="dx239-986003"></a><a 
 id="dx239-986004"></a><a 
 id="dx239-986005"></a> is deﬁned which has to be turned on (<span 
class="pcrr8t-x-x-109">anticom </span>is normally
set to <span 
class="pcrr8t-x-x-109">OFF</span>). In this case, the above example is replaced by:
                                                                     

                                                                     
</p>
<pre class="verbatim" id="verbatim-1244">
ON ANTICOM;
A*B;
 --&#x003E;  ANTICOMM(A,B) - B*A
</pre>
<!--l. 451--><p class="nopar" >
</p><!--l. 453--><p class="noindent" >Once the operator ordering has been ﬁxed (in the example above <span 
class="pcrr8t-x-x-109">B </span>has to be ordered
ahead of <span 
class="pcrr8t-x-x-109">A</span>), there is <span class="underline">no way</span> to prevent the system from introducing (anti-)commutators
every time it encounters a product whose terms are not in the right order. On the other
hand, simply by changing the <span 
class="pcrr8t-x-x-109">OPORDER </span>statement and reevaluating the expression one
can change the operator ordering <span class="underline">without</span> the need to introduce new commutation
relations. Consider the following example:
                                                                     

                                                                     
</p>
<pre class="verbatim" id="verbatim-1245">
SCALOP A,B,C;   NONCOM A,B;   OPORDER B,A;
LET COMM(A,B)=C;
A*B;
- --&#x003E;  B*A + C;
OPORDER A,B;
 B*A;
- --&#x003E; A*B - C;
</pre>
<!--l. 472--><p class="nopar" >
</p><!--l. 474--><p class="noindent" >The functions <span 
class="pcrr8t-x-x-109">comm </span>and <span 
class="pcrr8t-x-x-109">anticomm </span>should only be used to deﬁne elementary (anti-)
commutation relations between single operators. For the calculation of (anti-)
commutators between complex operator expressions, the functions <span 
class="pcrr8t-x-x-109">commute</span><a 
 id="dx239-986006"></a> and
<span 
class="pcrr8t-x-x-109">anticommute</span><a 
 id="dx239-986007"></a> have been deﬁned. Example (is included as example 1 in the test
ﬁle):
                                                                     

                                                                     
</p>
<pre class="verbatim" id="verbatim-1246">
VECOP P,A,K;
PHYSINDEX X,Y;
FOR ALL X,Y LET COMM(P(X),A(Y))=K(X)*A(Y);
COMMUTE(P**2,P DOT A);
</pre>
<!--l. 488--><p class="nopar" >
</p><!--l. 490--><p class="noindent" >
</p>
<h5 class="likesubsubsectionHead"><a 
 id="x239-98700020.40.3.4"></a>Adjoint expressions</h5>
<!--l. 492--><p class="noindent" >As has been already mentioned, for each operator and state deﬁned using the
declaration commands quoted in section 3.1, the system generates automatically the
corresponding adjoint operator. For the calculation of the adjoint representation
of a complicated operator expression, a function <span 
class="pcrr8t-x-x-109">adj</span><a 
 id="dx239-987001"></a> has been deﬁned.
Example<span class="footnote-mark"><a 
href="manual243.html#fn40x20"><sup class="textsuperscript">40</sup></a></span><a 
 id="x239-987002f40"></a> :
                                                                     

                                                                     
</p>
<pre class="verbatim" id="verbatim-1247">
SCALOP A,B;
ADJ(A*B);
       +    +
 --&#x003E; (B )*(A )
</pre>
<!--l. 505--><p class="nopar" >
</p>
<h5 class="likesubsubsectionHead"><a 
 id="x239-98800020.40.3.4"></a>Application of operators on states</h5>
<!--l. 509--><p class="noindent" >For this purpose, a function <span 
class="pcrr8t-x-x-109">opapply</span><a 
 id="dx239-988001"></a> has been deﬁned. It has 2 arguments and is used
in the following combinations:
</p><!--l. 513--><p class="noindent" ><span 
class="ptmb8t-x-x-109">(i) </span><span 
class="pcrr8t-x-x-109">let opapply(</span><span 
class="ptmri8t-x-x-109">operator, state</span><span 
class="pcrr8t-x-x-109">) = </span><span 
class="ptmri8t-x-x-109">state</span>; This is to deﬁne a elementary action of an
operator on a state in analogy to the way elementary commutation relations are
introduced to the system. Example:
                                                                     

                                                                     
</p>
<pre class="verbatim" id="verbatim-1248">
SCALOP A; STATE U;
FOR ALL N,P LET OPAPPLY((A(N),U(P))= EXP(I*N*P)*U(P);
</pre>
<!--l. 522--><p class="nopar" >
</p><!--l. 524--><p class="noindent" ><span 
class="ptmb8t-x-x-109">(ii) </span><span 
class="pcrr8t-x-x-109">let opapply(</span><span 
class="ptmri8t-x-x-109">state, state</span><span 
class="pcrr8t-x-x-109">) = </span><span 
class="ptmri8t-x-x-109">scalar exp.</span>; This form is to deﬁne scalar products
between states and normalization conditions. Example:
                                                                     

                                                                     
</p>
<pre class="verbatim" id="verbatim-1249">
STATE U;
FOR ALL N,M LET OPAPPLY(U(N),U(M)) = IF N=M THEN 1 ELSE 0;
</pre>
<!--l. 532--><p class="nopar" >
</p><!--l. 534--><p class="noindent" ><span 
class="ptmb8t-x-x-109">(iii) </span><span 
class="ptmri8t-x-x-109">state </span><span 
class="pcrr8t-x-x-109">:= opapply(</span><span 
class="ptmri8t-x-x-109">operator expression, state</span>); In this way, the action of an
operator expression on a given state is calculated using elementary relations deﬁned as
explained in <span 
class="ptmb8t-x-x-109">(i)</span>. The result may be assigned to a diﬀerent state vector.
</p><!--l. 539--><p class="noindent" ><span 
class="ptmb8t-x-x-109">(iv) </span><span 
class="pcrr8t-x-x-109">opapply(</span><span 
class="ptmri8t-x-x-109">state</span><span 
class="pcrr8t-x-x-109">, opapply(</span><span 
class="ptmri8t-x-x-109">operator expression, state</span><span 
class="pcrr8t-x-x-109">))</span>; This is the way how to
calculate matrix elements of operator expressions. The system proceeds in the following
way: ﬁrst the rightmost operator is applied on the right state, which means that the
system tries to ﬁnd an elementary relation which match the application of the operator on
the state. If it fails the system tries to apply the leftmost operator of the expression on the
left state using the adjoint representations. If this fails also, the system prints out a
warning message and stops the evaluation. Otherwise the next operator occuring in the
expression is taken and so on until the complete expression is applied. Then the system
looks for a relation expressing the scalar product of the two resulting states and
prints out the ﬁnal result. An example of such a calculation is given in the test
ﬁle.
</p><!--l. 557--><p class="noindent" >The inﬁx version of the <span 
class="pcrr8t-x-x-109">opapply </span>function is the vertical bar \(\mid \) . It is <span class="underline">right</span> associative
and placed in the precedence list just above the minus (\(-\)) operator. Some of the
REDUCE implementation may not work with this character, the preﬁx form should then be used
instead<span class="footnote-mark"><a 
href="manual244.html#fn41x20"><sup class="textsuperscript">41</sup></a></span><a 
 id="x239-988002f41"></a> .
</p>
<h4 class="subsectionHead"><span class="titlemark">20.40.4    </span> <a 
 id="x239-98900020.40.4"></a>Known problems in the current release of PHYSOP</h4>
<!--l. 567--><p class="noindent" ><span 
class="ptmb8t-x-x-109">(i) </span>Some spurious negative powers of operators may appear in the result of a calculation
using the <span 
class="ptmrc8t-x-x-109">P<span 
class="small-caps">H</span><span 
class="small-caps">Y</span><span 
class="small-caps">S</span><span 
class="small-caps">O</span><span 
class="small-caps">P</span> </span>package. This is a purely ”cosmetic” eﬀect which is due to an
additional factorization of the expression in the output printing routines of REDUCE.
Setting oﬀ the REDUCE switch <span 
class="pcrr8t-x-x-109">allfac </span>(<span 
class="pcrr8t-x-x-109">allfac </span>is normally on)<a 
 id="dx239-989001"></a><a 
 id="dx239-989002"></a><a 
 id="dx239-989003"></a> should make
these terms disappear and print out the correct result (see example 1 in the test
                                                                     

                                                                     
ﬁle).
</p><!--l. 578--><p class="noindent" ><span 
class="ptmb8t-x-x-109">(ii) </span>The current release of the <span 
class="ptmrc8t-x-x-109">P<span 
class="small-caps">H</span><span 
class="small-caps">Y</span><span 
class="small-caps">S</span><span 
class="small-caps">O</span><span 
class="small-caps">P</span> </span>package is not optimized w.r.t. computation
speed. Users should be aware that the evaluation of complicated expressions involving a
lot of commutation relations requires a signiﬁcant amount of CPU time <span class="underline">and</span> memory.
Therefore the use of <span 
class="ptmrc8t-x-x-109">P<span 
class="small-caps">H</span><span 
class="small-caps">Y</span><span 
class="small-caps">S</span><span 
class="small-caps">O</span><span 
class="small-caps">P</span> </span>on small machines is rather limited. A minimal hardware
conﬁguration should include at least 4 MB of memory and a reasonably fast CPU (type
Intel 80386 or equiv.).
</p><!--l. 586--><p class="noindent" ><span 
class="ptmb8t-x-x-109">(iii) </span>Slightly diﬀerent ordering of operators (especially with multiple occurrences of the
same operator with diﬀerent indices) may appear in some calculations due to the internal
ordering of atoms in the underlying LISP system (see last example in the test ﬁle). This
cannot be entirely avoided by the package but does not aﬀect the correctness of the
results.
</p><!--l. 594--><p class="noindent" >
</p>
<h4 class="subsectionHead"><span class="titlemark">20.40.5    </span> <a 
 id="x239-99000020.40.5"></a>Final remarks</h4>
<!--l. 595--><p class="noindent" >The package <span 
class="ptmrc8t-x-x-109">P<span 
class="small-caps">H</span><span 
class="small-caps">Y</span><span 
class="small-caps">S</span><span 
class="small-caps">O</span><span 
class="small-caps">P</span> </span>has been presented by the author at the IV inter. Conference on
Computer Algebra in Physical Research, Dubna (USSR) 1990 (see <span class="cite">[<a 
href="manualap2.html#XWarns:1991a">War91</a>]</span>). It has been
developed with the aim in mind to perform calculations of the type exempliﬁed in the test
ﬁle included in the distribution of this package. However it should also be useful in some
other domains like e.g. the calculations of complicated Feynman diagrams in QCD
which could not be performed using the HEPHYS package. The author is therefore
grateful for any suggestion to improve or extend the usability of the package. Users
should not hesitate to contact the author for additional help and explanations on how to
use this package. Some bugs may also appear which have not been discovered
during the tests performed prior to the release of this version. Please send in this
case to the author a short input and output listing displaying the encountered
problem.
</p><!--l. 615--><p class="noindent" >
</p>
<h4 class="likesubsectionHead"><a 
 id="x239-99100020.40.5"></a>Acknowledgements</h4>
<!--l. 616--><p class="noindent" >The main ideas for the implementation of a new data type in the REDUCE environnement
have been taken from the VECTOR package developed by Dr. David Harper (<span class="cite">[<a 
href="manualap2.html#XHarper:89a">Har89</a>]</span>).
Useful discussions with Dr. Eberhard Schrüfer and Prof. John Fitch are also gratefully
acknowledged.
                                                                     

                                                                     
</p><!--l. 624--><p class="noindent" >
</p>
<h4 class="subsectionHead"><span class="titlemark">20.40.6    </span> <a 
 id="x239-99200020.40.6"></a>Appendix: List of error and warning messages</h4>
<!--l. 625--><p class="noindent" >In the following the error (E) and warning (W) messages speciﬁc to the PHYSOP
package are listed.
     </p><dl class="description"><dt class="description">
     <!--l. 628--><p class="noindent" >
<span 
class="pcrr8t-x-x-109">cannot declare</span><span 
class="ptmbi8t-x-x-109">x  </span><span 
class="pcrr8t-x-x-109">as </span><span 
class="ptmbi8t-x-x-109">data type</span> </p></dt><dd 
class="description">
     <!--l. 628--><p class="noindent" >(W): An attempt has been made to declare an object <span 
class="ptmri8t-x-x-109">x </span>which cannot be used
     as  a  <span 
class="ptmrc8t-x-x-109">P<span 
class="small-caps">H</span><span 
class="small-caps">Y</span><span 
class="small-caps">S</span><span 
class="small-caps">O</span><span 
class="small-caps">P</span>  </span>operator  of  the  required  type.  The  declaration  command  is
     ignored.
     </p></dd><dt class="description">
     <!--l. 633--><p class="noindent" >
<span 
class="ptmbi8t-x-x-109">x </span><span 
class="pcrr8t-x-x-109">already defined as</span><span 
class="ptmbi8t-x-x-109">data type</span> </p></dt><dd 
class="description">
     <!--l. 633--><p class="noindent" >(W):  The  object  <span 
class="ptmri8t-x-x-109">x  </span>has  already  been  declared  using  a  REDUCE type
     declaration command and can therefore not be used as a <span 
class="ptmrc8t-x-x-109">P<span 
class="small-caps">H</span><span 
class="small-caps">Y</span><span 
class="small-caps">S</span><span 
class="small-caps">O</span><span 
class="small-caps">P</span> </span>operator.
     The declaration command is ignored.
     </p></dd><dt class="description">
     <!--l. 638--><p class="noindent" >
<span 
class="ptmbi8t-x-x-109">x </span><span 
class="pcrr8t-x-x-109">already declared as</span><span 
class="ptmbi8t-x-x-109">data type</span> </p></dt><dd 
class="description">
     <!--l. 638--><p class="noindent" >(W):  The  object  <span 
class="pcrr8t-x-x-109">x </span>has  already  been  declared  with  a  <span 
class="ptmrc8t-x-x-109">P<span 
class="small-caps">H</span><span 
class="small-caps">Y</span><span 
class="small-caps">S</span><span 
class="small-caps">O</span><span 
class="small-caps">P</span>  </span>declaration
     command. The declaration command is ignored.
     </p></dd><dt class="description">
     <!--l. 642--><p class="noindent" >
<span 
class="ptmbi8t-x-x-109">x </span><span 
class="pcrr8t-x-x-109">is not a PHYSOP</span> </p></dt><dd 
class="description">
     <!--l. 642--><p class="noindent" >(E):  An  invalid  argument  has  been  included  in  an  <span 
class="pcrr8t-x-x-109">OPORDER </span>command.
     Check the arguments.
     </p></dd><dt class="description">
     <!--l. 645--><p class="noindent" >
<span 
class="pcrr8t-x-x-109">invalid argument(s) to </span><span 
class="ptmbi8t-x-x-109">function</span> </p></dt><dd 
class="description">
     <!--l. 645--><p class="noindent" >(E): A function implemented by the <span 
class="ptmrc8t-x-x-109">P<span 
class="small-caps">H</span><span 
class="small-caps">Y</span><span 
class="small-caps">S</span><span 
class="small-caps">O</span><span 
class="small-caps">P</span> </span>package has been called with
     an invalid argument. Check type of arguments.
                                                                     

                                                                     
     </p></dd><dt class="description">
     <!--l. 650--><p class="noindent" >
<span 
class="pcrr8t-x-x-109">Type conflict in </span><span 
class="ptmbi8t-x-x-109">operation</span> </p></dt><dd 
class="description">
     <!--l. 650--><p class="noindent" >(E):  A  <span 
class="ptmrc8t-x-x-109">P<span 
class="small-caps">H</span><span 
class="small-caps">Y</span><span 
class="small-caps">S</span><span 
class="small-caps">O</span><span 
class="small-caps">P</span>  </span>type  conﬂict  has  occured  during  an  arithmetic  operation.
     Check the arguments.
     </p></dd><dt class="description">
     <!--l. 653--><p class="noindent" >
<span 
class="pcrr8t-x-x-109">invalid call of </span><span 
class="ptmbi8t-x-x-109">function </span><span 
class="pcrr8t-x-x-109">with args:</span><span 
class="ptmbi8t-x-x-109">arguments</span> </p></dt><dd 
class="description">
     <!--l. 653--><p class="noindent" >(E):  A  function  of  the  <span 
class="ptmrc8t-x-x-109">P<span 
class="small-caps">H</span><span 
class="small-caps">Y</span><span 
class="small-caps">S</span><span 
class="small-caps">O</span><span 
class="small-caps">P</span>  </span>package  has  been  declared  with  invalid
     argument(s). Check the argument list.
     </p></dd><dt class="description">
     <!--l. 658--><p class="noindent" >
<span 
class="pcrr8t-x-x-109">type mismatch in</span><span 
class="ptmbi8t-x-x-109">expression</span> </p></dt><dd 
class="description">
     <!--l. 658--><p class="noindent" >(E):  A  type  mismatch  has  been  detected  in  an  expression.  Check  the
     corresponding expression.
     </p></dd><dt class="description">
     <!--l. 661--><p class="noindent" >
<span 
class="pcrr8t-x-x-109">type mismatch in</span><span 
class="ptmbi8t-x-x-109">assignement</span> </p></dt><dd 
class="description">
     <!--l. 661--><p class="noindent" >(E):  A  type  mismatch  has  been  detected  in  an  assignment  or  in  a  <span 
class="pcrr8t-x-x-109">LET</span>
     statement. Check the listed statement.
     </p></dd><dt class="description">
     <!--l. 665--><p class="noindent" >
<span 
class="pcrr8t-x-x-109">PHYSOP type conflict in</span><span 
class="ptmbi8t-x-x-109">expr</span> </p></dt><dd 
class="description">
     <!--l. 665--><p class="noindent" >(E):  A  ambiguity  has  been  detected  during  the  type  analysis  of  the
     expression. Check the expression.
     </p></dd><dt class="description">
     <!--l. 669--><p class="noindent" >
<span 
class="pcrr8t-x-x-109">operators in exponent cannot be handled</span> </p></dt><dd 
class="description">
     <!--l. 669--><p class="noindent" >(E): An operator has occurred in the exponent of an expression.
     </p></dd><dt class="description">
     <!--l. 672--><p class="noindent" >
<span 
class="pcrr8t-x-x-109">cannot raise a state to a power</span> </p></dt><dd 
class="description">
     <!--l. 672--><p class="noindent" >(E): states cannot be exponentiated by the system.
                                                                     

                                                                     
     </p></dd><dt class="description">
     <!--l. 675--><p class="noindent" >
<span 
class="pcrr8t-x-x-109">invalid quotient</span> </p></dt><dd 
class="description">
     <!--l. 675--><p class="noindent" >(E):   An   invalid   denominator   has   occurred   in   a   quotient.   Check   the
     expression.
     </p></dd><dt class="description">
     <!--l. 678--><p class="noindent" >
<span 
class="pcrr8t-x-x-109">physops of different types cannot be commuted</span> </p></dt><dd 
class="description">
     <!--l. 678--><p class="noindent" >(E):
     An invalid operator has occurred in a call of the <span 
class="pcrr8t-x-x-109">COMMUTE</span>/<span 
class="pcrr8t-x-x-109">ANTICOMMUTE</span>
     function.
     </p></dd><dt class="description">
     <!--l. 681--><p class="noindent" >
<span 
class="pcrr8t-x-x-109">commutators only implemented between scalar operators</span> </p></dt><dd 
class="description">
     <!--l. 681--><p class="noindent" >(E):    An    invalid    operator    has    occurred    in    the    call    of    the
     <span 
class="pcrr8t-x-x-109">COMMUTE</span>/<span 
class="pcrr8t-x-x-109">ANTICOMMUTE </span>function.
     </p></dd><dt class="description">
     <!--l. 685--><p class="noindent" >
<span 
class="pcrr8t-x-x-109">evaluation incomplete due to missing elementary relations</span> </p></dt><dd 
class="description">
     <!--l. 685--><p class="noindent" >(W): <br 
class="newline" />The  system  has  not  found  all  the  elementary  commutators  or  application
     relations necessary to calculate or reorder the input expression. The result
     may however be used for further calculations.</p></dd></dl>
<!--l. 840--><p class="noindent" >
                                                                     

                                                                     
                                                                     

                                                                     
</p><!--l. 842--><p class="noindent" ><table cellspacing="5"><tr><td class="clinks"><a 
href="../manual-lookup.php%3FUser&#32;Contributed&#32;Packages.html#manualse163.html" >Up</a></td><td class="clinks"><a 
href="manualse164.html" >Next</a></td><td class="clinks"><a 
href="manualse162.html" >Prev</a></td><td class="clinks"><a 
href="manualse162.html#tailmanualse162.html" >PrevTail</a></td><td class="clinks"><a 
href="manualse163.html" >Front</a></td></tr></table><a 
 id="tailmanualse163.html"></a>  <hr> <p style="font-family:sans-serif">Hosted by <a href="https://sourceforge.net/p/reduce-algebra/"> <img title="Download REDUCE" alt="Download REDUCE" style="vertical-align:middle" src="https://sourceforge.net/sflogo.php?type=16&amp;group_id=248416"/></a> <a href="https://www.mathjax.org"> <img title="Powered by MathJax" alt="Powered by MathJax" style="float:right" src="https://www.mathjax.org/badge/badge.gif"/></a></p></p> 
</body> 
</html>