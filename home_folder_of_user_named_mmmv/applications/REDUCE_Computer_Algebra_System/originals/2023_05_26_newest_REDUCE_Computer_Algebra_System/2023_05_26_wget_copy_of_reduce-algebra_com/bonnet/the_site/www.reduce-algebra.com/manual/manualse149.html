<!DOCTYPE html> 
<html lang="en-US" xml:lang="en-US" > 
<head><title>GUARDIAN: Guarded Expressions in Practice</title> 
<meta  charset="utf-8" /> 
<meta name="generator" content="TeX4ht (https://tug.org/tex4ht/)" /> 
<meta name="viewport" content="width=device-width,initial-scale=1" /> 
<link rel="stylesheet" type="text/css" href="manual.css" /> 
<meta name="src" content="manual.tex" /> 
<script>window.MathJax = { tex: { tags: "ams", }, }; </script> 
 <script type="text/javascript" async="async" id="MathJax-script" src="../../cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js"></script>  
<meta name="description" content="The REDUCE Computer Algebra System User's Manual" /> 
</head><body 
>
<header>REDUCE</header><table cellspacing="5"><tr><td class="clinks"><a 
href="../manual-lookup.php%3FUser&#32;Contributed&#32;Packages.html#manualse149.html" >Up</a></td><td class="clinks"><a 
href="manualse150.html" >Next</a></td><td class="clinks"><a 
href="../manual-lookup.php%3FGROEBNER:.html" >Prev</a></td><td class="clinks"><a 
href="../manual-lookup.php%3FGROEBNER:.html#tailmanualse148.html" >PrevTail</a></td><td class="clinks"><a 
href="manualse149.html#tailmanualse149.html">Tail</a></td></tr></table><h3 class="sectionHead"><span class="titlemark">20.26    </span> <a 
 id="x214-78700020.26"></a>GUARDIAN: Guarded Expressions in Practice</h3>
<a 
 id="dx214-787001"></a>
<a 
 id="dx214-787002"></a>
<!--l. 539--><p class="noindent" >Computer algebra systems typically drop some degenerate cases when evaluating
expressions, e.g., \(x/x\) becomes \(1\) dropping the case \(x=0\). We claim that it is feasible in practice
to compute also the degenerate cases yielding <span 
class="ptmri8t-x-x-109">guarded expressions</span>. We work
over real closed ﬁelds but our ideas about handling guarded expression can
be easily transferred to other situations. Using formulas as guards provides a
powerful tool for heuristically reducing the combinatorial explosion of cases:
equivalent, redundant, tautological, and contradictive cases can be detected
by simpliﬁcation and quantiﬁer elimination. Our approach allows to simplify
the expressions on the basis of simpliﬁcation knowledge on the logical side.
The method described in this paper is implemented in the REDUCE package
<span 
class="ptmrc8t-x-x-109">G<span 
class="small-caps">U</span><span 
class="small-caps">A</span><span 
class="small-caps">R</span><span 
class="small-caps">D</span><span 
class="small-caps">I</span><span 
class="small-caps">A</span><span 
class="small-caps">N</span></span>.
</p><!--l. 553--><p class="noindent" >Authors: Andreas Dolzmann and Thomas Sturm.
<a 
 id="dx214-787003"></a>
<a 
 id="dx214-787004"></a>
<a 
 id="dx214-787005"></a>
<a 
 id="dx214-787006"></a>
</p><!--l. 5--><p class="noindent" >
</p>
<h4 class="subsectionHead"><span class="titlemark">20.26.1    </span> <a 
 id="x214-78800020.26.1"></a>Introduction</h4>
<!--l. 8--><p class="noindent" >\( \newenvironment {gex}{\left [\begin {array}{c|c}}{\end {array}\right ]} \newcommand {\gc }[1]{\boldsymbol {#1}} \newcommand {\true }{\textrm {T}} \newcommand {\false }{\textrm {F}} \newcommand {\E }{\textrm {E}} \newcommand {\GE }{\textrm {GE}} \newcommand {\gscheme }{\textrm {gscheme}} \newcommand {\sign }{\textrm {sign}} \)It is meanwhile a well-known fact that evaluations obtained with the interactive use of
computer algebra systems (<span 
class="ptmrc8t-x-x-109"><span 
class="small-caps">C</span><span 
class="small-caps">A</span><span 
class="small-caps">S</span></span>) are not entirely correct in general. Typically, some
degenerate cases are dropped. Consider for instance the evaluation \[ \frac {x^2}{x}=x, \] which is correct only
if \(x\neq 0\). The problem here is that <span 
class="ptmrc8t-x-x-109"><span 
class="small-caps">C</span><span 
class="small-caps">A</span><span 
class="small-caps">S</span> </span>consider variables to be transcendental elements. The
user, in contrast, has in mind variables in the sense of logic. In other words: The user
does not think of rational functions but of terms.
</p><!--l. 41--><p class="noindent" >Next consider the valid expression \[ \frac {\sqrt {x}+\sqrt {-x}}{x}. \] It is meaningless over the reals. <span 
class="ptmrc8t-x-x-109">C<span 
class="small-caps">A</span><span 
class="small-caps">S</span> </span>often oﬀer no
choice than to interprete surds over the complex numbers even if they distinguish
between a <span 
class="ptmri8t-x-x-109">real </span>and a <span 
class="ptmri8t-x-x-109">complex </span>mode.
</p><!--l. 49--><p class="noindent" >Corless and Jeﬀrey <span class="cite">[<a 
href="manualap2.html#XCorlessJeffrey:92">CJ92</a>]</span> have examined the behavior of a number of <span 
class="ptmrc8t-x-x-109"><span 
class="small-caps">C</span><span 
class="small-caps">A</span><span 
class="small-caps">S</span> </span>with such
                                                                     

                                                                     
input data. They come to the conclusion that simultaneous computation of all cases is
exemplary but not feasible due to the combinatorial explosion of cases to be considered.
Therefore, they suggest to ignore the degenerate cases but to provide the assumptions to
the user on request. We claim, in contrast, that it is in fact feasible to compute all possible
cases.
</p><!--l. 57--><p class="noindent" >Our setting is as follows: Expressions are evaluated to <span 
class="ptmri8t-x-x-109">guarded expressions </span>consisting of
possibly several conventional expressions guarded by quantiﬁer-free formulas. For the
above examples, we would obtain \[ \begin {gex} \gc {x\neq 0}&amp;\gc {x} \end {gex},\quad \begin {gex} \gc {\false }&amp;\gc {\frac {\sqrt {x}+\sqrt {-x}}{x}} \end {gex}. \] As the second example illustrates, we are working in
ordered ﬁelds, more precisely in real closed ﬁelds. The handling of guarded
expressions as described in this paper can, however, be easily transferred to other
situations.
</p><!--l. 74--><p class="noindent" >Our approach can also deal with redundant guarded expressions, such as \[ \begin {gex} \gc {\true } &amp; \gc {|x|-x}\\ x\geq 0 &amp; 0\\ x&lt;0 &amp; -2x \end {gex} \] which leads to
algebraic simpliﬁcation techniques based on logical simpliﬁcation as proposed by
Davenport and Faure <span class="cite">[<a 
href="manualap2.html#XDavenportFaure:94">DF94</a>]</span>.
</p><!--l. 86--><p class="noindent" >We use <span 
class="ptmri8t-x-x-109">formulas </span>over the language of ordered rings as guards. This provides powerful tools
for heuristically reducing the combinatorial explosion of cases: equivalent, redundant,
tautological, and contradictive cases can be detected by <span 
class="ptmri8t-x-x-109">simpliﬁcation</span> <span class="cite">[<a 
href="manualap2.html#XDolzmann:97b">DS97b</a>]</span> and
<span 
class="ptmri8t-x-x-109">quantiﬁer elimination</span> <span class="cite">[<a 
href="manualap2.html#XTarski:48">Tar48</a>, <a 
href="manualap2.html#XCollins:75">Col75</a>, <a 
href="manualap2.html#XWeispfenning:88">Wei88</a>, <a 
href="manualap2.html#XLoosWeispfenning:93">RLW93</a>, <a 
href="manualap2.html#XWeispfenning:96">Wei97</a>, <a 
href="manualap2.html#XWeispfenning:94">Wei94</a>]</span>. In certain
situations, we will allow the formulas also to contain extra functions such as \(\sqrt {\cdot }\) or \(|\cdot |\). Then
we take care that there is no quantiﬁer elimination applied.
</p><!--l. 96--><p class="noindent" >Simultaneous computation of several cases concerning certain expressions being zero or not has
been extensively investigated as <span 
class="ptmri8t-x-x-109">dynamic evaluation</span> <span class="cite">[<a 
href="manualap2.html#XGomezDiaz:93">GD96</a>, <a 
href="manualap2.html#XDuvalReynaud:94">DR94a</a>, <a 
href="manualap2.html#XDuvalReynaud:94a">DR94b</a>, <a 
href="manualap2.html#XBroadberryGomezDiazWatt:95">BGDW95</a>]</span>.
It has also been extended to real closed ﬁelds <span class="cite">[<a 
href="manualap2.html#XDuvalGonzalesVega:93">DGV96</a>]</span>. The idea behind the
development of these methods is of a more theoretical nature than to overcome the
problems with the interactive usage of <span 
class="ptmrc8t-x-x-109"><span 
class="small-caps">C</span><span 
class="small-caps">A</span><span 
class="small-caps">S</span> </span>sketched above: one wishes to compute in
algebraic (or real) extension ﬁelds of the rationals. Guarded expressions occur naturally
when solving problems parametrically. Consider, e.g., the <span 
class="ptmri8t-x-x-109">Gr</span><span 
class="ptmri8t-x-x-109">ö</span><span 
class="ptmri8t-x-x-109">bner systems </span>used during
the computation of <span 
class="ptmri8t-x-x-109">comprehensive Gr</span><span 
class="ptmri8t-x-x-109">ö</span><span 
class="ptmri8t-x-x-109">bner bases </span><span class="cite">[<a 
href="manualap2.html#XWeispfenning:92">Wei92</a>]</span>.
</p><!--l. 110--><p class="noindent" >The algorithms described in this paper are implemented in the REDUCE
package <span 
class="ptmrc8t-x-x-109"><span 
class="small-caps">G</span><span 
class="small-caps">U</span><span 
class="small-caps">A</span><span 
class="small-caps">R</span><span 
class="small-caps">D</span><span 
class="small-caps">I</span><span 
class="small-caps">A</span><span 
class="small-caps">N</span></span>. It is based on the REDUCE <span class="cite">[<a 
href="manualap2.html#XHearn:91">Hea95</a>, <a 
href="manualap2.html#XMelenk:95">Mel95</a>]</span> package
<span 
class="ptmrc8t-x-x-109"><span 
class="small-caps">R</span><span 
class="small-caps">E</span><span 
class="small-caps">D</span><span 
class="small-caps">L</span><span 
class="small-caps">O</span><span 
class="small-caps">G</span></span> <span class="cite">[<a 
href="manualap2.html#XDolzmannSturm:97a">DS97a</a>, <a 
href="manualap2.html#XDolzmann:96a">DS96</a>]</span> implementing a formula data type with corresponding
algorithms, in particular including simpliﬁcation and quantiﬁer elimination.
</p><!--l. 117--><p class="noindent" >
</p>
<h4 class="subsectionHead"><span class="titlemark">20.26.2    </span> <a 
 id="x214-78900020.26.2"></a>An outline of our method</h4>
                                                                     

                                                                     
<!--l. 118--><p class="noindent" >
</p>
<h5 class="subsubsectionHead"><a 
 id="x214-79000020.26.2"></a>Guarded expressions</h5>
<!--l. 119--><p class="noindent" >A <span 
class="ptmri8t-x-x-109">guarded expression </span>is a scheme \[ \begin {gex} \gc {\gamma _0} &amp; \gc {t_0}\\ \gamma _1 &amp; t_1\\ \vdots&amp; \vdots \\ \gamma _n&amp; t_n \end {gex} \] where each \(\gamma _i\) is a quantiﬁer-free formula, the <span 
class="ptmri8t-x-x-109">guard</span>,
and each \(t_i\) is an associated <span 
class="ptmri8t-x-x-109">conventional expression</span>. The idea is that some \(t_i\) is a valid
interpretation iﬀ \(\gamma _i\) holds. Each pair \((\gamma _i,t_i)\) is called a <span 
class="ptmri8t-x-x-109">case</span>.
</p><!--l. 133--><p class="noindent" >The ﬁrst case \((\gamma _0,t_0)\) is the <span 
class="ptmri8t-x-x-109">generic </span>case: \(t_0\) is the expression the system would compute without
our package, and \(\gamma _0\) is the corresponding guard.
</p><!--l. 137--><p class="noindent" >The guards \(\gamma _i\) need neither exclude one another, nor do we require that they form a
complete case distinction. We shall, however, assume that all cases covered by a
guarded expression are already covered by the generic case; in other words: \begin {equation}  \bigwedge _{i=1}^n(\gamma _i\longrightarrow \gamma _0).\label {gencoversall}  \end {equation}
</p><!--l. 145--><p class="noindent" >Consider the following evaluation of \(|x|\) to a guarded expression: \[ \begin {gex} \gc {\true } &amp; \gc {|x|}\\ x\geq 0 &amp; x\\ x&lt;0 &amp; -x \end {gex}. \] Here the non-generic
cases already cover the whole domain. The generic case is in some way <span 
class="ptmri8t-x-x-109">redundant</span>. It is
just present for keeping track of the system’s default behavior. Formally we have
\begin {equation}  \Bigl (\bigvee _{i=1}^n\gamma _i\Bigr )\longleftrightarrow \gamma _0. \label {formalredund}  \end {equation}
As an example for a non-redundant, i.e., <span 
class="ptmri8t-x-x-109">necessary </span>generic case we have the evaluation
of the reciprocal \(\frac {1}{x}\): \[ \begin {gex} \gc {x\neq 0}&amp; \gc {\frac {1}{x}} \end {gex}. \]
</p><!--l. 168--><p class="noindent" >In every guarded expression, the generic case is explicitly marked as either necessary or
redundant. The corresponding tag is inherited during the evaluation process.
Unfortunately it can happen that guarded expressions satisfy (\ref {formalredund}) without being tagged
redundant, e.g., specialization of \[ \begin {gex} \gc {\true }&amp;\gc {\sin x}\\ x=0&amp;0 \end {gex} \] to \(x=0\) if the system cannot evaluate \(\sin (0)\). This does not happen
if one claims for necessary generic cases to have, as the reciprocal above, no alternative
cases at all. Else, in the sequel “redundant generic case” has to be read as “tagged
redundant.”
</p><!--l. 184--><p class="noindent" >With guarded expressions, the evaluation splits into two independent parts:
<span 
class="ptmri8t-x-x-109">Algebraic evaluation </span>and a subsequent <span 
class="ptmri8t-x-x-109">simpliﬁcation </span>of the guarded expression
obtained.
</p>
<h5 class="subsubsectionHead"><a 
 id="x214-79100020.26.2"></a>Guarding schemes</h5>
<!--l. 189--><p class="noindent" >In the introduction we have seen that certain operators introduce case distinctions.
For this, with each operator \(f\) there is a <span 
class="ptmri8t-x-x-109">guarding scheme </span>associated providing
information on how to map \(f(t_1,\ldots ,t_m)\) to a guarded expression provided that one does
not have to care for the argument expressions \(t_1\), …, \(t_m\). In the easiest case, this
is a rewrite rule \[ f(a_1,\ldots ,a_m)\to G(a_1,\ldots ,a_m). \] The actual terms \(t_1\), …, \(t_m\) are simply substituted for the formal
symbols \(a_1\), …, \(a_m\) into the generic guarded expression \(G(a_1,\ldots ,a_m)\). We give some examples: \begin {align}  \frac {a_1}{a_2} &amp; \to \begin {gex} \gc {a_2\neq 0} &amp; \gc {\frac {a_1}{a_2}} \end {gex}\nonumber \\ \sqrt {a_1} &amp; \to \begin {gex} \gc {a_1\geq 0} &amp; \gc {\sqrt {a_1}} \end {gex}\nonumber \\ \sign (a_1) &amp; \to \begin {gex} \gc {\true } &amp; \gc {\sign (a_1)}\\ a_1&gt;0 &amp; 1\\ a_1=0 &amp; 0\\ a_1&lt;0 &amp; -1 \end {gex}\nonumber \\ |a_1| &amp; \to \begin {gex} \gc {\true } &amp; \gc {|a_1|}\\ a_1\geq 0 &amp; a_1\\ a_1&lt;0 &amp; -a_1 \end {gex}\label {absrewrite}  \end {align}
                                                                     

                                                                     
</p><!--l. 225--><p class="noindent" >For functions of arbitrary arity, e.g., \(\min \) or \(\max \), we formally assume inﬁnitely many
operators of the same name. Technically, we associate a procedure parameterized
with the number of arguments \(m\) that generates the corresponding rewrite rule.
As \(\tt min\_scheme(2)\) we obtain, e.g., \[ \min (a_1,a_2) \to \begin {gex} \gc {\true } &amp; \gc {\min (a_1,a_2)}\\ a_1\leq a_2 &amp; a_1\\ a_2\leq a_1 &amp; a_2 \end {gex}\label {binminscheme}, \] while for higher arities there are more case distinctions
necessary.
</p><!--l. 240--><p class="noindent" >For later complexity analysis, we state the concept of a guarding scheme formally: a
guarding scheme for an \(m\)-ary operator \(f\) is a map \[ \gscheme _f: \E ^m \to \GE \] where \(\E \) is the set of expressions, and \(\GE \) is
the set of guarded expressions. This allows to split \(f(t_1,\ldots ,t_m)\) in dependence on the form of the
parameter expressions \(t_1\), …, \(t_m\).
</p>
<h5 class="subsubsectionHead"><a 
 id="x214-79200020.26.2"></a>Algebraic evaluation</h5>
<!--l. 251--><p class="noindent" >
</p>
<h5 class="likesubsubsectionHead"><a 
 id="x214-79300020.26.2"></a>Evaluating conventional expressions</h5>
<!--l. 252--><p class="noindent" >The evaluation of conventional expressions into guarded expressions is performed
recursively: Constants \(c\) evaluate to \[ \begin {gex} \gc {\true } &amp; \gc {c} \end {gex}. \] For the evaluation of \(f(e_1,\ldots ,e_m)\) the argument expressions \(e_1\), …, \(e_m\)
are recursively evaluated to guarded expressions \begin {equation}  e_i'=\begin {gex} \gc {\gamma _{i0}} &amp; \gc {t_{i0}}\\ \gamma _{i1} &amp; t_{i1}\\ \vdots &amp; \vdots \\ \gamma _{in_i} &amp; t_{in_i}\end {gex}\quad \mbox {for}\quad 1\leq i\leq m. \label {eprimes}  \end {equation}
</p><!--l. 271--><p class="noindent" >Then the operator \(f\) is “moved inside” the \(e_i'\) by combining all cases, technically a
simultaneous Cartesian product computation of both the sets of guards and the sets of
terms: \begin {equation}  \Gamma =\prod _{i=1}^m\{\gamma _{i0},\ldots ,\gamma _{in_i}\},\quad T=\prod _{i=1}^m\{t_{i0},\ldots ,t_{in_i}\}. \label {cartprod}  \end {equation}
This leads to the intermediate result \begin {equation}  \begin {gex} \gc {\gamma _{10}\land \dots \land \gamma _{m0}}&amp; \gc {f(t_{10},\dots ,t_{m0})}\\ \vdots &amp;\vdots \\ \gamma _{1n_1}\land \dots \land \gamma _{m0}&amp; f(t_{1n_1},\dots ,t_{m0})\\ \vdots &amp;\vdots \\ \gamma _{1n_1}\land \dots \land \gamma _{mn_m}&amp; f(t_{1n_1},\dots ,t_{mn_m}) \end {gex}. \label {intermediate}  \end {equation}
The new generic case is exactly the combination of the generic cases of the \(e_i'\). It is
redundant if at least one of these combined cases is redundant.
</p><!--l. 297--><p class="noindent" >Next, all non-generic cases containing at least one <span 
class="ptmri8t-x-x-109">redundant </span>generic constituent \(\gamma _{i0}\) in their
guard are deleted. The reason for this is that generic cases are only used to
keep track of the system default behavior. All other cases get the status of a
non-generic case even if they contain necessary generic constituents in their
guard.
</p><!--l. 304--><p class="noindent" >At this point, we apply the guarding scheme of \(f\) to all remaining expressions \(f(t_{1i_1},\ldots ,t_{mi_m})\) in the
form (\ref {intermediate}) yielding a nested guarded expression \begin {equation}  \begin {gex} \gc {\Gamma _0} &amp; \begin {gex} \gc {\delta _{00}} &amp; \gc {u_{00}}\\ \vdots &amp; \vdots \\ \delta _{0k_0} &amp; u_{0k_0} \end {gex}\\ \vdots &amp; \vdots \\ \Gamma _N &amp; \begin {gex} \gc {\delta _{N0}} &amp; \gc {u_{N0}}\\ \vdots &amp; \vdots \\ \delta _{Nk_N} &amp; u_{Nk_N} \end {gex} \end {gex},\label {nestedge}  \end {equation}
which can be straightforwardly resolved to a guarded expression \[ \begin {gex} \gc {\Gamma _0\land \delta _{00}} &amp; \gc {u_{00}}\\ \vdots &amp; \vdots \\ \Gamma _0\land \delta _{0k_0} &amp; u_{0k_0}\\ \vdots &amp; \vdots \\ \Gamma _N\land \delta _{N0} &amp; u_{N0}\\ \vdots &amp; \vdots \\ \Gamma _N\land \delta _{Nk_N} &amp; u_{Nk_N} \end {gex}. \] This form is treated
                                                                     

                                                                     
analogously to the form (\ref {intermediate}): The new generic case \((\Gamma _0\land \delta _{00},u_{00})\) is redundant if at least one of \(\bigl (\Gamma _0,f(t_{10},\dots ,t_{m0})\bigr )\) and
\((\delta _{00},u_{00})\) is redundant. Among the non-generic cases all those containing redundant
generic constituents in their guard are deleted, and all those containing necessary
generic constituents in their guard get the status of an ordinary non-generic
case.
</p><!--l. 340--><p class="noindent" >Finally the standard evaluator of the system—<span 
class="pcrr8t-x-x-109">reval </span>in the case of <span 
class="ptmrc8t-x-x-109"><span 
class="small-caps">R</span><span 
class="small-caps">E</span><span 
class="small-caps">D</span><span 
class="small-caps">U</span><span 
class="small-caps">C</span><span 
class="small-caps">E</span></span>—is
applied to all contained expressions, which completes the algebraic part of the
evaluation.
</p>
<h5 class="likesubsubsectionHead"><a 
 id="x214-79400020.26.2"></a>Evaluating guarded expressions</h5>
<!--l. 345--><p class="noindent" >The previous section was concerned with the evaluation of pure conventional expressions
into guarded expressions. Our system currently combines both conventional and guarded
expressions. We are thus faced with the problem of treating guarded subexpressions
during evaluation.
</p><!--l. 351--><p class="noindent" >When there is a <span 
class="ptmri8t-x-x-109">guarded </span>subexpression \(e_i\) detected during evaluation, all contained
expressions are recursively evaluated to guarded expressions yielding a nested guarded
expression of the form (\ref {nestedge}). This is resolved as described above yielding the evaluation
subresult \(e_i'\).
</p><!--l. 357--><p class="noindent" >As a special case, this explains how guarded expressions are (re)evaluated to guarded
expressions.
</p>
<h5 class="subsubsectionHead"><a 
 id="x214-79500020.26.2"></a>Example</h5>
<!--l. 361--><p class="noindent" >We describe the evaluation of the expression \(\min (x,|x|)\). The ﬁrst argument \(e_1=x\) evaluates recursively to
\begin {equation}  e_1'=\begin {gex} \gc {\true } &amp; \gc {x} \end {gex} \label {evalx}  \end {equation}
with a necessary generic case. The nested \(x\) inside \(e_2=|x|\) evaluates to the same form (\ref {evalx}). For
obtaining \(e_2'\), we apply the guarding scheme (\ref {absrewrite}) of the absolute value to the only
term of (\ref {evalx}) yielding \[ \begin {gex} \gc {\true } &amp; \begin {gex} \gc {\true } &amp; \gc {|x|}\\ x\geq 0 &amp; x\\ x&lt;0 &amp; -x \end {gex} \end {gex}, \] where the inner generic case is redundant. This form is
resolved to \[ e_2'=\begin {gex} \gc {\true \land \true } &amp; \gc {|x|}\\ \true \land x\geq 0 &amp; x\\ \true \land x&lt;0 &amp; -x \end {gex} \] with a redundant generic case. The next step is the combination of
cases by Cartesian product computation. We obtain \[ \begin {gex} \gc {\true \land (\true \land \true )} &amp; \gc {\min (x,|x|)}\\ \true \land (\true \land x\geq 0) &amp; \min (x,x)\\ \true \land (\true \land x&lt;0) &amp; \min (x,-x) \end {gex}, \] which corresponds to (\ref {intermediate})
above. For the outer \(\min \), we apply the guarding scheme (\ref {binminscheme}) to all terms yielding the
nested guarded expression \[ \begin {gex} \gc {\true \land (\true \land \true )} &amp; \begin {gex} \gc {\true } &amp; \gc {\min (x,|x|)}\\ x\leq |x| &amp; x\\ |x|\leq x &amp; |x| \end {gex}\\ \true \land (\true \land x\geq 0) &amp; \begin {gex} \gc {\true } &amp; \gc {\min (x,x)}\\ x\leq x &amp; x\\ x\leq x &amp; x \end {gex}\\ \true \land (\true \land x&lt;0) &amp; \begin {gex} \gc {\true } &amp; \gc {\min (x,-x)}\\ x\leq -x &amp; x\\ -x\leq x &amp; -x \end {gex} \end {gex}, \] which is in turn resolved to \[ \begin {gex} \gc {(\true \land (\true \land \true ))\land \true } &amp; \gc {\min (x,|x|)}\\ (\true \land (\true \land \true ))\land x\leq |x| &amp; x\\ (\true \land (\true \land \true ))\land |x|\leq x &amp; |x|\\ (\true \land (\true \land x\geq 0))\land \true &amp; \min (x,x)\\ (\true \land (\true \land x\geq 0))\land x\leq x &amp; x\\ (\true \land (\true \land x\geq 0))\land x\leq x &amp; x\\ (\true \land (\true \land x&lt;0))\land \true &amp; \min (x,-x)\\ (\true \land (\true \land x&lt;0))\land x\leq -x &amp; x\\ (\true \land (\true \land x&lt;0))\land -x\leq x &amp; -x \end {gex}. \] From this, we delete the
two non-generic cases obtained by combination with the redundant generic
case of the \(\min \). The ﬁnal result of the algebraic evaluation step is the following: \begin {equation}  \begin {gex} \gc {(\true \land (\true \land \true ))\land \true } &amp; \gc {\min (x,|x|)}\\ (\true \land (\true \land \true ))\land x\leq |x| &amp; x\\ (\true \land (\true \land \true ))\land |x|\leq x &amp; |x|\\ (\true \land (\true \land x\geq 0))\land x\leq x &amp; x\\ (\true \land (\true \land x\geq 0))\land x\leq x &amp; x\\ (\true \land (\true \land x&lt;0))\land x\leq -x &amp; x\\ (\true \land (\true \land x&lt;0))\land -x\leq x &amp; -x \end {gex}.\label {example}  \end {equation}
                                                                     

                                                                     
</p>
<h5 class="subsubsectionHead"><a 
 id="x214-79600020.26.2"></a>Worst-case complexity</h5>
<!--l. 447--><p class="noindent" >Our measure of complexity \(|G|\) for guarded expressions \(G\) is the number of contained cases:
\[ \left |\begin {gex} \gc {\gamma _0} &amp; \gc {t_0}\\ \gamma _1 &amp; t_1\\ \vdots&amp; \vdots \\ \gamma _n&amp; t_n \end {gex}\right |=n+1. \]
</p><!--l. 458--><p class="noindent" >As in Section <a 
href="manualse149.html#x214-79200020.26.2">20.26.2<!--tex4ht:ref: algeval --></a>, consider an \(m\)-ary operator \(f\), guarded expression arguments \(e_1'\), …, \(e_m'\) as
in equation (\ref {eprimes}), and the Cartesian product \(T\) as in equation (\ref {cartprod}). Then \begin {align*}  |f(e_1',\ldots ,e_m')| &amp; \leq \sum _{(t_1,\dots ,t_m)\in T}|\gscheme _f(t_1,\dots ,t_m)| \\ &amp; \leq \max _{(t_1,\ldots ,t_m)\in T}|\gscheme _f(t_1,\ldots ,t_m)|\cdot \#T\\ &amp; = \max _{(t_1,\ldots ,t_m)\in T}|\gscheme _f(t_1,\ldots ,t_m)|\cdot \prod _{j=1}^m|e_j'|\\ &amp; \leq \max _{(t_1,\ldots ,t_m)\in T}|\gscheme _f(t_1,\ldots ,t_m)|\cdot \bigl (\max _{1\leq j\leq m}|e_j'|\bigr )^m.  \end {align*}
</p><!--l. 473--><p class="noindent" >In the important special case that the guarding scheme of \(f\) is a rewrite rule \(f(a_1,\ldots ,a_m)\to G\), the above
complexity estimation simpliﬁes to \[ |f(e_1',\ldots ,e_m')| \leq |G|\cdot \prod _{j=1}^m|e_j'| \leq |G|\cdot \bigl (\max _{1\leq j\leq m}|e_j'|\bigr )^m. \] In other words: \(|G|\) plays the role of a factor, which,
however, depends on \(f\), and \(|f(e_1',\ldots ,e_m')|\) is polynomial in the size of the \(e_i\) but exponential in the arity of
\(f\).
</p><!--l. 485--><p class="noindent" >
</p>
<h5 class="subsubsectionHead"><a 
 id="x214-79700020.26.2"></a>Simpliﬁcation</h5>
<!--l. 486--><p class="noindent" >In view of the increasing size of the guarded expressions coming into existence with
subsequent computations, it is indispensable to apply simpliﬁcation strategies.
There are two diﬀerent algorithms involved in the simpliﬁcation of guarded
expressions:
     </p><ol  class="enumerate1" >
<li 
  class="enumerate" id="x214-797002x1">
     <!--l. 492--><p class="noindent" >A <span 
class="ptmri8t-x-x-109">formula simpliﬁer </span>mapping quantiﬁer-free formulas to equivalent simpler
     ones.
     </p></li>
<li 
  class="enumerate" id="x214-797004x2">
     <!--l. 495--><p class="noindent" >Eﬀective <span 
class="ptmri8t-x-x-109">quantiﬁer elimination </span>for real closed ﬁelds over the language of
     ordered rings.</p></li></ol>
<!--l. 499--><p class="noindent" >It is not relevant, which simpliﬁer and which quantiﬁer elimination procedure is actually
used. We use the formula simpliﬁer described in <span class="cite">[<a 
href="manualap2.html#XDolzmann:97b">DS97b</a>]</span>. Our quantiﬁer elimination
uses test point methods developed by Weispfenning <span class="cite">[<a 
href="manualap2.html#XWeispfenning:88">Wei88</a>, <a 
href="manualap2.html#XLoosWeispfenning:93">RLW93</a>, <a 
href="manualap2.html#XWeispfenning:96">Wei97</a>]</span>. It is
restricted to formulas obeying certain degree restrictions wrt. the quantiﬁed variables.
As an alternative, <span 
class="ptmrc8t-x-x-109"><span 
class="small-caps">R</span><span 
class="small-caps">E</span><span 
class="small-caps">D</span><span 
class="small-caps">L</span><span 
class="small-caps">O</span><span 
class="small-caps">G</span> </span>provides an interface to Hong’s <span 
class="ptmrc8t-x-x-109"><span 
class="small-caps">Q</span><span 
class="small-caps">E</span><span 
class="small-caps">P</span><span 
class="small-caps">C</span><span 
class="small-caps">A</span><span 
class="small-caps">D</span> </span>quantiﬁer
elimination package <span class="cite">[<a 
href="manualap2.html#XHong:93">HCJE93</a>]</span>. Compared to the simpliﬁcation, the quantiﬁer
                                                                     

                                                                     
elimination is more time consuming. It can be turned oﬀ by a <span 
class="ptmri8t-x-x-109">switch</span>.
</p><!--l. 511--><p class="noindent" >The following simpliﬁcation steps are applied in the given order:
</p>
<!--l. 513--><p class="noindent" ><span class="paragraphHead"><a 
 id="x214-79800020.26.2"></a><span 
class="ptmb8t-x-x-109">Contraction of cases</span></span>
This is restricted to the non-generic cases of the considered guarded expression. We
contract diﬀerent cases containing the same terms: \[ \begin {gex} \gc {\gamma _0}&amp;\gc {t_0}\\ \vdots &amp; \vdots \\ \gamma _i &amp; t_i\\ \vdots &amp; \vdots \\ \gamma _j &amp; t_i\\ \vdots &amp; \vdots \end {gex}\quad \mbox {becomes}\quad \begin {gex} \gc {\gamma _0}&amp;\gc {t_0}\\ \vdots &amp; \vdots \\ \gamma _i\lor \gamma _j &amp; t_i\\ \vdots &amp; \vdots \\ \end {gex}. \]
</p>
<!--l. 532--><p class="noindent" ><span class="paragraphHead"><a 
 id="x214-79900020.26.2"></a><span 
class="ptmb8t-x-x-109">Simpliﬁcation of the guards</span></span>
The simpliﬁer is applied to all guards replacing them by simpliﬁed equivalents. Since our
simpliﬁer maps \(\gamma \lor \gamma \) to \(\gamma \), this together with the contraction of cases takes care for the deletion
of duplicate cases.
</p>
<!--l. 537--><p class="noindent" ><span class="paragraphHead"><a 
 id="x214-80000020.26.2"></a><span 
class="ptmb8t-x-x-109">Keep one tautological case</span></span>
If the guard of some non-generic case becomes “\(\true \),” we delete all other non-generic cases.
Else, if quantiﬁer elimination is turned on, we try to detect a tautology by eliminating the
universal closures \(\underline \forall \gamma \) of the guards \(\gamma \). This quantiﬁer elimination is also applied to the guards
of generic cases. These are, in case of success, simply replaced by “\(\true \)” without deleting the
case.
</p>
<!--l. 546--><p class="noindent" ><span class="paragraphHead"><a 
 id="x214-80100020.26.2"></a><span 
class="ptmb8t-x-x-109">Remove contradictive cases</span></span>
A non-generic case is deleted if its guard has become “\(\false \).” If quantiﬁer elimination is
turned on, we try to detect further contradictive cases by eliminating the existential
closure \(\underline \exists \gamma \) for each guard \(\gamma \). This quantiﬁer elimination is also applied to generic cases. In
case of success they are not deleted but their guards are replaced by “\(\false \).” Our assumption (\ref {gencoversall})
allows then to delete all non-generic cases.
</p><!--l. 555--><p class="noindent" >
</p>
<h5 class="subsubsectionHead"><a 
 id="x214-80200020.26.2"></a>Example revisited</h5>
                                                                     

                                                                     
<!--l. 556--><p class="noindent" >We turn back to the form (\ref {example}) of our example \(\min (x,|x|)\). Contraction of cases with subsequent
simpliﬁcation automatically yields \[ \begin {gex} \gc {\true } &amp; \gc {\min (x,|x|)}\\ \true &amp; x\\ |x|-x\leq 0 &amp; |x|\\ \false &amp; -x \end {gex}, \] of which only the tautological non-generic case
survives: \begin {equation}  \begin {gex} \gc {\true } &amp; \gc {\min (x,|x|)}\\ \true &amp; x \end {gex}.\label {minabs}  \end {equation}
</p><!--l. 575--><p class="noindent" >
</p>
<h5 class="subsubsectionHead"><a 
 id="x214-80300020.26.2"></a>Output modes</h5>
<!--l. 576--><p class="noindent" >An <span 
class="ptmri8t-x-x-109">output mode </span>determines which part of the information contained in the guarded
expressions is provided to the user. <span 
class="ptmrc8t-x-x-109">G<span 
class="small-caps">U</span><span 
class="small-caps">A</span><span 
class="small-caps">R</span><span 
class="small-caps">D</span><span 
class="small-caps">I</span><span 
class="small-caps">A</span><span 
class="small-caps">N</span> </span>knows the following output
modes:
</p>
<!--l. 580--><p class="noindent" ><span class="paragraphHead"><a 
 id="x214-80400020.26.2"></a><span 
class="ptmb8t-x-x-109">Matrix</span></span>
Output matrices in the style used throughout this paper. We have already seen that these
can become very large in general.
</p>
<!--l. 583--><p class="noindent" ><span class="paragraphHead"><a 
 id="x214-80500020.26.2"></a><span 
class="ptmb8t-x-x-109">Generic case</span></span>
Output only the generic case.
</p>
<!--l. 584--><p class="noindent" ><span class="paragraphHead"><a 
 id="x214-80600020.26.2"></a><span 
class="ptmb8t-x-x-109">Generic term</span></span>
Output only the generic term. Thus the output is exactly the same as without the
guardian package. If the condition of the generic case becomes “\(\false \),” a <span 
class="ptmri8t-x-x-109">warning</span>
“<span 
class="pcrr8t-x-x-109">contradictive situation</span>” is given. The computation can, however, be
continued.
</p><!--l. 590--><p class="noindent" >Note that output modes are restrictions concerning only the output; internally the system
still computes with the complete guarded expressions.
</p>
<h5 class="subsubsectionHead"><a 
 id="x214-80700020.26.2"></a>A smart mode</h5>
<!--l. 595--><p class="noindent" >Consider the evaluation result (\ref {minabs}) of \(\min (x,|x|)\). The <span 
class="ptmri8t-x-x-109">generic term </span>output mode would output \(\min (x,|x|)\),
                                                                     

                                                                     
although more precise information could be given, namely \(x\). The problem is caused by
the fact that generic cases are used to keep track of the system’s default behavior. In this
section we will describe an optional <span 
class="ptmri8t-x-x-109">smart mode </span>with a diﬀerent notion of <span 
class="ptmri8t-x-x-109">generic case</span>.
To begin with, we show why the problem can not be overcome by a “smart output
mode.”
</p><!--l. 604--><p class="noindent" >Assume that there is an output mode which outputs \(x\) for (\ref {minabs}). As the next computation
involving (\ref {minabs}) consider division by \(y\). This would result in \[ \begin {gex} \gc {y\neq 0} &amp; \gc {\frac {\min (x,|x|)}{y}}\\ y\neq 0 &amp; \frac {x}{y} \end {gex}. \] Again, there are identic
conditions for the generic case and some non-generic case, and, again, the term
belonging to the latter is simpler. Our mode would output \(\frac {x}{y}\). Next, we apply the absolute
value once more yielding \[ \begin {gex} \gc {y\neq 0} &amp; \gc {\frac {|\min (x,|x|)|}{|y|}}\\ xy\geq 0 \land y\neq 0 &amp; \frac {x}{y}\\ xy&lt;0 \land y\neq 0 &amp; \frac {-x}{y} \end {gex}. \] Here, the condition of the generic case diﬀers from all other
conditions. We thus have to output the generic term. For the user, the evaluation of \(|\frac {x}{y}|\)
results in \(\frac {|\min (x,|x|)|}{|y|}\).
</p><!--l. 628--><p class="noindent" >The smart mode can turn a non-generic case into a necessary generic one dropping the
original generic case and all other non-generic cases. Consider, e.g., (\ref {minabs}), where the
conditions are equal, and the non-generic term is “simpler.”
</p><!--l. 633--><p class="noindent" >In fact, the relevant relationship between the conditions is that the generic condition
<span 
class="ptmri8t-x-x-109">implies </span>the non-generic one. In other words: Some non-generic condition is not more
restrictive than the generic condition, and thus covers the whole domain of the guarded
expression. Note that from the implication and (\ref {gencoversall}) we may conclude that the cases are
even equivalent.
</p><!--l. 640--><p class="noindent" >Implication is heuristically checked by simpliﬁcation. If this fails, quantiﬁer elimination
provides a decision procedure. Note that our test point methods are incomplete in this
regard due to the degree restrictions. Also it cannot be applied straightforwardly
to guards containing operators that do not belong to the language of ordered
rings.
</p><!--l. 647--><p class="noindent" >Whenever we happen to detect a relevant implication, we actually turn the corresponding
non-generic case into the generic one. From our motivation of non-generic cases, we may
expect that non-generic expressions are generally more convenient than generic
ones.
</p>
<h4 class="subsectionHead"><span class="titlemark">20.26.3    </span> <a 
 id="x214-80800020.26.3"></a>Examples</h4>
<!--l. 653--><p class="noindent" >We give the results for the following computations as they are printed in the output mode
<span 
class="ptmri8t-x-x-109">matrix </span>providing the full information on the computation result. The reader can derive
himself what the output in the mode <span 
class="ptmri8t-x-x-109">generic case </span>or <span 
class="ptmri8t-x-x-109">generic term </span>would be.
</p>
     <ul class="itemize1">
     <li class="itemize">
                                                                     

                                                                     
     <!--l. 658--><p class="noindent" >Smart  mode  or  not:  \[ \frac {1}{x^2+2x+1}=\begin {gex} \gc {x+1\neq 0}&amp; \gc {\frac {1}{x^2+2x+1}} \end {gex}. \]  The  simpliﬁer  recognizes  that  the  denominator  is  a
     square.
     </p></li>
     <li class="itemize">
     <!--l. 665--><p class="noindent" >Smart   mode   or   not:   \[ \frac {1}{x^2+2x+2}=\begin {gex} \gc {\true }&amp; \gc {\frac {1}{x^2+2x+2}} \end {gex}. \]   Quantiﬁer   elimination   recognizes   the   positive
     deﬁniteness of the denominator.
     </p></li>
     <li class="itemize">
     <!--l. 673--><p class="noindent" >Smart mode: \[ |x|-\sqrt {x}=\begin {gex} \gc {x\geq 0} &amp; \gc {-\sqrt {x}+x} \end {gex}. \] The square root allows to forget about the negative branch of
     the absolute value.
     </p></li>
     <li class="itemize">
     <!--l. 681--><p class="noindent" >Smart mode: \[ |x^2+2x+1|=\begin {gex} \gc {\true }&amp;\gc {x^2+2x+1} \end {gex}. \] The simpliﬁer recognizes the positive semideﬁniteness of the
     argument. <span 
class="ptmrc8t-x-x-109">R<span 
class="small-caps">E</span><span 
class="small-caps">D</span><span 
class="small-caps">U</span><span 
class="small-caps">C</span><span 
class="small-caps">E</span> </span>itself recognizes squares within absolute values only in
     very special cases such as \(|x^2|\).
     </p></li>
     <li class="itemize">
     <!--l. 690--><p class="noindent" >Smart  mode:  \[ \min \bigl (x,\max (x,y)\bigr )=\begin {gex} \gc {\true }&amp;\gc {x} \end {gex}. \]  Note  that  <span 
class="ptmrc8t-x-x-109"><span 
class="small-caps">R</span><span 
class="small-caps">E</span><span 
class="small-caps">D</span><span 
class="small-caps">U</span><span 
class="small-caps">C</span><span 
class="small-caps">E</span>  </span>does  not  know  any  rules  about  nested
     minima and maxima.
     </p></li>
     <li class="itemize">
     <!--l. 699--><p class="noindent" >Smart mode: \[ \min \bigl (\sign (x),-1\bigr )=\begin {gex} \gc {\true }&amp;\gc {-1} \end {gex}. \]
     </p></li>
     <li class="itemize">
     <!--l. 705--><p class="noindent" >Smart mode or not: \[ |x|-x=\begin {gex} \gc {\true }&amp;\gc {|x|-x}\\ x\geq 0&amp;0\\ x&lt;0&amp;-2x \end {gex}. \] This example is taken from <span class="cite">[<a 
href="manualap2.html#XDavenportFaure:94">DF94</a>]</span>.
     </p></li>
     <li class="itemize">
     <!--l. 715--><p class="noindent" >Smart mode or not: \[ \sqrt {1+x^2 y^2 (x^2+y^2-3)}={} \begin {gex}\gc {\true }&amp;\gc {\sqrt {x^4 y^2 + x^2 y^4 - 3 x^2 y^2 + 1}}\end {gex} \] The <span 
class="ptmri8t-x-x-109">Motzkin polynomial </span>is recognized to be positive
     semideﬁnite by quantiﬁer elimination.</p></li></ul>
<!--l. 723--><p class="noindent" >The evaluation time for the last example is 119 ms on a <span 
class="ptmrc8t-x-x-109"><span 
class="small-caps">S</span><span 
class="small-caps">U</span><span 
class="small-caps">N</span> <span 
class="small-caps">S</span><span 
class="small-caps">P</span><span 
class="small-caps">A</span><span 
class="small-caps">R</span><span 
class="small-caps">C</span>-4</span>. This illustrates
that eﬃciency is no problem with such interactive examples.
</p>
<h4 class="subsectionHead"><span class="titlemark">20.26.4    </span> <a 
 id="x214-80900020.26.4"></a>Outlook</h4>
                                                                     

                                                                     
<!--l. 727--><p class="noindent" >This section describes possible extensions of the <span 
class="ptmrc8t-x-x-109"><span 
class="small-caps">G</span><span 
class="small-caps">U</span><span 
class="small-caps">A</span><span 
class="small-caps">R</span><span 
class="small-caps">D</span><span 
class="small-caps">I</span><span 
class="small-caps">A</span><span 
class="small-caps">N</span></span>. The extensions
proposed in Section <a 
href="manualse149.html#x214-81000020.26.4">20.26.4<!--tex4ht:ref: simplification --></a> on simpliﬁcation of terms and Section <a 
href="manualse149.html#x214-81100020.26.4">20.26.4<!--tex4ht:ref: background --></a>
on a background theory are clear from a theoretical point of view but not yet
implemented. Section <a 
href="manualse149.html#x214-81200020.26.4">20.26.4<!--tex4ht:ref: integration --></a> collects some ideas on the application of our ideas
to the <span 
class="ptmrc8t-x-x-109"><span 
class="small-caps">R</span><span 
class="small-caps">E</span><span 
class="small-caps">D</span><span 
class="small-caps">U</span><span 
class="small-caps">C</span><span 
class="small-caps">E</span> </span>integrator. In this ﬁeld, there is some more theoretical work
necessary.
</p>
<h5 class="subsubsectionHead"><a 
 id="x214-81000020.26.4"></a>Simpliﬁcation of terms</h5>
<!--l. 736--><p class="noindent" >Consider the expression \(\sign (x)x-|x|\). It evaluates to the following guarded expression: \[ \begin {gex} \gc {\true } &amp; \gc {-|x|+\sign (x)x}\\ x\neq 0 &amp; 0\\ x=0 &amp; -x \end {gex}. \] This suggests
to substitute \(-x\) by \(0\) in the third case, which would in turn allow to contract the two
non-generic cases yielding \[ \begin {gex} \gc {\true } &amp; \gc {-|x|+\sign (x)x}\\ \true &amp; 0\end {gex}. \] In smart mode second case would then become the only
generic case.
</p><!--l. 754--><p class="noindent" >Generally, one would proceed as follows: If the guard is a conjunction containing as
toplevel equations \[ t_1=0,\quad \dots ,\quad t_k=0, \] reduce the corresponding expression modulo the set of univariate
linear polynomials among \(t_1\), …, \(t_k\).
</p><!--l. 762--><p class="noindent" >A more general approach would reduce the expression modulo a Gröbner basis of all
the \(t_1\), …, \(t_k\). This leads, however, to larger expressions in general.
</p><!--l. 766--><p class="noindent" >One can also imagine to make use of non-conjunctive guards in the following
way:
     </p><ol  class="enumerate1" >
<li 
  class="enumerate" id="x214-810002x1">
     <!--l. 769--><p class="noindent" >Compute a <span 
class="ptmrc8t-x-x-109"><span 
class="small-caps">D</span><span 
class="small-caps">N</span><span 
class="small-caps">F</span> </span>of the guard.
     </p></li>
<li 
  class="enumerate" id="x214-810004x2">
     <!--l. 770--><p class="noindent" >Split  the  case  into  several  cases  corresponding  to  the  conjunctions  in  the
     <span 
class="ptmrc8t-x-x-109"><span 
class="small-caps">D</span><span 
class="small-caps">N</span><span 
class="small-caps">F</span></span>.
     </p></li>
<li 
  class="enumerate" id="x214-810006x3">
     <!--l. 772--><p class="noindent" >Simplify the terms.
     </p></li>
<li 
  class="enumerate" id="x214-810008x4">
                                                                     

                                                                     
     <!--l. 773--><p class="noindent" >Apply   the   standard   simpliﬁcation   procedure   to   the   resulting   guarded
     expression. Note that it includes <span 
class="ptmri8t-x-x-109">contraction of cases</span>.</p></li></ol>
<!--l. 776--><p class="noindent" >According to experiences with similar ideas in the “Gröbner simpliﬁer” described
in <span class="cite">[<a 
href="manualap2.html#XDolzmann:97b">DS97b</a>]</span>, this should work well.
</p>
<h5 class="subsubsectionHead"><a 
 id="x214-81100020.26.4"></a>Background theory</h5>
<!--l. 781--><p class="noindent" >In practice one often computes with quantities guaranteed to lie in a certain range. For
instance, when computing an electrical resistance, one knows in advance that it will not
be negative. For such cases one would like to have some facility to provide external
information to the system. This can then be used to reduce the complexity of the guarded
expressions.
</p><!--l. 788--><p class="noindent" >One would provide a function <span 
class="pcrr8t-x-x-109">assert(</span>\(\varphi \)<span 
class="pcrr8t-x-x-109">)</span>, which asserts the formula \(\varphi \) to hold.
Successive applications of <span 
class="pcrr8t-x-x-109">assert </span>establish a <span 
class="ptmri8t-x-x-109">background theory</span>, which is a
set of formulas considered conjunctively. The information contained in the
background theory can be used with the guarded expression computation. The
user must, however, not rely on all the background information to be actually
used.
</p><!--l. 796--><p class="noindent" >Technically, denote by \(\Phi \) the (conjunctive) background theory. For the <span 
class="ptmri8t-x-x-109">simpliﬁcation of the</span>
<span 
class="ptmri8t-x-x-109">guards</span>, we can make use of the fact that our simpliﬁer is designed to simplify wrt. a
theory, cf. <span class="cite">[<a 
href="manualap2.html#XDolzmann:97b">DS97b</a>]</span>. For proving that some guard \(\gamma \) is <span 
class="ptmri8t-x-x-109">tautological</span>, we try to prove \[\underline {\forall }(\Phi \longrightarrow \gamma )\]
instead of \(\underline {\forall }\gamma \). Similarly, for proving that \(\gamma \) is <span 
class="ptmri8t-x-x-109">contradictive</span>, we try to disprove \[\underline {\exists }(\Phi \land \gamma ).\] Instead of
proving \(\underline {\forall }(\gamma _1\longrightarrow \gamma _2)\) in smart mode, we try to prove \[\underline {\forall }\bigl ((\Phi \land \gamma _1)\longrightarrow \gamma _2\bigr ).\]
</p><!--l. 809--><p class="noindent" >Independently, one can imagine to use a background theory for reducing the <span 
class="ptmri8t-x-x-109">output </span>with
the <span 
class="ptmri8t-x-x-109">matrix </span>output mode. For this, one simpliﬁes each guard wrt. the theory at the
output stage treating contradictions and tautologies appropriately. Using the
theory for replacing all cases by one at output stage in a smart mode manner
leads once more to the problem of expressions or even guarded expressions
“mysteriously” getting more complicated. Applying the theory only at the output stage
makes it possible to implement a procedure <span 
class="pcrr8t-x-x-109">unassert(</span>\(\varphi \)<span 
class="pcrr8t-x-x-109">) </span>in a reasonable
way.
</p>
<h5 class="subsubsectionHead"><a 
 id="x214-81200020.26.4"></a>Integration</h5>
<!--l. 820--><p class="noindent" ><span 
class="ptmrc8t-x-x-109">C<span 
class="small-caps">A</span><span 
class="small-caps">S</span> </span>integrators make “mistakes” similar to those we have examined. Consider, e.g.,
the typical result \[ \int x^a\,dx=\frac {1}{a+1}x^{a+1}. \] It does not cover the case \(a=-1\), for which one wishes to obtain \[ \int x^{-1}\,dx=\ln x. \]
                                                                     

                                                                     
This problem can also be solved by using guarded expressions for integration
results.
</p><!--l. 832--><p class="noindent" >Within the framework of this paper, we would have to associate a guarding scheme to the
integrator <span 
class="pcrr8t-x-x-109">int</span>. It is not hard to see that this cannot be done in a reasonable way without
putting as much knowledge into the scheme as into the integrator itself. Thus
for treating integration, one has to modify the integrator to provide guarded
expressions.
</p><!--l. 839--><p class="noindent" >Next, we have to clarify what the guarded expression for the above integral would look
like. Since we know that the integral is deﬁned for all interpretations of the variables, our
assumption (\ref {gencoversall}) implies that the generic condition be “\(\true \).” We obtain the guarded
expression \[ \begin {gex} \gc {\true }&amp; \gc {\int x^a\,dx}\\ a\neq -1&amp; \frac {1}{a+1}x^{a+1}\\ a=-1 &amp; \ln x \end {gex}. \] Note that the redundant generic case does not model the system’s current
behavior.
</p>
<h5 class="subsubsectionHead"><a 
 id="x214-81300020.26.4"></a>Combining algebra with logic</h5>
<!--l. 855--><p class="noindent" >Our method, in the described form, uses an already implemented algebraic evaluator. In
the previous section, we have seen that this point of view is not suﬃcient for treating
integration appropriately.
</p><!--l. 860--><p class="noindent" >Also our approach runs into trouble with built-in knowledge such as \begin {align}  \sqrt {x^2} &amp;= |x|\label {sqrtrule},\\ \sign (|x|) &amp;= 1\label {signrule}.  \end {align}
</p><!--l. 865--><p class="noindent" >Equation (\ref {sqrtrule}) introduces an absolute value operator within a non-generic term
without making a case distinction. Equation (\ref {signrule}) is wrong when not considering \(x\)
transcendental. In contrast to the situation with reciprocals, our technique cannot be
used to avoid this “mistake.” We obtain \[ \sign (|x|)=\begin {gex} \gc {\true } &amp; \gc {1}\\ x\neq 0 &amp; 1\\ x=0 &amp; 0 \end {gex} \] yielding two diﬀerent answers for
\(x=0\).
</p><!--l. 879--><p class="noindent" >We have already seen in the example Section <a 
href="manualse149.html#x214-80800020.26.3">20.26.3<!--tex4ht:ref: examples --></a> that the implementation of
knowledge such as (\ref {sqrtrule}) and (\ref {signrule}) is usually quite <span 
class="ptmri8t-x-x-109">ad hoc</span>, and can be mostly covered by using
guarded expressions. This obesrvation gives rise to the following question: When
designing a new <span 
class="ptmrc8t-x-x-109"><span 
class="small-caps">C</span><span 
class="small-caps">A</span><span 
class="small-caps">S</span> </span>based on guarded expressions, how should the knowledge be
distributed between the algebraic side and the logic side?
</p>
<h4 class="subsectionHead"><span class="titlemark">20.26.5    </span> <a 
 id="x214-81400020.26.5"></a>Conclusions</h4>
<!--l. 888--><p class="noindent" >Guarded expressions can be used to overcome well-known problems with interpreting
expressions as terms. We have explained in detail how to compute with guarded
expressions including several simpliﬁcation techniques. Moreover we gain algebraic
                                                                     

                                                                     
simpliﬁcation power from the logical simpliﬁcations. Numerous examples illustrate the
power of our simpliﬁcation methods. The largest part of our ideas is eﬃciently
implemented, and the software is published. The outlook on background theories and on
the treatment of integration by guarded expressions points on interesting future
extensions.
</p><!--l. 557--><p class="noindent" >
                                                                     

                                                                     
                                                                     

                                                                     
</p><!--l. 559--><p class="noindent" ><table cellspacing="5"><tr><td class="clinks"><a 
href="../manual-lookup.php%3FUser&#32;Contributed&#32;Packages.html#manualse149.html" >Up</a></td><td class="clinks"><a 
href="manualse150.html" >Next</a></td><td class="clinks"><a 
href="../manual-lookup.php%3FGROEBNER:.html" >Prev</a></td><td class="clinks"><a 
href="../manual-lookup.php%3FGROEBNER:.html#tailmanualse148.html" >PrevTail</a></td><td class="clinks"><a 
href="manualse149.html" >Front</a></td></tr></table><a 
 id="tailmanualse149.html"></a>  <hr> <p style="font-family:sans-serif">Hosted by <a href="https://sourceforge.net/p/reduce-algebra/"> <img title="Download REDUCE" alt="Download REDUCE" style="vertical-align:middle" src="https://sourceforge.net/sflogo.php?type=16&amp;group_id=248416"/></a> <a href="https://www.mathjax.org"> <img title="Powered by MathJax" alt="Powered by MathJax" style="float:right" src="https://www.mathjax.org/badge/badge.gif"/></a></p></p> 
</body> 
</html>