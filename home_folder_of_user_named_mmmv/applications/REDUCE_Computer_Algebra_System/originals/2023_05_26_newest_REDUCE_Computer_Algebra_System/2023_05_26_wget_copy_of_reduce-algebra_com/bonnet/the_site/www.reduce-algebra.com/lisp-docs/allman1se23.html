<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"  
  "http://www.w3.org/TR/html4/loose.dtd">  
<html > 
<head><title>Sequencing Evaluation</title> 
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1"> 
<meta name="generator" content="TeX4ht (http://www.cse.ohio-state.edu/~gurari/TeX4ht/)"> 
<meta name="originator" content="TeX4ht (http://www.cse.ohio-state.edu/~gurari/TeX4ht/)"> 
<!-- 3,html --> 
<meta name="src" content="allman1.tex"> 
<meta name="date" content="2014-05-02 18:10:00"> 
<link rel="stylesheet" type="text/css" href="allman1.css"> 
</head><body 
>
<p align="centre"><img src="http://www.reduce-algebra.com/lisp-docs/redlogo.png" width=621 height=60 border=0 alt="REDUCE"></p><table cellspacing="5"><tr><td class="clinks"><a 
href="allman1li6.html#allman1se23.html" >Up</a></td><td class="clinks"><a 
href="allman1se24.html" >Next</a></td><td class="clinks"><a 
href="allman1se22.html" >Prev</a></td><td class="clinks"><a 
href="allman1se22.html#tailallman1se22.html" >PrevTail</a></td><td class="clinks"><a 
href="allman1se23.html#tailallman1se23.html">Tail</a></td></tr></table><h3 class="sectionHead"><span class="titlemark">7.3    </span> <a 
 id="x32-800007.3"></a>Sequencing Evaluation</h3>
<!--l. 205--><p class="noindent" >These functions provide for explicit control sequencing, and the definition of blocks altering the
scope of local variables.
<!--l. 213--><p class="noindent" ><div class="minipage"><a 
 id="dx32-80001"></a>
<span 
class="ptmb7t-x-x-120">(let A:list [B:form]): any                                                                                          </span><span 
class="ptmri7t-x-x-120">macro</span>
<br 
class="newline" /><div class="minipage">The general form follows, the square brackets are used to indicate zero or
more occurances of an expression.</div>
</div>

<div class="verbatim" id="verbatim-160">
&#x00A0;&#x00A0;&#x00A0;&#x00A0;(LET&#x00A0;([(&#x003C;var&#x003E;&#x00A0;&#x003C;value&#x003E;)])&#x00A0;[&#x003C;body&#x003E;])
</div>
<!--l. 216--><p class="nopar" >The <span 
class="cmmi-12">&#x003C;</span>value<span 
class="cmmi-12">&#x003E;</span>s are evaluated (in an unspecified order), and then the <span 
class="cmmi-12">&#x003C;</span>var<span 
class="cmmi-12">&#x003E;</span>s are bound to these
values. The body, consisting of the <span 
class="cmmi-12">&#x003C;</span>body<span 
class="cmmi-12">&#x003E; </span>forms, is evaluated in a left to right order. The
value returned is the result of the last body form or nil if the body is empty. Note
that the <span 
class="cmmi-12">&#x003C;</span>value<span 
class="cmmi-12">&#x003E;</span>s are evaluated in the outer environment, before the <span 
class="cmmi-12">&#x003C;</span>var<span 
class="cmmi-12">&#x003E;</span>s are
bound.<br 
class="newline" />
<!--l. 225--><p class="noindent" >This function is equivalent to

<div class="verbatim" id="verbatim-161">
&#x00A0;&#x00A0;&#x00A0;&#x00A0;((lambda&#x00A0;([&#x003C;var&#x003E;])&#x00A0;[&#x003C;body&#x003E;])&#x00A0;[&#x003C;value&#x003E;])
</div>
<!--l. 229--><p class="nopar" >The let-style is attractive since it places the <span 
class="cmmi-12">&#x003C;</span>var<span 
class="cmmi-12">&#x003E;</span>s close to their binding forms (<span 
class="cmmi-12">&#x003C;</span>value<span 
class="cmmi-12">&#x003E;</span>s),
thereby increasing readability.<br 
class="newline" />
<!--l. 234--><p class="noindent" >There are two shorthand formats for (<span 
class="cmmi-12">&#x003C;</span>var<span 
class="cmmi-12">&#x003E; &#x003C;</span>value<span 
class="cmmi-12">&#x003E;</span>). One is (<span 
class="cmmi-12">&#x003C; var &#x003E;</span>) and the other is just
<span 
class="cmmi-12">&#x003C; var &#x003E;</span>. Both of these mean bind <span 
class="cmmi-12">&#x003C; var &#x003E; </span>to nil. As a rule of style, you should
use (<span 
class="cmmi-12">&#x003C; var &#x003E; </span>nil) if you mean to use the value of <span 
class="cmmi-12">&#x003C; var &#x003E; </span>without assigning it it
first, and just (<span 
class="cmmi-12">&#x003C; var &#x003E;</span>) or <span 
class="cmmi-12">&#x003C; var &#x003E; </span>if you do not care what <span 
class="cmmi-12">&#x003C; var &#x003E; </span>gets bound
to.<br 
class="newline" />
<!--l. 241--><p class="noindent" >The following expression returns the middle element of a vector.

<div class="verbatim" id="verbatim-162">
&#x00A0;&#x00A0;&#x00A0;&#x00A0;(let&#x00A0;((n&#x00A0;(vector-size&#x00A0;vector)))
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;(unless&#x00A0;(zerop&#x00A0;n)
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;(vector-fetch&#x00A0;vector&#x00A0;(add1&#x00A0;(/&#x00A0;n&#x00A0;2)))))
</div>
<!--l. 247--><p class="nopar" >
<!--l. 254--><p class="noindent" ><div class="minipage"><a 
 id="dx32-80002"></a>
<span 
class="ptmb7t-x-x-120">(let* A:list [B:form]): any                                                                                        </span><span 
class="ptmri7t-x-x-120">macro</span>
<br 
class="newline" /><div class="minipage">Let* is just like let except that it makes the assignments sequentially. That
is, the first binding is made before the value for the second one is computed.
The example below illustrates the difference between let and let*.</div>
</div>

<div class="verbatim" id="verbatim-163">
&#x00A0;&#x00A0;&#x00A0;&#x00A0;1&#x00A0;lisp&#x003E;&#x00A0;(setq&#x00A0;front&#x00A0;'red&#x00A0;back&#x00A0;'orange)
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;orange
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;2&#x00A0;lisp&#x003E;&#x00A0;(let&#x00A0;((front&#x00A0;'blue)&#x00A0;(back&#x00A0;front))&#x00A0;&#x00A0;back)
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;red
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;3&#x00A0;lisp&#x003E;&#x00A0;(let&#x22C6;&#x00A0;((front&#x00A0;'blue)&#x00A0;(back&#x00A0;front))&#x00A0;&#x00A0;back)
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;blue
</div>
<!--l. 262--><p class="nopar" >
<!--l. 267--><p class="noindent" ><div class="minipage"><a 
 id="dx32-80003"></a>
<span 
class="ptmb7t-x-x-120">(progn [U:form]): any                                                                        </span><span 
class="ptmri7t-x-x-120">open-compiled fexpr</span>
<br 
class="newline" /><div class="minipage">U  is  a  set  of  expressions  which  are  executed  sequentially.  The  value
returned is the value of the last expression.</div>
</div>
<!--l. 272--><p class="noindent" ><div class="minipage"><a 
 id="dx32-80004"></a>
<span 
class="ptmb7t-x-x-120">(prog2 A:form B:form): any                                                              </span><span 
class="ptmri7t-x-x-120">open-compiled expr</span>
<br 
class="newline" /><div class="minipage">Returns the value of the second argument B. Note that prog2 expects only
two arguments.</div>
</div>
<!--l. 278--><p class="noindent" ><div class="minipage"><a 
 id="dx32-80005"></a>
<span 
class="ptmb7t-x-x-120">(prog1 [U:form]): any                                                                                               </span><span 
class="ptmri7t-x-x-120">macro</span>
<br 
class="newline" /><div class="minipage">Prog1 is a function defined in the USEFUL package. Prog1 evaluates its
arguments in order, like progn, but returns the value of the first.</div>
</div>
<!--l. 292--><p class="noindent" ><div class="minipage"><a 
 id="dx32-80006"></a>
<span 
class="ptmb7t-x-x-120">(prog VARS:id-list [PROGRAM:id,form]): any open-compiled fexpr                          </span><br 
class="newline" /><div class="minipage">VARS is a list of ids which are considered fluid if the prog is interpreted
and local if compiled (see the &#8221;Variables and Bindings&#8221; Section, 9.2). The
prog&#8217;s variables are allocated space when the prog form is applied, and are
deallocated when the prog is exited. Prog variables are initialized to nil. The
program is a set of expressions to be evaluated in order of their appearance
in the prog function. An id which appears at the top level of the program are
labels which can be referred by go. The value returned by the prog function
is determined by a return function or nil if the prog &#8221;falls through&#8221;.</div>
</div>

<div class="verbatim" id="verbatim-164">
&#x00A0;&#x00A0;&#x00A0;&#x00A0;(de&#x00A0;sum-up&#x00A0;(seq)
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;(prog&#x00A0;(sum)
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;(setq&#x00A0;sum&#x00A0;0)
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;loop
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;(when&#x00A0;(null&#x00A0;seq)&#x00A0;(return&#x00A0;sum))
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;(when&#x00A0;(numberp&#x00A0;(first&#x00A0;seq))
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;(setq&#x00A0;sum&#x00A0;(plus&#x00A0;sum&#x00A0;(first&#x00A0;seq)))
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;(setq&#x00A0;seq&#x00A0;(rest&#x00A0;seq))
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;(go&#x00A0;loop))))
</div>
<!--l. 303--><p class="nopar" >

<div class="verbatim" id="verbatim-165">
&#x00A0;&#x00A0;&#x00A0;&#x00A0;1&#x00A0;lisp&#x003E;&#x00A0;(sum-up&#x00A0;'(1&#x00A0;3&#x00A0;5))
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;9
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;2&#x00A0;lisp&#x003E;&#x00A0;(sum-up&#x00A0;'(a))
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;nil
</div>
<!--l. 309--><p class="nopar" >There are restrictions as to where the control functions go and return may be placed. The
functions go and return are intended to be used within a prog. This is so that they may have only
locally determinable effects. Unfortunately these restrictions are not consistent across compiled
and interpreted code. It is recommended that if a non-local exit is required then use catch and
throw (see section 8.5).
<!--l. 318--><p class="noindent" >In interpreted code, upon encountering a return a search is made for the latest instance of an
entrance to a prog. If the search is successful then the evaluation of that prog is considered
complete, the value returned is the argument to return. If the search for a prog fails then the
message

<div class="verbatim" id="verbatim-166">
&#x22C6;&#x22C6;&#x22C6;&#x22C6;&#x22C6;&#x00A0;RETURN&#x00A0;attempted&#x00A0;outside&#x00A0;the&#x00A0;scope&#x00A0;of&#x00A0;a&#x00A0;PROG
</div>
<!--l. 326--><p class="nopar" >is displayed. The treatment of return is much different when the code is compiled. A return
may appear outside the scope of a prog. For example, the compiler will compile the
sequence

<div class="verbatim" id="verbatim-167">
(if&#x00A0;(not&#x00A0;(numberp&#x00A0;x))&#x00A0;(return&#x00A0;'unknown))
&#x00A0;<br />(compute&#x00A0;x))
</div>
<!--l. 334--><p class="nopar" >as if it were were enclosed within a prog.

<div class="verbatim" id="verbatim-168">
(prog&#x00A0;()
&#x00A0;<br />&#x00A0;&#x00A0;(if&#x00A0;(not&#x00A0;(numberp&#x00A0;x))&#x00A0;(return&#x00A0;'unknown))
&#x00A0;<br />&#x00A0;&#x00A0;(return&#x00A0;(compute&#x00A0;x))))
</div>
<!--l. 341--><p class="nopar" >Upon reaching a go within interpreted code a search is made for the latest entrance to a prog.
If this search is successful then a second search is made for a label which matches
the argument to go. The failure of either search is an error. If the first search fails
then

<div class="verbatim" id="verbatim-169">
&#x22C6;&#x22C6;&#x22C6;&#x22C6;&#x22C6;&#x00A0;GO&#x00A0;attempted&#x00A0;outside&#x00A0;the&#x00A0;scope&#x00A0;of&#x00A0;a&#x00A0;PROG
</div>
<!--l. 350--><p class="nopar" >is printed. The message

<div class="verbatim" id="verbatim-170">
&#x22C6;&#x22C6;&#x22C6;&#x22C6;&#x22C6;&#x00A0;&#8216;LABEL'&#x00A0;is&#x00A0;not&#x00A0;a&#x00A0;label&#x00A0;within&#x00A0;the&#x00A0;current&#x00A0;scope
</div>
<!--l. 355--><p class="nopar" >is printed if the second search fails. When a prog form is compiled the compiler expects to be
able to resolve all label references. Thus every go must appear within a prog otherwise the
following error message is printed.

<div class="verbatim" id="verbatim-171">
&#x22C6;&#x22C6;&#x22C6;&#x22C6;&#x22C6;&#x00A0;FORM&#x00A0;invalid&#x00A0;go
</div>
<!--l. 363--><p class="nopar" >In addition, the argument to a go must refer to a label defined inside the prog which contains
that go. The message

<div class="verbatim" id="verbatim-172">
&#x22C6;&#x22C6;&#x22C6;&#x22C6;&#x22C6;&#x00A0;Compiler&#x00A0;bug:&#x00A0;missing&#x00A0;label&#x00A0;LABEL
</div>
<!--l. 369--><p class="nopar" >is printed to indicate when this second restriction is not met.
<!--l. 377--><p class="noindent" ><div class="minipage"><a 
 id="dx32-80007"></a>
<span 
class="ptmb7t-x-x-120">(go LABEL:id): None Returned                                                       </span><span 
class="ptmri7t-x-x-120">open-compiled fexpr</span>
<br 
class="newline" /><div class="minipage">Go  alters  the  normal  flow  of  control  within  a  prog  function.  The  next
statement of a prog function to be evaluated is immediately preceded by
label.</div></div>
<!--l. 382--><p class="noindent" ><div class="minipage"><a 
 id="dx32-80008"></a>
<span 
class="ptmb7t-x-x-120">(return U:form): None Returned                                                       </span><span 
class="ptmri7t-x-x-120">open-compiled expr</span>
<br 
class="newline" /><div class="minipage">Within a prog, return terminates the evaluation of a prog and returns U as
the value of the prog.</div>
</div>
<h4 class="subsectionHead"><span class="titlemark">7.3.1    </span> <a 
 id="x32-810007.3.1"></a>Iteration</h4>
<!--l. 392--><p class="noindent" ><div class="minipage"><a 
 id="dx32-81001"></a>
<span 
class="ptmb7t-x-x-120">(while E:form [S:form]): nil                                                                                     </span><span 
class="ptmri7t-x-x-120">macro</span>
<br 
class="newline" /><div class="minipage">This  is  a  commonly  used  construct  for  indefinite  iteration  in  PSL.  E  is
evaluated; if non-nil the S&#8217;s are evaluated from left to right and then the
process  is  repeated.  If  E  evaluates  to  nil  the  while  returns  nil.  Exit  may
be used to terminate the while and to return a value. Next may be used to
terminate the current iteration.</div></div>
<!--l. 400--><p class="noindent" ><div class="minipage"><a 
 id="dx32-81002"></a>
<span 
class="ptmb7t-x-x-120">(repeat [S:form] E:form): nil                                                                                   </span><span 
class="ptmri7t-x-x-120">macro</span>
<br 
class="newline" /><div class="minipage">The S&#8217;s are evaluated left to right, and then E is evaluated. This is repeated
until the value of E is non-nil, at which point repeat returns nil. Next and
exit may be used in the S&#8217;s to branch to the next iteration of a repeat or to
terminate one and possibly return a value.</div>
</div>

<!--l. 409--><p class="noindent" ><div class="minipage"><a 
 id="dx32-81003"></a>
<span 
class="ptmb7t-x-x-120">(next): None Returned                                                    </span><span 
class="ptmri7t-x-x-120">open-compiled, restricted macro</span>
<br 
class="newline" /><div class="minipage">This  terminates  the  current  iteration  of  the  most  closely  surrounding
while or repeat, and causes the next to commence. Both while and repeat
are  macros  which  expand  into  prog&#8217;s  and  next  is  essentially  a  go.  The
restrictions on the placement of next are similar to those of go, see section
8.3 for details.</div></div>
<!--l. 419--><p class="noindent" ><div class="minipage"><a 
 id="dx32-81004"></a>
<span 
class="ptmb7t-x-x-120">(exit [U:form]): None Returned                                      </span><span 
class="ptmri7t-x-x-120">open-compiled,restricted macro</span>
<br 
class="newline" /><div class="minipage">The  U&#8217;s  are  evaluated  left  to  right,  the  most  closely  surrounding  while
or  repeat  is  terminated,  and  the  value  of  the  last  U  is  returned.  With  no
argument nil is returned. Both while and repeat are macros which expand
into prog&#8217;s and exit is essentially a return. The restrictions on the placement
of exit are similar to those of return, see section 8.3 for details.</div>
</div>The following function defintion is intended to illustrate the use of repeat and while. The
function will return a list of prime numbers which are less than or equal to the argument N,
which is assumed to be greater than one.

<div class="verbatim" id="verbatim-173">
&#x00A0;&#x00A0;(de&#x00A0;primes&#x00A0;(n)
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;(let&#x00A0;((result&#x00A0;(list&#x00A0;2))
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;(number&#x00A0;3)
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;(pointer)
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;(prime))
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;(while&#x00A0;(&#x003C;=&#x00A0;number&#x00A0;n)
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;(setq&#x00A0;pointer&#x00A0;result)
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;(setq&#x00A0;prime&#x00A0;t)
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;(repeat
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;(when&#x00A0;(zerop&#x00A0;(remainder&#x00A0;number&#x00A0;(first&#x00A0;pointer)))
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;(setq&#x00A0;prime&#x00A0;nil))
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;(setq&#x00A0;pointer&#x00A0;(rest&#x00A0;pointer))
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;(or&#x00A0;(null&#x00A0;pointer)&#x00A0;(not&#x00A0;prime)))
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;(when&#x00A0;prime&#x00A0;(setq&#x00A0;result&#x00A0;(aconc&#x00A0;result&#x00A0;number)))
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;(incr&#x00A0;number))
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;(cons&#x00A0;1&#x00A0;result)))
</div>
<!--l. 442--><p class="nopar" >
<h5 class="subsubsectionHead"><a 
 id="x32-820007.3.1"></a>For</h5>
<!--l. 445--><p class="noindent" >A simple for construct is available in the basic PSL system; an extended version is defined in the
USEFUL package. The basic PSL for provides only the iterator FROM and the action clause
DO. PSL users should use the extended version, described here:
<!--l. 455--><p class="noindent" ><div class="minipage"><a 
 id="dx32-82001"></a>
<span 
class="ptmb7t-x-x-120">(for [S:form]): any                                                                                                    </span><span 
class="ptmri7t-x-x-120">macro</span>
<br 
class="newline" /><div class="minipage">Each argument to for is a one of the clauses described below. If an argument
is not a clause then one of the following continuable errors will occur.</div>
</div>

<div class="verbatim" id="verbatim-174">
&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x22C6;&#x22C6;&#x22C6;&#x22C6;&#x22C6;&#x00A0;For&#x00A0;clauses&#x00A0;may&#x00A0;not&#x00A0;be&#x00A0;atomic:&#x00A0;&#8216;SYMBOL'
</div>
<!--l. 458--><p class="nopar" >

<div class="verbatim" id="verbatim-175">
&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x22C6;&#x22C6;&#x22C6;&#x22C6;&#x22C6;&#x00A0;Unknown&#x00A0;for&#x00A0;clause&#x00A0;operator:&#x00A0;&#8216;LIST'
</div>
<!--l. 461--><p class="nopar" >A clause is a list, its first element is an identifier, the remaining elements are arguments. A
clause may introduce a local variable, specify a return value, or specify when the iteration
should cease.
<!--l. 467--><p class="noindent" >The first few clauses are used to introduce local variables. Some of these clauses also provide
the means to stop loop iteration.

<div class="verbatim" id="verbatim-176">
&#x00A0;&#x00A0;&#x00A0;&#x00A0;(in&#x00A0;&#x003C;variable&#x003E;&#x00A0;&#x003C;list&#x003E;&#x00A0;&#x003C;function&#x003E;)
</div>
<!--l. 474--><p class="nopar" >The variable <span 
class="cmmi-12">&#x003C;</span>variable<span 
class="cmmi-12">&#x003E; </span>is set to successive elements of <span 
class="cmmi-12">&#x003C;</span>list<span 
class="cmmi-12">&#x003E;</span>. The argument <span 
class="cmmi-12">&#x003C;</span>function<span 
class="cmmi-12">&#x003E; </span>is
optional. If present, it may be either the name of a function or a lambda expression. The function
is applied to the extracted element before it is assigned to <span 
class="cmmi-12">&#x003C;</span>variable<span 
class="cmmi-12">&#x003E;</span>. Once the argument
<span 
class="cmmi-12">&#x003C;</span>list<span 
class="cmmi-12">&#x003E; </span>is exhausted the iteration will stop. The only argument which will be evaluated is
<span 
class="cmmi-12">&#x003C;</span>list<span 
class="cmmi-12">&#x003E;</span>.

<div class="verbatim" id="verbatim-177">
&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;1&#x00A0;lisp&#x003E;&#x00A0;(for&#x00A0;(in&#x00A0;v&#x00A0;'(0&#x00A0;1)&#x00A0;add1)
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;(do&#x00A0;(print&#x00A0;v)))
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;1
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;2
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;nil
</div>
<!--l. 490--><p class="nopar" >

<div class="verbatim" id="verbatim-178">
&#x00A0;&#x00A0;&#x00A0;&#x00A0;(on&#x00A0;&#x003C;variable&#x003E;&#x00A0;&#x003C;list&#x003E;)
</div>
<!--l. 494--><p class="nopar" >The variable <span 
class="cmmi-12">&#x003C;</span>variable<span 
class="cmmi-12">&#x003E; </span>is set to successive cdrs of <span 
class="cmmi-12">&#x003C;</span>list<span 
class="cmmi-12">&#x003E;</span>. The first value assigned to
<span 
class="cmmi-12">&#x003C;</span>variable<span 
class="cmmi-12">&#x003E; </span>is <span 
class="cmmi-12">&#x003C;</span>list<span 
class="cmmi-12">&#x003E;</span>. Once the <span 
class="cmmi-12">&#x003C;</span>list<span 
class="cmmi-12">&#x003E; </span>is exhausted the iteration will stop. The only argument
which will be evaluated is <span 
class="cmmi-12">&#x003C;</span>list<span 
class="cmmi-12">&#x003E;</span>.

<div class="verbatim" id="verbatim-179">
&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;1&#x00A0;lisp&#x003E;&#x00A0;(for&#x00A0;(on&#x00A0;v&#x00A0;'(0&#x00A0;1))
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;(do&#x00A0;(print&#x00A0;v)))
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;(0&#x00A0;1)
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;(1)
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;nil
</div>
<!--l. 509--><p class="nopar" >

<div class="verbatim" id="verbatim-180">
&#x00A0;&#x00A0;&#x00A0;&#x00A0;(from&#x00A0;&#x003C;variable&#x003E;&#x00A0;&#x003C;initial&#x003E;&#x00A0;&#x003C;final&#x003E;&#x00A0;&#x003C;step&#x003E;)
</div>
<!--l. 513--><p class="nopar" >The variable <span 
class="cmmi-12">&#x003C;</span>variable<span 
class="cmmi-12">&#x003E; </span>is set to <span 
class="cmmi-12">&#x003C;</span>initial<span 
class="cmmi-12">&#x003E; </span>for the first iteration of the loop. The value of
<span 
class="cmmi-12">&#x003C;</span>variable<span 
class="cmmi-12">&#x003E; </span>will be incremented by <span 
class="cmmi-12">&#x003C;</span>step<span 
class="cmmi-12">&#x003E; </span>before each following iteration. Once the value of
<span 
class="cmmi-12">&#x003C;</span>variable<span 
class="cmmi-12">&#x003E; </span>is larger than <span 
class="cmmi-12">&#x003C;</span>final<span 
class="cmmi-12">&#x003E; </span>the iteration will stop. Both <span 
class="cmmi-12">&#x003C;</span>initial<span 
class="cmmi-12">&#x003E; </span>and <span 
class="cmmi-12">&#x003C;</span>step<span 
class="cmmi-12">&#x003E;</span>
are optional, the default values for each is 1. The argument <span 
class="cmmi-12">&#x003C;</span>final<span 
class="cmmi-12">&#x003E; </span>is optional, in
which case the iteration must be stopped by another clause. Each argument except for
<span 
class="cmmi-12">&#x003C;</span>variable<span 
class="cmmi-12">&#x003E; </span>will be evaluated once, before the first iteration. To specify <span 
class="cmmi-12">&#x003C;</span>step<span 
class="cmmi-12">&#x003E; </span>without
<span 
class="cmmi-12">&#x003C;</span>initial<span 
class="cmmi-12">&#x003E; </span>and <span 
class="cmmi-12">&#x003C;</span>final<span 
class="cmmi-12">&#x003E;</span>, or <span 
class="cmmi-12">&#x003C;</span>final<span 
class="cmmi-12">&#x003E; </span>with <span 
class="cmmi-12">&#x003C;</span>initial<span 
class="cmmi-12">&#x003E; </span>omitted place nil in the slot to be
omitted.

<div class="verbatim" id="verbatim-181">
&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;1&#x00A0;lisp&#x003E;&#x00A0;(for&#x00A0;(from&#x00A0;v&#x00A0;1&#x00A0;5&#x00A0;2)
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;(do&#x00A0;(print&#x00A0;v)))
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;1
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;3
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;5
</div>
<!--l. 537--><p class="nopar" >

<div class="verbatim" id="verbatim-182">
&#x00A0;&#x00A0;&#x00A0;&#x00A0;(FOR&#x00A0;&#x003C;variable&#x003E;&#x00A0;&#x003C;initial&#x003E;&#x00A0;&#x003C;next&#x003E;)
</div>
<!--l. 541--><p class="nopar" >At the outset of the first iteration, the variable <span 
class="cmmi-12">&#x003C;</span>variable<span 
class="cmmi-12">&#x003E; </span>will be set to the evaluation of
<span 
class="cmmi-12">&#x003C;</span>initial<span 
class="cmmi-12">&#x003E;</span>. Prior to subsequent iterations, the expression <span 
class="cmmi-12">&#x003C;</span>next<span 
class="cmmi-12">&#x003E; </span>will be evaluated and assigned
to <span 
class="cmmi-12">&#x003C;</span>variable<span 
class="cmmi-12">&#x003E;</span>.

<div class="verbatim" id="verbatim-183">
&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;1&#x00A0;lisp&#x003E;&#x00A0;(for&#x00A0;(for&#x00A0;v&#x00A0;1&#x00A0;(add1&#x00A0;v))
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;(until&#x00A0;(&#x003E;&#x00A0;v&#x00A0;3))
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;(do&#x00A0;(print&#x00A0;v)))
&#x00A0;<br />
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;1
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;2
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;3
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;nil
</div>
<!--l. 558--><p class="nopar" >

<div class="verbatim" id="verbatim-184">
&#x00A0;&#x00A0;&#x00A0;&#x00A0;(with&#x00A0;[&#x003C;variable-form&#x003E;])
</div>
<!--l. 562--><p class="nopar" >Each argument <span 
class="cmmi-12">&#x003C;</span>variable-form<span 
class="cmmi-12">&#x003E; </span>is either <span 
class="cmmi-12">&#x003C;</span>variable<span 
class="cmmi-12">&#x003E; </span>or (<span 
class="cmmi-12">&#x003C;</span>variable<span 
class="cmmi-12">&#x003E; &#x003C;</span>initial<span 
class="cmmi-12">&#x003E;</span>). The square
brackets are used to indicate zero or more occurances of <span 
class="cmmi-12">&#x003C;</span>variable-form<span 
class="cmmi-12">&#x003E;</span>. If the first form is
used then the variable will be set to nil prior to the first iteration. With the second form the
variable will be set to the value of <span 
class="cmmi-12">&#x003C;</span>initial<span 
class="cmmi-12">&#x003E;</span>.

<div class="verbatim" id="verbatim-185">
&#x00A0;&#x00A0;&#x00A0;&#x00A0;(do&#x00A0;[&#x003C;form&#x003E;])
</div>
<!--l. 573--><p class="nopar" >The square brackets are used to indicate zero or more occurances of <span 
class="cmmi-12">&#x003C;</span>form<span 
class="cmmi-12">&#x003E;</span>. Each expression
<span 
class="cmmi-12">&#x003C;</span>form<span 
class="cmmi-12">&#x003E; </span>is evaluated during each iteration. They are evaluated in the order of their
appearance. You may use return within a <span 
class="cmmi-12">&#x003C;</span>form<span 
class="cmmi-12">&#x003E;</span>, it will cause an immediate exit from the
for.
<!--l. 581--><p class="noindent" >There are two clauses which allow for the evaluation of expressions before the first iteration, and
after the last iteration.

<div class="verbatim" id="verbatim-186">
&#x00A0;&#x00A0;&#x00A0;&#x00A0;(initially&#x00A0;[&#x003C;form&#x003E;])
</div>
<!--l. 587--><p class="nopar" >The square brackets are used to indicate zero or more occurances of <span 
class="cmmi-12">&#x003C;</span>form<span 
class="cmmi-12">&#x003E;</span>. Once the iteration
variables have been bound to their values each expression <span 
class="cmmi-12">&#x003C;</span>form<span 
class="cmmi-12">&#x003E; </span>will be evaluated. They are
evaluated in the order of their appearance.

<div class="verbatim" id="verbatim-187">
&#x00A0;&#x00A0;&#x00A0;&#x00A0;(finally&#x00A0;[&#x003C;form&#x003E;])
</div>
<!--l. 595--><p class="nopar" >
<!--l. 597--><p class="noindent" >The square brackets are used to indicate zero or more occurances of <span 
class="cmmi-12">&#x003C;</span>form<span 
class="cmmi-12">&#x003E;</span>. After the final
iteration each expression <span 
class="cmmi-12">&#x003C;</span>form<span 
class="cmmi-12">&#x003E; </span>will be evaluated. They are evaluated in the order of their
appearance. The use of the clauses always and never (described below), may prevent
evaluation of the arguments to this clause. There are clauses which specify a return value,
if none of them are used then the value of the last <span 
class="cmmi-12">&#x003C;</span>form<span 
class="cmmi-12">&#x003E; </span>will be the value of the
for.

<div class="verbatim" id="verbatim-188">
&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;1&#x00A0;lisp&#x003E;&#x00A0;(for&#x00A0;(from&#x00A0;v&#x00A0;1&#x00A0;3)
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;(finally&#x00A0;v))
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;4
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;nil
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;2&#x00A0;lisp&#x003E;&#x00A0;(for&#x00A0;(for&#x00A0;v&#x00A0;1&#x00A0;(add1&#x00A0;v))
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;(always&#x00A0;(&#x003C;&#x00A0;v&#x00A0;3))
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;(finally&#x00A0;v))
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;nil
</div>
<!--l. 616--><p class="nopar" >
<!--l. 618--><p class="noindent" >The next few clauses are used to build a value to be returned from for Except for the returns and
returning clauses, a second argument is used in these clauses to specify that instead of returning
the result it will be stored as the value of this second argument. This means that the second
argument should be an identifier, it will not be evaluated.

<div class="verbatim" id="verbatim-189">
&#x00A0;&#x00A0;&#x00A0;&#x00A0;1&#x00A0;lisp&#x003E;&#x00A0;(for&#x00A0;(in&#x00A0;v&#x00A0;'(0&#x00A0;1))
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;(collect&#x00A0;(add1&#x00A0;v)))
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;(1&#x00A0;2)
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;2&#x00A0;lisp&#x003E;&#x00A0;(for&#x00A0;(in&#x00A0;v&#x00A0;'(0&#x00A0;1))
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;(collect&#x00A0;(add1&#x00A0;v)&#x00A0;result))
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;nil
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;3&#x00A0;lisp&#x003E;&#x00A0;result
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;(1&#x00A0;2)
</div>
<!--l. 635--><p class="nopar" >If more than one return value is implied then an error will result

<div class="verbatim" id="verbatim-190">
&#x00A0;&#x00A0;&#x00A0;&#x00A0;1&#x00A0;lisp&#x003E;&#x00A0;(for&#x00A0;(in&#x00A0;v&#x00A0;'(0&#x00A0;1))
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;(collect&#x00A0;v)
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;(adjoin&#x00A0;v))
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x22C6;&#x22C6;&#x22C6;&#x22C6;&#x22C6;&#x00A0;For&#x00A0;loops&#x00A0;may&#x00A0;only&#x00A0;return&#x00A0;one&#x00A0;value
</div>
<!--l. 644--><p class="nopar" >

<div class="verbatim" id="verbatim-191">
&#x00A0;&#x00A0;&#x00A0;&#x00A0;(returns&#x00A0;[&#x003C;form&#x003E;])
</div>
<!--l. 647--><p class="nopar" >Prior to returning from the for each <span 
class="cmmi-12">&#x003C;</span>form<span 
class="cmmi-12">&#x003E; </span>is evaluated. The order of evalution is left to right.
The value of the last <span 
class="cmmi-12">&#x003C;</span>form<span 
class="cmmi-12">&#x003E; </span>is returned as the value of the for.A synonym for returns is
returning.

<div class="verbatim" id="verbatim-192">
&#x00A0;&#x00A0;&#x00A0;&#x00A0;(collect&#x00A0;&#x003C;form&#x003E;&#x00A0;&#x003C;variable&#x003E;)
</div>
<!--l. 655--><p class="nopar" >This clause is used to build a list. During each iteration the value of <span 
class="cmmi-12">&#x003C;</span>form<span 
class="cmmi-12">&#x003E; </span>is added at the end
of the list. The use of the optional argument <span 
class="cmmi-12">&#x003C;</span>variable<span 
class="cmmi-12">&#x003E; </span>is described above.

<div class="verbatim" id="verbatim-193">
&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;1&#x00A0;lisp&#x003E;&#x00A0;(for&#x00A0;(on&#x00A0;v&#x00A0;'(one&#x00A0;two))
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;(collect&#x00A0;v))
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;((one&#x00A0;two)&#x00A0;(two))
</div>
<!--l. 664--><p class="nopar" >

<div class="verbatim" id="verbatim-194">
&#x00A0;&#x00A0;&#x00A0;&#x00A0;(ADJOIN&#x00A0;&#x003C;form&#x003E;&#x00A0;&#x003C;variable&#x003E;)
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;(ADJOINQ&#x00A0;&#x003C;form&#x003E;&#x00A0;&#x003C;variable&#x003E;)
</div>
<!--l. 669--><p class="nopar" >These clauses are similar to collect. The difference is that the value of <span 
class="cmmi-12">&#x003C;</span>form<span 
class="cmmi-12">&#x003E; </span>is only added to
the list if it is not already an element. To detemine membership in the list adjoin uses
member, adjoinq uses memq. The use of the optional argument <span 
class="cmmi-12">&#x003C;</span>variable<span 
class="cmmi-12">&#x003E; </span>is described
above.

<div class="verbatim" id="verbatim-195">
&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;1&#x00A0;lisp&#x003E;&#x00A0;(for&#x00A0;(in&#x00A0;i&#x00A0;'("one"&#x00A0;"one"))
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;(adjoin&#x00A0;i&#x00A0;one)
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;(adjoinq&#x00A0;i&#x00A0;two))
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;nil
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;2&#x00A0;lisp&#x003E;&#x00A0;one
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;("one")
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;3&#x00A0;lisp&#x003E;&#x00A0;two
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;("one"&#x00A0;"one")
</div>
<!--l. 686--><p class="nopar" >

<div class="verbatim" id="verbatim-196">
&#x00A0;&#x00A0;&#x00A0;&#x00A0;(JOIN&#x00A0;&#x003C;form&#x003E;&#x00A0;&#x003C;variable&#x003E;)
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;(CONC&#x00A0;&#x003C;form&#x003E;&#x00A0;&#x003C;variable&#x003E;)
</div>
<!--l. 691--><p class="nopar" >These clauses are similar to collect. The difference is that the value of <span 
class="cmmi-12">&#x003C;</span>form<span 
class="cmmi-12">&#x003E; </span>is appended
(nonc is used with the conc clause), to the end of the list. The use of the optional argument
<span 
class="cmmi-12">&#x003C;</span>variable<span 
class="cmmi-12">&#x003E; </span>is described above.

<div class="verbatim" id="verbatim-197">
&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;1&#x00A0;lisp&#x003E;&#x00A0;(for&#x00A0;(on&#x00A0;v&#x00A0;'(one&#x00A0;two))
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;(join&#x00A0;v))
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;(one&#x00A0;two&#x00A0;two)
</div>
<!--l. 701--><p class="nopar" >
<!--l. 704--><p class="noindent" >You should be careful with conc. In the example, if conc were used in place of join the
computation would never terminate.

<div class="verbatim" id="verbatim-198">
&#x00A0;&#x00A0;&#x00A0;&#x00A0;(UNION&#x00A0;&#x003C;form&#x003E;&#x00A0;&#x003C;variable&#x003E;)
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;(UNIONQ&#x00A0;&#x003C;form&#x003E;&#x00A0;&#x003C;variable&#x003E;)
</div>
<!--l. 710--><p class="nopar" >These clauses are used to build a set. During each iteration the union of <span 
class="cmmi-12">&#x003C;</span>form<span 
class="cmmi-12">&#x003E; </span>and
the set being constructed is computed. Set membership is determined with equal for
union, and eq for unionq. The use of the optional argument <span 
class="cmmi-12">&#x003C;</span>variable<span 
class="cmmi-12">&#x003E; </span>is described
above.

<div class="verbatim" id="verbatim-199">
&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;1&#x00A0;lisp&#x003E;&#x00A0;(for&#x00A0;(in&#x00A0;v&#x00A0;'((0&#x00A0;2)&#x00A0;(0&#x00A0;1&#x00A0;2&#x00A0;3)&#x00A0;(0)))
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;(unionq&#x00A0;v))
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;(3&#x00A0;2&#x00A0;1&#x00A0;0)
</div>
<!--l. 721--><p class="nopar" >

<div class="verbatim" id="verbatim-200">
&#x00A0;&#x00A0;&#x00A0;&#x00A0;(INTERSECTION&#x00A0;&#x003C;form&#x003E;&#x00A0;&#x003C;variable&#x003E;)
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;(INTERSECTIONQ&#x00A0;&#x003C;form&#x003E;&#x00A0;&#x003C;variable&#x003E;)
</div>
<!--l. 726--><p class="nopar" >These clauses are similar to union and unionq. The difference is that the intersection of sets in
constructed instead of the union. The use of the optional argument <span 
class="cmmi-12">&#x003C;</span>variable<span 
class="cmmi-12">&#x003E; </span>is described
above.

<div class="verbatim" id="verbatim-201">
&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;1&#x00A0;lisp&#x003E;&#x00A0;(for&#x00A0;(in&#x00A0;v&#x00A0;'((0&#x00A0;2)&#x00A0;(0&#x00A0;1&#x00A0;2&#x00A0;3)&#x00A0;(0)))
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;(intersectionq&#x00A0;v))
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;(0)
</div>
<!--l. 735--><p class="nopar" >

<div class="verbatim" id="verbatim-202">
&#x00A0;&#x00A0;&#x00A0;&#x00A0;(COUNT&#x00A0;&#x003C;form&#x003E;&#x00A0;&#x003C;variable&#x003E;)
</div>
<!--l. 739--><p class="nopar" >Returns the number of times <span 
class="cmmi-12">&#x003C;</span>form<span 
class="cmmi-12">&#x003E; </span>evaluates to a nonnil value. The use of the optional
argument <span 
class="cmmi-12">&#x003C;</span>variable<span 
class="cmmi-12">&#x003E; </span>is described above.

<div class="verbatim" id="verbatim-203">
&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;1&#x00A0;lisp&#x003E;&#x00A0;(for&#x00A0;(in&#x00A0;v&#x00A0;'(0&#x00A0;1&#x00A0;2))
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;(count&#x00A0;(zerop&#x00A0;(remainder&#x00A0;v&#x00A0;2))))
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;2
</div>
<!--l. 748--><p class="nopar" >

<div class="verbatim" id="verbatim-204">
&#x00A0;&#x00A0;&#x00A0;&#x00A0;(SUM&#x00A0;&#x003C;form&#x003E;&#x00A0;&#x003C;variable&#x003E;)
</div>
<!--l. 752--><p class="nopar" >
<!--l. 754--><p class="noindent" >Returns the sum of each evaluation of <span 
class="cmmi-12">&#x003C;</span>form<span 
class="cmmi-12">&#x003E;</span>. The use of the optional argument <span 
class="cmmi-12">&#x003C;</span>variable<span 
class="cmmi-12">&#x003E; </span>is
described above.

<div class="verbatim" id="verbatim-205">
&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;1&#x00A0;lisp&#x003E;&#x00A0;(for&#x00A0;(in&#x00A0;v&#x00A0;'(2&#x00A0;3&#x00A0;4))
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;(sum&#x00A0;v))
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;9
</div>
<!--l. 762--><p class="nopar" >

<div class="verbatim" id="verbatim-206">
&#x00A0;&#x00A0;&#x00A0;&#x00A0;(PRODUCT&#x00A0;&#x003C;form&#x003E;&#x00A0;&#x003C;variable&#x003E;)
</div>
<!--l. 766--><p class="nopar" >
<!--l. 768--><p class="noindent" >Returns the product of each evaluation of <span 
class="cmmi-12">&#x003C;</span>form<span 
class="cmmi-12">&#x003E;</span>. The use of the optional argument
<span 
class="cmmi-12">&#x003C;</span>variable<span 
class="cmmi-12">&#x003E; </span>is described above.

<div class="verbatim" id="verbatim-207">
&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;1&#x00A0;lisp&#x003E;&#x00A0;(for&#x00A0;(in&#x00A0;v&#x00A0;'(2&#x00A0;3&#x00A0;4))
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;(product&#x00A0;v))
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;24
</div>
<!--l. 775--><p class="nopar" >

<div class="verbatim" id="verbatim-208">
&#x00A0;&#x00A0;&#x00A0;&#x00A0;(MAXIMIZE&#x00A0;&#x003C;form&#x003E;&#x00A0;&#x003C;variable&#x003E;)
</div>
<!--l. 779--><p class="nopar" >Returns the maximum value of <span 
class="cmmi-12">&#x003C;</span>form<span 
class="cmmi-12">&#x003E;</span>. The use of the optional argument <span 
class="cmmi-12">&#x003C;</span>variable<span 
class="cmmi-12">&#x003E; </span>is
described above.

<div class="verbatim" id="verbatim-209">
&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;1&#x00A0;lisp&#x003E;&#x00A0;(for&#x00A0;(in&#x00A0;v&#x00A0;'(1&#x00A0;2&#x00A0;3))
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;(maximize&#x00A0;v))
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;3
</div>
<!--l. 787--><p class="nopar" >

<div class="verbatim" id="verbatim-210">
&#x00A0;&#x00A0;&#x00A0;&#x00A0;(MINIMIZE&#x00A0;&#x003C;form&#x003E;&#x00A0;&#x003C;variable&#x003E;)
</div>
<!--l. 791--><p class="nopar" >Returns the minimum value of <span 
class="cmmi-12">&#x003C;</span>form<span 
class="cmmi-12">&#x003E;</span>. The use of the optional argument <span 
class="cmmi-12">&#x003C;</span>variable<span 
class="cmmi-12">&#x003E; </span>is
described above.

<div class="verbatim" id="verbatim-211">
&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;1&#x00A0;lisp&#x003E;&#x00A0;(for&#x00A0;(in&#x00A0;v&#x00A0;'(1&#x00A0;2&#x00A0;3))
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;(minimize&#x00A0;v))
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;1
</div>
<!--l. 799--><p class="nopar" >

<div class="verbatim" id="verbatim-212">
&#x00A0;&#x00A0;&#x00A0;&#x00A0;(MAXIMAL&#x00A0;&#x003C;value&#x003E;&#x00A0;&#x003C;test&#x003E;&#x00A0;&#x003C;variable&#x003E;)
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;(MINIMAL&#x00A0;&#x003C;value&#x003E;&#x00A0;&#x003C;test&#x003E;&#x00A0;&#x003C;variable&#x003E;)
</div>
<!--l. 804--><p class="nopar" >These clauses are generalizations of the clauses maximize and minimize. Maximal determines
the greatest value of <span 
class="cmmi-12">&#x003C;</span>test<span 
class="cmmi-12">&#x003E; </span>over all of the loop iterations. The corresponding value of <span 
class="cmmi-12">&#x003C;</span>value<span 
class="cmmi-12">&#x003E;</span>
is returned. As a particular case it is possible to return the value of an iteration variable for
which some function attains a maximum value. The functions used for comparisons
are greaterp and lessp. The use of the optional argument <span 
class="cmmi-12">&#x003C;</span>variable<span 
class="cmmi-12">&#x003E; </span>is described
above.

<div class="verbatim" id="verbatim-213">
&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;1&#x00A0;lisp&#x003E;&#x00A0;(for&#x00A0;(in&#x00A0;v&#x00A0;'(2&#x00A0;-2))
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;(minimal&#x00A0;v&#x00A0;(-&#x00A0;(expt&#x00A0;v&#x00A0;2)&#x00A0;(&#x22C6;&#x00A0;7&#x00A0;v))))
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;2
</div>
<!--l. 819--><p class="nopar" >
<!--l. 821--><p class="noindent" >The remaining clauses are used to control loop iteration.

<div class="verbatim" id="verbatim-214">
&#x00A0;&#x00A0;&#x00A0;&#x00A0;(ALWAYS&#x00A0;[&#x003C;form&#x003E;])
</div>
<!--l. 825--><p class="nopar" >The square brackets are used to indicate zero or more occurances of <span 
class="cmmi-12">&#x003C;</span>form<span 
class="cmmi-12">&#x003E;</span>. If there is more
than one form then the clause is equivalent to (ALWAYS (and [<span 
class="cmmi-12">&#x003C;</span>form<span 
class="cmmi-12">&#x003E;</span>])). This clause is used
to specify a return value, t is returned if each <span 
class="cmmi-12">&#x003C;</span>form<span 
class="cmmi-12">&#x003E; </span>is non-nil during each iteration. If one of
the <span 
class="cmmi-12">&#x003C;</span>form<span 
class="cmmi-12">&#x003E;</span>s evaluates to nil then the for is terminated and nil is returned, this means that
arguments of any finally clause will not be evaluated.

<div class="verbatim" id="verbatim-215">
&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;1&#x00A0;lisp&#x003E;&#x00A0;(for&#x00A0;(in&#x00A0;v&#x00A0;'(1&#x00A0;0&#x00A0;2))
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;(always&#x00A0;(&#x003E;&#x00A0;v&#x00A0;0))
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;(do&#x00A0;(print&#x00A0;v)))
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;1
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;nil
&#x00A0;<br />
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;(never&#x00A0;[&#x003C;form&#x003E;])
</div>
<!--l. 844--><p class="nopar" >The square brackets are used to indicate zero or more occurances of <span 
class="cmmi-12">&#x003C;</span>form<span 
class="cmmi-12">&#x003E;</span>. If there is more
than one form then the clause is equivalent to (NEVER (or [<span 
class="cmmi-12">&#x003C;</span>form<span 
class="cmmi-12">&#x003E;</span>])). Equivalent to
(ALWAYS (not [<span 
class="cmmi-12">&#x003C;</span>form<span 
class="cmmi-12">&#x003E;</span>])).

<div class="verbatim" id="verbatim-216">
&#x00A0;&#x00A0;&#x00A0;&#x00A0;(THEREIS&#x00A0;&#x003C;form&#x003E;)
</div>
<!--l. 852--><p class="nopar" >
<!--l. 855--><p class="noindent" >If the argument <span 
class="cmmi-12">&#x003C;</span>form<span 
class="cmmi-12">&#x003E; </span>evaluates to a non-nil value then the for is terminated, the value of
<span 
class="cmmi-12">&#x003C;</span>form<span 
class="cmmi-12">&#x003E; </span>is the return value.

<div class="verbatim" id="verbatim-217">
&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;1&#x00A0;lisp&#x003E;&#x00A0;(for&#x00A0;(in&#x00A0;v&#x00A0;'(-1&#x00A0;0&#x00A0;2))
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;(thereis&#x00A0;(and&#x00A0;(zerop&#x00A0;v)&#x00A0;v))
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;(do&#x00A0;(print&#x00A0;v)))
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;-1
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;0
</div>
<!--l. 864--><p class="nopar" >

<div class="verbatim" id="verbatim-218">
&#x00A0;&#x00A0;&#x00A0;&#x00A0;(WHILE&#x00A0;[&#x003C;form&#x003E;])
</div>
<!--l. 868--><p class="nopar" >The square brackets are used to indicate zero or more occurances of <span 
class="cmmi-12">&#x003C;</span>form<span 
class="cmmi-12">&#x003E;</span>. If there is more
than one form then the clause is equivalent to (WHILE (and [<span 
class="cmmi-12">&#x003C;</span>form<span 
class="cmmi-12">&#x003E;</span>])). Loop iteration stops if
any <span 
class="cmmi-12">&#x003C;</span>form<span 
class="cmmi-12">&#x003E; </span>evaluates to nil.

<div class="verbatim" id="verbatim-219">
&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;1&#x00A0;lisp&#x003E;&#x00A0;(for&#x00A0;(from&#x00A0;v&#x00A0;2&#x00A0;nil&#x00A0;-1)
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;(while&#x00A0;(&#x003E;&#x00A0;v&#x00A0;0))
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;(collect&#x00A0;(sqrt&#x00A0;v))
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;(finally&#x00A0;(print&#x00A0;v)))
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;0
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;(1.41421&#x00A0;1.0)
</div>
<!--l. 882--><p class="nopar" >

<div class="verbatim" id="verbatim-220">
&#x00A0;&#x00A0;&#x00A0;&#x00A0;(UNTIL&#x00A0;[&#x003C;form&#x003E;])
</div>
<!--l. 886--><p class="nopar" >The square brackets are used to indicate zero or more occurances of <span 
class="cmmi-12">&#x003C;</span>form<span 
class="cmmi-12">&#x003E;</span>. If there is more
than one form then the clause is equivalent to (UNTIL (or [<span 
class="cmmi-12">&#x003C;</span>form<span 
class="cmmi-12">&#x003E;</span>])). Loop iteration stops if
any <span 
class="cmmi-12">&#x003C;</span>form<span 
class="cmmi-12">&#x003E; </span>evaluates to a non nil value.

<div class="verbatim" id="verbatim-221">
&#x00A0;&#x00A0;&#x00A0;&#x00A0;(WHEN&#x00A0;&#x003C;form&#x003E;)
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;Jump&#x00A0;to&#x00A0;the&#x00A0;next&#x00A0;iteration&#x00A0;if&#x00A0;the&#x00A0;value&#x00A0;of&#x00A0;&#x003C;form&#x003E;&#x00A0;is&#x00A0;nil.
</div>
<!--l. 895--><p class="nopar" >

<div class="verbatim" id="verbatim-222">
&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;1&#x00A0;lisp&#x003E;&#x00A0;(for&#x00A0;(in&#x00A0;v&#x00A0;'(-2&#x00A0;2))
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;(when&#x00A0;(&#x003E;&#x00A0;v&#x00A0;0))
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;(do&#x00A0;(print&#x00A0;(sqrt&#x00A0;v))))
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;1.41421
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;nil
</div>
<!--l. 903--><p class="nopar" >

<div class="verbatim" id="verbatim-223">
&#x00A0;&#x00A0;&#x00A0;&#x00A0;(UNLESS&#x00A0;&#x003C;form&#x003E;)
</div>
<!--l. 907--><p class="nopar" >Jump to the next iteration if the value of <span 
class="cmmi-12">&#x003C;</span>form<span 
class="cmmi-12">&#x003E; </span>is non-nil.
<!--l. 910--><p class="noindent" >The evaluation of a for expression follows a specific order, irregardless of the order in which you
place clauses.
<!--l. 914--><p class="noindent" >
      <ol  class="enumerate1" >
      <li 
  class="enumerate" id="x32-82003x1">Bind loop variables to their initial values. Each of the expressions which represent
      initial values is evaluated before the variables are bound.
      </li>
      <li 
  class="enumerate" id="x32-82005x2">If an initially clause is present, evaluate its arguments.
      </li>
      <li 
  class="enumerate" id="x32-82007x3">Check for termination. A terminating condition may be specified by an in, on, from,
      while, until, thereis, always, or never clause. Satisfaction of a condition will force
      control to step 4 (unless the condition was specified by always or never).
      </li>
      <li 
  class="enumerate" id="x32-82009x4">If  present,  check  when  and  unless  clauses.  If  any  condition  is  not  satisfied  then
      evaluate  the  body.  The  body  is  constructed  from  the  clauses  do,  collect,  adjoin,
      adjoinq, join, conc, union, unionq, intersection, intersectionq, count, sum, product,
      maximize, minimize, maximal, and minimal. Continue at step 3.
      </li>
      <li 
  class="enumerate" id="x32-82011x5">If an finally clause is present, evaluate its arguments. Return the value of the last
      argument unless a returns or returning clause is present. Otherwise evaluate their
      arguments, return the value of the last.</li></ol>
<!--l. 940--><p class="noindent" ><div class="minipage"><a 
 id="dx32-82012"></a>
<span 
class="ptmb7t-x-x-120">(for* [S:form]): any                                                                                                  </span><span 
class="ptmri7t-x-x-120">macro</span>
<br 
class="newline" /><div class="minipage">Identical  to  for  except  that  variable  bindings  and  updates  are  done
sequentially instead of in parallel</div>
</div>
<h4 class="subsectionHead"><span class="titlemark">7.3.2    </span> <a 
 id="x32-830007.3.2"></a>Mapping Functions</h4>
<!--l. 943--><p class="noindent" >The mapping functions long familiar to LISP programmers are present in PSL. However, we
believe that the for construct described above or the simpler foreach described below is
generally more useful, since it obviates the usual necessity of constructing a lambda expression,
and is often more transparent. Mapping functions with more than two arguments are not
currently supported. Note however that several lists may be iterated along with for, and with
considerably more generality. For example:

<div class="verbatim" id="verbatim-224">
(let&#x00A0;((i&#x00A0;0))
&#x00A0;<br />&#x00A0;&#x00A0;(mapcar&#x00A0;l&#x00A0;(function&#x00A0;(lambda&#x00A0;(x)
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;(setq&#x00A0;i&#x00A0;(add1&#x00A0;i))
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;(cons&#x00A0;i&#x00A0;x)))))
</div>
<!--l. 958--><p class="nopar" >may be expressed more transparently as

<div class="verbatim" id="verbatim-225">
(for&#x00A0;(in&#x00A0;x&#x00A0;l)&#x00A0;(from&#x00A0;i&#x00A0;1)&#x00A0;(collect&#x00A0;(cons&#x00A0;i&#x00A0;x)))
</div>
<!--l. 963--><p class="nopar" >To augment the simpler for loop present in basic PSL the following list iterator has been
provided:
<!--l. 971--><p class="noindent" ><div class="minipage"><a 
 id="dx32-83001"></a>
<span 
class="ptmb7t-x-x-120">(foreach U:any): any                                                                                                 </span><span 
class="ptmri7t-x-x-120">macro</span>
<br 
class="newline" /><div class="minipage">This macro is essentially equivalent to the the map functions as follows:
</div></div>
<!--l. 973--><p class="noindent" >Possible forms are: Setting x to successive elements of u:

<div class="verbatim" id="verbatim-226">
&#x00A0;&#x00A0;&#x00A0;&#x00A0;(foreach&#x00A0;x&#x00A0;in&#x00A0;u&#x00A0;do&#x00A0;(foo&#x00A0;x))&#x00A0;--&#x003E;&#x00A0;(mapc&#x00A0;u&#x00A0;'foo)
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;(foreach&#x00A0;x&#x00A0;in&#x00A0;u&#x00A0;collect&#x00A0;(foo&#x00A0;x))--&#x003E;&#x00A0;(mapcar&#x00A0;u&#x00A0;'foo)
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;(foreach&#x00A0;x&#x00A0;in&#x00A0;u&#x00A0;conc&#x00A0;(foo&#x00A0;x))&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;--&#x003E;&#x00A0;(mapcan&#x00A0;u&#x00A0;'foo)
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;(foreach&#x00A0;x&#x00A0;in&#x00A0;u&#x00A0;join&#x00A0;(foo&#x00A0;x))&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;--&#x003E;&#x00A0;(mapcan&#x00A0;u&#x00A0;'foo)
</div>
<!--l. 980--><p class="nopar" >Setting x to successive cdrs of u:

<div class="verbatim" id="verbatim-227">
&#x00A0;&#x00A0;&#x00A0;&#x00A0;(foreach&#x00A0;x&#x00A0;on&#x00A0;u&#x00A0;do&#x00A0;(foo&#x00A0;x))&#x00A0;--&#x003E;&#x00A0;(map&#x00A0;u&#x00A0;'foo)
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;(foreach&#x00A0;x&#x00A0;on&#x00A0;u&#x00A0;collect&#x00A0;(foo&#x00A0;x))--&#x003E;&#x00A0;(maplist&#x00A0;u&#x00A0;'foo)
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;(foreach&#x00A0;x&#x00A0;on&#x00A0;u&#x00A0;conc&#x00A0;(foo&#x00A0;x))&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;--&#x003E;&#x00A0;(mapcon&#x00A0;u&#x00A0;'foo)
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;(foreach&#x00A0;x&#x00A0;on&#x00A0;u&#x00A0;join&#x00A0;(foo&#x00A0;x))&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;--&#x003E;&#x00A0;(mapcon&#x00A0;u&#x00A0;'foo)
</div>
<!--l. 987--><p class="nopar" >Within the context of for the JOIN is used to append successive values. However, inside foreach
successive values are concatenated together.

<div class="verbatim" id="verbatim-228">
&#x00A0;&#x00A0;&#x00A0;&#x00A0;1&#x00A0;lisp&#x003E;&#x00A0;(setq&#x00A0;x&#x00A0;'(a&#x00A0;b&#x00A0;c)&#x00A0;y&#x00A0;(1&#x00A0;2&#x00A0;3))
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;(1&#x00A0;2&#x00A0;3)
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;2&#x00A0;lisp&#x003E;&#x00A0;(for&#x00A0;(in&#x00A0;u&#x00A0;'(x&#x00A0;y))&#x00A0;(join&#x00A0;(eval&#x00A0;u)))
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;(A&#x00A0;B&#x00A0;C&#x00A0;1&#x00A0;2&#x00A0;3)
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;3&#x00A0;lisp&#x003E;&#x00A0;x
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;(A&#x00A0;B&#x00A0;C)
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;4&#x00A0;lisp&#x003E;&#x00A0;(foreach&#x00A0;u&#x00A0;in&#x00A0;'(x&#x00A0;y)&#x00A0;join&#x00A0;(eval&#x00A0;u))
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;(A&#x00A0;B&#x00A0;C&#x00A0;1&#x00A0;2&#x00A0;3)
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;5&#x00A0;lisp&#x003E;&#x00A0;x
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;(A&#x00A0;B&#x00A0;C&#x00A0;1&#x00A0;2&#x00A0;3)
</div>
<!--l. 1002--><p class="nopar" >
<!--l. 1007--><p class="noindent" ><div class="minipage"><a 
 id="dx32-83002"></a>
<span 
class="ptmb7t-x-x-120">(map X:list FN:function): nil                                                                                      </span><span 
class="ptmri7t-x-x-120">expr</span>
<br 
class="newline" /><div class="minipage">Applies FN to successive cdrs of X. The first value passed to FN is X, unless
X is nil.</div></div>

<div class="verbatim" id="verbatim-229">
&#x00A0;&#x00A0;&#x00A0;&#x00A0;1&#x00A0;lisp&#x003E;&#x00A0;(map&#x00A0;'(one&#x00A0;two)&#x00A0;#'print)
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;(one&#x00A0;two)
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;(two)
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;nil
</div>
<!--l. 1013--><p class="nopar" >
<!--l. 1018--><p class="noindent" ><div class="minipage"><a 
 id="dx32-83003"></a>
<span 
class="ptmb7t-x-x-120">(mapc X:list FN:function): nil                                                                                    </span><span 
class="ptmri7t-x-x-120">expr</span>
<br 
class="newline" /><div class="minipage">FN is applied to successive elements of list X, nil is returned.
</div></div>

<div class="verbatim" id="verbatim-230">
&#x00A0;&#x00A0;&#x00A0;&#x00A0;1&#x00A0;lisp&#x003E;&#x00A0;(mapc&#x00A0;'(one&#x00A0;two)&#x00A0;#'print)
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;one
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;two
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;nil
</div>
<!--l. 1024--><p class="nopar" >
<!--l. 1029--><p class="noindent" ><div class="minipage"><a 
 id="dx32-83004"></a>
<span 
class="ptmb7t-x-x-120">(mapcar X:list FN:function): list                                                                                </span><span 
class="ptmri7t-x-x-120">expr</span>
<br 
class="newline" /><div class="minipage">Similar to mapc except that the return value is a list of the results of each
applicaton of FN.</div>
</div>

<div class="verbatim" id="verbatim-231">
&#x00A0;&#x00A0;&#x00A0;&#x00A0;1&#x00A0;lisp&#x003E;&#x00A0;(map&#x00A0;'((one)&#x00A0;(two))&#x00A0;#'(lambda&#x00A0;(i)&#x00A0;i))
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;(one&#x00A0;two)
</div>
<!--l. 1033--><p class="nopar" >
<!--l. 1039--><p class="noindent" ><div class="minipage"><a 
 id="dx32-83005"></a>
<span 
class="ptmb7t-x-x-120">(mapcan X:list FN:function): list                                                                               </span><span 
class="ptmri7t-x-x-120">expr</span>
<br 
class="newline" /><div class="minipage">Similar  to  mapcar  except  that  the  values  returned  by  FN  are  nconced
together instead of being listed together. The argument X may be modified
to construct the result.</div></div>

<div class="verbatim" id="verbatim-232">
&#x00A0;&#x00A0;&#x00A0;&#x00A0;1&#x00A0;lisp&#x003E;&#x00A0;(setq&#x00A0;this&#x00A0;'((one)&#x00A0;(two)))
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;((one)&#x00A0;(two))
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;2&#x00A0;lisp&#x003E;&#x00A0;(mapcan&#x00A0;this&#x00A0;#'(lambda&#x00A0;(i)&#x00A0;i))
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;(one&#x00A0;two)
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;3&#x00A0;lisp&#x003E;&#x00A0;this
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;((one&#x00A0;two)&#x00A0;(two))
</div>
<!--l. 1047--><p class="nopar" >
<!--l. 1052--><p class="noindent" ><div class="minipage"><a 
 id="dx32-83006"></a>
<span 
class="ptmb7t-x-x-120">(maplist X:list FN:function): list                                                                                </span><span 
class="ptmri7t-x-x-120">expr</span>
<br 
class="newline" /><div class="minipage">Similar to map except that the return value is a list of the results of each
application of FN.</div>
</div>

<div class="verbatim" id="verbatim-233">
&#x00A0;&#x00A0;&#x00A0;&#x00A0;1&#x00A0;lisp&#x003E;&#x00A0;(maplist&#x00A0;'(one&#x00A0;two)&#x00A0;#'(lambda&#x00A0;(i)&#x00A0;i))
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;((one&#x00A0;two)&#x00A0;(two))
</div>
<!--l. 1056--><p class="nopar" >
<!--l. 1061--><p class="noindent" ><div class="minipage"><a 
 id="dx32-83007"></a>
<span 
class="ptmb7t-x-x-120">(mapcon X:list FN:function): list                                                                               </span><span 
class="ptmri7t-x-x-120">expr</span>
<br 
class="newline" /><div class="minipage">Similar  to  maplist  except  that  the  values  returned  by  FN  are  nconced
together instead of being listed together.</div>
</div>

<div class="verbatim" id="verbatim-234">
&#x00A0;&#x00A0;&#x00A0;&#x00A0;1&#x00A0;lisp&#x003E;&#x00A0;(setq&#x00A0;this&#x00A0;'(one&#x00A0;two))
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;(one&#x00A0;two)
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;2&#x00A0;lisp&#x003E;&#x00A0;(mapcon&#x00A0;this&#x00A0;#'(lambda&#x00A0;(i)&#x00A0;(copy&#x00A0;i)))
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;(one&#x00A0;two&#x00A0;two)
</div>
<!--l. 1067--><p class="nopar" >Note that the nconc happens as the mapping process proceeds, not afterward. Therefore the
result is not the same as nconcing the results of a maplist. Consider what would occur
if

<div class="verbatim" id="verbatim-235">
&#x00A0;&#x00A0;&#x00A0;&#x00A0;(mapcon&#x00A0;this&#x00A0;#'(lambda&#x00A0;(i)&#x00A0;i))
</div>
<!--l. 1075--><p class="nopar" >had been used in the example above. Mapcon would apply its second argument to its first
argument giving a partial result of (one two). Notice that the first argument to mapcon is eq to
this partial result. Now mapcon applies its second argument to (two), the cdr of its first
argument. The partial result becomes (one two two). However, the first argument to mapcon has
been modified because nconc was used to build the partial result. The value of the first argument
is now (one two two). The computation will never terminate, the length of the first argument to
mapcon will continue to grow.
<!--l. 1088--><p class="noindent" >
<h5 class="subsubsectionHead"><a 
 id="x32-840007.3.2"></a>Do</h5>
<!--l. 1094--><p class="noindent" ><div class="minipage"><a 
 id="dx32-84001"></a>
<span 
class="ptmb7t-x-x-120">(do A:list B:list [S:form]): any                                                                                 </span><span 
class="ptmri7t-x-x-120">macro</span>
<br 
class="newline" /><div class="minipage">The general form follows, the square brackets are used to indicate zero or
more occurances of an expression.</div>
</div>

<div class="verbatim" id="verbatim-236">
&#x00A0;&#x00A0;&#x00A0;&#x00A0;(DO&#x00A0;([&#x003C;var-form&#x003E;])&#x00A0;(&#x003C;exit-test&#x003E;&#x00A0;[&#x003C;result&#x003E;])&#x00A0;[&#x003C;body&#x003E;])
</div>
<!--l. 1097--><p class="nopar" >A <span 
class="cmmi-12">&#x003C;</span>var-form<span 
class="cmmi-12">&#x003E; </span>is either an id or a list of the form

<div class="verbatim" id="verbatim-237">
&#x00A0;&#x00A0;&#x00A0;&#x00A0;(&#x003C;var&#x003E;&#x00A0;&#x003C;initial&#x003E;&#x00A0;&#x003C;next&#x003E;)
</div>
<!--l. 1102--><p class="nopar" >
<!--l. 1104--><p class="noindent" >There are four basic steps in the evaluation of a do form.
      <ol  class="enumerate1" >
      <li 
  class="enumerate" id="x32-84003x1">.....
      </li>
      <li 
  class="enumerate" id="x32-84005x2">If <span 
class="cmmi-12">&#x003C;</span>exit-test<span 
class="cmmi-12">&#x003E; </span>evaluates to a non-nil value the <span 
class="cmmi-12">&#x003C;</span>result<span 
class="cmmi-12">&#x003E; </span>forms are evaluated and the
      do is exited, unbinding the local variables. The value of a do is the value of the last
      <span 
class="cmmi-12">&#x003C;</span>result<span 
class="cmmi-12">&#x003E; </span>unless there are no <span 
class="cmmi-12">&#x003C;</span>result<span 
class="cmmi-12">&#x003E; </span>forms, in which case nil is returned.
      </li>
      <li 
  class="enumerate" id="x32-84007x3">The body of the do, consisting of the <span 
class="cmmi-12">&#x003C;</span>body<span 
class="cmmi-12">&#x003E; </span>forms, is evaluated in left to right
      order.
      </li>
      <li 
  class="enumerate" id="x32-84009x4">The  <span 
class="cmmi-12">&#x003C;</span>next<span 
class="cmmi-12">&#x003E; </span>forms  are  evaluated  in  parallel,  the  values  are  assigned  to  the
      corresponding <span 
class="cmmi-12">&#x003C;</span>var<span 
class="cmmi-12">&#x003E;</span>s rather than being bound. Once this is complete the process
      continues at step 2.</li></ol>
<!--l. 1125--><p class="noindent" >If <span 
class="cmmi-12">&#x003C;</span>next<span 
class="cmmi-12">&#x003E; </span>is omitted, the value of the corresponding <span 
class="cmmi-12">&#x003C;</span>var<span 
class="cmmi-12">&#x003E; </span>is left unchanged during step 4. If
both <span 
class="cmmi-12">&#x003C;</span>initial<span 
class="cmmi-12">&#x003E; </span>and <span 
class="cmmi-12">&#x003C;</span>next<span 
class="cmmi-12">&#x003E; </span>are omitted or if the <span 
class="cmmi-12">&#x003C;</span>var-form<span 
class="cmmi-12">&#x003E; </span>is an id then the variable is bound
to nil in step 1 and left unchanged during step 4.
<!--l. 1131--><p class="noindent" >The function definition below illustrates the use of do. This function will reverse the order of
elements in a list.

<div class="verbatim" id="verbatim-238">
&#x00A0;&#x00A0;&#x00A0;&#x00A0;(de&#x00A0;reverse&#x00A0;(sequence)
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;(do&#x00A0;((local&#x00A0;sequence&#x00A0;(rest&#x00A0;local))
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;(result&#x00A0;nil&#x00A0;(cons&#x00A0;(first&#x00A0;local)&#x00A0;result)))
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;((null&#x00A0;local)&#x00A0;result)))
</div>
<!--l. 1139--><p class="nopar" >
<!--l. 1145--><p class="noindent" ><div class="minipage"><a 
 id="dx32-84010"></a>
<span 
class="ptmb7t-x-x-120">(do* A:list B:list [C:form]): any                                                                              </span><span 
class="ptmri7t-x-x-120">macro</span>
<br 
class="newline" /><div class="minipage">Do*  is  like  do,  except  the  variable  bindings  and  updatings  are  done
sequentially  instead  of  in  parallel.  The  following  is  a  definition  of  assoc
using do*.</div>
</div>

<div class="verbatim" id="verbatim-239">
&#x00A0;&#x00A0;&#x00A0;&#x00A0;(de&#x00A0;assoc&#x00A0;(item&#x00A0;a-list)
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;(do&#x22C6;&#x00A0;((local&#x00A0;a-list&#x00A0;(rest&#x00A0;local))
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;(pair&#x00A0;(first&#x00A0;local)&#x00A0;(first&#x00A0;local)))
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;((or&#x00A0;(null&#x00A0;local)
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;(equal&#x00A0;item&#x00A0;(first&#x00A0;pair)))
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;local)))
</div>
<!--l. 1153--><p class="nopar" >If do had been used, evaluation of the <span 
class="cmmi-12">&#x003C;</span>initial<span 
class="cmmi-12">&#x003E; </span>form (first local) would have resulted in an
error. Either local would be unbound or the value of local from the surrounding environment
would have been used.
<!--l. 1165--><p class="noindent" ><div class="minipage"><a 
 id="dx32-84011"></a>
<span 
class="ptmb7t-x-x-120">(do-loop A:list B:list C:list [S:form]): any                                                              </span><span 
class="ptmri7t-x-x-120">macro</span>
<br 
class="newline" /><div class="minipage">Do-loop is like do, except that it takes an additional argument, a prologue.
The general form follows, the square brackets are used to indicate zero or
more occurances of an expression.</div>
</div>

<div class="verbatim" id="verbatim-240">
&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;(DO-LOOP&#x00A0;([&#x003C;var-form&#x003E;])&#x00A0;([&#x003C;first&#x003E;])
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;(&#x003C;exit-test&#x003E;[&#x003C;result&#x003E;])&#x00A0;[&#x003C;body&#x003E;])
</div>
<!--l. 1169--><p class="nopar" >
<!--l. 1171--><p class="noindent" >This is executed just like the corresponding do, except that after the initial bindings are
established, but before the exit test is first evaluated, the prologue forms, consisting of
the <span 
class="cmmi-12">&#x003C;</span>first<span 
class="cmmi-12">&#x003E; </span>forms, are evaluated in a left to right order. Note that all of the <span 
class="cmmi-12">&#x003C;</span>first<span 
class="cmmi-12">&#x003E;</span>
forms are evaluated exactly once, assuming that none of the <span 
class="cmmi-12">&#x003C;</span>first<span 
class="cmmi-12">&#x003E; </span>forms causes an
error.
<!--l. 1183--><p class="noindent" ><div class="minipage"><a 
 id="dx32-84012"></a>
<span 
class="ptmb7t-x-x-120">(do-loop* A:list B:list C:list [S:form]): any                                                            </span><span 
class="ptmri7t-x-x-120">macro</span>
<br 
class="newline" /><div class="minipage">Do-loop* does the variable bindings and updates sequentially instead of in
parallel.</div>
</div>

<table cellspacing="5"><tr><td class="clinks"><a 
href="allman1li6.html#allman1se23.html" >Up</a></td><td class="clinks"><a 
href="allman1se24.html" >Next</a></td><td class="clinks"><a 
href="allman1se22.html" >Prev</a></td><td class="clinks"><a 
href="allman1se22.html#tailallman1se22.html" >PrevTail</a></td><td class="clinks"><a 
href="allman1se23.html" >Front</a></td></tr></table><a 
 id="tailallman1se23.html"></a>    
</body></html> 
