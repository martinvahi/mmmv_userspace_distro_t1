<!DOCTYPE html> 
<html lang="en-US" xml:lang="en-US" > 
<head><title>CDE: A Package for Integrability of PDEs</title> 
<meta  charset="utf-8" /> 
<meta name="generator" content="TeX4ht (https://tug.org/tex4ht/)" /> 
<meta name="viewport" content="width=device-width,initial-scale=1" /> 
<link rel="stylesheet" type="text/css" href="manual.css" /> 
<meta name="src" content="manual.tex" /> 
<script>window.MathJax = { tex: { tags: "ams", }, }; </script> 
 <script type="text/javascript" async="async" id="MathJax-script" src="../../cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js"></script>  
<meta name="description" content="The REDUCE Computer Algebra System User's Manual" /> 
</head><body 
>
<header>REDUCE</header><table cellspacing="5"><tr><td class="clinks"><a 
href="../manual-lookup.php%3FUser&#32;Contributed&#32;Packages.html#manualse133.html" >Up</a></td><td class="clinks"><a 
href="manualse134.html" >Next</a></td><td class="clinks"><a 
href="manualse132.html" >Prev</a></td><td class="clinks"><a 
href="manualse132.html#tailmanualse132.html" >PrevTail</a></td><td class="clinks"><a 
href="manualse133.html#tailmanualse133.html">Tail</a></td></tr></table><h3 class="sectionHead"><span class="titlemark">20.10    </span> <a 
 id="x194-44600020.10"></a>CDE: A Package for Integrability of PDEs</h3>
<!--l. 227--><p class="noindent" >Author: Raﬀaele Vitolo
<a 
 id="dx194-446001"></a>
<a 
 id="dx194-446002"></a>
<a 
 id="dx194-446003"></a>
<a 
 id="dx194-446004"></a>
</p><!--l. 17--><p class="noindent" >\( \newcommand {\pd }[2]{\mathchoice {\frac {\partial {#1}}{\partial {#2}}} {\partial {#1}/\partial {#2}}{\partial {#1}/\partial {#2}} {\partial {#1}/\partial {#2}}} \newcommand {\od }[2]{\mathchoice {\frac {d#1}{d#2}} {d{#1}/d{#2}}{d{#1}/d{#2}}{d{#1}/d{#2}}} \newcommand {\fd }[2]{\mathchoice {\frac {\delta {#1}}{\delta {#2}}} {\delta {#1}/\delta {#2}}{\delta {#1}/\delta {#2}}{\delta {#1}/\delta {#2}}} \newcommand {\N }{\mathbb {N}} \newcommand {\R }{\mathbb {R}} \newcommand {\Z }{\mathbb {Z}} \newcommand {\CDiff }{\mathop {\mathcal {C}\mathrm {Dif{}f}}} \newcommand {\CDiffsym }[1]{\CDiff _{(#1)}^{\,\mathrm {sym}}} \newcommand {\CDiffself }[1]{\CDiff _{(#1)}^{\,\mathrm {self}}} \newcommand {\CDiffskew }[1]{\CDiff _{(#1)}^{\,\mathrm {skew}}} \newcommand {\ddx }[1]{D_x^{#1}} \)We describe CDE, a REDUCE package devoted to diﬀerential-geometric computations
on Diﬀerential Equations (DEs, for short).
</p><!--l. 60--><p class="noindent" >We will give concrete recipes for computations in the geometry of diﬀerential equations:
higher symmetries, conservation laws, Hamiltonian operators and their Schouten bracket,
recursion operators. All programs discussed here are shipped together with the CDE
sources, inside the REDUCE sources. The mathematical theory on which computations
are based can be found in refs. <span class="cite">[<a 
href="manualap2.html#XKrasilshchik:99">BCD\(^{+}\)99</a>, <a 
href="manualap2.html#XKerstenKrasilshchikVerboretsky:2004">KKV04</a>]</span>. We invite the interested reader to
have a look at the website <span class="cite">[<a 
href="manualap2.html#Xgdeq">gde</a>]</span> which contains useful resources in the above
mathematical area. There is also a book on integrable systems and CDE <span class="cite">[<a 
href="manualap2.html#XKrasilshchikVerbovetskyVitolo:2018">KVV18</a>]</span>
with more examples and more detailed explanations about the mathematical
part.
</p><!--l. 71--><p class="noindent" >
</p>
<h4 class="subsectionHead"><span class="titlemark">20.10.1    </span> <a 
 id="x194-44700020.10.1"></a>Introduction: why CDE?</h4>
<!--l. 74--><p class="noindent" >CDE is a REDUCE package for diﬀerential-geometric computations for DEs. The
package aims at deﬁning diﬀerential operators in total derivatives and computing with
them. Such operators are called \(\mathcal {C}\)<span 
class="ptmri8t-x-x-109">-diﬀerential operators </span>(see <span class="cite">[<a 
href="manualap2.html#XKrasilshchik:99">BCD\(^{+}\)99</a>]</span>).
</p><!--l. 79--><p class="noindent" >CDE depends on the REDUCE package CDIFF for constructing total derivatives. CDIFF
was developed by Gragert and Kersten for symmetry computations in DEs, and later
extended by Roelofs and Post.
</p><!--l. 83--><p class="noindent" >There are many software packages that can compute symmetries and conservation laws;
many of them run on Mathematica or Maple. Those who run on REDUCE were
written by M. C. Nucci <span class="cite">[<a 
href="manualap2.html#XNucci:92">Nuc92</a>, <a 
href="manualap2.html#XNucci:96">Nuc96</a>]</span>, F. Oliveri (<span 
class="ptmrc8t-x-x-109">R<span 
class="small-caps">E</span>L<span 
class="small-caps">I</span><span 
class="small-caps">E</span></span>, <span class="cite">[<a 
href="manualap2.html#XOliveri:ReLie">Oli</a>]</span>), F. Schwartz
(SPDE, <a 
href="manualse176.html#x264-113100020.53">20.53<!--tex4ht:ref: package:SPDE --></a>), T. Wolf (APPLYSYM (<a 
href="manualse124.html#x164-30700020.1">20.1<!--tex4ht:ref: package:APPLYSYM --></a>) and CONLAW in the oﬃcial
REDUCE distribution, <span class="cite">[<a 
href="manualap2.html#XWolf:99d">Wol02</a>, <a 
href="manualap2.html#XWolf:APPLYSYM">Wol95</a>, <a 
href="manualap2.html#XBrand:95">BW95</a>, <a 
href="manualap2.html#XBrand:92">BW92</a>]</span>).
                                                                     

                                                                     
</p><!--l. 90--><p class="noindent" >The development of CDE started from the idea that a computer algebra tool for the
investigation of integrability-related structures of PDEs still does not exist in the public
domain. We are only aware of a Mathematica package that may ﬁnd recursion operators
under quite restrictive hypotheses <span class="cite">[<a 
href="manualap2.html#XBaldwinHereman:2010">BH10</a>]</span>.
</p><!--l. 95--><p class="noindent" >CDE is especially designed for computations of integrability-related structures (such as
Hamiltonian, symplectic and recursion operators) for systems of diﬀerential equations
with an arbitrary number of independent or dependent variables. On the other hand CDE
is also capable of (generalized) symmetry and conservation laws computations. The aim
of this guide is to introduce the reader to computations of integrability related structures
using CDE.
</p><!--l. 103--><p class="noindent" >The current version of CDE, 3.0, has the following features:
     </p><ol  class="enumerate1" >
<li 
  class="enumerate" id="x194-447002x1">
     <!--l. 105--><p class="noindent" >It is able to do standard computations in integrable systems like determining
     systems for generalized symmetries and conservation laws. However, CDE
     has not been programmed with this purpose in mind.
     </p></li>
<li 
  class="enumerate" id="x194-447004x2">
     <!--l. 108--><p class="noindent" >CDE is able to compute linear overdetermined systems of partial diﬀerential
     equations   whose   solutions   are   Hamiltonian,   symplectic   or   recursion
     operators.  Such  equations  may  be  solved  by  diﬀerent  techniques;  one
     of  the  possibilities  is  to  use  CRACK,  a  REDUCE  package  for  solving
     overdetermined systems of PDEs <span class="cite">[<a 
href="manualap2.html#XWolfBrand:CRACK">WB</a>]</span>.
     </p></li>
<li 
  class="enumerate" id="x194-447006x3">
     <!--l. 113--><p class="noindent" >CDE can compute linearization (or Fréchet derivatives) of vector functions
     and adjoints of diﬀerential operators.
     </p></li>
<li 
  class="enumerate" id="x194-447008x4">
     <!--l. 115--><p class="noindent" >CDE can do calculations on supermanifolds. In particular it can compute
     variational  derivatives  of  superdensities,  linearization  of  superfunctions,
     adjoint   of   superdiﬀerential   operators.   Some   of   the   features   are   still
     undocumented as they will be published in forthcoming papers.
     </p></li>
                                                                     

                                                                     
<li 
  class="enumerate" id="x194-447010x5">
     <!--l. 119--><p class="noindent" >CDE is able to compute Schouten brackets between local multivectors. This
     can  be  used  <span 
class="ptmri8t-x-x-109">eg  </span>to  check  Hamiltonianity  of  an  operator  or  to  check  their
     compatibility.
     </p></li>
<li 
  class="enumerate" id="x194-447012x6">
     <!--l. 122--><p class="noindent" >CDE  can  calculate  the  Schouten  bracket  of  weakly  nonlocal  diﬀerential
     operators;   these   are   distinguished   pseudodiﬀerential   operators   in   one
     independent variable. The algorithm has been published in <span class="cite">[<a 
href="manualap2.html#XCLV2020">CLV20</a>]</span>, while
     a user guide is being written and will appear soon (interested readers can ask
     the author of CDE for details).</p></li></ol>
<!--l. 129--><p class="noindent" >At the moment the papers <span class="cite">[<a 
href="manualap2.html#XFerapontov:2014">FPV14</a>, <a 
href="manualap2.html#XFerapontov:2016">FPV16</a>, <a 
href="manualap2.html#XKerstenKrasilshchikVerbovetskyVitolo:HSGP">KKVV09</a>, <a 
href="manualap2.html#XKrasilshchikVerbovetskyVitolo:SPT:2012">KVV12</a>, <a 
href="manualap2.html#XPavlovVitolo:2015">PV15</a>, <a 
href="manualap2.html#XSaccomandiVitolo:2014">SV14</a>]</span> have
been written using CDE, and more research by CDE on integrable systems is in
progress.
</p><!--l. 134--><p class="noindent" >The readers are warmly invited to send questions, comments, etc., both on the
computations and on the technical aspects of installation and conﬁguration of REDUCE,
to the author of this document.
</p><!--l. 138--><p class="noindent" ><span 
class="ptmb8t-x-x-109">Acknowledgements. </span>I’d like to thank Paul H.M. Kersten, who explained to me how to
use the original CDIFF package for several computations of interest in the Geometry of
Diﬀerential Equations. When I started writing CDE I was substantially helped by A.C.
Norman in understanding many features of Reduce which were deeply hidden in the
source code and not well documented. This also led to writing a manual of Reduce’s
internals for programmers <span class="cite">[<a 
href="manualap2.html#XNormanVitolo:InsideReduce">NV</a>]</span>. Moreover, I’d like to thank the developers of the
REDUCE mailing list for their prompt replies with solutions to my problems. On the
mathematical side, I would like to thank J.S. Krasil’shchik and A.M. Verbovetsky for
constant support and stimulating discussions which led me to write the software. Thanks
are also due to B.A. Dubrovin, M. Casati, E.V. Ferapontov, P. Lorenzoni, M.
Marvan, V. Novikov, A. Savoldi, A. Sergyeyev, M.V. Pavlov for many interesting
discussions.
</p><!--l. 153--><p class="noindent" >
</p>
<h4 class="subsectionHead"><span class="titlemark">20.10.2    </span> <a 
 id="x194-44800020.10.2"></a>Jet space of even and odd variables, and total derivatives</h4>
<!--l. 156--><p class="noindent" >The mathematical theory for jets of even (<span 
class="ptmri8t-x-x-109">ie </span>standard) variables and total derivatives can
be found in <span class="cite">[<a 
href="manualap2.html#XKrasilshchik:99">BCD\(^{+}\)99</a>, <a 
href="manualap2.html#XOlver:93">Olv93</a>]</span>.
</p><!--l. 159--><p class="noindent" >Let us consider the space \(\mathbb {R}^n\times \mathbb {R}^m\), with coordinates \((x^\lambda ,u^i)\), \(1\leq \lambda \leq n\), \(1\leq i\leq m\). We say \(x^\lambda \) to be <span 
class="ptmri8t-x-x-109">independent variables </span>and \(u^i\)
                                                                     

                                                                     
to be <span 
class="ptmri8t-x-x-109">dependent variables</span>. Let us introduce the <span 
class="ptmri8t-x-x-109">jet space</span> \(J^r(n,m)\). This is the space with
coordinates \((x^\lambda ,u^i_\sigma )\), where \(u^i_\sigma \) is deﬁned as follows. If \(s\colon \R ^n\to \R ^m\) is a diﬀerentiable function, then \[ u^i_\sigma \circ s(x)=\frac {\partial ^{|\sigma |}(u^i\circ s)} {(\partial x^1)^{\sigma _1}\cdots (\partial x^n)^{\sigma _n}}. \] Here \(\sigma =(\sigma _1,\ldots ,\sigma _n)\in \N ^n\) is a
multiindex. We set \(|\sigma |=\sigma _1+\cdots +\sigma _n\). If \(\sigma =(0,\ldots ,0)\) we set \(u^i_\sigma =u^i\).
</p><!--l. 173--><p class="noindent" >CDE is ﬁrst of all a program which is able to create a <span 
class="ptmri8t-x-x-109">ﬁnite order jet space </span>inside
REDUCE. To this aim, issue the command
                                                                     

                                                                     
</p>
<pre class="verbatim" id="verbatim-776">
load_package cde;
</pre>
<!--l. 177--><p class="nopar" > Then, CDE needs to know the variables and the maximal order of derivatives. The input
can be organized as in the following example: <a 
 id="dx194-448001"></a> <a 
 id="dx194-448002"></a> <a 
 id="dx194-448003"></a> <a 
 id="variable:INDEP_VAR"></a> <a 
 id="variable:DEP_VAR"></a> <a 
 id="variable:TOTAL_ORDER"></a>
                                                                     

                                                                     
</p>
<pre class="verbatim" id="verbatim-777">
indep_var:={x,t}$
dep_var:={u,v}$
total_order:=10$
</pre>
<!--l. 190--><p class="nopar" > Here </p>
     <ul class="itemize1">
     <li class="itemize">
     <!--l. 193--><p class="noindent" ><span 
class="pcrr8t-x-x-109">indep_var </span>is the list of independent variables;
     </p></li>
     <li class="itemize">
     <!--l. 194--><p class="noindent" ><span 
class="pcrr8t-x-x-109">dep_var </span>is the list of dependent variables;
     </p></li>
     <li class="itemize">
     <!--l. 195--><p class="noindent" ><span 
class="pcrr8t-x-x-109">total_order </span>is the maximal order of derivatives.</p></li></ul>
<!--l. 198--><p class="noindent" >Two more parameters can be set for convenience:
                                                                     

                                                                     
</p>
<pre class="verbatim" id="verbatim-778">
statename:=&#x0022;jetuv_state.red&#x0022;$
resname:=&#x0022;jetuv_res.red&#x0022;$
</pre>
<!--l. 202--><p class="nopar" > These are the name of the output ﬁle for recording the internal state of the program
<span 
class="pcrr8t-x-x-109">cde.red </span>(and for debugging purposes), and the name of the ﬁle containing results of
the computation.
</p><!--l. 207--><p class="noindent" >The main routine in <span 
class="pcrr8t-x-x-109">cde.red </span>is called as follows: <a 
 id="dx194-448004"></a> <a 
 id="operator:CDE"></a>
                                                                     

                                                                     
</p>
<pre class="verbatim" id="verbatim-779">
cde({indep_var,dep_var,{},total_order},{})$
</pre>
<!--l. 212--><p class="nopar" > Here the two empty lists are placeholders; they are of interest for computations with odd
variables/diﬀerential equations. The function \(\texttt {cde}\) deﬁnes derivative symbols of the
type:
                                                                     

                                                                     
</p>
<pre class="verbatim" id="verbatim-780">
u_x,v_t,u_2xt,v_xt,v_2x3t,...
</pre>
<!--l. 218--><p class="nopar" > Note that the symbol <span 
class="pcrr8t-x-x-109">v_tx </span>does not exist in the jet space. Indeed, introducing all
possible permutations of independent variables in indices would increase the complexity
and slow down every computation.
</p><!--l. 223--><p class="noindent" >Two lists generated by CDE can be useful: <span 
class="pcrr8t-x-x-109">all_der_id </span>and <span 
class="pcrr8t-x-x-109">all_odd_id</span>, which
are, respectively, the lists of identiﬁers of all even and odd variables.
</p><!--l. 227--><p class="noindent" >Other lists are generated by CDE, but they are accessible in REDUCE symbolic mode
only. Please check the ﬁle <span 
class="pcrr8t-x-x-109">global.txt </span>to know the names of the lists.
<a 
 id="dx194-448005"></a>
</p><!--l. 232--><p class="noindent" ><a 
 id="operator:SAVE_CDE_STATE"></a> It can be useful to inspect the output generated by the function <span 
class="pcrr8t-x-x-109">cde </span>and the above lists
in particular. All that data can be saved by the function:
                                                                     

                                                                     
</p>
<pre class="verbatim" id="verbatim-781">
save_cde_state(statename)$
</pre>
<!--l. 237--><p class="nopar" >
<a 
 id="dx194-448006"></a>
<a 
 id="dx194-448007"></a>
<a 
 id="dx194-448008"></a>
</p><!--l. 242--><p class="noindent" ><a 
 id="operator:JET_FIBER_DIM"></a> <a 
 id="operator:JET_DIM"></a><a 
 id="operator:SELECTVARS"></a> CDE has a few procedures involving the jet space, namely: </p>
     <ul class="itemize1">
     <li class="itemize">
     <!--l. 247--><p class="noindent" ><span 
class="pcrr8t-x-x-109">jet_fiber_dim(jorder) </span>returns the number of derivative coordinates
     \(u^i_\sigma \) with \(|\sigma |\) equal to <span 
class="pcrr8t-x-x-109">jorder</span>;
     </p></li>
     <li class="itemize">
     <!--l. 249--><p class="noindent" ><span 
class="pcrr8t-x-x-109">jet_dim(jorder) </span>returns the number of derivative coordinates \(u^i_\sigma \) with \(0\leq |\sigma |\)
     and \(|\sigma |\) equal to <span 
class="pcrr8t-x-x-109">jorder</span>;
     </p></li>
     <li class="itemize">
     <!--l. 252--><p class="noindent" ><span 
class="pcrr8t-x-x-109">selectvars(par,orderofder,depvars,vars)</span>
     returns all derivative coordinates (even if <span 
class="pcrr8t-x-x-109">par=0</span>, odd if <span 
class="pcrr8t-x-x-109">par=1</span>) of order
     <span 
class="pcrr8t-x-x-109">orderofder </span>of the list of dependent variables <span 
class="pcrr8t-x-x-109">depvars </span>which belong to
     the set of derivative coordinates <span 
class="pcrr8t-x-x-109">vars</span>.</p></li></ul>
<!--l. 258--><p class="noindent" >The function <span 
class="pcrr8t-x-x-109">cde </span>deﬁnes total derivatives truncated at the order <span 
class="pcrr8t-x-x-109">total_order</span>. Their
coordinate expressions are of the form \begin {equation}  \label {cdeeq:2} D_\lambda =\pd {}{x^\lambda } + u^i_{\mathbf {\sigma }\lambda }\pd {}{u^i_{\mathbf {\sigma }}},  \end {equation}
where \(\mathbf {\sigma }\) is a multiindex.
</p><!--l. 268--><p class="noindent" >The total derivative of an argument \(\varphi \) is invoked as follows:
                                                                     

                                                                     
</p>
<pre class="verbatim" id="verbatim-782">
td(phi,x,2);
td(phi,x,t,3);
</pre>
<!--l. 272--><p class="nopar" > the syntax closely follows REDUCE’s syntax for standard derivatives <span 
class="pcrr8t-x-x-109">df</span>; the above
expression translates to \(D_xD_x\varphi \), or \(D_{\{2,0\}}\varphi \) in multiindex notation.
</p><!--l. 277--><p class="noindent" >When in total derivatives there is a coeﬃcient of order higher than maximal this is
replaced by the identiﬁer <span 
class="pcrr8t-x-x-109">letop</span>, which is a function that depends on independent
variables. If such a function (or its derivatives) appears during computations it is likely
that we went too close to the highest order variables that we deﬁned in the ﬁle. All results
of computations are scanned for the presence of such variables by default, and if the
presence of <span 
class="pcrr8t-x-x-109">letop </span>is detected the computation is stopped with an error message. This
usually means that we need to extend the order of the jet space, just by increasing the
number <span 
class="pcrr8t-x-x-109">total_order</span>.
</p><!--l. 287--><p class="noindent" >Note that in the folder containing all examples there is also a shell script, <span 
class="pcrr8t-x-x-109">rrr.sh</span>
(works only under <span 
class="pcrr8t-x-x-109">bash</span>, a GNU/Linux command interpreter) which can be used to run
reduce on a given CDE program. When an error message about <span 
class="pcrr8t-x-x-109">letop </span>is issued the
script reruns the computation with a new value of <span 
class="pcrr8t-x-x-109">total_order </span>one unity higher than
the previous one.
</p><!--l. 294--><p class="noindent" ><a 
 id="switch:CHECKORD"></a> The function that checks an expression for the presence of <span 
class="pcrr8t-x-x-109">letop </span>is <span 
class="pcrr8t-x-x-109">check_letop</span>. If
you wish to switch oﬀ this kind of check in order to increase the speed, the switch
<span 
class="pcrr8t-x-x-109">checkord</span><a 
 id="dx194-448009"></a><a 
 id="dx194-448010"></a><a 
 id="dx194-448011"></a> must be set oﬀ:
                                                                     

                                                                     
</p>
<pre class="verbatim" id="verbatim-783">
off checkord;
</pre>
<!--l. 301--><p class="nopar" >
<a 
 id="dx194-448012"></a>
<a 
 id="dx194-448013"></a>
</p><!--l. 305--><p class="noindent" ><a 
 id="operator:NOEXPAND_TD"></a> <a 
 id="operator:EXPAND_TD"></a> The computation of total derivatives of a huge expression can be extremely time and
resources consuming. In some cases it is a good idea to disable the expansion of the total
derivative and leave an expression of the type \(D_\sigma \varphi \) as indicated. This is achieved by the
command
                                                                     

                                                                     
</p>
<pre class="verbatim" id="verbatim-784">
noexpand_td();
</pre>
<!--l. 313--><p class="nopar" > If you wish to restore the default behaviour, do
                                                                     

                                                                     
</p>
<pre class="verbatim" id="verbatim-785">
expand_td();
</pre>
<!--l. 317--><p class="nopar" >
<a 
 id="dx194-448014"></a>
</p><!--l. 320--><p class="noindent" ><a 
 id="variable:ODD_VAR"></a> CDE can also compute on jets of supermanifolds. The theory can be found in
<span class="cite">[<a 
href="manualap2.html#XIgoninVerbovetskyVitolo:2004">IVV04</a>, <a 
href="manualap2.html#XKerstenKrasilshchikVerboretsky:2004">KKV04</a>, <a 
href="manualap2.html#XKrasilshchikVerbovetsky:JGP:2011">KV11</a>]</span>. The input can be organized as follows:
                                                                     

                                                                     
</p>
<pre class="verbatim" id="verbatim-786">
indep_var:={x,t}$
dep_var:={u,v}$
odd_var:={p,q}
total_order:=10$
</pre>
<!--l. 328--><p class="nopar" > Here <span 
class="pcrr8t-x-x-109">odd_var </span>is the list of odd variables. The call
                                                                     

                                                                     
</p>
<pre class="verbatim" id="verbatim-787">
cde({indep_var,dep_var,odd_var,total_order},{})$
</pre>
<!--l. 332--><p class="nopar" > will create the jet space of the supermanifold described by the independent variables and
the even and odd dependent variables, up to the order <span 
class="pcrr8t-x-x-109">total_order</span>. Total
derivatives truncated at the order <span 
class="pcrr8t-x-x-109">total_order </span>will also include odd derivatives:
\begin {equation}  D_\lambda =\pd {}{x^\lambda } + u^i_{\mathbf {\sigma }\lambda }\pd {}{u^i_{\mathbf {\sigma }}} + p^i_{\mathbf {\sigma }\lambda }\pd {}{p^i_{\mathbf {\sigma }}},  \end {equation}
where \(\mathbf {\sigma }\) is a multiindex. The considerations on expansion and <span 
class="pcrr8t-x-x-109">letop </span>apply in this case
too.
<a 
 id="dx194-448015"></a>
</p><!--l. 346--><p class="noindent" ><a 
 id="operator:EXT"></a> Odd variables can appear in anticommuting products; this is represented as
                                                                     

                                                                     
</p>
<pre class="verbatim" id="verbatim-788">
ext(p,p_2xt),ext(p_x,q_t,q_x2t),...
</pre>
<!--l. 350--><p class="nopar" > where <span 
class="pcrr8t-x-x-109">ext(p_2xt,p) = - ext(p,p_2xt) </span>and the variables are arranged in a
unique way terms of an internal ordering. Indeed, the internal representation of odd
variables and their products (not intended for normal users!) is
                                                                     

                                                                     
</p>
<pre class="verbatim" id="verbatim-789">
ext(3,23),ext(1,3,5),...
</pre>
<!--l. 357--><p class="nopar" > as all odd variables and their derivatives are indexed by integers. <a 
 id="dx194-448016"></a> <a 
 id="operator:SUPER_PRODUCT"></a> Note that <span 
class="pcrr8t-x-x-109">p </span>and
<span 
class="pcrr8t-x-x-109">ext(p) </span>are just the same. The odd product of two expressions \(\varphi \) and \(\psi \) is achieved by the
CDIFF function
                                                                     

                                                                     
</p>
<pre class="verbatim" id="verbatim-790">
super_product(phi,psi);
</pre>
<!--l. 365--><p class="nopar" > The derivative of an expression \(\varphi \) with respect to an odd variable \(p\) is achieved by<a 
 id="dx194-448017"></a>
<a 
 id="operator:DF_ODD"></a>
                                                                     

                                                                     
</p>
<pre class="verbatim" id="verbatim-791">
df_odd(phi,p);
</pre>
<!--l. 371--><p class="nopar" >
</p><!--l. 373--><p class="noindent" >
</p>
<h4 class="subsectionHead"><span class="titlemark">20.10.3    </span> <a 
 id="x194-44900020.10.3"></a>Diﬀerential equations in even and odd variables</h4>
<!--l. 376--><p class="noindent" >We now give the equation in the form of one or more derivatives equated to right-hand side expressions.
The left-hand side derivatives are called <span 
class="ptmri8t-x-x-109">principal</span>, and the remaining derivatives are called
<span 
class="ptmri8t-x-x-109">parametric</span><span class="footnote-mark"><a 
href="manual195.html#fn22x20"><sup class="textsuperscript">22</sup></a></span><a 
 id="x194-449001f22"></a> .
Parametric coordinates are coordinates on the equation manifold and its diﬀerential
consequences, and principal coordinates are determined by the diﬀerential equation and
its diﬀerential consequences. For scalar evolutionary equations with two independent
variables parametric derivatives are of the type \((u,u_x,u_{xx},\ldots )\). Note that the system must be
in passive orthonomic form; this also means that there will be no nontrivial
integrability conditions between parametric derivatives. (Lines beginning with <span 
class="pcrr8t-x-x-109">% </span>are
comments for REDUCE.) The input is formed as follows (Burger’s equation).
<a 
 id="dx194-449002"></a> <a 
 id="variable:PRINCIPAL_DER"></a>
                                                                     

                                                                     
</p>
<pre class="verbatim" id="verbatim-792">
% left-hand side of the differential equation
principal_der:={u_t}$
% right-hand side of the differential equation
de:={u_2x+2*u*u_x}$
</pre>
<!--l. 396--><p class="nopar" > Systems of PDEs are input in the same way: of course, the above two lists must have the
same length. See <a 
href="manualse133.html#x194-46300020.10.11">20.10.11<!--tex4ht:ref: cdesec:comp-syst-pdes --></a> for an example.
</p><!--l. 400--><p class="noindent" >The main routine in <span 
class="pcrr8t-x-x-109">cde.red </span>is called as follows:
                                                                     

                                                                     
</p>
<pre class="verbatim" id="verbatim-793">
cde({indep_var,dep_var,{},total_order},
   {principal_der,de,{},{}})$
</pre>
<!--l. 404--><p class="nopar" > <a 
 id="dx194-449003"></a> <a 
 id="dx194-449004"></a> <a 
 id="dx194-449005"></a> <a 
 id="dx194-449006"></a> <a 
 id="variable:ALL_PRINCIPAL_DER"></a><a 
 id="variable:ALL_PRINCIPAL_ODD"></a><a 
 id="variable:ALL_PARAMETRIC_DER"></a><a 
 id="variable:ALL_PARAMETRIC_ODD"></a> Here the three empty lists are placeholders; they are important for computations
with odd variables. The function <span 
class="pcrr8t-x-x-109">cde </span>computes principal and parametric derivatives of
even and odd variables, they are stored in the lists <span 
class="pcrr8t-x-x-109">all_parametric_der,</span>
<span 
class="pcrr8t-x-x-109">all_principal_der, all_parametric_odd, all_principal_odd</span>.
</p><!--l. 419--><p class="noindent" >The function <span 
class="pcrr8t-x-x-109">cde </span>also deﬁnes total derivatives truncated at the order <span 
class="pcrr8t-x-x-109">total_order</span>
and restricted on the (even and odd) equation; this means that total derivatives are
tangent to the equation manifold. Their coordinate expressions are of the form
\begin {equation}  D_\lambda =\pd {}{x^\lambda }+\sum _{u^i_{\mathbf {\sigma }}\\text {parametric}}u^i_{\mathbf {\sigma }\lambda }\pd {}{u^i_{\mathbf {\sigma }}} + \sum _{p^i_{\mathbf {\sigma }}\\text {parametric}}p^i_{\mathbf {\sigma }\lambda }\pd {}{p^i_{\mathbf {\sigma }}},  \end {equation}
where \(\mathbf {\sigma }\) is a multiindex. It can happen that \(u^i_{\mathbf {\sigma }\lambda }\) (or \(p^i_{\mathbf {\sigma }\lambda }\)) is principal and must be replaced with
diﬀerential consequences of the equation. Such diﬀerential consequences are
called <span 
class="ptmri8t-x-x-109">primary diﬀerential consequences</span>, and are computed; in general they
will depend on other, possibly new, diﬀerential consequences, and so on. Such
newly appearing diﬀerential consequences are called <span 
class="ptmri8t-x-x-109">secondary diﬀerential</span>
<span 
class="ptmri8t-x-x-109">consequences</span>. If the equation is in passive orthonomic form, the system of all
diﬀerential consequences (up to the maximal order <span 
class="pcrr8t-x-x-109">total_order</span>) must be
solvable in terms of parametric derivatives only. The function <span 
class="ptmri8t-x-x-109">cde </span>automatically
computes all necessary and suﬃcient diﬀerential consequences which are needed
to solve the system. The solved system is available in the form of REDUCE
let-rules in the variables <span 
class="pcrr8t-x-x-109">repprincparam_der </span>and <span 
class="pcrr8t-x-x-109">repprincparam_odd</span>. <a 
 id="dx194-449007"></a> <a 
 id="dx194-449008"></a> <a 
 id="variable:REPPRINCPARAM_DER"></a>
<a 
 id="variable:REPPRINCPARAM_ODD"></a>
</p><!--l. 448--><p class="noindent" >The syntax and properties (expansion and <span 
class="pcrr8t-x-x-109">letop</span>) of total derivatives remain the same.
For exmaple:
                                                                     

                                                                     
</p>
<pre class="verbatim" id="verbatim-794">
td(u,t);
</pre>
<!--l. 452--><p class="nopar" > returns
                                                                     

                                                                     
</p>
<pre class="verbatim" id="verbatim-795">
u_2x+2*u*u_x;
</pre>
<!--l. 456--><p class="nopar" >
</p><!--l. 458--><p class="noindent" >It is possible to deal with mixed systems on eve and odd variables. For example, in the
case of Burgers equation we can input the linearized equation as a PDE on a
new odd variable as follows (of course, in addition to what has been deﬁned
before):
                                                                     

                                                                     
</p>
<pre class="verbatim" id="verbatim-796">
odd_var:={q}$
principal_odd:={q_t}$
de_odd:={q_2x + 2*u_x*q + 2*u*q_x}$
</pre>
<!--l. 466--><p class="nopar" > The main routine in <span 
class="pcrr8t-x-x-109">cde.red </span>is called as follows:
                                                                     

                                                                     
</p>
<pre class="verbatim" id="verbatim-797">
cde({indep_var,dep_var,odd_var,total_order},
   {principal_der,de,principal_odd,de_odd})$
</pre>
<!--l. 471--><p class="nopar" >
</p>
<h4 class="subsectionHead"><span class="titlemark">20.10.4    </span> <a 
 id="x194-45000020.10.4"></a>Calculus of variations</h4>
<!--l. 476--><p class="noindent" >CDE can compute variational derivatives of any function (usually a Lagrangian density)
or superfunction \(\mathcal {L}\). We have the following coordinate expression \begin {equation}  \label {eq:9} \fd {\mathcal {L}}{u^i} = (-1)^{|\sigma |}D_\sigma \pd {\mathcal {L}}{u^i_\sigma }, \quad \fd {\mathcal {L}}{p^i} = (-1)^{|\sigma |}D_\sigma \pd {\mathcal {L}}{p^i_\sigma }  \end {equation}
which translates into the CDE commands
                                                                     

                                                                     
</p>
<pre class="verbatim" id="verbatim-798">
pvar_df(0,lagrangian_dens,ui);
pvar_df(1,lagrangian_dens,pi);
</pre>
<!--l. 489--><p class="nopar" > where<a 
 id="dx194-450001"></a> <a 
 id="operator:PVAR_DF"></a> </p>
     <ul class="itemize1">
     <li class="itemize">
     <!--l. 493--><p class="noindent" >the ﬁrst argument can be \(0\) or \(1\) and is the parity of the variable <span 
class="pcrr8t-x-x-109">ui </span>or <span 
class="pcrr8t-x-x-109">pi</span>;
     </p></li>
     <li class="itemize">
     <!--l. 495--><p class="noindent" ><span 
class="pcrr8t-x-x-109">lagrangian_dens </span>is \(\mathcal {L}\);
     </p></li>
     <li class="itemize">
     <!--l. 496--><p class="noindent" ><span 
class="pcrr8t-x-x-109">ui </span>or <span 
class="pcrr8t-x-x-109">pi </span>are the given dependent variables.</p></li></ul>
<!--l. 498--><p class="noindent" >The Euler operator computes variational derivatives with respect to all even and odd
variables in the jet space, and arranges them in a list of two lists, the list of even
variational derivatives and the list of odd variational derivatives. The command is<a 
 id="dx194-450002"></a>
<a 
 id="operator:EULER_DF"></a>
                                                                     

                                                                     
</p>
<pre class="verbatim" id="verbatim-799">
euler_df(lagrangian_dens);
</pre>
<!--l. 505--><p class="nopar" > All the above is used in the deﬁnition of Schouten brackets, as we will see in
Subsection <a 
href="manualse133.html#x194-45300020.10.6">20.10.6<!--tex4ht:ref: cdesec:mathc-diff-oper-odd --></a>.
</p><!--l. 509--><p class="noindent" >
</p>
<h4 class="subsectionHead"><span class="titlemark">20.10.5    </span> <a 
 id="x194-45100020.10.5"></a>\(\mathcal {C}\)-diﬀerential operators</h4>
<!--l. 512--><p class="noindent" >Linearizing (or taking the Fréchet derivative) of a vector function that deﬁnes a
diﬀerential equation yields a diﬀerential operator in total derivatives. This operator can
be restricted to the diﬀerential equation, which may be regarded as a diﬀerential
constraint; the kernel of the restricted operator is the space of all symmetries (including
higher or generalized symmetries) <span class="cite">[<a 
href="manualap2.html#XKrasilshchik:99">BCD\(^{+}\)99</a>, <a 
href="manualap2.html#XOlver:93">Olv93</a>]</span>.
</p><!--l. 519--><p class="noindent" >The formal adjoint of the linearization operator yields by restriction to the corresponding
diﬀerential equation a diﬀerential operator whose kernel contains all characteristic
vectors or generating functions of conservation laws <span class="cite">[<a 
href="manualap2.html#XKrasilshchik:99">BCD\(^{+}\)99</a>, <a 
href="manualap2.html#XOlver:93">Olv93</a>]</span>.
</p><!--l. 524--><p class="noindent" >Such operators are examples of \(\mathcal {C}\)-diﬀerential operators. The (still incomplete) REDUCE
implementation of the calculus of \(\mathcal {C}\)-diﬀerential operators is the subject of this
section.
</p><!--l. 528--><p class="noindent" >
</p>
<h5 class="subsubsectionHead"><a 
 id="x194-45200020.10.5"></a>\(\mathcal {C}\)-diﬀerential operators</h5>
<!--l. 531--><p class="noindent" >Let us consider the spaces \[ P=\{\varphi \colon J^r(n,m)\to \R ^k\},\qquad Q=\{\psi \colon J^r(n,m)\to \R ^s\}. \] A \(\mathcal {C}\)<span 
class="ptmri8t-x-x-109">-diﬀerential operator</span> \(\Delta \colon P\to Q\) is deﬁned to be a map of the type
\begin {equation} \relax \expandafter \ifx \csname cur:th\endcsname \relax \expandafter \:label \else \expandafter \l:bel \fi {eq:4} \Delta (\varphi ) = (\sum _{\sigma , i}a^{\sigma j}_i D_\sigma \varphi ^i),  \end {equation}
where \(a^{\sigma j}_i\) are diﬀerentiable functions on \(J^r(n,m)\), \(1\leq i\leq k\), \(1\leq j\leq s\). The <span 
class="ptmri8t-x-x-109">order </span>of \(\delta \) is the highest length of \(\sigma \) in the
above formula.
</p><!--l. 544--><p class="noindent" >We may consider a generalization to \(k\)-\(\mathcal {C}\)<span 
class="ptmri8t-x-x-109">-diﬀerential operators </span>of the type \begin {multline} \relax \expandafter \ifx \csname cur:th\endcsname \relax \expandafter \:label \else \expandafter \l:bel \fi {eq:7} \Delta \colon P_1\times \cdots \times P_h \to Q\\ \Delta (\varphi _1,\dots ,\varphi _h) = (\sum _{\sigma _1,\ldots ,\sigma _h, i_1,\ldots , i_h}a^{\sigma _1,\ldots ,\sigma _h,\ j}_{i_1\cdots i_h} D_{\sigma _1} \varphi _1^{i_1}\cdots D_{\sigma _h}\varphi _h^{i_h}),  \end {multline}
where the enclosing parentheses mean that the value of the operator is a vector function
in \(Q\).
                                                                     

                                                                     
</p><!--l. 556--><p class="noindent" >A \(\mathcal {C}\)-diﬀerential operator in CDE must be declared as follows: <a 
 id="dx194-452001"></a> <a 
 id="operator:MK_CDIFFOP"></a>
                                                                     

                                                                     
</p>
<pre class="verbatim" id="verbatim-800">
mk_cdiffop(opname,num_arg,length_arg,length_target)
</pre>
<!--l. 561--><p class="nopar" > where </p>
     <ul class="itemize1">
     <li class="itemize">
     <!--l. 564--><p class="noindent" ><span 
class="pcrr8t-x-x-109">opname </span>is the name of the operator;
     </p></li>
     <li class="itemize">
     <!--l. 565--><p class="noindent" ><span 
class="pcrr8t-x-x-109">num_arg </span>is the number of arguments <span 
class="ptmri8t-x-x-109">eg</span> \(k\) in \eqref {eq:7};
     </p></li>
     <li class="itemize">
     <!--l. 567--><p class="noindent" ><span 
class="pcrr8t-x-x-109">length_arg </span>is the list of lengths of the arguments: <span 
class="ptmri8t-x-x-109">eg </span>the length of the
     single argument of \(\Delta \) \eqref {eq:4} is \(k\), and the corresponding list is <span 
class="pcrr8t-x-x-109">{k}</span>, while in \eqref {eq:7} one
     needs  a  list  of  \(k\)  items  <span 
class="pcrr8t-x-x-109">{k_1,</span><span 
class="pcrr8t-x-x-109">…,k_h}</span>,  each  corresponding  to  number  of
     components of the vector functions to which the operator is applied;
     </p></li>
     <li class="itemize">
     <!--l. 572--><p class="noindent" ><span 
class="pcrr8t-x-x-109">length_target </span>is the numer of components of the image vector function.</p></li></ul>
<!--l. 575--><p class="noindent" >The syntax for one component of the operator <span 
class="pcrr8t-x-x-109">opname </span>is
                                                                     

                                                                     
</p>
<pre class="verbatim" id="verbatim-801">
  opname(j,i1,...,ih,phi1,...,phih)
</pre>
<!--l. 578--><p class="nopar" > The above operator will compute \begin {equation}  \label {eq:10} \Delta (\varphi _1,\dots ,\varphi _h) = \sum _{\sigma _1,\ldots ,\sigma _h} a^{\sigma _1,\ldots ,\sigma _h,\ j}_{i_1\cdots i_h} D_{\sigma _1} \varphi _1^{i_1}\cdots D_{\sigma _h}\varphi _h^{i_h},  \end {equation}
for ﬁxed integer indices \(i_1\),…,\(i_h\) and \(j\).
</p><!--l. 590--><p class="noindent" >There are several operations which involve diﬀerential operators. Obviously they can be
summed and multiplied by scalars.
</p><!--l. 593--><p class="noindent" >An important example of \(\mathcal {C}\)-diﬀerential operator is that of <span 
class="ptmri8t-x-x-109">linearization</span>, or <span 
class="ptmri8t-x-x-109">Fr</span><span 
class="ptmri8t-x-x-109">é</span><span 
class="ptmri8t-x-x-109">chet</span>
<span 
class="ptmri8t-x-x-109">derivative</span>, of a vector function \[ F\colon J^r(n,m) \to \R ^k. \] This is the operator \[ \ell _F\colon \varkappa \to P ,\quad \varphi \mapsto \sum _{\sigma , i}\pd {F^k}{u^i_\sigma }D_\sigma \varphi ^i, \] where \(\varkappa = \{ \varphi \colon J^r(n,m) \to \R ^m \}\) is the space of <span 
class="ptmri8t-x-x-109">generalized</span>
<span 
class="ptmri8t-x-x-109">vector ﬁelds on jets </span><span class="cite">[<a 
href="manualap2.html#XKrasilshchik:99">BCD\(^{+}\)99</a>, <a 
href="manualap2.html#XOlver:93">Olv93</a>]</span>.
</p><!--l. 606--><p class="noindent" >Linearization can be extended to an operation that, starting from a \(k\)-\(\mathcal {C}\)-diﬀerential operator,
generates a \(k+1\)-\(\mathcal {C}\)-diﬀerential operator as follows: \[ \ell _{\Delta }(p_1,\dots ,p_k,\varphi ) = (\sum _{\sigma ,\sigma _1,\ldots ,\sigma _k, i,i_1,\ldots ,i_k} \frac {\partial a^{\sigma _1,\ldots ,\sigma _k,\ j}_{i_1\cdots i_k}}{\partial u^i_\sigma } D_{\sigma }\varphi ^i D_{\sigma _1}p_1^{i_1}\cdots D_{\sigma _k}p_k^{i_k}) \] (The above operation is also denoted by
\(\ell _{\Delta ,p_1,\dots ,p_k}(\varphi )\).)
</p><!--l. 618--><p class="noindent" >At the moment, CDE is only able to compute the linearization of a vector function
(Section <a 
href="manualse133.html#x194-45500020.10.8">20.10.8<!--tex4ht:ref: cdesec:linadj --></a>).
</p><!--l. 621--><p class="noindent" >Given a \(\mathcal {C}\)-diﬀerential operator \(\Delta \) like in \eqref {eq:4} we can deﬁne its <span 
class="ptmri8t-x-x-109">adjoint </span>as \begin {equation} \relax \expandafter \ifx \csname cur:th\endcsname \relax \expandafter \:label \else \expandafter \l:bel \fi {eq:5} \Delta ^*((q_j)) = (\sum _{\sigma , i} (-1)^{|\sigma |} D_\sigma (a^{\sigma j}_i q_j)).  \end {equation}
Note that the matrix of coeﬃcients is transposed. Again, the coeﬃcients of the adjoint
operator can be found by computing \(\Delta ^*(x^\sigma e_j)\) for every basis vector \(e_j\) and every count \(x^\sigma \), where \(|\sigma |\leq r\), and
\(r\) is the order of the operator. This operation can be generalized to \(\mathcal {C}\)-diﬀerential operators
with \(h\) arguments.
</p><!--l. 633--><p class="noindent" >At the moment, CDE can compute the adjoint of an operator with one argument
(Section <a 
href="manualse133.html#x194-45500020.10.8">20.10.8<!--tex4ht:ref: cdesec:linadj --></a>).
</p><!--l. 636--><p class="noindent" >Now, consider two operators \(\Delta \colon P\to Q\) and \(\nabla \colon Q\to R\). Then the composition \(\nabla \circ \Delta \) is again a \(\mathcal {C}\)-diﬀerential
operator. In particular, if \[ \Delta (p) = (\sum _{\sigma , i}a^{\sigma j}_i D_\sigma p^i),\quad \nabla (q) = (\sum _{\tau , j}b^{\tau k}_j D_\tau q^j), \] then \[ \nabla \circ \Delta (p) = (\sum _{\tau , j}b^{\tau k}_j D_\tau (\sum _{\sigma , i}a^{\sigma j}_i D_\sigma p^i)) \] This operation can be generalized to \(\mathcal {C}\)-diﬀerential
operators with \(h\) arguments.
</p><!--l. 651--><p class="noindent" >There is another important operation between \(\mathcal {C}\)-diﬀerential operators with \(h\) arguments: the
<span 
class="ptmri8t-x-x-109">Schouten bracket </span><span class="cite">[<a 
href="manualap2.html#XKrasilshchik:99">BCD\(^{+}\)99</a>]</span>. We will discuss it in next Subsection, in the context of
another formalism, where it takes an easier form <span class="cite">[<a 
href="manualap2.html#XKerstenKrasilshchikVerboretsky:2004">KKV04</a>]</span>.
</p><!--l. 655--><p class="noindent" >
</p>
                                                                     

                                                                     
<h4 class="subsectionHead"><span class="titlemark">20.10.6    </span> <a 
 id="x194-45300020.10.6"></a>\(\mathcal {C}\)-diﬀerential operators as superfunctions</h4>
<!--l. 658--><p class="noindent" >In the papers <span class="cite">[<a 
href="manualap2.html#XIgoninVerbovetskyVitolo:2004">IVV04</a>, <a 
href="manualap2.html#XKerstenKrasilshchikVerboretsky:2004">KKV04</a>]</span> (and independently in <span class="cite">[<a 
href="manualap2.html#XGetzler:2002">Get02</a>]</span>) a scheme for dealing
with (skew-adjoint) variational multivectors was devised. The idea was that operators of
the type \eqref {eq:7} could be represented by homogeneous vector superfunctions on a
supermanifold, where odd coordinates \(q^i_\sigma \) would correspond to total derivatives
\(D_\sigma \varphi ^i\).
</p><!--l. 664--><p class="noindent" >The isomorphism between the two languages is given by \begin {equation}  \label {eq:13} \begin {split} \Big (\sum _{\sigma _1,\ldots ,\sigma _h, i_1,\ldots , i_h}a^{\sigma _1,\ldots ,\sigma _h,\ j}_{i_1\cdots i_h} D_{\sigma _1} \varphi _1^{i_1}\cdots D_{\sigma _h}\varphi _h^{i_h}\Big ) \\ \longrightarrow \Big (\sum _{\sigma _1,\ldots ,\sigma _h, i_1,\ldots , i_h}a^{\sigma _1,\ldots ,\sigma _h,\ j}_{i_1\cdots i_h} q^{i_1}_{\sigma _1} \cdots q^{i_h}_{\sigma _h}\Big ) \end {split}  \end {equation}
where \(q^i_\sigma \) is the derivative of an odd dependent variable (and an odd variable itself).
</p><!--l. 681--><p class="noindent" >A superfunction in CDE must be declared as follows: <a 
 id="dx194-453001"></a> <a 
 id="operator:MK_SUPERFUN"></a>
                                                                     

                                                                     
</p>
<pre class="verbatim" id="verbatim-802">
mk_superfun(sfname,num_arg,length_arg,length_target)
</pre>
<!--l. 686--><p class="nopar" > where </p>
     <ul class="itemize1">
     <li class="itemize">
     <!--l. 689--><p class="noindent" ><span 
class="pcrr8t-x-x-109">sfname </span>is the name of the superfunction;
     </p></li>
     <li class="itemize">
     <!--l. 690--><p class="noindent" ><span 
class="pcrr8t-x-x-109">num_arg </span>is the degree of the superfunction <span 
class="ptmri8t-x-x-109">eg</span> \(h\) in \eqref {eq:13};
     </p></li>
     <li class="itemize">
     <!--l. 692--><p class="noindent" ><span 
class="pcrr8t-x-x-109">length_arg </span>is the list of lengths of the arguments: <span 
class="ptmri8t-x-x-109">eg </span>the length of the
     single argument of \(\Delta \) \eqref {eq:4} is \(k\), and the corresponding list is <span 
class="pcrr8t-x-x-109">{k}</span>, while in \eqref {eq:7} one
     needs  a  list  of  \(k\)  items  <span 
class="pcrr8t-x-x-109">{k_1,</span><span 
class="pcrr8t-x-x-109">…,k_h}</span>,  each  corresponding  to  number  of
     components of the vector functions to which the operator is applied;
     </p></li>
     <li class="itemize">
     <!--l. 697--><p class="noindent" ><span 
class="pcrr8t-x-x-109">length_target </span>is the numer of components of the image vector function.</p></li></ul>
<!--l. 700--><p class="noindent" >The above parameters of the operator <span 
class="pcrr8t-x-x-109">opname </span>are stored in the property
list<span class="footnote-mark"><a 
href="manual196.html#fn23x20"><sup class="textsuperscript">23</sup></a></span><a 
 id="x194-453002f23"></a> 
of the identiﬁer <span 
class="pcrr8t-x-x-109">opname</span>. This means that if one would like to know how many
arguments has the operator <span 
class="pcrr8t-x-x-109">opname </span>the answer will be the output of the command
                                                                     

                                                                     
</p>
<pre class="verbatim" id="verbatim-803">
get(’cdnarg,cdiff_op);
</pre>
<!--l. 707--><p class="nopar" > and the same for the other parameters.
</p><!--l. 710--><p class="noindent" >The syntax for one component of the superfunction <span 
class="pcrr8t-x-x-109">sfname </span>is
                                                                     

                                                                     
</p>
<pre class="verbatim" id="verbatim-804">
  sfname(j)
</pre>
<!--l. 713--><p class="nopar" >
</p><!--l. 715--><p class="noindent" >CDE is able to deal with \(\mathcal {C}\)-diﬀerential operators in both formalisms, and provides
conversion utilities: <a 
 id="dx194-453003"></a> <a 
 id="dx194-453004"></a> <a 
 id="operator:CONV_CDIFF2SUPERFUN"></a> <a 
 id="operator:CONV_SUPERFUN2CDIFF"></a> </p>
     <ul class="itemize1">
     <li class="itemize">
     <!--l. 722--><p class="noindent" ><span 
class="pcrr8t-x-x-109">conv_cdiff2superfun(cdop,superfun)</span>
     </p></li>
     <li class="itemize">
     <!--l. 723--><p class="noindent" ><span 
class="pcrr8t-x-x-109">conv_superfun2cdiff(superfun,cdop)</span></p></li></ul>
<!--l. 725--><p class="noindent" >where in the ﬁrst case a \(\mathcal {C}\)-diﬀerential operator <span 
class="pcrr8t-x-x-109">cdop </span>is converted into a vector
superfunction <span 
class="pcrr8t-x-x-109">superfun </span>with the same properties, and conversely.
</p>
<h4 class="subsectionHead"><span class="titlemark">20.10.7    </span> <a 
 id="x194-45400020.10.7"></a>The Schouten bracket</h4>
<!--l. 732--><p class="noindent" >We are interested in the operation of Schouten bracket between <span 
class="ptmri8t-x-x-109">variational multivectors</span>
<span class="cite">[<a 
href="manualap2.html#XIgoninVerbovetskyVitolo:2004">IVV04</a>]</span>. These are diﬀerential operators with \(h\) arguments in \(\varkappa \) with values in densities,
and whose image is deﬁned up to total divergencies: \begin {multline}  \label {eq:16} \Delta \colon \varkappa \times \cdots \times \varkappa \to \\ \{J^r(n,m) \to \lambda ^nT^*\mathbb {R^n}\}/ \bar {d}(\{J^r(n,m) \to \lambda ^{n-1} T^*\mathbb {R^n}\})  \end {multline}
It is known <span class="cite">[<a 
href="manualap2.html#XGetzler:2002">Get02</a>, <a 
href="manualap2.html#XKerstenKrasilshchikVerboretsky:2004">KKV04</a>]</span> that the Schouten bracket between two variational
multivectors \(A_1\), \(A_2\) can be computed in terms of their corresponding superfunction by the
formula \begin {equation} \relax \expandafter \ifx \csname cur:th\endcsname \relax \expandafter \:label \else \expandafter \l:bel \fi {eq:11} [A_1,A_2] = \Big [\fd {A_1}{u^j}\fd {A_2}{p_j} + \fd {A_2}{u^j}\fd {A_1}{p_j}\Big ]  \end {equation}
where \(\fd {}{u^i}\), \(\fd {}{p_j}\) are the variational derivatives and the square brackets at the right-hand side
should be understood as the equivalence class up to total divergencies.
</p><!--l. 753--><p class="noindent" >If the operators \(A_1\), \(A_2\) are compatible, <span 
class="ptmri8t-x-x-109">ie</span> \([A_1,A_2]=0\), the expression \eqref {eq:11} must be a total derivative. This
means that: \begin {equation}  \label {eq:14} [A_1,A_2] = 0 \quad \Leftrightarrow \quad \mathcal {E}\left (\fd {A_1}{u^j}\fd {A_2}{p_j} + \fd {A_2}{u^j}\fd {A_1}{p_j}\right )=0.  \end {equation}
</p><!--l. 762--><p class="noindent" >If \(A_1\) is an \(h\)-vector and \(A_2\) is a \(k\)-vector the formula \eqref {eq:11} produces a \((h+k-1)\)-vector, or a \(\mathcal {C}\)-diﬀerential
operator with \(h+k-1\) arguments. If we would like to check that this multivector is indeed a total
divergence, we should apply the Euler operator, and check that it is zero. This procedure
is considerably simpler than the analogue formula with operators (see for example
                                                                     

                                                                     
<span class="cite">[<a 
href="manualap2.html#XKerstenKrasilshchikVerboretsky:2004">KKV04</a>]</span>). All this is computed by CDE:<a 
 id="dx194-454001"></a> <a 
 id="operator:SCHOUTEN_BRACKET"></a>
                                                                     

                                                                     
</p>
<pre class="verbatim" id="verbatim-805">
schouten_bracket(biv1,biv2,tv12),
</pre>
<!--l. 772--><p class="nopar" > where <span 
class="pcrr8t-x-x-109">biv1 </span>and <span 
class="pcrr8t-x-x-109">biv2 </span>are bivectors, or \(\mathcal {C}\)-diﬀerential operators with \(2\) arguments, and
<span 
class="pcrr8t-x-x-109">tv12 </span>is the result of the computation, which is a three-vector (it is automatically
declared to be a superfunction). Examples of this computation are given in
Section <a 
href="manualse133.html#x194-46500020.10.12">20.10.12<!--tex4ht:ref: cdesec:scho-brack-local --></a>.
</p><!--l. 778--><p class="noindent" >
</p>
<h4 class="subsectionHead"><span class="titlemark">20.10.8    </span> <a 
 id="x194-45500020.10.8"></a>Computing linearization and its adjoint</h4>
<!--l. 781--><p class="noindent" >Currently, CDE supports linearization of a vector function, or a \(\mathcal {C}\)-diﬀerential operator
with \(0\) arguments. The computation is performed in odd coordinates.
</p><!--l. 784--><p class="noindent" >Suppose that we would like to linearize the vector function that deﬁnes the
(dispersionless) Boussinesq equation <span class="cite">[<a 
href="manualap2.html#XKerstenKrasilshchikVerboretsky:2006">KKV06</a>]</span>: \begin {equation}  \label {cdeeq:1} \left \{ \begin {array}{l} u_t-u_xv-uv_x-\sigma v_{xxx}=0\\ v_t-u_x-vv_x=0 \end {array} \right .  \end {equation}
where \(\sigma \) is a constant. Then a jet space with independent variables <span 
class="pcrr8t-x-x-109">x,t</span>, dependent
variables <span 
class="pcrr8t-x-x-109">u,v </span>and odd variables <span 
class="ptmri8t-x-x-109">in the same number as dependent variables </span><span 
class="pcrr8t-x-x-109">p,q </span>must
be created:
                                                                     

                                                                     
</p>
<pre class="verbatim" id="verbatim-806">
indep_var:={x,t}$
dep_var:={u,v}$
odd_var:={p,q}$
total_order:=8$
cde({indep_var,dep_var,odd_var,total_order},{})$
</pre>
<!--l. 804--><p class="nopar" > The linearization of the above system and its adjoint are, respectively \begin {align*}  \ell _{\text {Bou}}&amp;= \begin {pmatrix} D_t-vD_x-v_x &amp; -u_x-uD_x-\sigma D_{xxx}\\ -D_x &amp; D_t-v_x-vD_x \end {pmatrix},\\ \ell ^*_{\text {Bou}}&amp;= \begin {pmatrix} -D_t+vD_x &amp; D_x\\ uD_x+\sigma D_{xxx} &amp; -D_t+vD_x \end {pmatrix}  \end {align*}
</p><!--l. 818--><p class="noindent" >Let us introduces the vector function whose zeros are the Boussinesq equation:
                                                                     

                                                                     
</p>
<pre class="verbatim" id="verbatim-807">
f_bou:={u_t - (u_x*v + u*v_x + sig*v_3x),
        v_t - (u_x + v*v_x)};
</pre>
<!--l. 822--><p class="nopar" > The following command assigns to the identiﬁer <span 
class="pcrr8t-x-x-109">lbou </span>the linearization \(\mathcal {C}\)-diﬀerential
operator \(\ell _{\text {Bou}}\) of the vector function <span 
class="pcrr8t-x-x-109">f_bou</span><a 
 id="dx194-455001"></a><a 
 id="operator:ELL_FUNCTION"></a>
                                                                     

                                                                     
</p>
<pre class="verbatim" id="verbatim-808">
ell_function(f_bou,lbou);
</pre>
<!--l. 829--><p class="nopar" > moreover, a superfunction <span 
class="pcrr8t-x-x-109">lbou_sf </span>is also deﬁned as the vector superfunction
corresponding to \(\ell _{\text {Bou}}\). Indeed, the following sequence of commands:
                                                                     

                                                                     
</p>
<pre class="verbatim" id="verbatim-809">
2: lbou_sf(1);

 - p*v_x + p_t - p_x*v - q*u_x - q_3x*sig - q_x*u

3: lbou_sf(2);

 - p_x - q*v_x + q_t - q_x*v
</pre>
<!--l. 841--><p class="nopar" > shows the vector superfunction corresponding to \(\ell _{\text {Bou}}\). To compute the value of the \((1,1)\)
component of the matrix \(\ell _{\text {Bou}}\) applied to an argument <span 
class="pcrr8t-x-x-109">psi </span>do
                                                                     

                                                                     
</p>
<pre class="verbatim" id="verbatim-810">
lbou(1,1,psi);
</pre>
<!--l. 847--><p class="nopar" > In order to check that the result is correct one could deﬁne the linearization as a
\(\mathcal {C}\)-diﬀerential operator and then check that the corresponding superfunctions are the
same:
                                                                     

                                                                     
</p>
<pre class="verbatim" id="verbatim-811">
mk_cdiffop(lbou2,1,{2},2);
for all phi let lbou2(1,1,phi)
              = td(phi,t) - v*td(phi,x) - v_x*phi;
for all phi let lbou2(1,2,phi)
              = - u_x*phi - u*td(phi,x) - sig*td(phi,x,3);
for all phi let lbou2(2,1,phi)
              = - td(phi,x);
for all phi let lbou2(2,2,phi)
              = td(phi,t) - v*td(phi,x) - v_x*phi;

conv_cdiff2superfun(lbou2,lbou2_sf);
lbou2_sf(1) - lbou_sf(1);
lbou2_sf(2) - lbou_sf(2);
</pre>
<!--l. 865--><p class="nopar" > the result of the two last commands must be zero.
</p><!--l. 868--><p class="noindent" >The formal adjoint of <span 
class="pcrr8t-x-x-109">lbou </span>can be computed and assigned to the identiﬁer <span 
class="pcrr8t-x-x-109">lbou_star</span>
by the command <a 
 id="dx194-455002"></a> <a 
 id="operator:ADJOINT_CDIFFOP"></a>
                                                                     

                                                                     
</p>
<pre class="verbatim" id="verbatim-812">
adjoint_cdiffop(lbou,lbou_star);
</pre>
<!--l. 874--><p class="nopar" > Again, the associated vector superfunction <span 
class="pcrr8t-x-x-109">lbou_star_sf </span>is computed, with
values
                                                                     

                                                                     
</p>
<pre class="verbatim" id="verbatim-813">
4: lbou_star_sf(1);

 - p_t + p_x*v + q_x

5: lbou_star_sf(2);

p_3x*sig + p_x*u - q_t + q_x*v
</pre>
<!--l. 885--><p class="nopar" > Again, the above operator can be checked for correctness.
</p><!--l. 888--><p class="noindent" >Once the linearization and its ajdoint are computed, in order to do computations with
symmetries and conservation laws such operator must be restricted to the corresponding
equation. This can be achieved with the following steps:
     </p><ol  class="enumerate1" >
<li 
  class="enumerate" id="x194-455004x1">
     <!--l. 893--><p class="noindent" > compute linearization of a PDE of the form \(F=0\) and its adjoint, and save them
     in the form of a vector superfunction;
     </p></li>
<li 
  class="enumerate" id="x194-455006x2">
     <!--l. 895--><p class="noindent" >start a new computation with the given <span 
class="ptmri8t-x-x-109">even </span>PDE as a constraint on the (even)
     jet space;
     </p></li>
<li 
  class="enumerate" id="x194-455008x3">
     <!--l. 897--><p class="noindent" >load the superfunctions of item <a 
href="manualse133.html#x194-455004x1">1<!--tex4ht:ref: first --></a>;
     </p></li>
<li 
  class="enumerate" id="x194-455010x4">
     <!--l. 898--><p class="noindent" >restrict them to the even PDE.</p></li></ol>
<!--l. 900--><p class="noindent" >Only the last step needs to be explained. If we are considering, <span 
class="ptmri8t-x-x-109">eg </span>the Boussinesq
equation, then \(u_t\) and its diﬀerential consequences (<span 
class="ptmri8t-x-x-109">ie </span>the principal derivatives) are not
                                                                     

                                                                     
automatically expanded to the right-hand side of the equation and its diﬀerential
consequences. At the moment this step is not fully automatic. More precisely, only
principal derivatives which appear as coeﬃcients in total derivatives can be replaced by
their expression. The lists of such derivatives with the corresponding expressions are
<span 
class="pcrr8t-x-x-109">repprincparam_der </span>and <span 
class="pcrr8t-x-x-109">repprincparam_odd </span>(see Section <a 
href="manualse133.html#x194-44900020.10.3">20.10.3<!--tex4ht:ref: cdesec:diff-equat-even --></a>). They are
in the format of REDUCE’s replacement list and can be used in let-rules. If the
linearization or its adjoint happen to depend on another principal derivative this must be
computed separately. A forthcoming release of REDUCE will automatize this
procedure.
</p><!--l. 913--><p class="noindent" >However, note that for evolutionary equations this step is trivial, as the restriction of
linearization and its adjoint on the given PDE will only aﬀect total derivatives which are
restricted by CDE to the PDE.
</p><!--l. 917--><p class="noindent" >
</p>
<h4 class="subsectionHead"><span class="titlemark">20.10.9    </span> <a 
 id="x194-45600020.10.9"></a>Higher symmetries</h4>
<!--l. 920--><p class="noindent" >In this section we show the computation of (some) higher <span class="cite">[<a 
href="manualap2.html#XKrasilshchik:99">BCD\(^{+}\)99</a>]</span> (or generalized,
<span class="cite">[<a 
href="manualap2.html#XOlver:93">Olv93</a>]</span>) symmetries of Burgers’equation \(B=u_t-u_{xx}+2uu_x=0\).
</p><!--l. 923--><p class="noindent" >We provide two ways to solve the equations for higher symmetries. The ﬁrst possibility is
to use dimensional analysis. The idea is that one can use the scale symmetries of
Burgers’equation to assign “gradings” to each variable appearing in the equation (in
other words, one can use dimensional analisys). As a consequence, one could try
diﬀerent ansatz for symmetries with polynomial generating functions. For example, it is
possible to require that they are sum of monomials of given degrees. This ansatz yields a
simpliﬁcation of the equations for symmetries, because it is possible to solve them in a
“graded” way, <span 
class="ptmri8t-x-x-109">i.e.</span>, it is possible to split them into several equations made by
the homogeneous components of the equation for symmetries with respect to
gradings.
</p><!--l. 935--><p class="noindent" >In particular, Burgers’equation translates into the following dimensional equation: \[ [u_t]=[u_{xx}],\quad [u_{xx}]=[2uu_x]. \] By
the rules \([u_z]=[u]-[z]\) and \([uv]=[u]+[v]\), and choosing \([x]=-1\), we have \([u]=1\) and \([t]=-2\). This will be used to generate the list of
homogeneous monomials of given grading to be used in the ansatz about the structure of
the generating function of the symmetries.
</p><!--l. 945--><p class="noindent" >The ﬁle for the above computation is <span 
class="pcrr8t-x-x-109">bur_hsy1.red </span>and the results of the
computation are in <span 
class="pcrr8t-x-x-109">results/bur_hsy1_res.red</span>.
</p><!--l. 949--><p class="noindent" >Another possibility to solve the equation for higher symmetries is to use a PDE solver
that is especially devoted to overdetermined systems, which is the distinguishing feature
of systems coming from the symmetry analysis of PDEs. This approach is described
below. The ﬁle for the above computation is <span 
class="pcrr8t-x-x-109">bur_hsy2.red </span>and the results of the
                                                                     

                                                                     
computation are in <span 
class="pcrr8t-x-x-109">results/bur_hsy2_res.red</span>.
</p>
<!--l. 957--><p class="noindent" ><span class="likeparagraphHead"><a 
 id="x194-45700020.10.9"></a>Setting up the jet space and the diﬀerential equation.</span>
After loading CDE:
                                                                     

                                                                     
</p>
<pre class="verbatim" id="verbatim-814">
indep_var:={x,t}$
dep_var:={u}$
deg_indep_var:={-1,-2}$
deg_dep_var:={1}$
total_order:=10$
</pre>
<!--l. 966--><p class="nopar" > Here the new lists are scale degrees: </p>
     <ul class="itemize1">
     <li class="itemize">
     <!--l. 969--><p class="noindent" ><span 
class="pcrr8t-x-x-109">deg_indep_var </span>is the list of scale degrees of the independent variables;
     </p></li>
     <li class="itemize">
     <!--l. 971--><p class="noindent" ><span 
class="pcrr8t-x-x-109">deg_dep_var </span>is the list of scale degrees of the dependent variables;</p></li></ul>
<!--l. 975--><p class="noindent" >We now give the equation and call CDE:
                                                                     

                                                                     
</p>
<pre class="verbatim" id="verbatim-815">
principal_der:={u_t}$
de:={u_2x+2*u*u_x}$
cde({indep_var,dep_var,{},total_order},
   {principal_der,de,{},{}})$
</pre>
<!--l. 981--><p class="nopar" >
</p>
<!--l. 983--><p class="noindent" ><span class="likeparagraphHead"><a 
 id="x194-45800020.10.9"></a>Solving the problem via dimensional analysis.</span>
Higher symmetries of the given equation are functions <span 
class="pcrr8t-x-x-109">sym </span>depending on parametric
coordinates up to some jet space order. We assume that they are graded polynomials of
all parametric derivatives. In practice, we generate a linear combination of graded
monomials with arbitrary coeﬃcients, then we plug it in the equation of the problem and
ﬁnd conditions on the coeﬃcients that fulﬁll the equation. To construct a good ansatz, it
is required to make several attempts with diﬀerent gradings, possibly including
independent variables, etc.. For this reason, ansatz-constructing functions are especially
verbose. In order to use such functions they must be initialized with the following
command:<a 
 id="dx194-458001"></a> <a 
 id="operator:CDE_GRADING"></a>
                                                                     

                                                                     
</p>
<pre class="verbatim" id="verbatim-816">
cde_grading(deg_indep_var,deg_dep_var,{})$
</pre>
<!--l. 998--><p class="nopar" > Note the empty list at the end; it playe a role only for computations involving odd
variables.
</p><!--l. 1002--><p class="noindent" >We need one operator <span 
class="pcrr8t-x-x-109">equ </span>whose components will be the equation of higher symmetries
and its consequences. Moreover, we need an operator <span 
class="pcrr8t-x-x-109">c </span>which will play the role of a
vector of constants, indexed by a counter <span 
class="pcrr8t-x-x-109">ctel</span>:
                                                                     

                                                                     
</p>
<pre class="verbatim" id="verbatim-817">
ctel:=0;
operator c,equ;
</pre>
<!--l. 1009--><p class="nopar" > We prepare a list of variables ordered by scale degree: <a 
 id="dx194-458002"></a> <a 
 id="operator:DER_DEG_ORDERING"></a>
                                                                     

                                                                     
</p>
<pre class="verbatim" id="verbatim-818">
l_grad_var:=der_deg_ordering(0,all_parametric_der)$
</pre>
<!--l. 1015--><p class="nopar" > The function <span 
class="pcrr8t-x-x-109">der_deg_ordering </span>is deﬁned in <span 
class="pcrr8t-x-x-109">cde.red</span>. It produces the given list
using the list <span 
class="pcrr8t-x-x-109">all_parametric_der </span>of all parametric derivatives of the given
equation up to the order <span 
class="pcrr8t-x-x-109">total_order</span>. The ﬁrst two parameters can assume the values
\(0\) or \(1\) and say that we are considering even variables and that the variables are of
parametric type.
</p><!--l. 1023--><p class="noindent" >Then, due to the fact that <span 
class="ptmri8t-x-x-109">all parametric variables have positive scale degree </span>then
we prepare the list <span 
class="pcrr8t-x-x-109">ansatz </span>of all graded monomials of scale degree from \(0\) to
\(5\)
                                                                     

                                                                     
</p>
<pre class="verbatim" id="verbatim-819">
gradmon:=graded_mon(1,5,l_grad_var)$
gradmon:={1} . gradmon$
ansatz:=for each el in gradmon join el$
</pre>
<!--l. 1030--><p class="nopar" > More precisely, the command <span 
class="pcrr8t-x-x-109">graded_mon </span>produces a list of monomials of degrees
from <span 
class="pcrr8t-x-x-109">i </span>to <span 
class="pcrr8t-x-x-109">j</span>, formed from the list of graded variables <span 
class="pcrr8t-x-x-109">l_grad_var</span>; the second
command adds the zero-degree monomial; and the last command produces a single list of
all monomials.
</p><!--l. 1036--><p class="noindent" >Finally, we assume that the higher symmetry is a graded polynomial obtained from the
above monomials (so, it is independent of \(x\) and \(t\)!)
                                                                     

                                                                     
</p>
<pre class="verbatim" id="verbatim-820">
sym:=(for each el in ansatz sum (c(ctel:=ctel+1)*el))$
</pre>
<!--l. 1040--><p class="nopar" > Next, we deﬁne the equation \(\ell _B(\mathtt {sym})=0\). Here, \(\ell _B\) stands for the linearization (Section <a 
href="manualse133.html#x194-45500020.10.8">20.10.8<!--tex4ht:ref: cdesec:linadj --></a>).
A function <span 
class="pcrr8t-x-x-109">sym </span>that fulﬁlls the above equation, on account of \(B=0\), is an higher
symmetry.
</p><!--l. 1046--><p class="noindent" >We <span 
class="ptmb8t-x-x-109">cannot </span>deﬁne the linearization as a \(\mathcal {C}\)-diﬀerential operator in this way:
                                                                     

                                                                     
</p>
<pre class="verbatim" id="verbatim-821">
bur:={u_t - (2*u*u_x+u_2x)};
ell_function(bur,lbur);
</pre>
<!--l. 1050--><p class="nopar" > as the linearization is performed with respect to parametric derivatives only! This means
that the linearization has to be computed beforehand in a free jet space, then it may be
used here.
</p><!--l. 1055--><p class="noindent" >So, the right way to go is
                                                                     

                                                                     
</p>
<pre class="verbatim" id="verbatim-822">
mk_cdiffop(lbur,1,{1},1);
for all phi let lbur(1,1,phi)
       = td(phi,t)-td(phi,x,2)-2*u*td(phi,x)-2*u_x*phi;
</pre>
<!--l. 1060--><p class="nopar" > Note that for evolutionary equations the restriction of the linearization to the
equation is equivalent to just restricting total derivatives, which is automatic in
CDE.
</p><!--l. 1065--><p class="noindent" >The equation becomes
                                                                     

                                                                     
</p>
<pre class="verbatim" id="verbatim-823">
equ 1:=lbur(1,1,sym);
</pre>
<!--l. 1068--><p class="nopar" > At this point we initialize the equation solver. This is a part of the CDIFF package
called <span 
class="pcrr8t-x-x-109">integrator.red </span>(see the original documentation inside the folder
<span 
class="pcrr8t-x-x-109">packages/cdiff </span>in REDUCE’s source code). In our case the above package will
solve a large sparse linear system of algebraic equations on the coeﬃcients of
<span 
class="pcrr8t-x-x-109">sym</span>.
</p><!--l. 1075--><p class="noindent" >The list of variables, to be passed to the equation solver:
                                                                     

                                                                     
</p>
<pre class="verbatim" id="verbatim-824">
vars:=append(indep_var,all_parametric_der);
</pre>
<!--l. 1078--><p class="nopar" > The number of initial equation(s):
                                                                     

                                                                     
</p>
<pre class="verbatim" id="verbatim-825">
tel:=1;
</pre>
<!--l. 1082--><p class="nopar" > Next command initializes the equation solver. It passes </p>
     <ul class="itemize1">
     <li class="itemize">
     <!--l. 1085--><p class="noindent" >the equation vector <span 
class="pcrr8t-x-x-109">equ </span>togeher with its length <span 
class="pcrr8t-x-x-109">tel </span>(<span 
class="ptmri8t-x-x-109">i.e.</span>, the total number
     of equations);
     </p></li>
     <li class="itemize">
     <!--l. 1087--><p class="noindent" >the  list  of  variables  with  respect  to  which  the  system  <span 
class="ptmri8t-x-x-109">must  not  </span>split  the
     equations,  <span 
class="ptmri8t-x-x-109">i.e.</span>,  variables  with  respect  to  which  the  unknowns  are  not
     polynomial. In this case this list is just \(\{\}\);
     </p></li>
     <li class="itemize">
     <!--l. 1090--><p class="noindent" >the constants’vector <span 
class="pcrr8t-x-x-109">c</span>, its length <span 
class="pcrr8t-x-x-109">ctel</span>, and the number of negative indexes
     if any; just \(\texttt {0}\) in our example;
     </p></li>
     <li class="itemize">
     <!--l. 1092--><p class="noindent" >the vector of free functions <span 
class="pcrr8t-x-x-109">f </span>that may appear in computations. Note that in
     \(\{\)<span 
class="pcrr8t-x-x-109">f,0,0</span> \(\}\) the second \(\texttt {0}\) stands for the length of the vector of free functions. In
     this example there are no free functions, but the command needs the presence
     of at least a dummy argument, <span 
class="pcrr8t-x-x-109">f </span>in this case. There is also a last zero which
     is the negative length of the vector \(f\), just as for constants.</p></li></ul>
<a 
 id="dx194-458003"></a>
<!--l. 1100--><p class="noindent" ><a 
 id="operator:INITIALIZE_EQUATIONS"></a>
                                                                     

                                                                     
</p>
<pre class="verbatim" id="verbatim-826">
initialize_equations(equ,tel,{},{c,ctel,0},{f,0,0});
</pre>
<!--l. 1103--><p class="nopar" > Run the procedure <span 
class="pcrr8t-x-x-109">splitvars_opequ </span>on the ﬁrst component of <span 
class="pcrr8t-x-x-109">equ </span>in order to
obtain equations on coeﬃciens of each monomial. <a 
 id="dx194-458004"></a> <a 
 id="operator:SPLITVARS_OPEQU"></a>
                                                                     

                                                                     
</p>
<pre class="verbatim" id="verbatim-827">
tel:=splitvars_opequ(equ,1,1,vars);
</pre>
<!--l. 1110--><p class="nopar" > Note that <span 
class="pcrr8t-x-x-109">splitvars_opequ </span>needs to know the indices of the ﬁrst and the last
equation in <span 
class="pcrr8t-x-x-109">equ</span>, and here we have only one equation as <span 
class="pcrr8t-x-x-109">equ(1)</span>. The output <span 
class="pcrr8t-x-x-109">tel </span>is
the ﬁnal number of splitted equations, starting just after the initial equation
<span 
class="pcrr8t-x-x-109">equ(1)</span>.
</p><!--l. 1116--><p class="noindent" >Next command tells the solver the total number of equations obtained after running
<span 
class="pcrr8t-x-x-109">splitvars</span>.<a 
 id="dx194-458005"></a> <a 
 id="operator:PUT_EQUATIONS_USED"></a>
                                                                     

                                                                     
</p>
<pre class="verbatim" id="verbatim-828">
put_equations_used tel;
</pre>
<!--l. 1121--><p class="nopar" > This command solves the equations for the coeﬃcients. Note that we have to skip the
initial equations! <a 
 id="dx194-458006"></a> <a 
 id="operator:INTEGRATE_EQUATION"></a>
                                                                     

                                                                     
</p>
<pre class="verbatim" id="verbatim-829">
for i:=2:tel do integrate_equation i;
</pre>
<!--l. 1128--><p class="nopar" >
</p><!--l. 1130--><p class="noindent" >The output is written in the result ﬁle by the commands
                                                                     

                                                                     
</p>
<pre class="verbatim" id="verbatim-830">
off echo$
off nat$
out &#x003C;&#x003C;resname&#x003E;&#x003E;;
sym:=sym;
write &#x0022;;end;&#x0022;;
shut &#x003C;&#x003C;resname&#x003E;&#x003E;;
on nat$
on echo$
</pre>
<!--l. 1140--><p class="nopar" > The command <span 
class="pcrr8t-x-x-109">off nat </span>turns oﬀ writing in natural notation; results in this
form are better only for visualization, not for writing or for input into another
computation. The command <span 
class="pcrr8t-x-x-109">«resname» </span>forces the evaluation of the variable
<span 
class="pcrr8t-x-x-109">resname </span>to its string value. The commands <span 
class="pcrr8t-x-x-109">out </span>and <span 
class="pcrr8t-x-x-109">shut </span>are for ﬁle opening
and closing. The command <span 
class="pcrr8t-x-x-109">sym:=sym </span>is evaluated only on the right-hand
side.
</p><!--l. 1148--><p class="noindent" >One more example ﬁle is available; it concerns higher symmetries of the KdV equation.
In order to deal with symmetries explicitely depending on \(x\) and \(t\) it is possible to
use REDUCE and CDE commands in order to have <span 
class="pcrr8t-x-x-109">sym = x*</span>(something
of degree 3)  <span 
class="pcrr8t-x-x-109">+ t*</span>(something of degree 5) + (something of degree 2); this
yields scale symmetries. Or we could use <span 
class="pcrr8t-x-x-109">sym = x*</span>(something of degree 1)
<span 
class="pcrr8t-x-x-109">+ t*</span>(something of degree 3) + (something of degree 0); this yields Galilean
boosts.
</p>
<!--l. 1157--><p class="noindent" ><span class="likeparagraphHead"><a 
 id="x194-45900020.10.9"></a>Solving the problem using CRACK.</span>
CRACK is a PDE solver which is devoted mostly to the solution of overdetermined PDE
systems <span class="cite">[<a 
href="manualap2.html#XBrand:95">BW95</a>, <a 
href="manualap2.html#XWolfBrand:CRACK">WB</a>]</span>. Several mathematical problems have been solved by the help of
CRACK, like ﬁnding symmetries <span class="cite">[<a 
href="manualap2.html#XWolf:APPLYSYM">Wol95</a>, <a 
href="manualap2.html#XBrand:92">BW92</a>]</span> and conservation laws <span class="cite">[<a 
href="manualap2.html#XWolf:99d">Wol02</a>]</span>. The
aim of CDE is to provide a tool for computations with total derivatives, but it can be used
to compute symmetries too. In this subsection we show how to interface CDE with
CRACK in order to ﬁnd higher (or generalized) symmetries for the Burgers’equation. To
do that, after loading CDE and introducing the equation, we deﬁne the linearization of
the equation <span 
class="pcrr8t-x-x-109">lbur</span>.
</p><!--l. 1168--><p class="noindent" >We introduce the new unknown function ‘<span 
class="pcrr8t-x-x-109">ansatz</span>’. We assume that the function
                                                                     

                                                                     
depends on parametric variables of order not higher than \(3\). The variables are selected by
the function <span 
class="pcrr8t-x-x-109">selectvars </span>of CDE as follows:
                                                                     

                                                                     
</p>
<pre class="verbatim" id="verbatim-831">
even_vars:=for i:=0:3 join
          selectvars(0,i,dep_var,all_parametric_der)$
</pre>
<!--l. 1174--><p class="nopar" > <a 
 id="dx194-459001"></a> In the arguments of <span 
class="pcrr8t-x-x-109">selectvars</span>, <span 
class="pcrr8t-x-x-109">0 </span>means that we want even variables, <span 
class="pcrr8t-x-x-109">i </span>stands for
the order of variables, <span 
class="pcrr8t-x-x-109">dep_var </span>stands for the dependent variables to be selected by the
command (here we use all dependent variables), <span 
class="pcrr8t-x-x-109">all_parametric_der </span>is the set of
variables where the function will extract the variables with the required properties. In the
current example we wish to get all higher symmetries depending on parametric variables
of order not higher than \(3\).
</p><!--l. 1184--><p class="noindent" >The dependency of <span 
class="pcrr8t-x-x-109">ansatz </span>from the variables is given with the standard REDUCE
command <span 
class="pcrr8t-x-x-109">depend</span>:
                                                                     

                                                                     
</p>
<pre class="verbatim" id="verbatim-832">
for each el in even_vars do depend(ansatz,el)$
</pre>
<!--l. 1188--><p class="nopar" > The equation to be solved is the equation <span 
class="pcrr8t-x-x-109">lbur(ansatz)=0</span>, hence we give the
command
                                                                     

                                                                     
</p>
<pre class="verbatim" id="verbatim-833">
total_eq:=lbur(1,1,ansatz)$
</pre>
<!--l. 1193--><p class="nopar" > The above command will issue an error if the list <span 
class="pcrr8t-x-x-109">{total_eq} </span>depends on the ﬂag
variable <span 
class="pcrr8t-x-x-109">letop</span>. In this case the computation has to be redone within a jet space of
higher order.
</p><!--l. 1198--><p class="noindent" >The equation <span 
class="pcrr8t-x-x-109">ell_b(ansatz)=0 </span>is polynomial with respect to the variables of order
higher than those appearing in <span 
class="pcrr8t-x-x-109">ansatz</span>. For this reason, its coeﬃcients can be put to
zero independently. This is the reason why the PDEs that determine symmetries are
overdetermined. To tell this to CRACK, we issue the command
                                                                     

                                                                     
</p>
<pre class="verbatim" id="verbatim-834">
split_vars:=diffset(all_parametric_der,even_vars)$
</pre>
<!--l. 1205--><p class="nopar" > The list <span 
class="pcrr8t-x-x-109">split_vars </span>contains variables which are in the current CDE jet space but <span 
class="ptmri8t-x-x-109">not</span>
in <span 
class="pcrr8t-x-x-109">even_vars</span>.
</p><!--l. 1209--><p class="noindent" >Then, we load the package CRACK and get results. <a 
 id="dx194-459002"></a>
                                                                     

                                                                     
</p>
<pre class="verbatim" id="verbatim-835">
load_package crack;
crack_results:=crack(total_eq,{},{ansatz},split_vars);
</pre>
<!--l. 1214--><p class="nopar" > The results are in the variable <span 
class="pcrr8t-x-x-109">crack_results</span>:
                                                                     

                                                                     
</p>
<pre class="verbatim" id="verbatim-836">
{{{},
{ansatz=(2*c_12*u_x + 2*c_13*u*u_x + c_13*u_2x
 + 6*c_8*u**2*u_x + 6*c_8*u*u_2x + 2*c_8*u_3x
 + 6*c_8*u_x**2)/2},{c_8,c_13,c_12},
{}}}$
</pre>
<!--l. 1222--><p class="nopar" > So, we have three symmetries; of course the generalized symmetry corresponds to <span 
class="pcrr8t-x-x-109">c_8</span>.
Remember to check <span 
class="ptmri8t-x-x-109">always </span>the output of CRACK to see if any of the symbols <span 
class="pcrr8t-x-x-109">c_n</span>
is indeed a free function depending on some of the variables, and not just a
constant.
</p><!--l. 1229--><p class="noindent" >
</p>
<h4 class="subsectionHead"><span class="titlemark">20.10.10    </span> <a 
 id="x194-46000020.10.10"></a>Local conservation laws</h4>
<!--l. 1232--><p class="noindent" >In this section we will ﬁnd (some) local conservation laws for the KdV equation \(F=u_t-u_{xxx}+uu_x=0\).
Concretely, we have to ﬁnd non-trivial \(1\)-forms \(f=f_xdx+f_tdt\) on \(F=0\) such that \(\bar d f=0\) on \(F=0\). “Triviality” of
conservation laws is a delicate matter, for which we invite the reader to have a look in
<span class="cite">[<a 
href="manualap2.html#XKrasilshchik:99">BCD\(^{+}\)99</a>]</span>.
</p><!--l. 1238--><p class="noindent" >The ﬁles containing this example are <span 
class="pcrr8t-x-x-109">kdv_lcl1,kdv_lcl2 </span>and the corresponding
results and debug ﬁles.
</p><!--l. 1241--><p class="noindent" >We suppose that the conservation law has the form \(\omega =f_x dx+f_t dt\). Using the same <span 
class="pcrr8t-x-x-109">ansatz </span>as in the
previous example we assume
                                                                     

                                                                     
</p>
<pre class="verbatim" id="verbatim-837">
fx:=(for each el in ansatz sum (c(ctel:=ctel+1)*el))$
ft:=(for each el in ansatz sum (c(ctel:=ctel+1)*el))$
</pre>
<!--l. 1246--><p class="nopar" > Next we deﬁne the equation \(\bar d(\omega )=0\), where \(\bar d\) is the total exterior derivative restricted to the
equation.
                                                                     

                                                                     
</p>
<pre class="verbatim" id="verbatim-838">
equ 1:=td(fx,t)-td(ft,x)$
</pre>
<!--l. 1251--><p class="nopar" >
</p><!--l. 1253--><p class="noindent" >After solving the equation as in the above example we get
                                                                     

                                                                     
</p>
<pre class="verbatim" id="verbatim-839">
fx := c(3)*u_x + c(2)*u + c(1)$
ft := (2*c(8) + 2*c(3)*u*u_x + 2*c(3)*u_3x + c(2)*u**2 +
2*c(2)*u_2x)/2$
</pre>
<!--l. 1258--><p class="nopar" > Unfortunately it is clear that the conservation law corresponding to <span 
class="pcrr8t-x-x-109">c(3) </span>is trivial,
because it is just the KdV equation. Here this fact is evident; how to get rid of less
evident trivialities by an ‘automatic’ mechanism? We considered this problem in the ﬁle
<span 
class="pcrr8t-x-x-109">kdv_lcl2</span>, where we solved the equation
                                                                     

                                                                     
</p>
<pre class="verbatim" id="verbatim-840">
equ 1:=fx-td(f0,x);
equ 2:=ft-td(f0,t);
</pre>
<!--l. 1267--><p class="nopar" > after having loaded the values <span 
class="pcrr8t-x-x-109">fx </span>and <span 
class="pcrr8t-x-x-109">ft </span>found by the previous program. In order to do
that we have to introduce two new counters:
                                                                     

                                                                     
</p>
<pre class="verbatim" id="verbatim-841">
operator cc,equ;
cctel:=0;
</pre>
<!--l. 1273--><p class="nopar" > We make the following ansatz on <span 
class="pcrr8t-x-x-109">f0</span>:
                                                                     

                                                                     
</p>
<pre class="verbatim" id="verbatim-842">
f0:=(for each el in ansatz sum (cc(cctel:=cctel+1)*el))$
</pre>
<!--l. 1277--><p class="nopar" > After solving the system, issuing the commands
                                                                     

                                                                     
</p>
<pre class="verbatim" id="verbatim-843">
fxnontriv := fx-td(f0,x);
ftnontriv := ft-td(f0,t);
</pre>
<!--l. 1282--><p class="nopar" > we obtain
                                                                     

                                                                     
</p>
<pre class="verbatim" id="verbatim-844">
fxnontriv := c(2)*u$
ftnontriv := (c(2)*(u**2 + 2*u_2x))/2$
</pre>
<!--l. 1287--><p class="nopar" > This mechanism can be easily generalized to situations in which the conservation laws
which are found by the program are diﬃcult to treat by pen and paper. However,
we will present another approach to the computation of conservation laws in
subsection <a 
href="manualse133.html#x194-47200020.10.15">20.10.15<!--tex4ht:ref: cdesec:plebanski-equation --></a>.
</p><!--l. 1293--><p class="noindent" >
</p>
<h4 class="subsectionHead"><span class="titlemark">20.10.11    </span> <a 
 id="x194-46100020.10.11"></a>Local Hamiltonian operators</h4>
<!--l. 1296--><p class="noindent" >In this section we will show how to compute local Hamiltonian operators for
Korteweg–de Vries, Boussinesq and Kadomtsev–Petviashvili equations. It is interesting
to note that we will adopt the same computational scheme for all equations, even if the
latter is not in evolutionary form and it has more than two independent variables.
This comes from a new mathematical theory which started in <span class="cite">[<a 
href="manualap2.html#XKerstenKrasilshchikVerboretsky:2004">KKV04</a>]</span> for
evolution equations and was later extended to general diﬀerential equations in
<span class="cite">[<a 
href="manualap2.html#XKerstenKrasilshchikVerbovetskyVitolo:HSGP">KKVV09</a>]</span>.
</p>
<!--l. 1304--><p class="noindent" ><span class="likeparagraphHead"><a 
 id="x194-46200020.10.11"></a>Korteweg–de Vries equation.</span>
Here we will ﬁnd local Hamiltonian operators for the KdV equation \(u_t=u_{xxx}+uu_x\). A necessary
condition for an operator to be Hamiltonian is that it sends generating functions
(or characteristics, according with <span class="cite">[<a 
href="manualap2.html#XOlver:93">Olv93</a>]</span>) of conservation laws to higher (or
generalized) symmetries. As it is proved in <span class="cite">[<a 
href="manualap2.html#XKerstenKrasilshchikVerboretsky:2004">KKV04</a>]</span>, this amounts at solving \(\bar \ell _{KdV}(\mathtt {phi})=0\) over the
equation \[ \left \{\begin {array}{l} u_t=u_{xxx}+uu_x\\ p_t=p_{xxx}+up_x \end {array}\right . \] or, in geometric terminology, ﬁnd the shadows of symmetries on the
\(\ell ^*\)-covering of the KdV equation, with the further condition that the shadows must
be linear in the \(p\)-variables. Note that the second equation (in odd variables!)
is just the adjoint of the linearization of the KdV equation applied to an odd
variable.
</p><!--l. 1324--><p class="noindent" >The ﬁle containing this example is <span 
class="pcrr8t-x-x-109">kdv_lho1</span>.
</p><!--l. 1326--><p class="noindent" >We stress that the linearization \(\bar \ell _{KdV}(\mathtt {phi})=0\) is the equation
                                                                     

                                                                     
</p>
<pre class="verbatim" id="verbatim-845">
td(phi,t)-u*td(phi,x)-u_x*phi-td(phi,x,3)=0
</pre>
<!--l. 1330--><p class="nopar" > but the total derivatives are lifted to the \(\ell ^*\) covering, hence they contain also
derivatives with respect to \(p\)’s. We can deﬁne a linearization operator <span 
class="pcrr8t-x-x-109">lkdv </span>as
usual.
</p><!--l. 1335--><p class="noindent" >In order to produce an ansatz which is a superfunction of one odd variable (or a linear
function in odd variables) we produce two lists: the list <span 
class="pcrr8t-x-x-109">l_grad_var </span>of all even
variables collected by their gradings and a similar list <span 
class="pcrr8t-x-x-109">l_grad_odd </span>for odd
variables:
                                                                     

                                                                     
</p>
<pre class="verbatim" id="verbatim-846">
l_grad_var:=der_deg_ordering(0,all_parametric_der)$
l_grad_odd:={1} . der_deg_ordering(1,all_parametric_odd)$
gradmon:=graded_mon(1,10,l_grad_var)$
gradmon:={1} . gradmon$
</pre>
<!--l. 1344--><p class="nopar" > We need a list of graded monomials which are linear in odd variables. The function
<span 
class="pcrr8t-x-x-109">mkalllinodd </span>produces all monomials which are linear with respect to the variables
from <span 
class="pcrr8t-x-x-109">l_grad_odd</span>, have (monomial) coeﬃcients from the variables in <span 
class="pcrr8t-x-x-109">l_grad_var</span>,
and have total scale degrees from \(1\) to \(6\). Such monomials are then converted to the internal
representation of odd variables. <a 
 id="dx194-462001"></a> <a 
 id="operator:MKALLLINODD"></a>
                                                                     

                                                                     
</p>
<pre class="verbatim" id="verbatim-847">
linodd:=mkalllinodd(gradmon,l_grad_odd,1,6)$
</pre>
<!--l. 1355--><p class="nopar" > Note that all odd variables have positive scale degrees thanks to our initial choice
<span 
class="pcrr8t-x-x-109">deg_odd_var:=1;</span>. Finally, the ansatz for local Hamiltonian operators:
                                                                     

                                                                     
</p>
<pre class="verbatim" id="verbatim-848">
sym:=(for each el in linext sum (c(ctel:=ctel+1)*el))$
</pre>
<!--l. 1361--><p class="nopar" > After having set
                                                                     

                                                                     
</p>
<pre class="verbatim" id="verbatim-849">
equ 1:=lkdv(1,1,sym);
</pre>
<!--l. 1365--><p class="nopar" > and having initialized the equation solver as before, we do <span 
class="pcrr8t-x-x-109">splitext</span><a 
 id="dx194-462002"></a><a 
 id="operator:SPLITEXT_OPEQU"></a>
                                                                     

                                                                     
</p>
<pre class="verbatim" id="verbatim-850">
tel:=splitext_opequ(equ,1,1);
</pre>
<!--l. 1371--><p class="nopar" > in order to split the polynomial equation with respect to the <span 
class="pcrr8t-x-x-109">ext </span>variables, then
<span 
class="pcrr8t-x-x-109">splitvars</span>
                                                                     

                                                                     
</p>
<pre class="verbatim" id="verbatim-851">
tel2:=splitvars_opequ(equ,2,tel,vars);
</pre>
<!--l. 1376--><p class="nopar" > in order to split the resulting polynomial equation in a list of equations on the
coeﬃcients of all monomials.
</p><!--l. 1380--><p class="noindent" >Now we are ready to solve all equations:
                                                                     

                                                                     
</p>
<pre class="verbatim" id="verbatim-852">
put_equations_used tel;
for i:=2:tel do integrate_equation i;
end;
</pre>
<!--l. 1385--><p class="nopar" > Note that we want <span 
class="ptmri8t-x-x-109">all </span>equations to be solved!
</p><!--l. 1388--><p class="noindent" >The results are the two well-known Hamiltonian operators for the KdV. After integration
the function <span 
class="pcrr8t-x-x-109">sym </span>becomes
                                                                     

                                                                     
</p>
<pre class="verbatim" id="verbatim-853">
sym := (c(5)*p*u_x + 2*c(5)*p_x*u +
        3*c(5)*p_3x + 3*c(2)*p_x)/3$
</pre>
<!--l. 1393--><p class="nopar" > Of course, the results correspond to the operators </p>
<div class="center" 
>
<!--l. 1395--><p class="noindent" >
</p><!--l. 1396--><p class="noindent" >\(p_x \to D_x\),<br />
\(\displaystyle \frac {1}{3}(3p_{3x} + 2up_x + u_xp) \to \frac {1}{3}(3D_{xxx} + 2uD_{x} + u_x)\).</p></div>
<!--l. 1399--><p class="noindent" >Note that each operator is multiplied by one arbitrary real constant, <span 
class="pcrr8t-x-x-109">c(5) </span>and
<span 
class="pcrr8t-x-x-109">c(2)</span>.
</p><!--l. 1402--><p class="noindent" >The same problem can be approached using CRACK, as follows (ﬁle <span 
class="pcrr8t-x-x-109">kdv_lho2.red</span>).
An ansatz is constructed by the following instructions:
                                                                     

                                                                     
</p>
<pre class="verbatim" id="verbatim-854">
even_vars:=for i:=0:3 join
                selectvars(0,i,dep_var,all_parametric_der)$
odd_vars:=for i:=0:3 join
                selectvars(1,i,odd_var,all_parametric_odd)$
ext_vars:=replace_oddext(odd_vars)$

ctemp:=0$
ansatz:=for each el in ext_vars sum
        mkid(s,ctemp:=ctemp+1)*el$
</pre>
<!--l. 1415--><p class="nopar" > Note that we have
                                                                     

                                                                     
</p>
<pre class="verbatim" id="verbatim-855">
ansatz := p*s1 + p_2x*s3 + p_3x*s4 + p_x*s2$
</pre>
<!--l. 1419--><p class="nopar" > Indeed, we are looking for a third-order operator whose coeﬃcients depend
on variables of order not higher than \(3\). This last property has to be introduced
by
                                                                     

                                                                     
</p>
<pre class="verbatim" id="verbatim-856">
unk:=for i:=1:ctemp collect mkid(s,i)$
for each ell in unk do
 for each el in even_vars do depend ell,el$
</pre>
<!--l. 1427--><p class="nopar" > Then, we introduce the linearization (lifted on the cotangent covering)
                                                                     

                                                                     
</p>
<pre class="verbatim" id="verbatim-857">
operator ell_f$
for all sym let ell_f(sym)=
   td(sym,t) - u*td(sym,x) - u_x*sym - td(sym,x,3)$
</pre>
<!--l. 1433--><p class="nopar" > and the equation to be solved, together with the usual test that checks for the nedd to
enlarge the jet space:
                                                                     

                                                                     
</p>
<pre class="verbatim" id="verbatim-858">
total_eq:=ell_f(ansatz)$
</pre>
<!--l. 1438--><p class="nopar" > Finally, we split the above equation by collecting all coeﬃcients of odd variables:<a 
 id="dx194-462003"></a>
<a 
 id="operator:SPLITEXT_LIST"></a>
                                                                     

                                                                     
</p>
<pre class="verbatim" id="verbatim-859">
system_eq:=splitext_list({total_eq})$
</pre>
<!--l. 1444--><p class="nopar" > and we feed CRACK with the equations that consist in asking to the above coeﬃcients
to be zero:
                                                                     

                                                                     
</p>
<pre class="verbatim" id="verbatim-860">
load_package crack;
crack_results:=crack(system_eq,{},unk,
   diffset(all_parametric_der,even_vars));
</pre>
<!--l. 1451--><p class="nopar" > The results are the same as in the previous section:
                                                                     

                                                                     
</p>
<pre class="verbatim" id="verbatim-861">
crack_results := {{{},
{s4=(3*c_17)/2,s3=0,s2=c_16 + c_17*u,s1=(c_17*u_x)/2},
{c_17,c_16},
{}}}$
</pre>
<!--l. 1458--><p class="nopar" >
</p>
<!--l. 1461--><p class="noindent" ><span class="likeparagraphHead"><a 
 id="x194-46300020.10.11"></a>Boussinesq equation.</span>
There is no conceptual diﬀerence when computing for systems of PDEs with respect to
the previous computations for scalar equations. We will look for Hamiltonian structures
for the dispersionless Boussinesq equation \eqref {cdeeq:1}.
</p><!--l. 1467--><p class="noindent" >We will proceed by dimensional analysis. Gradings can be taken as \[ [t]=-2,\quad [x]=-1,\quad [v]=1,\quad [u]=2,\quad [p]=1,\quad [q]=2 \] where \(p\), \(q\) are the two
odd coordinates. We have the \(\ell ^*_{\text {Bou}}\) covering equation \[ \label {eq:12} \left \{ \begin {array}{l} -p_t+vp_x+q_x=0\\ up_x+\sigma p_{xxx}-q_t+vq_x=0\\ u_t-u_xv-uv_x-\sigma v_{xxx}=0\\ v_t-u_x-vv_x=0 \end {array} \right . \] We have to ﬁnd Hamiltonian operators
as shadows of symmetries on the above covering. At the level of source ﬁle (<span 
class="pcrr8t-x-x-109">bou_lho1</span>)
the input data is:
                                                                     

                                                                     
</p>
<pre class="verbatim" id="verbatim-862">
indep_var:={x,t}$
dep_var:={u,v}$
odd_var:={p,q}$
deg_indep_var:={-1,-2}$
deg_dep_var:={2,1}$
deg_odd_var:={1,2}$
total_order:=8$
principal_der:={u_t,v_t}$
de:={u_x*v+u*v_x+sig*v_3x,u_x+v*v_x}$
principal_odd:={p_t,q_t}$
de_odd:={v*p_x+q_x,u*p_x+sig*p_3x+v*q_x}$
</pre>
<!--l. 1499--><p class="nopar" > The ansatz for the components of the Hamiltonian operator, of scale degree between \(1\)
and \(6\), is
                                                                     

                                                                     
</p>
<pre class="verbatim" id="verbatim-863">
linodd:=mkalllinodd(gradmon,l_grad_odd,1,6)$
phi1:=(for each el in linodd sum (c(ctel:=ctel+1)*el))$
phi2:=(for each el in linodd sum (c(ctel:=ctel+1)*el))$
</pre>
<!--l. 1506--><p class="nopar" > and the equation for shadows of symmetries is (<span 
class="pcrr8t-x-x-109">lbou2 </span>is taken from Section <a 
href="manualse133.html#x194-45500020.10.8">20.10.8<!--tex4ht:ref: cdesec:linadj --></a>)
                                                                     

                                                                     
</p>
<pre class="verbatim" id="verbatim-864">
equ 1:=lbou2(1,1,phi1) + lbou2(1,2,phi2);

equ 2:=lbou2(2,1,phi1) + lbou2(2,2,phi2);
</pre>
<!--l. 1513--><p class="nopar" > After the usual procedures for decomposing polynomials we obtain three local
Hamiltonian operators:
                                                                     

                                                                     
</p>
<pre class="verbatim" id="verbatim-865">
phi1_odd := (2*c(31)*p*sig*v_3x + 2*c(31)*p*u*v_x
 + 2*c(31)*p*u_x*v + 6*c(31)*p_2x*sig*v_x
 + 4*c(31)*p_3x*sig*v + 6*c(31)*p_x*sig*v_2x
 + 4*c(31)*p_x*u*v + 2*c(31)*q*u_x + 4*c(31)*q_3x*sig
 + 4*c(31)*q_x*u + c(31)*q_x*v**2 + 2*c(16)*p*u_x
 + 4*c(16)*p_3x*sig + 4*c(16)*p_x*u
 + 2*c(16)*q_x*v + 2*c(10)*q_x)/2$

phi2_odd := (2*c(31)*p*u_x + 2*c(31)*p*v*v_x
 + 4*c(31)*p_3x*sig + 4*c(31)*p_x*u
 + c(31)*p_x*v**2 + 2*c(31)*q*v_x + 4*c(31)*q_x*v
 + 2*c(16)*p*v_x + 2*c(16)*p_x*v
 + 4*c(16)*q_x + 2*c(10)*p_x)/2$
</pre>
<!--l. 1531--><p class="nopar" >
There is a whole hierarchy of nonlocal Hamiltonian operators <span class="cite">[<a 
href="manualap2.html#XKerstenKrasilshchikVerboretsky:2004">KKV04</a>]</span>.
</p>
<!--l. 1536--><p class="noindent" ><span class="likeparagraphHead"><a 
 id="x194-46400020.10.11"></a>Kadomtsev–Petviashvili equation.</span>
There is no conceptual diﬀerence in symbolic computations of Hamiltonian operators for
PDEs in \(2\) independent variables and in more than \(2\) independent variables, regardless of the
fact that the equation at hand is written in evolutionary form. As a model example, we
consider the KP equation \begin {equation}  \label {eq:3} u_{yy}=u_{tx}-u_x^2-uu_{xx}-\frac {1}{12}u_{xxxx}.  \end {equation}
Proceeding as in the above examples we input the following data:
                                                                     

                                                                     
</p>
<pre class="verbatim" id="verbatim-866">
indep_var:={t,x,y}$
dep_var:={u}$
odd_var:={p}$
deg_indep_var:={-3,-2,-1}$
deg_dep_var:={2}$
deg_odd_var:={1}$
total_order:=6$
principal_der:={u_2y}$
de:={u_tx-u_x**2-u*u_2x-(1/12)*u_4x}$
principal_odd:={p_2y}$
de_odd:={p_tx-u*p_2x-(1/12)*p_4x}$
</pre>
<!--l. 1559--><p class="nopar" > and look for Hamiltonian operators of scale degree between \(1\) and \(5\):
                                                                     

                                                                     
</p>
<pre class="verbatim" id="verbatim-867">
linodd:=mkalllinodd(gradmon,l_grad_odd,1,5)$
phi:=(for each el in linodd sum (c(ctel:=ctel+1)*el))$
</pre>
<!--l. 1564--><p class="nopar" > After solving the equation for shadows of symmetries in the cotangent covering
                                                                     

                                                                     
</p>
<pre class="verbatim" id="verbatim-868">
equ 1:=td(phi,y,2) - td(phi,x,t) + 2*u_x*td(phi,x)
 + u_2x*phi + u*td(phi,x,2) + (1/12)*td(phi,x,4);
</pre>
<!--l. 1569--><p class="nopar" > we get the only local Hamiltonian operator
                                                                     

                                                                     
</p>
<pre class="verbatim" id="verbatim-869">
phi := c(13)*p_2x$
</pre>
<!--l. 1573--><p class="nopar" > As far as we know there are no further local Hamiltonian operators.
</p><!--l. 1576--><p class="noindent" ><span 
class="ptmb8t-x-x-109">Remark</span>: the above Hamiltonian operator is already known in an evolutionary
presentation of the KP equation <span class="cite">[<a 
href="manualap2.html#XKuperschmidt:94">Kup94</a>]</span>. Our mathematical theory of Hamiltonian
operators for general diﬀerential equations <span class="cite">[<a 
href="manualap2.html#XKerstenKrasilshchikVerbovetskyVitolo:HSGP">KKVV09</a>]</span> allows us to formulate and solve
the problem for any presentation of the KP equation. Change of coordinate formulae
could also be provided.
</p><!--l. 1585--><p class="noindent" >
</p>
<h4 class="subsectionHead"><span class="titlemark">20.10.12    </span> <a 
 id="x194-46500020.10.12"></a>Examples of Schouten bracket of local Hamiltonian operators</h4>
<!--l. 1588--><p class="noindent" >In this Section we will discuss examples of calculation of Schouten bracket in order to
check the Hamiltonian property for \(\mathcal {C}\)-diﬀerential operators and/or the compatibility of two
distinct Hamiltonian operators. This subject is treated in a much greater detail in the
recent paper <span class="cite">[<a 
href="manualap2.html#XVitolo2019">Vit19</a>]</span>, where many examples of Schouten bracket calculations with CDE
have been described.
</p><!--l. 1595--><p class="noindent" >We observe that a package that is capable to calculate the Schouten bracket of weakly
nonlocal operators (in one independent variable) is currently part of CDE, version 3.0.
Documentation for the package is being written; interested readers may contact the
author of CDE for questions.
</p><!--l. 1600--><p class="noindent" >Let \(F=0\) be a system of PDEs. Here \(F\in P\), where \(P\) is the module (in the algebraic sense) of vector
functions \(P=\{J^r(n,m) \to \mathbb {R}^k\}\).
</p><!--l. 1603--><p class="noindent" >The Hamiltonian operators which have been computed in the previous Section are
diﬀerential operators sending generating functions of conservation laws into generating
functions of symmetries for the above system of PDEs: \begin {equation}  \label {eq:15} H\colon \hat P \to \varkappa  \end {equation}
</p>
     <ul class="itemize1">
     <li class="itemize">
     <!--l. 1611--><p class="noindent" >\(\hat P=\{J^r(n,m) \to (\mathbb {R}^k)^*\otimes \wedge ^n T^*\mathbb {R}^n\}\) is the space of covector-valued densities,
     </p></li>
                                                                     

                                                                     
     <li class="itemize">
     <!--l. 1613--><p class="noindent" >\(\varkappa =\{J^r(n,m) \to \mathbb {R}^m\}\)  is  the  space  of  generalized  vector  ﬁelds  on  jets;  generating  functions  of
     higher symmetries of the system of PDEs are elements of this space.</p></li></ul>
<!--l. 1617--><p class="noindent" >As the operators are mainly used to deﬁne a bracket operation and a Lie algebra structure
on conservation laws, two properties are required: skew-adjointness \(H^* = -H\) (corresponding with
skew-symmetry of the bracket) and \([H,H]=0\) (corresponding with the Jacobi property of the
bracket).
</p><!--l. 1622--><p class="noindent" >In order to compute the two properties we proceed as follows. Skew-adjointness is
checked by computing the adjoint and verifying that the sum with the initial operator is
zero.
</p><!--l. 1626--><p class="noindent" >In the case of evolutionary equations, \(P=\varkappa \), and Hamiltonian operators \eqref {eq:15} can also be
interpreted as <span 
class="ptmri8t-x-x-109">variational bivectors, ie </span>\begin {equation}  \label {eq:17} \hat H\colon \hat \varkappa \times \hat \varkappa \to \wedge ^n T^*\mathbb {R}^n  \end {equation}
where the correspondence is given by \begin {equation}  \label {eq:18} H(\psi ) = (a^{ij\sigma }D_\sigma \psi _j) \quad \to \quad \hat H(\psi _1,\psi _2) = (a^{ij\sigma }D_\sigma \psi _{1\ j}\psi _{2\ i})  \end {equation}
</p><!--l. 1641--><p class="noindent" >In terms of the corresponding superfunctions: \[ H = a^{ik\,\sigma } p_{k\,\sigma } \quad \to \quad \hat H = a^{ik\,\sigma } p_{k\,\sigma }p_i. \] Note that the product \(p_{k\,\sigma }p_i\) is anticommutative
since \(p\)’s are odd variables.
</p><!--l. 1649--><p class="noindent" >After that a \(\mathcal {C}\)-diﬀerential operator of the type of \(H\) has been converted into a bivector it is
possible to apply the formulae \eqref {eq:11} and \eqref {eq:14} in order to compute the Schouten bracket. This is
what we will see in next section.
</p>
<!--l. 1654--><p class="noindent" ><span class="likeparagraphHead"><a 
 id="x194-46600020.10.12"></a>Bi-Hamiltonian structure of the KdV equation.</span>
We can do the above computations using KdV equation as a test case (see the ﬁle
<span 
class="pcrr8t-x-x-109">kdv_lho3.red</span>).
</p><!--l. 1659--><p class="noindent" >Let us load the above operators:
                                                                     

                                                                     
</p>
<pre class="verbatim" id="verbatim-870">
operator ham1;
for all psi1 let ham1(psi1)=td(psi1,x);
operator ham2;
for all psi2 let ham2(psi2)=
 (1/3)*u_x*psi2 + td(psi2,x,3) + (2/3)*u*td(psi2,x);
</pre>
<!--l. 1666--><p class="nopar" > We may convert the two operators into the corresponding superfunctions
                                                                     

                                                                     
</p>
<pre class="verbatim" id="verbatim-871">
conv_cdiff2superfun(ham1,sym1);
conv_cdiff2superfun(ham2,sym2);
</pre>
<!--l. 1671--><p class="nopar" > The result of the conversion is
                                                                     

                                                                     
</p>
<pre class="verbatim" id="verbatim-872">
sym1(1) := {p_x};
sym2(2) := {(1/3)*p*u_x + p_3x + (2/3)*p_x*u};
</pre>
<!--l. 1676--><p class="nopar" > Skew-adjointness is checked at once:
                                                                     

                                                                     
</p>
<pre class="verbatim" id="verbatim-873">
adjoint_cdiffop(ham1,ham1_star);
adjoint_cdiffop(ham2,ham2_star);
ham1_star_sf(1)+sym1(1);
ham2_star_sf(1)+sym2(1);
</pre>
<!--l. 1683--><p class="nopar" > and the result of the last two commands is zero.
</p><!--l. 1686--><p class="noindent" >Then we shall convert the two superfunctions into bivectors:
                                                                     

                                                                     
</p>
<pre class="verbatim" id="verbatim-874">
conv_genfun2biv(sym1_odd,biv1);
conv_genfun2biv(sym2_odd,biv2);
</pre>
<!--l. 1690--><p class="nopar" > The output is:
                                                                     

                                                                     
</p>
<pre class="verbatim" id="verbatim-875">
biv1(1) :=  - ext(p,p_x);
biv2(1) := - (1/3)*( - 3*ext(p,p_3x) - 2*ext(p,p_x)*u);
</pre>
<!--l. 1695--><p class="nopar" > Finally, the three Schouten brackets \([\hat H_i,\hat H_j]\) are computed, with \(i,j=1,2\):
                                                                     

                                                                     
</p>
<pre class="verbatim" id="verbatim-876">
schouten_bracket(biv1,biv1,sb11);
schouten_bracket(biv1,biv2,sb12);
schouten_bracket(biv2,biv2,sb22);
</pre>
<!--l. 1702--><p class="nopar" > the result are well-known lists of zeros.
</p>
<!--l. 1705--><p class="noindent" ><span class="likeparagraphHead"><a 
 id="x194-46700020.10.12"></a>Bi-Hamiltonian structure of the WDVV equation.</span>
This subsection refers to the the example ﬁle <span 
class="pcrr8t-x-x-109">wdvv_biham1.red</span>. The simplest
nontrivial case of the WDVV equations is the third-order Monge–Ampère
equation, \(f_{ttt} = f_{xxt}^2 - f_{xxx}f_{xtt}\) <span class="cite">[<a 
href="manualap2.html#XDubrovin:96">Dub96</a>]</span>. This PDE can be transformed into hydrodynamic form,
\begin {equation*}  a_t=b_x,\quad b_t=c_x,\quad c_t=(b^2-ac)_x,  \end {equation*}
via the change of variables \(a=f_{xxx}\), \(b=f_{xxt}\), \(c=f_{xtt}\). This system possesses two Hamiltonian formulations
<span class="cite">[<a 
href="manualap2.html#XFerapontov:97">FGMN97</a>]</span>: \begin {equation*}  \begin {pmatrix} a \\ b \\ c \end {pmatrix}_t =A_i \begin {pmatrix} \fd {H_i}{a}\\ \fd {H_i}{b} \\ \fd {H_i}{c} \end {pmatrix},\quad i=1,2  \end {equation*}
with the homogeneous ﬁrst-order Hamiltonian operator \[ \hat {A}_{1}=\begin {pmatrix} -\frac {3}{2}D _{x}^{{}} &amp; \frac {1}{2}D _{x}^{{}}a &amp; D _{x}^{{}}b \\ \frac {1}{2}aD _{x}^{{}} &amp; \frac {1}{2}(D _{x}^{{}}b+bD _{x}^{{}}) &amp; \frac {3}{2}cD _{x}^{{}}+c_{x} \\ bD _{x}^{{}} &amp; \frac {3}{2}D _{x}^{{}}c-c_{x} &amp; (b^{2}-ac)D _{x}^{{}}+D _{x}^{{}}(b^{2}-ac)\end {pmatrix} \]with the Hamiltonian \(H_1 = \int c \, dx\), and the
homogeneous third-order Hamiltonian operator \[ A_2= \ddx {}\left ( \begin {array}{ccc} 0 &amp; 0 &amp; \displaystyle \ddx {} \\ 0 &amp; \displaystyle \ddx {} &amp; -\displaystyle \ddx {}a \\ \displaystyle \ddx {} &amp; -a\displaystyle \ddx {} &amp; \displaystyle \ddx {}b + b\ddx {} + a \ddx {} a \end {array}\right ) \ddx {}, \] with the nonlocal Hamiltonian \[ H_2=-\int \left ( \frac {1}{2}a\left ({\ddx {}}^{-1}b\right )^2 + {\ddx {}}^{-1}b {\ddx {}}^{-1}c\right )dx. \] Both
operators are of Dubrovin–Novikov type <span class="cite">[<a 
href="manualap2.html#XDubrovinNovikov:83">DN83</a>, <a 
href="manualap2.html#XDubrovinNovikov:84">DN84</a>]</span>. This means that the operators
are homogeneous with respect to the grading \(|D_x|=1\). It follows that the operators are
form-invariant under point transformations of the dependent variables, \(u^i=u^i(\tilde u^j)\). Here and in what
follows we will use the letters \(u^i\) to denote the dependent variables \((a,b,c)\). Under such
transformations, the coeﬃcients of the operators transform as diﬀerential-geometric
objects.
</p><!--l. 1763--><p class="noindent" >The operator \(A_1\) has the general structure \[ A_1 = g_1^{ij}\ddx {} + \Gamma ^{ij}_ku^k_x \] where the covariant metric \(g_{1\,ij}\) is ﬂat, \(\Gamma ^{ij}_k = g_1^{is}\Gamma ^j_{sk}\) (here \(g_1^{ij}\) is the
inverse matrix that represent the contravariant metric induced by \(g_{1\,ij}\)), and \(\Gamma ^j_{sk}\) are the usual
Christoﬀel symbols of \(g_{1\,ij}\).
</p><!--l. 1772--><p class="noindent" >The operator \(A_2\) has the general structure \begin {equation}  A_2=\ddx {}\left (g^{ij}_2\ddx {}+c_{k}^{ij}u_{x}^{k}\right )\ddx {}, \label {casimir}  \end {equation}
where the inverse \(g_{2\,ij}\) of the leading term transforms as a covariant pseudo-Riemannian
metric. From now on we drop the subscript \(2\) for the metric of \(A_2\). It was proved in
<span class="cite">[<a 
href="manualap2.html#XFerapontov:2014">FPV14</a>]</span> that, if we set \(c_{ijk}=g_{iq}g_{jp}c_{k}^{pq}\), then \[ c_{ijk}=\frac {1}{3}(g_{ik,j}-g_{ij,k}) \] and the metric fulﬁlls the following identity:
\begin {equation}  g_{mk,n}+g_{kn,m}+g_{mn,k}=0. \label {Killing}  \end {equation}
This means that the metric is a Monge metric <span class="cite">[<a 
href="manualap2.html#XFerapontov:2014">FPV14</a>]</span>. In particular, its coeﬃcients are
quadratic in the variables \(u^i\). It is easy to input the two operators in CDE. Let us start by \(A_1\):
we may deﬁne its entries one by one as follows
                                                                     

                                                                     
</p>
<pre class="verbatim" id="verbatim-877">
operator a1;

for all psi let a1(1,1,psi) = - (3/2)*td(psi,x);
for all psi let a1(1,2,psi) = (1/2)*td(a*psi,x);
...
</pre>
<!--l. 1798--><p class="nopar" > We could also use one specialized Reduce package for the computation of
the Christoﬀel symbols, like <span 
class="pcrr8t-x-x-109">RedTen </span>or <span 
class="pcrr8t-x-x-109">GRG</span>. Assuming that the operators
<span 
class="pcrr8t-x-x-109">gamma_hi(i,j,k) </span>have been deﬁned equal to \(\Gamma ^{ij}_k\) and computed in the
system using the inverse matrix \(g_{ij}\) of the leading coeﬃcient contravariant
metric<span class="footnote-mark"><a 
href="manual197.html#fn24x20"><sup class="textsuperscript">24</sup></a></span><a 
 id="x194-467001f24"></a>  \[ g^{ij} = \begin {pmatrix} -\frac {3}{2} &amp; \frac {1}{2}a &amp; b \\ \frac {1}{2}a &amp; b &amp; \frac {3}{2}c \\ b &amp; \frac {3}{2}c &amp; 2(b^2-ac) \end {pmatrix} \]
then, provided we deﬁned a list <span 
class="pcrr8t-x-x-109">dep_var </span>of the dependent variables, we could
set
                                                                     

                                                                     
</p>
<pre class="verbatim" id="verbatim-878">
operator gamma_hi_con;
for all i,j let gamma_hi_con(i,j) =
(
 for k:=1:3 sum gamma_hi(i,j,k)*mkid(part(dep_var,k),!_x)
)$
</pre>
<!--l. 1824--><p class="nopar" > and
                                                                     

                                                                     
</p>
<pre class="verbatim" id="verbatim-879">
operator a1$
for all i,j,psi let a1(i,j,psi) =
gu1(i,j)*td(psi,x)+(for k:=1:3 sum gamma_hi_con(i,j)*psi
)$
</pre>
<!--l. 1831--><p class="nopar" >
</p><!--l. 1833--><p class="noindent" >The third order operator can be reconstructed as follows. Observe that the leading
contravariant metric is \[ g^{ij}= \begin {pmatrix} 0 &amp; 0 &amp; 1 \\ 0 &amp; 1 &amp; -a \\ 1 &amp; -a &amp; 2b+a^2 \end {pmatrix} \] Introduce the above matrix in REDUCE as <span 
class="pcrr8t-x-x-109">gu3</span>. Then
set
                                                                     

                                                                     
</p>
<pre class="verbatim" id="verbatim-880">
gu3:=gl3**(-1)$
</pre>
<!--l. 1848--><p class="nopar" > and deﬁne \(c_{ijk}\) as
                                                                     

                                                                     
</p>
<pre class="verbatim" id="verbatim-881">
operator c_lo$
for i:=1:3 do
 for j:=1:3 do
  for k:=1:3 do
  &#x003C;&#x003C;
   c_lo(i,j,k):=
    (1/3)*(df(gl3(k,i),part(dep_var,j))
    - df(gl3(j,i),part(dep_var,k)))$
  &#x003E;&#x003E;$
</pre>
<!--l. 1860--><p class="nopar" > Then deﬁne \(c^{ij}_k\)
                                                                     

                                                                     
</p>
<pre class="verbatim" id="verbatim-882">
templist:={}$
operator c_hi$
for i:=1:ncomp do
 for j:=1:ncomp do
  for k:=1:ncomp do
   c_hi(i,j,k):=
    &#x003C;&#x003C;
     templist:=
      for m:=1:ncomp join
       for n:=1:ncomp collect
        gu3(n,i)*gu3(m,j)*c_lo(m,n,k)$
     templist:=part(templist,0):=plus
    &#x003E;&#x003E;$
</pre>
<!--l. 1876--><p class="nopar" > Introduce the contracted operator
                                                                     

                                                                     
</p>
<pre class="verbatim" id="verbatim-883">
operator c_hi_con$
for i:=1:ncomp do
 for j:=1:ncomp do
  c_hi_con(i,j):=
   &#x003C;&#x003C;
    templist:=for k:=1:ncomp collect
     c_hi(i,j,k)*mkid(part(dep_var,k),!_x)$
    templist:=part(templist,0):=plus
   &#x003E;&#x003E;$
</pre>
<!--l. 1888--><p class="nopar" > Finally, deﬁne the operator \(A_2\)
                                                                     

                                                                     
</p>
<pre class="verbatim" id="verbatim-884">
operator aa2$
for all i,j,psi let aa2(i,j,psi) =
td(
gu3(i,j)*td(psi,x,2)+c_hi_con(i,j)*td(psi,x)
,x)$
</pre>
<!--l. 1896--><p class="nopar" > Now, we can test the Hamiltonian property of \(A_1\), \(A_2\) and their compatibility:
                                                                     

                                                                     
</p>
<pre class="verbatim" id="verbatim-885">
conv_cdiff2genfun(aa1,sym1)$
conv_cdiff2genfun(aa2,sym2)$

conv_genfun2biv(sym1,biv1)$
conv_genfun2biv(sym2,biv2)$

schouten_bracket(biv1,biv1,sb11);
schouten_bracket(biv1,biv2,sb12);
schouten_bracket(biv2,biv2,sb22);
</pre>
<!--l. 1909--><p class="nopar" > Needless to say, the result of the last three command is a list of zeroes.
</p><!--l. 1912--><p class="noindent" >We observe that the same software can be used to prove the bi-Hamiltonianity of a
\(6\)-component WDVV system <span class="cite">[<a 
href="manualap2.html#XPavlovVitolo:2015">PV15</a>]</span>.
</p>
<!--l. 1915--><p class="noindent" ><span class="likeparagraphHead"><a 
 id="x194-46800020.10.12"></a>Schouten bracket of multidimensional operators.</span>
The formulae \eqref {eq:11}, \eqref {eq:14} hold also in the case of multidimensional operators, <span 
class="ptmri8t-x-x-109">ie </span>operators with
total derivatives in more than one independent variables. Here we give one Hamiltonian
operator \(H\) and we give two more variational bivectors \(P_1\), \(P_2\); all operators are of
Dubrovin–Novikov type (homogeneous). We check the compatibility by computing \([H,P_1]\) and
\([H,P_2]\). Such computations are standard for the problem of computing the Hamiltonian
cohomology of \(H\).
</p><!--l. 1925--><p class="noindent" >This example has been provided by M. Casati. The ﬁle of the computation is
<span 
class="pcrr8t-x-x-109">dn2d_sb1.red</span>. The dependent variables are \(p^1\), \(p^2\).
</p><!--l. 1928--><p class="noindent" >Let us set \begin {equation}  \label {eq:19} H= \begin {pmatrix} D_x &amp; 0 \\ 0 &amp; D_y \end {pmatrix}  \end {equation}
\begin {equation}  P_1= \begin {pmatrix} P_1^{11} &amp; P_1^{12} \\ P_1^{21} &amp; P_1^{22} \end {pmatrix}  \end {equation}
where \begin {align*}  P_1^{11} = &amp; 2 \pd {g}{p^1} p^2_y D_x + \pd {g}{p^1} p^2_{xy} + \pd {g}{p^1\partial p^2} p^2_x p^2_y + \pd {g}{^2p^1} p^1_x p^2_y \\ P_1^{21}=&amp; -f D^2_x + g D_y^2 + \pd {g}{p^2} p^2_y D_y - (\pd {f}{p^1} p^1_x+2 \pd {f}{p^2} p^2_x) D_x \\ &amp; - \pd {f}{^2p^2} p^2_x p^2_x - \pd {f}{p^1\partial p^2} p^1_x p^2_x - \pd {f}{p^2} p^2_2x ; \\ P_1^{12}=&amp; f D_x^2 - g D_y^2 + \pd {f}{p^1} p^1_x D_x - \Big (\pd {g}{p^2} p^2_y + 2 \pd {g}{p^1} p^1_y\Big ) D_y \\ &amp; - \pd {g}{^2p^1} p^1_y p^1_y - \pd {g}{p^1\partial p^2} p^1_y p^2_y - \pd {g}{p^1} p^1_{2y} ; \\ P_1^{22}=&amp; 2 \pd {f}{p^2} p^1_x D_y + \pd {f}{p^2} p^1_xy + \pd {f}{p^1\partial p^2} p^1_x p^1_y + \pd {f}{^2p^2} p^1_x p^2_y ;  \end {align*}
</p><!--l. 1970--><p class="noindent" >and let \(P_2 = P_1^T\). This is implemented as follows:
                                                                     

                                                                     
</p>
<pre class="verbatim" id="verbatim-886">
mk_cdiffop(aa2,1,{2},2)$
for all psi let aa2(1,1,psi) =
 2*df(g,p1)*p2_y*td(psi,x) + df(g,p1)*p2_xy*psi
 + df(g,p1,p2)*p2_x*p2_y*psi + df(g,p1,2)*p1_x*p2_y*psi;

for all psi let aa2(1,2,psi) =
 f*td(psi,x,2) - g*td(psi,y,2) + df(f,p1)*p1_x*td(psi,x)
 - (df(g,p2)*p2_y + 2*df(g,p1)*p1_y)*td(psi,y)
 - df(g,p1,2)*p1_y*p1_y*psi - df(g,p1,p2)*p1_y*p2_y*psi
 - df(g,p1)*p1_2y*psi;

for all psi let aa2(2,1,psi) =
 - f*td(psi,x,2) + g*td(psi,y,2)
 + df(g,p2)*p2_y*td(psi,y)
 - (df(f,p1)*p1_x+2*df(f,p2)*p2_x)*td(psi,x)
 - df(f,p2,2)*p2_x*p2_x*psi - df(f,p1,p2)*p1_x*p2_x*psi
 - df(f,p2)*p2_2x*psi;

for all psi let aa2(2,2,psi) =
 2*df(f,p2)*p1_x*td(psi,y)
 + df(f,p2)*p1_xy*psi + df(f,p1,p2)*p1_x*p1_y*psi
 + df(f,p2,2)*p1_x*p2_y*psi;

mk_cdiffop(aa3,1,{2},2)$
for all psi let aa3(1,1,psi) = aa2(1,1,psi);
for all psi let aa3(1,2,psi) = aa2(2,1,psi);
for all psi let aa3(2,1,psi) = aa2(1,2,psi);
for all psi let aa3(2,2,psi) = aa2(2,2,psi);
</pre>
<!--l. 2000--><p class="nopar" > Let us check the skew-adjointness of the above bivectors:
                                                                     

                                                                     
</p>
<pre class="verbatim" id="verbatim-887">
conv_cdiff2superfun(aa1,sym1)$
conv_cdiff2superfun(aa2,sym2)$
conv_cdiff2superfun(aa3,sym3)$

adjoint_cdiffop(aa1,aa1_star);
adjoint_cdiffop(aa2,aa2_star);
adjoint_cdiffop(aa3,aa3_star);

for i:=1:2 do write sym1(i) + aa1_star_sf(i);
for i:=1:2 do write sym2(i) + aa2_star_sf(i);
for i:=1:2 do write sym3(i) + aa3_star_sf(i);
</pre>
<!--l. 2014--><p class="nopar" > Of course the last three commands produce two zeros each.
</p><!--l. 2017--><p class="noindent" >Let us compute Schouten brackets.
                                                                     

                                                                     
</p>
<pre class="verbatim" id="verbatim-888">
conv_cdiff2superfun(aa1,sym1)$
conv_cdiff2superfun(aa2,sym2)$
conv_cdiff2superfun(aa3,sym3)$

conv_genfun2biv(sym1,biv1)$
conv_genfun2biv(sym2,biv2)$
conv_genfun2biv(sym3,biv3)$

schouten_bracket(biv1,biv1,sb11);
schouten_bracket(biv1,biv2,sb12);
schouten_bracket(biv1,biv3,sb13);
</pre>
<!--l. 2030--><p class="nopar" > <span 
class="pcrr8t-x-x-109">sb11(1) </span>is trivially a list of zeros, while <span 
class="pcrr8t-x-x-109">sb12(1) </span>is nonzero and <span 
class="pcrr8t-x-x-109">sb13(1) </span>is again
zero.
</p><!--l. 2036--><p class="noindent" >More formulae are currently being implemented in the system, like symplecticity and
Nijenhuis condition for recursion operators <span class="cite">[<a 
href="manualap2.html#XKerstenKrasilshchikVerboretsky:2006">KKV06</a>]</span>. Interested readers are warmly
invited to contact R. Vitolo for questions/feature requests.
</p><!--l. 2041--><p class="noindent" >
</p>
<h4 class="subsectionHead"><span class="titlemark">20.10.13    </span> <a 
 id="x194-46900020.10.13"></a>Non-local operators</h4>
<!--l. 2044--><p class="noindent" >In this section we will show an experimental way to ﬁnd nonlocal operators. The word
‘experimental’ comes from the lack of a comprehensive mathematical theory of nonlocal
operators; in particular, it is still missing a theoretical framework for Schouten brackets
of nonlocal opeartors in the odd variable language.
</p><!--l. 2050--><p class="noindent" >In any case we will achieve the results by means of a covering of the cotangent covering.
Indeed, it can be proved that there is a \(1-1\) correspondence between (higher) symmetries of
the initial equation and conservation laws on the cotangent covering. Such conservation
laws provide new potential variables, hence a covering (see <span class="cite">[<a 
href="manualap2.html#XKrasilshchik:99">BCD\(^{+}\)99</a>]</span> for theoretical
details on coverings).
</p><!--l. 2056--><p class="noindent" >In Section <a 
href="manualse133.html#x194-47200020.10.15">20.10.15<!--tex4ht:ref: cdesec:plebanski-equation --></a> we will also discuss a procedure for ﬁnding conservation laws from
their generating functions that is of independent interest.
                                                                     

                                                                     
</p>
<!--l. 2061--><p class="noindent" ><span class="likeparagraphHead"><a 
 id="x194-47000020.10.13"></a>Non-local Hamiltonian operators for the Korteweg–de Vries equation.</span>
Here we will compute some nonlocal Hamiltonian operators for the KdV equation. The
result of the computation (without the details below) has been published in
<span class="cite">[<a 
href="manualap2.html#XKerstenKrasilshchikVerboretsky:2004">KKV04</a>]</span>.
</p><!--l. 2067--><p class="noindent" >We have to solve equations of the type <span 
class="pcrr8t-x-x-109">ddx(ct)-ddt(cx) </span>as in <a 
href="manualse133.html#x194-46000020.10.10">20.10.10<!--tex4ht:ref: cdesec:local-cons-laws --></a>. The main
diﬀerence is that we will attempt a solution on the \(\ell ^*\)-covering (see Subsection <a 
href="manualse133.html#x194-46100020.10.11">20.10.11<!--tex4ht:ref: cdesec:local-hamilt-oper --></a>).
For this reason, ﬁrst of all we have to determine covering variables with the usual
mechanism of introducing them through conservation laws, this time on the
\(\ell ^*\)-covering.
</p><!--l. 2074--><p class="noindent" >As a ﬁrst step, let us compute conservation laws on the \(\ell ^*\)-covering whose components are
linear in the \(p\)’s. This computation can be found in the ﬁle <span 
class="pcrr8t-x-x-109">kdv_nlcl1 </span>and related results
and debug ﬁles.
</p><!--l. 2078--><p class="noindent" >The conservation laws that we are looking for are in \(1-1\) correspondence with symmetries
of the initial equation <span class="cite">[<a 
href="manualap2.html#XKerstenKrasilshchikVerboretsky:2004">KKV04</a>]</span>. We will look for conservatoin laws which
correspond to Galilean boost, \(x\)-translation, \(t\)-translation at the same time. In the
case of 2 independent variables and 1 dependent variable, one could prove that
one component of such conservation laws can always be written as <span 
class="pcrr8t-x-x-109">sym*p </span>as
follows:
                                                                     

                                                                     
</p>
<pre class="verbatim" id="verbatim-889">
c1x:=(t*u_x+1)*p$ % degree 1
c2x:=u_x*p$ % degree 4
c3x:=(u*u_x+u_3x)*p$ % degree 6
</pre>
<!--l. 2088--><p class="nopar" > The second component must be found by solving an equation. To this aim we produce
the ansatz
                                                                     

                                                                     
</p>
<pre class="verbatim" id="verbatim-890">
c1t:=f1*p+f2*p_x+f3*p_2x$
% degree 6
c2t:=(for each el in linodd6 sum (c(ctel:=ctel+1)*el))$
% degree 8
c3t:=(for each el in linodd8 sum (c(ctel:=ctel+1)*el))$
</pre>
<!--l. 2097--><p class="nopar" > where we already introduced the sets <span 
class="pcrr8t-x-x-109">linodd6 </span>and <span 
class="pcrr8t-x-x-109">linodd8 </span>of \(6\)-th and \(8\)-th degree
monomials which are linear in odd variables (see the source code). For the ﬁrst
conservation law solutions of the equation
                                                                     

                                                                     
</p>
<pre class="verbatim" id="verbatim-891">
equ 1:=td(c1t,x) - td(c1x,t);
</pre>
<!--l. 2103--><p class="nopar" > are found by hand due to the presence of ‘t’ in the symmetry:
                                                                     

                                                                     
</p>
<pre class="verbatim" id="verbatim-892">
f3:=t*u_x+1$
f2:=-td(f3,x)$
f1:=u*f3+td(f3,x,2)$
</pre>
<!--l. 2109--><p class="nopar" > We also have the equations
                                                                     

                                                                     
</p>
<pre class="verbatim" id="verbatim-893">
equ 2:=td(c2t,x)-td(c2x,t);
equ 3:=td(c3t,x)-td(c3x,t);
</pre>
<!--l. 2114--><p class="nopar" > They are solved in the usual way (see the source code of the example and the results ﬁle
<span 
class="pcrr8t-x-x-109">kdv_nlcl1_res</span>).
</p><!--l. 2118--><p class="noindent" >Now, we solve the equation for shadows of nonlocal symmetries in a covering of the
\(\ell ^*\)-covering (source ﬁle <span 
class="pcrr8t-x-x-109">kdv_nlho1</span>). We can produce such a covering by introducing
three new nonlocal (potential) variables <span 
class="pcrr8t-x-x-109">ra,rb,rc</span>. We are going to look for non-local
Hamiltonian operators depending linearly on one of these variables. To this aim we
modify the odd part of the equation to include the components of the above
conservation laws as the derivatives of the new non-local variables <span 
class="pcrr8t-x-x-109">r1</span>, <span 
class="pcrr8t-x-x-109">r2</span>,
<span 
class="pcrr8t-x-x-109">r3</span>:
                                                                     

                                                                     
</p>
<pre class="verbatim" id="verbatim-894">
principal_odd:={p_t,r1_x,r1_t,r2_x,r2_t,r3_x,r3_t}$
de_odd:={u*p_x+p_3x,
p*(t*u_x + 1),
p*t*u*u_x + p*t*u_3x + p*u + p_2x*t*u_x + p_2x
 - p_x*t*u_2x,
p*u_x,
p*u*u_x + p*u_3x + p_2x*u_x - p_x*u_2x,
p*(u*u_x + u_3x),
p*u**2*u_x + 2*p*u*u_3x + 3*p*u_2x*u_x + p*u_5x
 + p_2x*u*u_x + p_2x*u_3x - p_x*u*u_2x
 - p_x*u_4x - p_x*u_x**2}$
</pre>
<!--l. 2138--><p class="nopar" > The scale degree analysis of the local Hamiltonian operators of the KdV equation leads
to the formulation of the ansatz
                                                                     

                                                                     
</p>
<pre class="verbatim" id="verbatim-895">
phi:=(for each el in linodd sum (c(ctel:=ctel+1)*el))$
</pre>
<!--l. 2143--><p class="nopar" > where <span 
class="pcrr8t-x-x-109">linext </span>is the list of graded mononials which are linear in odd variables and
have degree \(7\) (see the source ﬁle). The equation for shadows of nonlocal symmetries in
\(\ell ^*\)-covering
                                                                     

                                                                     
</p>
<pre class="verbatim" id="verbatim-896">
equ 1:=td(phi,t)-u*td(phi,x)-u_x*phi-td(phi,x,3);
</pre>
<!--l. 2149--><p class="nopar" > is solved in the usual way, obtaining (in odd variables notation):
                                                                     

                                                                     
</p>
<pre class="verbatim" id="verbatim-897">
phi := (c(5)*(4*p*u*u_x + 3*p*u_3x + 18*p_2x*u_x
 + 12*p_3x*u + 9*p_5x + 4*p_x*u**2
 + 12*p_x*u_2x - r2*u_x))/4$
</pre>
<!--l. 2155--><p class="nopar" > Higher non-local Hamiltonian operators could also be found <span class="cite">[<a 
href="manualap2.html#XKerstenKrasilshchikVerboretsky:2004">KKV04</a>]</span>. The CRACK
approach also holds for non-local computations.
</p><!--l. 2161--><p class="noindent" >
</p>
<h4 class="subsectionHead"><span class="titlemark">20.10.14    </span> <a 
 id="x194-47100020.10.14"></a>Non-local recursion operator for the Korteweg–de Vries equation.</h4>
<!--l. 2163--><p class="noindent" >Following the ideas in <span class="cite">[<a 
href="manualap2.html#XKerstenKrasilshchikVerboretsky:2004">KKV04</a>]</span>, a diﬀerential operator that sends symmetries into
symmetries can be found as a shadow of symmetry on the \(\ell \)-covering of the KdV
equation, with the further condition that the shadows must be linear in the covering
\(q\)-variables. The tangent covering of the KdV equation is \[ \left \{\begin {array}{l} u_t=u_{xxx}+uu_x\\ q_t=u_xq + uq_x + q_{xxx} \end {array}\right . \] and we have to solve the
equation \(\bar \ell _{KdV}(\mathtt {phi})=0\), where \(\bar \ell _{KdV}\) means that the linearization of the KdV equation is lifted over the
tangent covering.
</p><!--l. 2178--><p class="noindent" >The ﬁle containing this example is <span 
class="pcrr8t-x-x-109">kdv_ro1.red</span>. The example closely follows the
computational scheme presented in <span class="cite">[<a 
href="manualap2.html#XKrasilshchikVerbovetskyVitolo:SPT:2012">KVV12</a>]</span>.
</p><!--l. 2181--><p class="noindent" >Usually, recursion operators are non-local: operators of the form \(D_x^{-1}\) appear in their
expression. Geometrically we interpret this kind of operator as follows. We
introduce a conservation law on the cotangent covering of the form \[ \omega = rt\,dx + rx\, dt \] where \(rt = uq+q_{xx}\)
and \(rx = q\). It has the remarkable feature of being linear with respect to \(q\)-variables. A
non-local variable \(r\) can be introduced as a potential of \(\omega \), as \(r_x=rx\), \(r_t=rt\). A computation of
shadows of symmetries on the system of PDEs \[ \left \{\begin {array}{l} u_t=u_{xxx}+uu_x\\ q_t=u_xq + uq_x + q_{xxx}\\ r_t = uq+q_{xx}\\ r_x = q \end {array}\right . \] yields, analogously to the previous
computations,
                                                                     

                                                                     
</p>
<pre class="verbatim" id="verbatim-898">
  2*c(5)*q*u + 3*c(5)*q_2x + c(5)*r*u_x + c(2)*q.
</pre>
<!--l. 2203--><p class="nopar" > The operator \(q\) stands for the identity operator, which is (and must be!) always a solution;
the other solution corresponds to the Lenard–Magri operator \[ 3D_{xx} + 2u + u_xD_x^{-1}. \]
</p><!--l. 2211--><p class="noindent" >
</p>
<h4 class="subsectionHead"><span class="titlemark">20.10.15    </span> <a 
 id="x194-47200020.10.15"></a>Non-local Hamiltonian-recursion operators for Plebanski equation.</h4>
<!--l. 2213--><p class="noindent" >The Plebanski (or second Heavenly) equation \begin {equation}  \label {eq:102} F=u_{tt}u_{xx}-u_{tx}^2+u_{xz}+u_{ty}=0  \end {equation}
is Lagrangian. This means that its linearization is self-adjoint: \(\ell _F=\ell ^*_F\), so that the tangent and
cotangent covering coincide, its odd equation being \begin {equation}  \label {eq:24} \ell _F(p) = p_{xz} + p_{ty} - 2u_{tx}p_{tx} + u_{2x}p_{2t} + u_{2t}p_{2x} = 0.  \end {equation}
</p><!--l. 2226--><p class="noindent" >It is not diﬃcult to realize that the above equation can be written in explicit conservative
form as \begin {multline*}  p_{xz}+p_{ty}+u_{tt}p_{xx}+u_{xx}p_{tt}-2u_{tx}p_{tx} \\ =D_x(p_z+u_{tt}p_x-u_{tx}p_t)+D_t(p_y+u_{xx}p_t-u_{tx}p_x)=0,  \end {multline*}
thus the corresponding conservation law is \begin {equation}  \label {eq:32} \upsilon (1)= (p_y+u_{xx}p_t-u_{tx}p_x)\,dx\wedge dy\wedge dz+ (u_{tx}p_t-p_z-u_{tt}p_x)\,dt\wedge dy\wedge dz.  \end {equation}
We can introduce a potential \(r\) for the above \(2\)-component conservation law. Namely, we
can assume that \begin {equation} \relax \expandafter \ifx \csname cur:th\endcsname \relax \expandafter \:label \else \expandafter \l:bel \fi {eq:101} r_x = p_y+u_{xx}p_t-u_{tx}p_x,\quad r_t = u_{tx}p_t-p_z-u_{tt}p_x.  \end {equation}
This is a new nonlocal variable for the (co)tangent covering of the Plebanski
equation. We can load the Plebanski equation together with its nonlocal variable \(r\) as
follows:
                                                                     

                                                                     
</p>
<pre class="verbatim" id="verbatim-899">
indep_var:={t,x,y,z}$
dep_var:={u}$
odd_var:={p,r}$
deg_indep_var:={-1,-1,-4,-4}$
deg_dep_var:={1}$
deg_odd_var:={1,4}$
total_order:=6$
principal_der:={u_xz}$
de:={-u_ty+u_tx**2-u_2t*u_2x}$
% rhs of the equations that define the nonlocal variable
rt:= - p_z - u_2t*p_x + u_tx*p_t$
rx:= p_y + u_2x*p_t - u_tx*p_x$
% We add conservation laws as new nonlocal odd variables;
principal_odd:={p_xz,r_x,r_t}$
%
de_odd:={-p_ty+2*u_tx*p_tx-u_2x*p_2t-u_2t*p_2x,rx,rt}$
</pre>
<!--l. 2263--><p class="nopar" > We can easily verify that the integrability condition for the new nonlocal variable
holds:
                                                                     

                                                                     
</p>
<pre class="verbatim" id="verbatim-900">
td(r,t,x) - td(r,x,t);
</pre>
<!--l. 2268--><p class="nopar" > the result is \(0\).
</p><!--l. 2271--><p class="noindent" >Now, we look for nonlocal recursion operators in the tangent covering using the new
nonlocal odd variable \(r\). We can load the equation exactly as before. We look for recursion
operators which depend on \(r\) (which has scale degree \(4\)); we produce the following ansatz
for <span 
class="pcrr8t-x-x-109">phi</span>:
                                                                     

                                                                     
</p>
<pre class="verbatim" id="verbatim-901">
linodd:=mkalllinodd(gradmon,l_grad_odd,1,4)$
phi:=(for each el in linodd sum (c(ctel:=ctel+1)*el))$
</pre>
<!--l. 2278--><p class="nopar" > then we solve the equation of shadows of symmetries:
                                                                     

                                                                     
</p>
<pre class="verbatim" id="verbatim-902">
equ 1:=td(phi,x,z)+td(phi,t,y)-2*u_tx*td(phi,t,x)
+u_2x*td(phi,t,2)+u_2t*td(phi,x,2)$
</pre>
<!--l. 2283--><p class="nopar" > The solution is
                                                                     

                                                                     
</p>
<pre class="verbatim" id="verbatim-903">
phi := c(28)*r + c(1)*p
</pre>
<!--l. 2287--><p class="nopar" > hence we obtain the identity operator \(p\) and the new nonlocal operator \(r\). It can be proved
that changing coordinates to the evolutionary presentation yields the local operator
(which has a much more complex expression than the identity operator) and one of the
nonlocal operators of <span class="cite">[<a 
href="manualap2.html#XNeyziNutkuSheftel:JPA:2005">NNS05</a>]</span>. More details on this computation can be found in
<span class="cite">[<a 
href="manualap2.html#XKrasilshchikVerbovetskyVitolo:SPT:2012">KVV12</a>]</span>.
</p><!--l. 231--><p class="noindent" >
                                                                     

                                                                     
                                                                     

                                                                     
</p><!--l. 233--><p class="noindent" ><table cellspacing="5"><tr><td class="clinks"><a 
href="../manual-lookup.php%3FUser&#32;Contributed&#32;Packages.html#manualse133.html" >Up</a></td><td class="clinks"><a 
href="manualse134.html" >Next</a></td><td class="clinks"><a 
href="manualse132.html" >Prev</a></td><td class="clinks"><a 
href="manualse132.html#tailmanualse132.html" >PrevTail</a></td><td class="clinks"><a 
href="manualse133.html" >Front</a></td></tr></table><a 
 id="tailmanualse133.html"></a>  <hr> <p style="font-family:sans-serif">Hosted by <a href="https://sourceforge.net/p/reduce-algebra/"> <img title="Download REDUCE" alt="Download REDUCE" style="vertical-align:middle" src="https://sourceforge.net/sflogo.php?type=16&amp;group_id=248416"/></a> <a href="https://www.mathjax.org"> <img title="Powered by MathJax" alt="Powered by MathJax" style="float:right" src="https://www.mathjax.org/badge/badge.gif"/></a></p></p> 
</body> 
</html>