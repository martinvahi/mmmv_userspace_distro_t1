<!DOCTYPE html> 
<html lang="en-US" xml:lang="en-US" > 
<head><title>GROEBNER: A Grobner Basis Package</title> 
<meta  charset="utf-8" /> 
<meta name="generator" content="TeX4ht (https://tug.org/tex4ht/)" /> 
<meta name="viewport" content="width=device-width,initial-scale=1" /> 
<link rel="stylesheet" type="text/css" href="manual/manual.css" /> 
<meta name="src" content="manual.tex" /> 
<script>window.MathJax = { tex: { tags: "ams", }, }; </script> 
 <script type="text/javascript" async="async" id="MathJax-script" src="../cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js"></script>  
<meta name="description" content="The REDUCE Computer Algebra System User's Manual" /> 
</head><body 
>
<header>REDUCE</header><table cellspacing="5"><tr><td class="clinks"><a 
href="manual-lookup.php%3FUser&#32;Contributed&#32;Packages.html#manualse148.html" >Up</a></td><td class="clinks"><a 
href="manual/manualse149.html" >Next</a></td><td class="clinks"><a 
href="manual/manualse147.html" >Prev</a></td><td class="clinks"><a 
href="manual/manualse147.html#tailmanualse147.html" >PrevTail</a></td><td class="clinks"><a 
href="manual-lookup.php%3FGROEBNER:.html#tailmanualse148.html">Tail</a></td></tr></table><h3 class="sectionHead"><span class="titlemark">20.25    </span> <a 
 id="x213-73800020.25"></a>GROEBNER: A Gröbner Basis Package</h3>
<a 
 id="dx213-738001"></a>
<a 
 id="dx213-738002"></a>
<!--l. 515--><p class="noindent" ><span 
class="ptmrc8t-x-x-109">G<span 
class="small-caps">R</span><span 
class="small-caps">O</span><span 
class="small-caps">E</span><span 
class="small-caps">B</span><span 
class="small-caps">N</span><span 
class="small-caps">E</span><span 
class="small-caps">R</span> </span>is a package for the computation of Gröbner Bases using the Buchberger
algorithm and related methods for polynomial ideals and modules. It can be used over a
variety of diﬀerent coeﬃcient domains, and for diﬀerent variable and term
orderings.
</p><!--l. 521--><p class="noindent" >Gröbner Bases can be used for various purposes in commutative algebra, e.g. for
elimination of variables,<a 
 id="dx213-738003"></a> converting surd expressions to implicit polynomial form,
computation of dimensions, solution of polynomial equation systems <a 
 id="dx213-738004"></a>etc. The package is
also used internally by the <span 
class="pcrr8t-x-x-109">SOLVE</span><a 
 id="dx213-738005"></a> operator.
</p><!--l. 530--><p class="noindent" >Authors: Herbert Melenk, H.M. Möller and Winfried Neun.
<a 
 id="dx213-738006"></a>
<a 
 id="dx213-738007"></a>
<a 
 id="dx213-738008"></a>
<a 
 id="dx213-738009"></a>
<a 
 id="dx213-738010"></a>
<a 
 id="dx213-738011"></a>
<a 
 id="dx213-738012"></a>
</p><!--l. 9--><p class="noindent" >Gröbner bases are a valuable tool for solving problems in connection with multivariate
polynomials, such as solving systems of algebraic equations and analyzing polynomial
ideals. For a deﬁnition of Gröbner bases, a survey of possible applications and further
references, see <span class="cite">[<a 
href="manual/manualap2.html#XBuchberger:85">Buc85</a>]</span>. Examples are given in <span class="cite">[<a 
href="manual/manualap2.html#XBoege:86">BGK86</a>]</span>, in <span class="cite">[<a 
href="manual/manualap2.html#XBuchberger:88">Buc88</a>]</span> and also in the test
ﬁle for this package.
<a 
 id="dx213-738013"></a>
<a 
 id="dx213-738014"></a>
</p><!--l. 17--><p class="noindent" >The <span 
class="ptmrc8t-x-x-109">G<span 
class="small-caps">R</span><span 
class="small-caps">O</span><span 
class="small-caps">E</span><span 
class="small-caps">B</span><span 
class="small-caps">N</span><span 
class="small-caps">E</span><span 
class="small-caps">R</span> </span>package calculates Gröbner bases using the Buchberger algorithm. It
can be used over a variety of diﬀerent coeﬃcient domains, and for diﬀerent variable and
term orderings.
</p><!--l. 21--><p class="noindent" >The current version of the package uses parts of a previous version, written by R.
Gebauer, A.C. Hearn, H. Kredel and H. M. Möller. The algorithms implemented
in the current version are documented in <span class="cite">[<a 
href="manual/manualap2.html#XFaugere:93">FGLM93</a>]</span>, <span class="cite">[<a 
href="manual/manualap2.html#XGebauer:88">GM88</a>]</span>, <span class="cite">[<a 
href="manual/manualap2.html#XKredel:88a">KW88</a>]</span> and
<span class="cite">[<a 
href="manual/manualap2.html#XGiovini:91">GMN\(^{+}\)91</a>]</span>. The operator <span 
class="pcrr8t-x-x-109">saturation </span>has been implemented in July 2000 (Herbert
Melenk).
                                                                     

                                                                     
</p><!--l. 28--><p class="noindent" >
</p>
<h4 class="subsectionHead"><span class="titlemark">20.25.1    </span> <a 
 id="x213-73900020.25.1"></a>Background</h4>
<!--l. 30--><p class="noindent" >
</p>
<h5 class="subsubsectionHead"><a 
 id="x213-74000020.25.1"></a>Variables, Domains and Polynomials</h5>
<!--l. 32--><p class="noindent" >The various functions of the <span 
class="ptmrc8t-x-x-109">G<span 
class="small-caps">R</span><span 
class="small-caps">O</span><span 
class="small-caps">E</span><span 
class="small-caps">B</span><span 
class="small-caps">N</span><span 
class="small-caps">E</span><span 
class="small-caps">R</span> </span>package manipulate equations and/or
polynomials; equations are internally transformed into polynomials by forming the
diﬀerence of left-hand side and right-hand side, if equations are given.
</p><!--l. 37--><p class="noindent" >All manipulations take place in a ring of polynomials in some variables \(x1, \ldots , xn\) over a
coeﬃcient domain \(d\): \[ d [x1,\ldots , xn], \] where \(d\) is a ﬁeld or at least a ring without zero divisors. The set of
variables \(x1,\ldots ,xn\) can be given explicitly by the user or it is extracted automatically from the
input expressions.
</p><!--l. 45--><p class="noindent" >All REDUCE kernels can play the role of “variables” in this context; examples
are
                                                                     

                                                                     
</p>
<pre class="verbatim" id="verbatim-1139">
x y z22 sin(alpha) cos(alpha) c(1,2,3) c(1,3,2) farina4711
</pre>
<!--l. 51--><p class="nopar" >
</p><!--l. 54--><p class="noindent" >The domain \(d\) is the current REDUCE domain with those kernels adjoined that are not
members of the list of variables. So the elements of \(d\) may be complicated polynomials
themselves over kernels not in the list of variables; if, however, the variables are
extracted automatically from the input expressions, \(d\) is identical with the current
REDUCE domain. It is useful to regard kernels not being members of the list of variables
as “parameters”, e.g. </p>
<div class="center" 
>
<!--l. 61--><p class="noindent" >
</p><!--l. 62--><p class="noindent" ><span 
class="pcrr8t-x-x-109">a * x + (a - b) * y**2</span><br />
with “variables” {\(x,y\)}<br />
and “parameters” \(\;a\;\) and \(\;b\;\).</p></div>
<!--l. 67--><p class="noindent" >The exponents of <span 
class="ptmrc8t-x-x-109">G<span 
class="small-caps">R</span><span 
class="small-caps">O</span><span 
class="small-caps">E</span><span 
class="small-caps">B</span><span 
class="small-caps">N</span><span 
class="small-caps">E</span><span 
class="small-caps">R</span> </span>variables must be positive integers.
</p><!--l. 69--><p class="noindent" >A <span 
class="ptmrc8t-x-x-109">G<span 
class="small-caps">R</span><span 
class="small-caps">O</span><span 
class="small-caps">E</span><span 
class="small-caps">B</span><span 
class="small-caps">N</span><span 
class="small-caps">E</span><span 
class="small-caps">R</span> </span>variable may not occur as a parameter (or part of a parameter) of a
coeﬃcient function. This condition is tested in the beginning of the <span 
class="ptmrc8t-x-x-109">G<span 
class="small-caps">R</span><span 
class="small-caps">O</span><span 
class="small-caps">E</span><span 
class="small-caps">B</span><span 
class="small-caps">N</span><span 
class="small-caps">E</span><span 
class="small-caps">R</span></span>
calculation; if it is violated, an error message occurs (with the variable name), and the
calculation is aborted. When the <span 
class="ptmrc8t-x-x-109">G<span 
class="small-caps">R</span><span 
class="small-caps">O</span><span 
class="small-caps">E</span><span 
class="small-caps">B</span><span 
class="small-caps">N</span><span 
class="small-caps">E</span><span 
class="small-caps">R</span> </span>package is called by <span 
class="pcrr8t-x-x-109">solve</span>, the test is
switched oﬀ internally.
</p><!--l. 76--><p class="noindent" >The current version of the Buchberger algorithm has two internal modes, a ﬁeld mode
and a ring mode. In the starting phase the algorithm analyzes the domain type; if it
recognizes \(d\) as being a ring it uses the ring mode, otherwise the ﬁeld mode is needed.
Normally ﬁeld calculations occur only if all coeﬃcients are numbers and if the current
REDUCE domain is a ﬁeld (e.g. rational numbers, modular numbers modulo a
prime). In general, the ring mode is faster. When no speciﬁc REDUCE domain is
selected, the ring mode is used, even if the input formulas contain fractional
coeﬃcients: they are multiplied by their common denominators so that they
become integer polynomials. Zeroes of the denominators are included in the result
list.
                                                                     

                                                                     
</p><!--l. 89--><p class="noindent" >
</p>
<h5 class="subsubsectionHead"><a 
 id="x213-74100020.25.1"></a>Term Ordering</h5>
<!--l. 91--><p class="noindent" >In the theory of Gröbner bases, the terms of polynomials are considered as ordered.
Several order modes are available in the current package, including the basic modes: <a 
 id="dx213-741001"></a><a 
 id="dx213-741002"></a> <a 
 id="dx213-741003"></a><a 
 id="dx213-741004"></a>
<a 
 id="dx213-741005"></a><a 
 id="dx213-741006"></a>
</p>
<div class="center" 
>
<!--l. 98--><p class="noindent" >
</p><!--l. 99--><p class="noindent" >\(lex\), \(gradlex\), \(revgradlex\)</p></div>
<!--l. 102--><p class="noindent" >All orderings are based on an ordering among the variables. For each pair of variables \((a,b)\) an
order relation must be deﬁned, e.g. “\( a\gg b \)”. The greater sign \(\gg \) does not represent a numerical
relation among the variables; it can be interpreted only in terms of formula
representation: “\(a\)” will be placed in front of “\(b\)” or “\(a\)” is more complicated than
“\(b\)”.
</p><!--l. 109--><p class="noindent" >The sequence of variables constitutes this order base. So the notion of \[ \{x1,x2,x3\} \]
</p><!--l. 113--><p class="noindent" >as a list of variables at the same time means \[ x1 \gg x2 \gg x3 \] with respect to the term order.
</p><!--l. 117--><p class="noindent" >If terms (products of powers of variables) are compared with <span 
class="ptmri8t-x-x-109">lex</span>, that term is chosen
which has a greater variable or a higher degree if the greatest variable is the ﬁrst in both.
With <span 
class="ptmri8t-x-x-109">gradlex </span>the sum of all exponents (the total degree) is compared ﬁrst, and if that
does not lead to a decision, the <span 
class="ptmri8t-x-x-109">lex </span>method is taken for the ﬁnal decision. The
<span 
class="ptmri8t-x-x-109">revgradlex </span>method also compares the total degree ﬁrst, but afterward it uses
the <span 
class="ptmri8t-x-x-109">lex </span>method in the reverse direction; this is the method originally used by
Buchberger.
<a 
 id="x213-741007r1"></a>
</p><!--l. 126--><p class="noindent" ><span 
class="ptmb8t-x-x-109">Example 1 </span>with \(\{x,y,z\}\): <a 
 id="dx213-741008"></a>
</p>
<div class="center" 
>
<!--l. 128--><p class="noindent" >
</p>
                                                                     

                                                                     
<div class="tabular"> <table id="TBL-80" class="tabular" 
 
><colgroup id="TBL-80-1g"><col 
id="TBL-80-1" /><col 
id="TBL-80-2" /><col 
id="TBL-80-3" /><col 
id="TBL-80-4" /></colgroup><tr  
 style="vertical-align:baseline;" id="TBL-80-1-"><td colspan="2" style="white-space:nowrap; text-align:left;" id="TBL-80-1-1"  
class="td01"><div class="multicolumn"  style="white-space:nowrap; text-align:left;"><span 
class="ptmb8t-x-x-109">lex:</span></div></td></tr><tr  
 style="vertical-align:baseline;" id="TBL-80-2-"><td  style="white-space:nowrap; text-align:right;" id="TBL-80-2-1"  
class="td01">\(x * y**3\)</td><td  style="white-space:nowrap; text-align:left;" id="TBL-80-2-2"  
class="td11">\(\gg \)  </td><td  style="white-space:nowrap; text-align:left;" id="TBL-80-2-3"  
class="td11">\(y**48\)</td><td  style="white-space:nowrap; text-align:left;" id="TBL-80-2-4"  
class="td11">(heavier variable)                    </td>
</tr><tr  
 style="vertical-align:baseline;" id="TBL-80-3-"><td  style="white-space:nowrap; text-align:right;" id="TBL-80-3-1"  
class="td01">\(x**4 * y**2\)</td><td  style="white-space:nowrap; text-align:left;" id="TBL-80-3-2"  
class="td11">\(\gg \)  </td><td  style="white-space:nowrap; text-align:left;" id="TBL-80-3-3"  
class="td11">\(x**3 * y**10\)</td><td  style="white-space:nowrap; text-align:left;" id="TBL-80-3-4"  
class="td11">(higher degree in 1st variable)</td>
</tr><tr 
class="vspace" style="font-size:5.69054pt"><td 
>&nbsp;</td><td 
>&nbsp;</td><td 
>&nbsp;</td><td 
>&nbsp;</td></tr><tr  
 style="vertical-align:baseline;" id="TBL-80-4-"><td colspan="2" style="white-space:nowrap; text-align:left;" id="TBL-80-4-1"  
class="td01"><div class="multicolumn"  style="white-space:nowrap; text-align:left;"><span 
class="ptmb8t-x-x-109">gradlex:</span></div>
</td></tr><tr  
 style="vertical-align:baseline;" id="TBL-80-5-"><td  style="white-space:nowrap; text-align:right;" id="TBL-80-5-1"  
class="td01">\(y**3 * z**4\)</td><td  style="white-space:nowrap; text-align:left;" id="TBL-80-5-2"  
class="td11">\(\gg \)  </td><td  style="white-space:nowrap; text-align:left;" id="TBL-80-5-3"  
class="td11">\(x**3 * y**3\)</td><td  style="white-space:nowrap; text-align:left;" id="TBL-80-5-4"  
class="td11">(higher total degree)               </td>
</tr><tr  
 style="vertical-align:baseline;" id="TBL-80-6-"><td  style="white-space:nowrap; text-align:right;" id="TBL-80-6-1"  
class="td01">\(x*z\)</td><td  style="white-space:nowrap; text-align:left;" id="TBL-80-6-2"  
class="td11">\(\gg \)  </td><td  style="white-space:nowrap; text-align:left;" id="TBL-80-6-3"  
class="td11">\(y**2\)</td><td  style="white-space:nowrap; text-align:left;" id="TBL-80-6-4"  
class="td11">(equal total degree)                 </td>
</tr><tr 
class="vspace" style="font-size:5.69054pt"><td 
>&nbsp;</td><td 
>&nbsp;</td><td 
>&nbsp;</td><td 
>&nbsp;</td></tr><tr  
 style="vertical-align:baseline;" id="TBL-80-7-"><td colspan="2" style="white-space:nowrap; text-align:left;" id="TBL-80-7-1"  
class="td01"><div class="multicolumn"  style="white-space:nowrap; text-align:left;"><span 
class="ptmb8t-x-x-109">revgradlex:</span></div>
</td></tr><tr  
 style="vertical-align:baseline;" id="TBL-80-8-"><td  style="white-space:nowrap; text-align:right;" id="TBL-80-8-1"  
class="td01">\(y**3 * z**4\)</td><td  style="white-space:nowrap; text-align:left;" id="TBL-80-8-2"  
class="td11">\(\gg \)  </td><td  style="white-space:nowrap; text-align:left;" id="TBL-80-8-3"  
class="td11">\(x**3 * y**3\)</td><td  style="white-space:nowrap; text-align:left;" id="TBL-80-8-4"  
class="td11">(higher total degree)               </td>
</tr><tr  
 style="vertical-align:baseline;" id="TBL-80-9-"><td  style="white-space:nowrap; text-align:right;" id="TBL-80-9-1"  
class="td01">\(x*z\)</td><td  style="white-space:nowrap; text-align:left;" id="TBL-80-9-2"  
class="td11">\(\ll \)  </td><td  style="white-space:nowrap; text-align:left;" id="TBL-80-9-3"  
class="td11">\(y**2\)</td><td  style="white-space:nowrap; text-align:left;" id="TBL-80-9-4"  
class="td11">(equal total degree,                 </td>
</tr><tr  
 style="vertical-align:baseline;" id="TBL-80-10-"><td  style="white-space:nowrap; text-align:right;" id="TBL-80-10-1"  
class="td01"></td><td  style="white-space:nowrap; text-align:left;" id="TBL-80-10-2"  
class="td11">  </td><td  style="white-space:nowrap; text-align:left;" id="TBL-80-10-3"  
class="td11"></td><td  style="white-space:nowrap; text-align:left;" id="TBL-80-10-4"  
class="td11">so reverse order of lex)           </td>
</tr></table></div></div>
<!--l. 143--><p class="noindent" >The formal description of the term order modes is similar to <span class="cite">[<a 
href="manual/manualap2.html#XKredel:88">Kre88</a>]</span>; this description
regards only the exponents of a term, which are written as vectors of integers with \(0\) for
exponents of a variable which does not occur: \[ \begin {array}{l} (e) = (e1,\ldots , en) \;\mbox { representing }\; x1**e1 \ x2**e2 \cdots xn**en. \\ \deg (e) \; \mbox { is the sum over all elements of } \;(e) \\ (e) \gg (l) \Longleftrightarrow (e)-(l)\gg (0) = (0,\ldots ,0) \end {array} \] </p>
<div class="center" 
>
<!--l. 155--><p class="noindent" >
</p>
<div class="tabular"> <table id="TBL-81" class="tabular" 
 
><colgroup id="TBL-81-1g"><col 
id="TBL-81-1" /><col 
id="TBL-81-2" /><col 
id="TBL-81-3" /></colgroup><tr  
 style="vertical-align:baseline;" id="TBL-81-1-"><td  style="white-space:nowrap; text-align:left;" id="TBL-81-1-1"  
class="td01"><div class="multicolumn"  style="white-space:nowrap; text-align:left;"><span 
class="ptmb8t-x-x-109">lex:</span></div></td></tr><tr  
 style="vertical-align:baseline;" id="TBL-81-2-"><td  style="white-space:nowrap; text-align:right;" id="TBL-81-2-1"  
class="td01">     \((e) &gt; lex &gt; (0)\)</td><td  style="white-space:nowrap; text-align:left;" id="TBL-81-2-2"  
class="td11">\(\Longrightarrow \)</td><td  style="white-space:nowrap; text-align:left;" id="TBL-81-2-3"  
class="td11">\(e_k &gt; 0 \mbox { and } e_j =0 \mbox { for }\; j=1,\ldots , k-1\)</td>
</tr><tr 
class="vspace" style="font-size:5.69054pt"><td 
>&nbsp;</td><td 
>&nbsp;</td><td 
>&nbsp;</td></tr><tr  
 style="vertical-align:baseline;" id="TBL-81-3-"><td  style="white-space:nowrap; text-align:left;" id="TBL-81-3-1"  
class="td01"><div class="multicolumn"  style="white-space:nowrap; text-align:left;"><span 
class="ptmb8t-x-x-109">gradlex:</span></div>
</td></tr><tr  
 style="vertical-align:baseline;" id="TBL-81-4-"><td  style="white-space:nowrap; text-align:right;" id="TBL-81-4-1"  
class="td01">      \((e) &gt;gl&gt; (0)\)</td><td  style="white-space:nowrap; text-align:left;" id="TBL-81-4-2"  
class="td11">\(\Longrightarrow \)</td><td  style="white-space:nowrap; text-align:left;" id="TBL-81-4-3"  
class="td11">\(\deg (e)&gt;0 \mbox { or } (e) &gt;lex&gt; (0)\)</td>
</tr><tr 
class="vspace" style="font-size:5.69054pt"><td 
>&nbsp;</td><td 
>&nbsp;</td><td 
>&nbsp;</td></tr><tr  
 style="vertical-align:baseline;" id="TBL-81-5-"><td  style="white-space:nowrap; text-align:left;" id="TBL-81-5-1"  
class="td01"><div class="multicolumn"  style="white-space:nowrap; text-align:left;"><span 
class="ptmb8t-x-x-109">revgradlex:</span></div>
</td></tr><tr  
 style="vertical-align:baseline;" id="TBL-81-6-"><td  style="white-space:nowrap; text-align:right;" id="TBL-81-6-1"  
class="td01">      \((e) &gt;rgl&gt; (0)\)</td><td  style="white-space:nowrap; text-align:left;" id="TBL-81-6-2"  
class="td11">\(\Longrightarrow \)</td><td  style="white-space:nowrap; text-align:left;" id="TBL-81-6-3"  
class="td11">\(\deg (e)&gt;0 \mbox { or }(e) &lt;lex&lt; (0)\)</td>
</tr></table></div></div>
<!--l. 167--><p class="noindent" >Note that the <span 
class="ptmri8t-x-x-109">lex </span>ordering is identical to the standard REDUCE kernel ordering, when
<span 
class="pcrr8t-x-x-109">korder </span>is set explicitly to the sequence of variables.
<a 
 id="dx213-741009"></a>
<a 
 id="dx213-741010"></a>
</p><!--l. 172--><p class="noindent" ><span 
class="ptmri8t-x-x-109">lex </span>is the default term order mode in the <span 
class="ptmrc8t-x-x-109">G<span 
class="small-caps">R</span><span 
class="small-caps">O</span><span 
class="small-caps">E</span><span 
class="small-caps">B</span><span 
class="small-caps">N</span><span 
class="small-caps">E</span><span 
class="small-caps">R</span> </span>package.
</p><!--l. 174--><p class="noindent" >It is beyond the scope of this manual to discuss the functionality of the term order modes.
See <span class="cite">[<a 
href="manual/manualap2.html#XBuchberger:88">Buc88</a>]</span>.
</p><!--l. 177--><p class="noindent" >The list of variables is declared as an optional parameter of the <span 
class="pcrr8t-x-x-109">torder </span>statement (see
below). If this declaration is missing or if the empty list has been used, the variables are
extracted from the expressions automatically and the REDUCE system order deﬁnes
their sequence; this can be inﬂuenced by setting an explicit order via the <span 
class="pcrr8t-x-x-109">korder</span>
statement.
</p><!--l. 184--><p class="noindent" >The result of a Gröbner calculation is algebraically correct only with respect to the term
order mode and the variable sequence which was in eﬀect during the calculation. This is
important if several calls to the <span 
class="ptmrc8t-x-x-109">G<span 
class="small-caps">R</span><span 
class="small-caps">O</span><span 
class="small-caps">E</span><span 
class="small-caps">B</span><span 
class="small-caps">N</span><span 
class="small-caps">E</span><span 
class="small-caps">R</span> </span>package are done with the result of the ﬁrst
being the input of the second call. Therefore we recommend that you declare the
variable list and the order mode explicitly. Once declared it remains valid until
you enter a new <span 
class="ptmri8t-x-x-109">torder </span>statement. The operator <span 
class="ptmri8t-x-x-109">gvars </span>helps you extract the
variables from a given set of polynomials, if an automatic reordering has been
                                                                     

                                                                     
selected.
</p><!--l. 194--><p class="noindent" >
</p>
<h5 class="subsubsectionHead"><a 
 id="x213-7420001"></a>The Buchberger Algorithm</h5>
<a 
 id="dx213-742001"></a>
<!--l. 196--><p class="noindent" >The Buchberger algorithm of the package is based on <span 
class="ptmrc8t-x-x-109">G<span 
class="small-caps">E</span><span 
class="small-caps">B</span><span 
class="small-caps">A</span><span 
class="small-caps">U</span><span 
class="small-caps">E</span><span 
class="small-caps">R</span>/M</span><span 
class="ptmrc8t-x-x-109">ö</span><span 
class="ptmrc8t-x-x-109"><span 
class="small-caps">L</span><span 
class="small-caps">L</span><span 
class="small-caps">E</span><span 
class="small-caps">R</span> </span><span class="cite">[<a 
href="manual/manualap2.html#XGebauer:88">GM88</a>]</span>.
Extensions are documented in <span class="cite">[<a 
href="manual/manualap2.html#XMelenk:88">MMN88</a>]</span> and <span class="cite">[<a 
href="manual/manualap2.html#XGiovini:91">GMN\(^{+}\)91</a>]</span>.
</p><!--l. 200--><p class="noindent" >
</p>
<h4 class="subsectionHead"><span class="titlemark">20.25.2    </span> <a 
 id="x213-74300020.25.2"></a>Loading of the Package</h4>
<!--l. 201--><p class="noindent" >The following command loads the package into REDUCE (this syntax may vary
according to the implementation): </p>
<div class="center" 
>
<!--l. 203--><p class="noindent" >
</p><!--l. 204--><p class="noindent" >load_package groebner;</p></div>
<!--l. 207--><p class="noindent" >The package contains various operators, and switches for control over the reduction
process. These are discussed in the following.
</p><!--l. 210--><p class="noindent" >
</p>
<h4 class="subsectionHead"><span class="titlemark">20.25.3    </span> <a 
 id="x213-74400020.25.3"></a>The Basic Operators</h4>
<!--l. 212--><p class="noindent" >
</p>
<h5 class="subsubsectionHead"><a 
 id="x213-74500020.25.3"></a>Term Ordering Mode</h5>
<a 
 id="dx213-745001"></a>
                                                                     

                                                                     
     <dl class="description"><dt class="description">
     <!--l. 216--><p class="noindent" >
<span 
class="pcrr8t-x-x-109">torder</span><span 
class="ptmb8t-x-x-109">(</span>\(vl,m,[p_1,p_2,\ldots ]\)<span 
class="ptmb8t-x-x-109">);</span> </p></dt><dd 
class="description">
     <!--l. 216--><p class="noindent" ><br 
class="newline" /><a 
 id="operator:TORDER"></a>  where  \(vl\)  is  a  variable  list  (or  the  empty  list  if  no  variables  are  declared
     explicitly), \(m\) is the name of a term ordering mode <span 
class="ptmri8t-x-x-109">lex</span>, <span 
class="ptmri8t-x-x-109">gradlex</span>, <span 
class="ptmri8t-x-x-109">revgradlex</span>
     (or another implemented mode) and \([p_1,p_2,\ldots ]\) are additional parameters for the term
     ordering mode (not needed for the basic modes).
     </p><!--l. 225--><p class="noindent" ><span 
class="pcrr8t-x-x-109">torder </span>sets variable set and the term ordering mode. The default mode
     is  <span 
class="ptmri8t-x-x-109">lex</span>.  The  previous  description  is  returned  as  a  list  with  corresponding
     elements.  Such  a  list  can  alternatively  be  passed  as  sole  argument  to
     <span 
class="pcrr8t-x-x-109">torder</span>.
     </p><!--l. 230--><p class="noindent" >If  the  variable  list  is  empty  or  if  the  <span 
class="pcrr8t-x-x-109">torder </span>declaration  is  omitted,  the
     automatic variable extraction is activated.
<a 
 id="dx213-745002"></a>
     </p></dd><dt class="description">
     <!--l. 234--><p class="noindent" >
<span 
class="pcrr8t-x-x-109">gvars</span><span 
class="ptmb8t-x-x-109">(</span><span 
class="ptmbi8t-x-x-109">{exp</span>\(1\)<span 
class="ptmbi8t-x-x-109">, exp</span>\(2\)<span 
class="ptmbi8t-x-x-109">,</span> \(\ldots \)<span 
class="ptmbi8t-x-x-109">, exp</span>\(n\)<span 
class="ptmbi8t-x-x-109">}</span><span 
class="ptmb8t-x-x-109">);</span> </p></dt><dd 
class="description">
     <!--l. 234--><p class="noindent" ><br 
class="newline" /><a 
 id="operator:GVARS"></a> where \(\{exp1, exp2, \ldots , expn\}\) is a list of expressions or equations.
     </p><!--l. 239--><p class="noindent" ><span 
class="pcrr8t-x-x-109">gvars </span>extracts from the expressions \(\{exp1, exp2, \ldots , expn\}\) the kernels, which can play the role
     of variables for a Gröbner calculation. This can be used e.g. in a <span 
class="pcrr8t-x-x-109">torder</span>
     declaration.</p></dd></dl>
<!--l. 244--><p class="noindent" >
</p>
<h5 class="subsubsectionHead"><a 
 id="x213-74600020.25.3"></a><span 
class="ptmrc8t-x-x-109">G<span 
class="small-caps">R</span><span 
class="small-caps">O</span><span 
class="small-caps">E</span><span 
class="small-caps">B</span><span 
class="small-caps">N</span><span 
class="small-caps">E</span><span 
class="small-caps">R</span></span>: Calculation of a Gröbner Basis</h5>
<a 
 id="dx213-746001"></a>
     <dl class="description"><dt class="description">
     <!--l. 247--><p class="noindent" >
<span 
class="pcrr8t-x-x-109">groebner</span>\(\{exp1, exp2, \ldots , expm\};\) </p></dt><dd 
class="description">
     <!--l. 247--><p class="noindent" ><br 
class="newline" /><a 
 id="operator:GROEBNER"></a> where \(\{exp1, exp2, \ldots , expm\}\) is a list of expressions or equations.
     </p><!--l. 252--><p class="noindent" ><span 
class="ptmrc8t-x-x-109">G<span 
class="small-caps">R</span><span 
class="small-caps">O</span><span 
class="small-caps">E</span><span 
class="small-caps">B</span><span 
class="small-caps">N</span><span 
class="small-caps">E</span><span 
class="small-caps">R</span> </span>calculates the Gröbner basis of the given set of expressions
     with respect to the current <span 
class="pcrr8t-x-x-109">torder </span>setting.
                                                                     

                                                                     
     </p><!--l. 255--><p class="noindent" >The Gröbner basis \(\{1\}\) means that the ideal generated by the input polynomials
     is the whole polynomial ring, or equivalently, that the input polynomials have
     no zeroes in common.
     </p><!--l. 259--><p class="noindent" >As a side eﬀect, the sequence of variables is stored as a REDUCE list in the shared
     variable <a 
 id="dx213-746002"></a> <a 
 id="reserved:GVARSLAST"></a> </p>
     <div class="center" 
>
<!--l. 263--><p class="noindent" >
</p><!--l. 264--><p class="noindent" ><span 
class="pcrr8t-x-x-109">gvarslast</span>.</p></div>
     <!--l. 267--><p class="noindent" >This is important if the variables are reordered because of optimization: you must
     set them afterwards explicitly as the current variable sequence if you want to use
     the Gröbner basis in the sequel, e.g. for a <span 
class="pcrr8t-x-x-109">preduce </span>call. A basis has the property
     “Gröbner” only with respect to the variable sequences which had been active
     during its computation.</p></dd></dl>
<a 
 id="x213-746003r2"></a>
<!--l. 274--><p class="noindent" ><span 
class="ptmb8t-x-x-109">Example 2</span><a 
 id="dx213-746004"></a>
                                                                     

                                                                     
</p>
<pre class="verbatim" id="verbatim-1140">
   torder({},lex)$
   groebner{3*x**2*y + 2*x*y + y + 9*x**2 + 5*x - 3,
   2*x**3*y - x*y - y + 6*x**3 - 2*x**2 - 3*x + 3,
   x**3*y + x**2*y + 3*x**3 + 2*x**2 };

               2
     {8*x - 2*y  + 5*y + 3,

         3      2
      2*y  - 3*y  - 16*y + 21}
</pre>
<!--l. 286--><p class="nopar" >
</p><!--l. 289--><p class="noindent" >This example used the default system variable ordering, which was \(\{x,y\}\). With the other
variable ordering, a diﬀerent basis results:
                                                                     

                                                                     
</p>
<pre class="verbatim" id="verbatim-1141">
   torder({y,x},lex)$
   groebner{3*x**2*y + 2*x*y + y + 9*x**2 + 5*x - 3,
   2*x**3*y - x*y - y + 6*x**3 - 2*x**2 - 3*x + 3,
   x**3*y + x**2*y + 3*x**3 + 2*x**2 };

               2
     {2*y + 2*x  - 3*x - 6,

         3      2
      2*x  - 5*x  - 5*x}
</pre>
<!--l. 303--><p class="nopar" >
</p><!--l. 306--><p class="noindent" >Another basis yet again results with a diﬀerent term ordering:
                                                                     

                                                                     
</p>
<pre class="verbatim" id="verbatim-1142">
   torder({x,y},revgradlex)$
   groebner{3*x**2*y + 2*x*y + y + 9*x**2 + 5*x - 3,
   2*x**3*y - x*y - y + 6*x**3 - 2*x**2 - 3*x + 3,
   x**3*y + x**2*y + 3*x**3 + 2*x**2 };

    2
{2*y  - 5*y - 8*x - 3,

 y*x - y + x + 3,

    2
 2*x  + 2*y - 3*x - 6}
</pre>
<!--l. 320--><p class="nopar" >
</p><!--l. 323--><p class="noindent" >The operation of <span 
class="ptmrc8t-x-x-109">G<span 
class="small-caps">R</span><span 
class="small-caps">O</span><span 
class="small-caps">E</span><span 
class="small-caps">B</span><span 
class="small-caps">N</span><span 
class="small-caps">E</span><span 
class="small-caps">R</span> </span>can be controlled by the following switches:
<a 
 id="dx213-746005"></a>
<a 
 id="dx213-746006"></a>
<a 
 id="dx213-746007"></a>
     </p><dl class="description"><dt class="description">
     <!--l. 326--><p class="noindent" >
<span 
class="pcrr8t-x-x-109">groebopt</span><span 
class="ptmb8t-x-x-109">–</span> </p></dt><dd 
class="description">
     <!--l. 326--><p class="noindent" ><a 
 id="switch:GROEBOPT"></a> If set <span 
class="pcrr8t-x-x-109">on</span>, the sequence of variables is optimized with respect to execution
     speed; the algorithm involved is described in <span class="cite">[<a 
href="manual/manualap2.html#XBoege:86">BGK86</a>]</span>; note that the ﬁnal
     list of variables is available in <a 
 id="dx213-746008"></a> <span 
class="pcrr8t-x-x-109">gvarslast</span>.
     </p><!--l. 334--><p class="noindent" >An explicitly declared dependency supersedes the variable optimization. For
     example </p>
     <div class="center" 
>
<!--l. 335--><p class="noindent" >
</p><!--l. 336--><p class="noindent" ><span 
class="pcrr8t-x-x-109">depend a, x, y;</span></p></div>
     <!--l. 338--><p class="noindent" >guarantees that <span 
class="pcrr8t-x-x-109">a </span>will be placed in front of <span 
class="pcrr8t-x-x-109">x </span>and <span 
class="pcrr8t-x-x-109">y</span>. So <span 
class="pcrr8t-x-x-109">groebopt </span>can be used
     even in cases where elimination of variables is desired.
     </p><!--l. 341--><p class="noindent" >By default <span 
class="pcrr8t-x-x-109">groebopt </span>is <span 
class="pcrr8t-x-x-109">off</span>, conserving the original variable sequence.
                                                                     

                                                                     
<a 
 id="dx213-746009"></a>
<a 
 id="dx213-746010"></a>
<a 
 id="dx213-746011"></a>
     </p></dd><dt class="description">
     <!--l. 344--><p class="noindent" >
<span 
class="pcrr8t-x-x-109">groebfullreduction</span><span 
class="ptmb8t-x-x-109">–</span> </p></dt><dd 
class="description">
     <!--l. 344--><p class="noindent" ><a 
 id="switch:GROEBFULLREDUCTION"></a> If set <span 
class="pcrr8t-x-x-109">off</span>, the reduction steps during the
     <span 
class="ptmrc8t-x-x-109">G<span 
class="small-caps">R</span><span 
class="small-caps">O</span><span 
class="small-caps">E</span><span 
class="small-caps">B</span><span 
class="small-caps">N</span><span 
class="small-caps">E</span><span 
class="small-caps">R</span> </span>operation are limited to the pure head term reduction; subsequent
     terms are reduced otherwise.
     </p><!--l. 350--><p class="noindent" >By default <span 
class="pcrr8t-x-x-109">groebfullreduction </span>is on.
<a 
 id="dx213-746012"></a>
<a 
 id="dx213-746013"></a>
<a 
 id="dx213-746014"></a>
<a 
 id="dx213-746015"></a>
     </p></dd><dt class="description">
     <!--l. 354--><p class="noindent" >
<span 
class="pcrr8t-x-x-109">gltbasis</span><span 
class="ptmb8t-x-x-109">–</span> </p></dt><dd 
class="description">
     <!--l. 354--><p class="noindent" ><a 
 id="reserved:GLTB"></a> <a 
 id="switch:GLTBASIS"></a> If set on, the leading terms of the result basis are extracted. They are collected in
     a basis of monomials, which is available as value of the global variable with the
     name <span 
class="pcrr8t-x-x-109">gltb</span>.
     </p></dd><dt class="description">
     <!--l. 361--><p class="noindent" >
<span 
class="pcrr8t-x-x-109">glterms</span><span 
class="ptmb8t-x-x-109">–</span> </p></dt><dd 
class="description">
     <!--l. 361--><p class="noindent" ><a 
 id="dx213-746016"></a><a 
 id="dx213-746017"></a><a 
 id="dx213-746018"></a> <a 
 id="dx213-746019"></a> <a 
 id="switch:GLTERMS"></a> <a 
 id="reserved:GLTERMS"></a> If \(\{exp_1, \ldots , exp_m\} \) contain parameters (symbols which are not member of the variable list), the
     shared variable <span 
class="pcrr8t-x-x-109">glterms </span>contains a list of expression which during the
     calculation were assumed to be nonzero. A Gröbner basis is valid only under the
     assumption that all these expressions do not vanish.
</p>
     </dd></dl>
<!--l. 374--><p class="noindent" >The following switches control the print output of <span 
class="ptmrc8t-x-x-109">G<span 
class="small-caps">R</span><span 
class="small-caps">O</span><span 
class="small-caps">E</span><span 
class="small-caps">B</span><span 
class="small-caps">N</span><span 
class="small-caps">E</span><span 
class="small-caps">R</span></span>; by default all these
switches are set <span 
class="pcrr8t-x-x-109">off </span>and nothing is printed.
<a 
 id="dx213-746020"></a>
<a 
 id="dx213-746021"></a>
<a 
 id="dx213-746022"></a>
     </p><dl class="description"><dt class="description">
     <!--l. 378--><p class="noindent" >
<span 
class="pcrr8t-x-x-109">groebstat</span><span 
class="ptmb8t-x-x-109">–</span> </p></dt><dd 
class="description">
                                                                     

                                                                     
     <!--l. 378--><p class="noindent" ><a 
 id="switch:GROEBSTAT"></a> A summary of the computation is printed including the computing time,
     the number of intermediate \(h\)–polynomials and the counters for the hits of the
     criteria.
<a 
 id="dx213-746023"></a>
<a 
 id="dx213-746024"></a>
<a 
 id="dx213-746025"></a>
     </p></dd><dt class="description">
     <!--l. 385--><p class="noindent" >
<span 
class="pcrr8t-x-x-109">trgroeb</span><span 
class="ptmb8t-x-x-109">–</span> </p></dt><dd 
class="description">
     <!--l. 385--><p class="noindent" ><a 
 id="switch:TRGROEB"></a> Includes <span 
class="pcrr8t-x-x-109">groebstat </span>and the printing of the intermediate \(h\)-polynomials.
<a 
 id="dx213-746026"></a>
<a 
 id="dx213-746027"></a>
<a 
 id="dx213-746028"></a>
     </p></dd><dt class="description">
     <!--l. 391--><p class="noindent" >
<span 
class="pcrr8t-x-x-109">trgroebs</span><span 
class="ptmb8t-x-x-109">–</span> </p></dt><dd 
class="description">
     <!--l. 391--><p class="noindent" ><a 
 id="switch:TRGROEBS"></a> Includes <span 
class="pcrr8t-x-x-109">trgroeb </span>and the printing of intermediate \(s\)–polynomials.
<a 
 id="dx213-746029"></a>
<a 
 id="dx213-746030"></a>
<a 
 id="dx213-746031"></a>
     </p></dd><dt class="description">
     <!--l. 397--><p class="noindent" >
<span 
class="pcrr8t-x-x-109">trgroeb1</span><span 
class="ptmb8t-x-x-109">–</span> </p></dt><dd 
class="description">
     <!--l. 397--><p class="noindent" ><a 
 id="switch:TRGROEB1"></a> The internal pairlist is printed when modiﬁed.</p></dd></dl>
<!--l. 402--><p class="noindent" >
</p>
<h5 class="subsubsectionHead"><a 
 id="x213-7470002"></a><span 
class="pcrb8t-x-x-109">Gzerodim!?</span>: Test of \(\dim = 0\)</h5>
<a 
 id="dx213-747001"></a>
     <dl class="description"><dt class="description">
     <!--l. 405--><p class="noindent" >
<span 
class="pcrr8t-x-x-109">gzerodim!?</span><span 
class="ptmbi8t-x-x-109">bas</span> </p></dt><dd 
class="description">
                                                                     

                                                                     
     <!--l. 405--><p class="noindent" ><br 
class="newline" /><a 
 id="operator:GZERODIM!?"></a> where <span 
class="ptmri8t-x-x-109">bas </span>is a Gröbner basis in the current setting. The result is <span 
class="pcrr8t-x-x-109">nil </span>if <span 
class="ptmri8t-x-x-109">bas</span>
     is the basis of an ideal of polynomials with more than ﬁnitely many common
     zeros. If the ideal is zero dimensional, i. e. the polynomials of the ideal have
     only ﬁnitely many zeros in common, the result is an integer \(k\) which is the
     number of these common zeros (counted with multiplicities).</p></dd></dl>
<!--l. 416--><p class="noindent" >
</p>
<h5 class="subsubsectionHead"><a 
 id="x213-7480002"></a><span 
class="pcrr8t-x-x-109">gdimension</span>, <span 
class="pcrr8t-x-x-109">gindependent_sets</span>: compute dimension and independent
variables</h5>
<!--l. 417--><p class="noindent" >The following operators can be used to compute the dimension and the independent
variable sets of an ideal which has the Gröbner basis <span 
class="ptmri8t-x-x-109">bas </span>with arbitrary term
order:
<a 
 id="dx213-748001"></a>
<a 
 id="dx213-748002"></a>
<a 
 id="dx213-748003"></a>
<a 
 id="dx213-748004"></a>
     </p><dl class="description"><dt class="description">
     <!--l. 423--><p class="noindent" >
<span 
class="pcrr8t-x-x-109">gdimension bas</span> </p></dt><dd 
class="description">
     <!--l. 423--><p class="noindent" ><a 
 id="operator:GDIMENSION"></a>
     </p></dd><dt class="description">
     <!--l. 425--><p class="noindent" >
<span 
class="pcrr8t-x-x-109">gindependent_sets bas</span> </p></dt><dd 
class="description">
     <!--l. 425--><p class="noindent" ><a 
 id="operator:GINDEPENDENT_SETS"></a> <span 
class="pcrr8t-x-x-109">gindependent_sets </span>computes the maximal left independent variable
     sets  of  the  ideal,  that  are  the  variable  sets  which  play  the  role  of  free
     parameters in the current ideal basis. Each set is a list which is a subset of
     the variable list. The result is a list of these sets. For an ideal with dimension
     zero the list is empty. <span 
class="pcrr8t-x-x-109">gdimension </span>computes the dimension of the ideal,
     which is the maximum length of the independent sets.</p></dd></dl>
<a 
 id="dx213-748005"></a>
<a 
 id="dx213-748006"></a>
<a 
 id="dx213-748007"></a>
<!--l. 438--><p class="noindent" >The switch <span 
class="pcrr8t-x-x-109">groebopt </span>plays no role in the algorithms <span 
class="pcrr8t-x-x-109">gdimension </span>and
<span 
class="pcrr8t-x-x-109">gindependent_sets</span>. It is set <span 
class="pcrr8t-x-x-109">off </span>during the processing even if it is set <span 
class="pcrr8t-x-x-109">on </span>before.
Its state is saved during the processing.
                                                                     

                                                                     
</p><!--l. 442--><p class="noindent" >The “Kredel-Weispfenning” algorithm is used (see <span class="cite">[<a 
href="manual/manualap2.html#XKredel:88a">KW88</a>]</span>, extended to general
ordering in <span class="cite">[<a 
href="manual/manualap2.html#XBecker:93">BWK93</a>]</span>.
</p><!--l. 445--><p class="noindent" >
</p>
<h5 class="subsubsectionHead"><a 
 id="x213-7490002"></a>Conversion of a Gröbner Basis</h5>
<!--l. 448--><p class="noindent" >
</p>
<h5 class="likesubsubsectionHead"><a 
 id="x213-7500002"></a><span 
class="pcrr8t-x-x-109">glexconvert</span>: Conversion of an Arbitrary Gröbner Basis of a Zero Dimensional
Ideal into a Lexical One</h5>
<a 
 id="dx213-750001"></a>
     <dl class="description"><dt class="description">
     <!--l. 452--><p class="noindent" >
<span 
class="pcrr8t-x-x-109">glexconvert</span>\(\left (\{exp,\ldots , expm\} \left [,\{var1 \ldots , varn\}\right ]\left [,maxdeg=mx\right ]\right .\) </p></dt><dd 
class="description">
     <!--l. 452--><p class="noindent" ><br 
class="newline" /><a 
 id="operator:GLEXCONVERT"></a>\(\left .\left [,newvars=\{nv1, \ldots , nvk\}\right ]\right )\)<br 
class="newline" />where \(\{exp1, \ldots , expm\}\) is a Gröbner basis with \(\{var1, \ldots , varn\}\) as variables in the current term order mode,
     \(mx\) is an integer, and \(\{nv1, \ldots , nvk\}\) is a subset of the basis variables. For this operator the
     source and target variable sets must be speciﬁed explicitly.</p></dd></dl>
<!--l. 463--><p class="noindent" ><span 
class="pcrr8t-x-x-109">glexconvert </span>converts a basis of a zero-dimensional ideal (ﬁnite number of isolated
solutions) from arbitrary ordering into a basis under <span 
class="ptmri8t-x-x-109">lex </span>ordering. During the
call of <span 
class="pcrr8t-x-x-109">glexconvert </span>the original ordering of the input basis must be still
active!
</p><!--l. 468--><p class="noindent" ><span 
class="ptmri8t-x-x-109">newvars </span>deﬁnes the new variable sequence. If omitted, the original variable sequence is
used. If only a subset of variables is speciﬁed here, the partial ideal basis is evaluated.
For the calculation of a univariate polynomial, <span 
class="ptmri8t-x-x-109">new-vars </span>should be a list with one
element.
</p><!--l. 474--><p class="noindent" ><span 
class="ptmri8t-x-x-109">maxdeg </span>is an upper limit for the degrees. The algorithm stops with an error message, if
this limit is reached.
</p><!--l. 477--><p class="noindent" >A warning occurs if the ideal is not zero dimensional.
</p><!--l. 479--><p class="noindent" ><span 
class="pcrr8t-x-x-109">glexconvert </span>is an implementation of the FLGM algorithm by
<span 
class="ptmrc8t-x-x-109">F<span 
class="small-caps">A</span><span 
class="small-caps">U</span><span 
class="small-caps">G</span></span><span 
class="ptmrc8t-x-x-109">è</span><span 
class="ptmrc8t-x-x-109"><span 
class="small-caps">R</span><span 
class="small-caps">E</span></span>, <span 
class="ptmrc8t-x-x-109">G<span 
class="small-caps">I</span><span 
class="small-caps">A</span><span 
class="small-caps">N</span><span 
class="small-caps">N</span><span 
class="small-caps">I</span></span>, <span 
class="ptmrc8t-x-x-109">L<span 
class="small-caps">A</span><span 
class="small-caps">Z</span><span 
class="small-caps">A</span><span 
class="small-caps">R</span><span 
class="small-caps">D</span> </span>and <span 
class="ptmrc8t-x-x-109">M<span 
class="small-caps">O</span><span 
class="small-caps">R</span><span 
class="small-caps">A</span> </span><span class="cite">[<a 
href="manual/manualap2.html#XFaugere:93">FGLM93</a>]</span>. Often, the calculation of
                                                                     

                                                                     
a Gröbner basis with a graded ordering and subsequent conversion to <span 
class="ptmri8t-x-x-109">lex </span>is
faster than a direct <span 
class="ptmri8t-x-x-109">lex </span>calculation. Additionally, <span 
class="pcrr8t-x-x-109">glexconvert </span>can be used to
transform a <span 
class="ptmri8t-x-x-109">lex </span>basis into one with diﬀerent variable sequence, and it supports the
calculation of a univariate polynomial. If the latter exists, the algorithm is even
applicable in the non zero-dimensional case, if such a polynomial exists. If the
polynomial does not exist, the algorithm computes until <span 
class="pcrr8t-x-x-109">maxdeg </span>has been
reached.
                                                                     

                                                                     
</p>
<pre class="verbatim" id="verbatim-1143">
   torder({{w,p,z,t,s,b},gradlex)

   g  :=  groebner  { f1 := 45*p + 35*s -165*b -36,
         35*p + 40*z + 25*t - 27*s, 15*w + 25*p*s +30*z -18*t
        -165*b**2, -9*w + 15*p*t  + 20*z*s,
        w*p + 2*z*t - 11*b**3, 99*w - 11*s*b +3*b**2,
        b**2 + 33/50*b + 2673/10000};

  g := {60000*w + 9500*b + 3969,

      1800*p - 3100*b - 1377,

      18000*z + 24500*b + 10287,

      750*t - 1850*b + 81,

      200*s - 500*b - 9,
             2
      10000*b  + 6600*b + 2673}

   glexconvert(g,{w,p,z,t,s,b},maxdeg=5,newvars={w});

               2
    100000000*w  + 2780000*w + 416421

   glexconvert(g,{w,p,z,t,s,b},maxdeg=5,newvars={p});

          2
    6000*p  - 2360*p + 3051
</pre>
<!--l. 520--><p class="nopar" >
</p><!--l. 523--><p class="noindent" >
</p>
<h5 class="likesubsubsectionHead"><a 
 id="x213-7510002"></a><span 
class="pcrr8t-x-x-109">groebner_walk</span>: Conversion of a (General) Total Degree Basis into a Lex
                                                                     

                                                                     
One</h5>
<!--l. 524--><p class="noindent" ><a 
 id="operator:GROEBNER_WALK"></a> The algorithm <span 
class="pcrr8t-x-x-109">groebner_walk </span>convertes from an arbitrary polynomial system a
<span 
class="ptmri8t-x-x-109">graduated </span>basis of the given variable sequence to a <span 
class="ptmri8t-x-x-109">lex </span>one of the same sequence. The
job is done by computing a sequence of Gröbner bases of correspondig monomial
ideals, lifting the original system each time. The algorithm has been described (more
generally) by <span class="cite">[<a 
href="manual/manualap2.html#XAmrheinGloorKuechlin:96a">AGK96a</a>]</span>,<span class="cite">[<a 
href="manual/manualap2.html#XAmrheinGloorKuechlin:96b">AGK96b</a>]</span>,<span class="cite">[<a 
href="manual/manualap2.html#XAmrheinGloor:98">AG98</a>]</span> and <span class="cite">[<a 
href="manual/manualap2.html#XCollart:97">CKM97</a>]</span>. <span 
class="pcrr8t-x-x-109">groebner_walk </span>should
be only called if the direct calculation of a <span 
class="ptmri8t-x-x-109">lex </span>Gröbner base does not work. The
computation of <span 
class="pcrr8t-x-x-109">groebner_walk </span>includes some overhead (e. g. the computation
divides polynomials). Normally <span 
class="pcrr8t-x-x-109">torder </span>must be called before to deﬁne the
variables and the variable sorting. The reordering of variables makes no sense
with <span 
class="pcrr8t-x-x-109">groebner_walk</span>; so do not call <span 
class="pcrr8t-x-x-109">groebner_walk </span>with <span 
class="pcrr8t-x-x-109">groebopt</span>
on!
<a 
 id="dx213-751001"></a>
     </p><dl class="description"><dt class="description">
     <!--l. 540--><p class="noindent" >
<span 
class="pcrr8t-x-x-109">groebner_walk</span>\(g\) </p></dt><dd 
class="description">
     <!--l. 540--><p class="noindent" ><br 
class="newline" />where  \(g\)  is  a  polynomial  ideal  basis  computed  under  <span 
class="ptmri8t-x-x-109">gradlex  </span>or  under
     <span 
class="ptmri8t-x-x-109">weighted </span>with a one-element, non zero weight vector with only one element,
     repeated for each variable. The result is a corresponding <span 
class="ptmri8t-x-x-109">lex </span>basis (if that
     is computable), independent of the degree of the ideal (even for non zero
     degree ideals). The variabe <span 
class="pcrr8t-x-x-109">gvarslast </span>is not set.<a 
 id="dx213-751002"></a>variable</p></dd></dl>
<!--l. 549--><p class="noindent" >
</p>
<h5 class="subsubsectionHead"><a 
 id="x213-7520002"></a><span 
class="pcrr8t-x-x-109">groebnerf</span>: Factorizing Gröbner Bases</h5>
<!--l. 551--><p class="noindent" ><a 
 id="operator:GROEBNERF"></a>
</p>
<h5 class="likesubsubsectionHead"><a 
 id="x213-7530002"></a>Background</h5>
<!--l. 553--><p class="noindent" >If Gröbner bases are computed in order to solve systems of equations or to ﬁnd the
common roots of systems of polynomials, the factorizing version of the Buchberger
algorithm can be used. The theoretical background is simple: if a polynomial \(p\) can be
represented as a product of two (or more) polynomials, e.g. \(h= f*g\), then \(h\) vanishes if and only if
                                                                     

                                                                     
one of the factors vanishes. So if during the calculation of a Gröbner basis \(h\) of
the above form is detected, the whole problem can be split into two (or more)
disjoint branches. Each of the branches is simpler than the complete problem; this
saves computing time and space. The result of this type of computation is a
list of (partial) Gröbner bases; the solution set of the original problem is the
union of the solutions of the partial problems, ignoring the multiplicity of an
individual solution. If a branch results in a basis \(\{1\}\), then there is no common
zero, i.e. no additional solution for the original problem, contributed by this
branch.
</p><!--l. 570--><p class="noindent" >
</p>
<h5 class="likesubsubsectionHead"><a 
 id="x213-7540002"></a><span 
class="pcrr8t-x-x-109">groebnerf </span>Call</h5>
<a 
 id="dx213-754001"></a>
<!--l. 573--><p class="noindent" >The syntax of <span 
class="pcrr8t-x-x-109">groebnerf </span>is the same as for <span 
class="pcrr8t-x-x-109">groebner</span>. \[ \f {groebnerf}(\{exp1, exp2, \ldots , expm\} [,\{\},\{nz1, \ldots nzk\}); \] where \(\{exp1, exp2, \ldots , expm\} \) is a given list of
expressions or equations, and \(\{nz1, \ldots nzk\}\) is an optional list of polynomials known to be
non-zero.
</p><!--l. 580--><p class="noindent" ><span 
class="pcrr8t-x-x-109">groebnerf </span>tries to separate polynomials into individual factors and to branch the
computation in a recursive manner (factorization tree). The result is a list of partial
Gröbner bases. If no factorization can be found or if all branches but one lead to
the trivial basis \(\{1\}\), the result has only one basis; nevertheless it is a list of lists
of polynomials. If no solution is found, the result will be \(\{\{1\}\}\). Multiplicities (one
factor with a higher power, the same partial basis twice) are deleted as early as
possible in order to speed up the calculation. The factorizing is controlled by some
switches.
</p><!--l. 590--><p class="noindent" >As a side eﬀect, the sequence of variables is stored as a REDUCE list in the shared
variable </p>
<div class="center" 
>
<!--l. 592--><p class="noindent" >
</p><!--l. 593--><p class="noindent" ><span 
class="pcrr8t-x-x-109">gvarslast </span>.</p></div>
<!--l. 595--><p class="noindent" >If <span 
class="pcrr8t-x-x-109">gltbasis </span>is on, a corresponding list of leading term bases is also produced and is
available in the variable <span 
class="pcrr8t-x-x-109">gltb</span>.
</p><!--l. 598--><p class="noindent" >The third parameter of <span 
class="pcrr8t-x-x-109">groebnerf </span>allows one to declare some polynomials
nonzero. If any of these is found in a branch of the calculation the branch is
cancelled. This can be used to save a substantial amount of computing time. The
second parameter must be included as an empty list if the third parameter is to be
                                                                     

                                                                     
used.
                                                                     

                                                                     
</p>
<pre class="verbatim" id="verbatim-1144">
   torder({x,y},lex)$
   groebnerf { 3*x**2*y + 2*x*y + y + 9*x**2 + 5*x = 3,
               2*x**3*y - x*y - y + 6*x**3 - 2*x**2 - 3*x = -3,
                x**3*y + x**2*y + 3*x**3 + 2*x**2 };


       {{y - 3,x},

                      2
    {2*y + 2*x - 1,2*x  - 5*x - 5}}
</pre>
<!--l. 615--><p class="nopar" > It is obvious here that the solutions of the equations can be read oﬀ immediately.
</p><!--l. 619--><p class="noindent" >All switches from <span 
class="pcrr8t-x-x-109">groebner </span>are valid for <span 
class="pcrr8t-x-x-109">groebnerf </span>as well: <a 
 id="dx213-754002"></a><a 
 id="dx213-754003"></a><a 
 id="dx213-754004"></a> <a 
 id="dx213-754005"></a><a 
 id="dx213-754006"></a><a 
 id="dx213-754007"></a> <a 
 id="dx213-754008"></a><a 
 id="dx213-754009"></a><a 
 id="dx213-754010"></a> <a 
 id="dx213-754011"></a><a 
 id="dx213-754012"></a><a 
 id="dx213-754013"></a> <a 
 id="dx213-754014"></a><a 
 id="dx213-754015"></a><a 
 id="dx213-754016"></a> <a 
 id="dx213-754017"></a><a 
 id="dx213-754018"></a><a 
 id="dx213-754019"></a> <a 
 id="dx213-754020"></a><a 
 id="dx213-754021"></a><a 
 id="dx213-754022"></a> </p>
<div class="center" 
>
<!--l. 627--><p class="noindent" >
</p>
<div class="tabular"> <table id="TBL-82" class="tabular" 
 
><colgroup id="TBL-82-1g"><col 
id="TBL-82-1" /></colgroup><tr  
 style="vertical-align:baseline;" id="TBL-82-1-"><td  style="white-space:nowrap; text-align:left;" id="TBL-82-1-1"  
class="td11"><span 
class="pcrr8t-x-x-109">groebopt          </span></td>
</tr><tr  
 style="vertical-align:baseline;" id="TBL-82-2-"><td  style="white-space:nowrap; text-align:left;" id="TBL-82-2-1"  
class="td11"><span 
class="pcrr8t-x-x-109">gltbasis          </span></td>
</tr><tr  
 style="vertical-align:baseline;" id="TBL-82-3-"><td  style="white-space:nowrap; text-align:left;" id="TBL-82-3-1"  
class="td11"><span 
class="pcrr8t-x-x-109">groebfullreduction</span></td>
</tr><tr  
 style="vertical-align:baseline;" id="TBL-82-4-"><td  style="white-space:nowrap; text-align:left;" id="TBL-82-4-1"  
class="td11"><span 
class="pcrr8t-x-x-109">groebstat         </span></td>
</tr><tr  
 style="vertical-align:baseline;" id="TBL-82-5-"><td  style="white-space:nowrap; text-align:left;" id="TBL-82-5-1"  
class="td11"><span 
class="pcrr8t-x-x-109">trgroeb           </span></td>
</tr><tr  
 style="vertical-align:baseline;" id="TBL-82-6-"><td  style="white-space:nowrap; text-align:left;" id="TBL-82-6-1"  
class="td11"><span 
class="pcrr8t-x-x-109">trgroebs          </span></td>
</tr><tr  
 style="vertical-align:baseline;" id="TBL-82-7-"><td  style="white-space:nowrap; text-align:left;" id="TBL-82-7-1"  
class="td11"><span 
class="pcrr8t-x-x-109">rgroeb1           </span></td>
</tr></table></div></div>
<!--l. 639--><p class="noindent" >
</p>
<h5 class="likesubsubsectionHead"><a 
 id="x213-7550002"></a>Additional switches for <span 
class="pcrr8t-x-x-109">groebnerf</span>:</h5>
<a 
 id="dx213-755001"></a>
<a 
 id="dx213-755002"></a>
<a 
 id="dx213-755003"></a>
     <dl class="description"><dt class="description">
                                                                     

                                                                     
     <!--l. 643--><p class="noindent" >
<span 
class="pcrr8t-x-x-109">trgroebr</span><span 
class="ptmb8t-x-x-109">–</span> </p></dt><dd 
class="description">
     <!--l. 643--><p class="noindent" ><a 
 id="switch:TRGROEBR"></a> All intermediate partial basis are printed when detected.
     </p><!--l. 647--><p class="noindent" >By default <span 
class="pcrr8t-x-x-109">trgroebr </span>is oﬀ.</p></dd></dl>
<!--l. 649--><p class="noindent" ><span 
class="pcrr8t-x-x-109">groebmonfacgroebresmaxgroebrestriction</span><br 
class="newline" />       These variables are described in the following paragraphs.
</p><!--l. 653--><p class="noindent" >
</p>
<h5 class="likesubsubsectionHead"><a 
 id="x213-7560002"></a>Suppression of Monomial Factors</h5>
<!--l. 654--><p class="noindent" >The factorization in <span 
class="pcrr8t-x-x-109">groebnerf </span>is controlled by the following switches and variables.
The variable <span 
class="pcrr8t-x-x-109">groebmonfac </span>is connected to the handling of “monomial factors”. A
monomial factor is a product of variable powers occurring as a factor, e.g. \( x**2*y\) in \(x**3*y - 2*x**2*y**2\). A
monomial factor represents a solution of the type “\( x = 0\) or \(y = 0\)” with a certain multiplicity. With
<span 
class="pcrr8t-x-x-109">groebnerf </span>the multiplicity of monomial factors is lowered to the value of the shared
variable <a 
 id="dx213-756001"></a> <a 
 id="reserved:GROEBMONFAC"></a> </p>
<div class="center" 
>
<!--l. 665--><p class="noindent" >
</p><!--l. 666--><p class="noindent" ><span 
class="pcrr8t-x-x-109">groebmonfac</span></p></div>
<!--l. 668--><p class="noindent" >which by default is 1 (= monomial factors remain present, but their multiplicity is
brought down). With </p>
<div class="center" 
>
<!--l. 670--><p class="noindent" >
</p><!--l. 671--><p class="noindent" ><span 
class="pcrr8t-x-x-109">groebmonfac </span>:= 0</p></div>
<!--l. 673--><p class="noindent" >the monomial factors are suppressed completely.
</p><!--l. 675--><p class="noindent" >
</p>
<h5 class="likesubsubsectionHead"><a 
 id="x213-7570002"></a>Limitation on the Number of Results</h5>
                                                                     

                                                                     
<!--l. 676--><p class="noindent" >The shared variable <a 
 id="dx213-757001"></a> <a 
 id="reserved:GROEBRESMAX"></a> </p>
<div class="center" 
>
<!--l. 679--><p class="noindent" >
</p><!--l. 680--><p class="noindent" ><span 
class="pcrr8t-x-x-109">groebresmax</span></p></div>
<!--l. 682--><p class="noindent" >controls the number of partial results. Its default value is 300. If <span 
class="pcrr8t-x-x-109">groebresmax </span>partial
results are calculated, the calculation is terminated. <span 
class="pcrr8t-x-x-109">groebresmax </span>counts all branches,
including those which are terminated (have been computed already), give no contribution
to the result (partial basis 1), or which are uniﬁed in the result with other (partial) bases.
So the resulting number may be much smaller. When the limit of <span 
class="pcrr8t-x-x-109">groeresmax </span>is
reached, a warning
</p><!--l. 690--><p class="noindent" ><span 
class="pcrr8t-x-x-109">warning: GROEBRESMAX limit reached</span>
</p><!--l. 692--><p class="noindent" >is issued; this warning in any case has to be taken as a serious one. For “normal”
calculations the <span 
class="pcrr8t-x-x-109">groebresmax </span>limit is not reached. <span 
class="ptmri8t-x-x-109">var </span>is a shared variable (with an
integer value); it can be set in the algebraic mode to a diﬀerent (positive integer)
value.
</p><!--l. 697--><p class="noindent" >
</p>
<h5 class="likesubsubsectionHead"><a 
 id="x213-7580002"></a>Restriction of the Solution Space</h5>
<!--l. 698--><p class="noindent" >In some applications only a subset of the complete solution set of a given set of equations
is relevant, e.g. only nonnegative values or positive deﬁnite values for the variables. A
signiﬁcant amount of computing time can be saved if nonrelevant computation branches
can be terminated early.
</p><!--l. 704--><p class="noindent" >Positivity: If a polynomial has no (strictly) positive zero, then every system containing it
has no nonnegative or strictly positive solution. Therefore, the Buchberger algorithm
tests the coeﬃcients of the polynomials for equal sign if requested. For example, in \(13*x + 15*y*z \) can
be zero with real nonnegative values for \(x, y\) and \(z\) only if \(x=0\) and \(y=0\) or \( z=0\); this is a sort of
“factorization by restriction”. A polynomial \(13*x + 15*y*z + 20\) never can vanish with nonnegative real
variable values.
</p><!--l. 713--><p class="noindent" >Zero point: If any polynomial in an ideal has an absolute term, the ideal cannot have the
origin point as a common solution.
</p><!--l. 716--><p class="noindent" >By setting the shared variable <a 
 id="dx213-758001"></a> <a 
 id="reserved:GROEBRESTRICTION"></a> </p>
<div class="center" 
>
                                                                     

                                                                     
<!--l. 719--><p class="noindent" >
</p><!--l. 719--><p class="noindent" ><span 
class="pcrr8t-x-x-109">groebrestriction</span></p></div>
<!--l. 720--><p class="noindent" ><span 
class="pcrr8t-x-x-109">groebnerf </span>is informed of the type of restriction the user wants to impose on the
solutions: </p>
<div class="center" 
>
<!--l. 722--><p class="noindent" >
</p>
<div class="tabular"> <table id="TBL-83" class="tabular" 
 
><colgroup id="TBL-83-1g"><col 
id="TBL-83-1" /></colgroup><tr  
 style="vertical-align:baseline;" id="TBL-83-1-"><td  style="white-space:nowrap; text-align:left;" id="TBL-83-1-1"  
class="td11"><span 
class="pcrr8t-x-x-109">groebrestiction:=nonnegative;            </span></td>
</tr><tr  
 style="vertical-align:baseline;" id="TBL-83-2-"><td  style="white-space:nowrap; text-align:left;" id="TBL-83-2-1"  
class="td11">       only nonnegative real solutions are of interest                  </td>
</tr><tr  
 style="vertical-align:baseline;" id="TBL-83-3-"><td  style="white-space:nowrap; text-align:left;" id="TBL-83-3-1"  
class="td11"><span 
class="pcrr8t-x-x-109">groebrestriction:=positive;              </span></td>
</tr><tr  
 style="vertical-align:baseline;" id="TBL-83-4-"><td  style="white-space:nowrap; text-align:left;" id="TBL-83-4-1"  
class="td11">      only nonnegative and nonzero solutions are of interest     </td>
</tr><tr  
 style="vertical-align:baseline;" id="TBL-83-5-"><td  style="white-space:nowrap; text-align:left;" id="TBL-83-5-1"  
class="td11"><span 
class="pcrr8t-x-x-109">groebrestriction:=zeropoint;             </span></td>
</tr><tr  
 style="vertical-align:baseline;" id="TBL-83-6-"><td  style="white-space:nowrap; text-align:left;" id="TBL-83-6-1"  
class="td11">      only solution sets which contain the point \(\{0,0,\ldots ,0\}\) are or interest.</td>
</tr></table></div></div>
<!--l. 736--><p class="noindent" >If <span 
class="pcrr8t-x-x-109">groebnerf </span>detects a polynomial which formally conﬂicts with the restriction, it
either splits the calculation into separate branches, or, if a violation of the restriction is
determined, it cancels the actual calculation branch.
</p><!--l. 741--><p class="noindent" >
</p>
<h5 class="subsubsectionHead"><a 
 id="x213-7590002"></a><span 
class="pcrr8t-x-x-109">greduce</span>, <span 
class="pcrr8t-x-x-109">preduce</span>: Reduction of Polynomials</h5>
<!--l. 743--><p class="noindent" >
</p>
<h5 class="likesubsubsectionHead"><a 
 id="x213-7600002"></a>Background</h5>
<!--l. 744--><p class="noindent" >Reduction of a polynomial “\(p\)” modulo a given sets of polynomials “\(b\)” is done by the
reduction algorithm incorporated in the Buchberger algorithm. Informally it can be
described for polynomials over a ﬁeld as follows: </p>
<div class="center" 
>
<!--l. 748--><p class="noindent" >
                                                                     

                                                                     
</p>
<div class="tabular"> <table id="TBL-84" class="tabular" 
 
><colgroup id="TBL-84-1g"><col 
id="TBL-84-1" /></colgroup><tr  
 style="vertical-align:baseline;" id="TBL-84-1-"><td  style="white-space:nowrap; text-align:left;" id="TBL-84-1-1"  
class="td11">          loop1:  % head term elimination                    </td>
</tr><tr  
 style="vertical-align:baseline;" id="TBL-84-2-"><td  style="white-space:nowrap; text-align:left;" id="TBL-84-2-1"  
class="td11">if there is one polynomial \(b\) in \(B\) such that the leading              </td>
</tr><tr  
 style="vertical-align:baseline;" id="TBL-84-3-"><td  style="white-space:nowrap; text-align:left;" id="TBL-84-3-1"  
class="td11">          term of \(p\) is a multiple of the leading term of \(P\) do</td>
</tr><tr  
 style="vertical-align:baseline;" id="TBL-84-4-"><td  style="white-space:nowrap; text-align:left;" id="TBL-84-4-1"  
class="td11">          \(p := p - lt(p)/lt(b) * b\) (the leading term vanishes)                               </td>
</tr><tr  
 style="vertical-align:baseline;" id="TBL-84-5-"><td  style="white-space:nowrap; text-align:left;" id="TBL-84-5-1"  
class="td11">do this loop as long as possible;                                            </td>
</tr><tr  
 style="vertical-align:baseline;" id="TBL-84-6-"><td  style="white-space:nowrap; text-align:left;" id="TBL-84-6-1"  
class="td11">          loop2:  % elimination of subsequent terms     </td>
</tr><tr  
 style="vertical-align:baseline;" id="TBL-84-7-"><td  style="white-space:nowrap; text-align:left;" id="TBL-84-7-1"  
class="td11">for each term \(s\) in \(p\) do                                                               </td>
</tr><tr  
 style="vertical-align:baseline;" id="TBL-84-8-"><td  style="white-space:nowrap; text-align:left;" id="TBL-84-8-1"  
class="td11">          if there is one polynomial \(b\) in \(B\) such that \(s\) is a     </td>
</tr><tr  
 style="vertical-align:baseline;" id="TBL-84-9-"><td  style="white-space:nowrap; text-align:left;" id="TBL-84-9-1"  
class="td11">          multiple of the leading term of \(p\) do                    </td>
</tr><tr  
 style="vertical-align:baseline;" id="TBL-84-10-"><td  style="white-space:nowrap; text-align:left;" id="TBL-84-10-1"  
class="td11">          \(p := p - s/lt(b) * b\) (the term \(s\) vanishes)                                           </td>
</tr><tr  
 style="vertical-align:baseline;" id="TBL-84-11-"><td  style="white-space:nowrap; text-align:left;" id="TBL-84-11-1"  
class="td11">do this loop as long as possible;                                            </td>
</tr></table></div></div>
<!--l. 764--><p class="noindent" >If the coeﬃcients are taken from a ring without zero divisors we cannot divide by each
possible number like in the ﬁeld case. But using that in the ﬁeld case, \(c*p \) is reduced to \(c*q \), if \( p \) is
reduced to \( q \), for arbitrary numbers \( c \), the reduction for the ring case uses the least \( c \) which
makes the (ﬁeld) reduction for \( c*p \) integer. The result of this reduction is returned as (ring)
reduction of \( p \) eventually after removing the content, i.e. the greatest common divisor of
the coeﬃcients. The result of this type of reduction is also called a pseudo reduction of
\( p \).
</p><!--l. 774--><p class="noindent" >
</p>
<h5 class="likesubsubsectionHead"><a 
 id="x213-7610002"></a>Reduction via Gröbner Basis Calculation</h5>
<a 
 id="dx213-761001"></a>
<!--l. 776--><p class="noindent" ><a 
 id="operator:GREDUCE"></a> \[ \f {greduce}(exp, \{exp1, exp2, \ldots , expm\}]); \] where <span 
class="ptmri8t-x-x-109">exp </span>is an expression, and \(\{exp1, exp2,\ldots , expm\}\) is a list of any number of expressions or equations.
</p><!--l. 783--><p class="noindent" ><span 
class="pcrr8t-x-x-109">greduce </span>ﬁrst converts the list of expressions \(\{exp1, \ldots , expn\}\) to a Gröbner basis, and then reduces the
given expression modulo that basis. An error results if the list of expressions is
inconsistent. The returned value is an expression representing the reduced polynomial.
As a side eﬀect, <span 
class="pcrr8t-x-x-109">greduce </span>sets the variable <span 
class="pcrr8t-x-x-109">gvarslast </span>in the same manner as
<span 
class="pcrr8t-x-x-109">groebner </span>does.
</p><!--l. 790--><p class="noindent" >
</p>
<h5 class="likesubsubsectionHead"><a 
 id="x213-7620002"></a>Reduction with Respect to Arbitrary Polynomials</h5>
<a 
 id="dx213-762001"></a>
<!--l. 792--><p class="noindent" ><a 
 id="operator:PREDUCE"></a> \[ \f {preduce}(exp, \{exp1, exp2,\ldots , expm\}); \] where <span 
class="ptmri8t-x-x-109">expm </span>is an expression, and \(\{exp1, exp2, \ldots , expm\}\) is a list of any number of expressions or
equations.
</p><!--l. 799--><p class="noindent" ><span 
class="pcrr8t-x-x-109">preduce </span>reduces the given expression modulo the set \(\{exp1, \ldots , expm\}\). If this set is a Gröbner basis,
                                                                     

                                                                     
the obtained reduced expression is uniquely determined. If not, then it depends on the
subsequence of the single reduction steps (see <a 
href="manual-lookup.php%3FGROEBNER:.html#x213-7600002">2<!--tex4ht:ref: groebner:background --></a>). <span 
class="pcrr8t-x-x-109">preduce </span>does not check whether \(\{exp1, exp2, \ldots , expm\}\) is
a Gröbner basis in the actual order. Therefore, if the expressions are a Gröbner
basis calculated earlier with a variable sequence given explicitly or modiﬁed by
optimization, the proper variable sequence and term order must be activated
ﬁrst.
<a 
 id="x213-762002r3"></a>
</p><!--l. 810--><p class="noindent" ><span 
class="ptmb8t-x-x-109">Example 3</span>(<span 
class="pcrr8t-x-x-109">preduce </span>called with a Gröbner basis):
                                                                     

                                                                     
</p>
<pre class="verbatim" id="verbatim-1145">
  torder({x,y},lex);
  gb:=groebner{3*x**2*y + 2*x*y + y + 9*x**2 + 5*x - 3,
               2*x**3*y - x*y - y + 6*x**3 - 2*x**2 - 3*x + 3,
               x**3*y + x**2*y + 3*x**3 + 2*x**2}$
  preduce (5*y**2 + 2*x**2*y + 5/2*x*y + 3/2*y
&#x003C;             + 8*x**2 + 3/2*x - 9/2, gb);

      2
     y
</pre>
<!--l. 821--><p class="nopar" >
</p><!--l. 823--><p class="noindent" >
</p>
<h5 class="likesubsubsectionHead"><a 
 id="x213-7630003"></a><span 
class="pcrr8t-x-x-109">greduce_orders</span>: Reduction with several term orders</h5>
<!--l. 824--><p class="noindent" >The shortest polynomial with diﬀerent polynomial term orders is computed with the
operator <span 
class="pcrr8t-x-x-109">greduce_orders</span>:
<a 
 id="dx213-763001"></a>
     </p><dl class="description"><dt class="description">
     <!--l. 830--><p class="noindent" >
<span 
class="pcrr8t-x-x-109">greduce_orders</span><span 
class="ptmb8t-x-x-109">(</span>\(exp\)<span 
class="ptmb8t-x-x-109">, {</span>\(exp1\)<span 
class="ptmb8t-x-x-109">,</span> \(exp2\)<span 
class="ptmb8t-x-x-109">, </span><span 
class="ptmb8t-x-x-109">…,</span> \(expm\)<span 
class="ptmb8t-x-x-109">} [,{</span>\(v_1,v_2,\ldots ,v_n\)<span 
class="ptmb8t-x-x-109">}]);</span> </p></dt><dd 
class="description">
     <!--l. 830--><p class="noindent" ><br 
class="newline" /><a 
 id="operator:GREDUCE_ORDERS"></a> where <span 
class="ptmri8t-x-x-109">exp </span>is an expression and \(\{exp1, exp2,\ldots , expm\}\) is a list of any number of expressions or
     equations. The list of variables \(v_1,v_2 \ldots v_n\) may be omitted; if set, the variables must be
     a list.</p></dd></dl>
<a 
 id="dx213-763002"></a>
<!--l. 838--><p class="noindent" ><a 
 id="reserved:GORDERS"></a> The expression <span 
class="ptmri8t-x-x-109">exp </span>is reduced by <span 
class="pcrr8t-x-x-109">greduce </span>with the orders in the shared variable
<span 
class="pcrr8t-x-x-109">gorders</span>, which must be a list of term orders (if set). By default it is set to
</p>
                                                                     

                                                                     
<div class="center" 
>
<!--l. 843--><p class="noindent" >
</p><!--l. 844--><p class="noindent" >{<span 
class="ptmri8t-x-x-109">revgradlex</span>, <span 
class="ptmri8t-x-x-109">gradlex</span>, <span 
class="ptmri8t-x-x-109">lex</span>}</p></div>
<!--l. 847--><p class="noindent" >The shortest polynomial is the result. The order with the shortest polynomial is set to the
shared variable <span 
class="pcrr8t-x-x-109">gorder</span>. A Gröbner basis of the system {\(exp1\), \(exp2\), …, \(expm\)} is computed for each
element of <span 
class="ptmri8t-x-x-109">orders</span>. With the default setting <span 
class="pcrr8t-x-x-109">gorders </span>in most cases will be set to
<span 
class="ptmri8t-x-x-109">revgradlex</span>. If the variable set is given, these variables are taken; otherwise all variables
of the system {\(exp1\), \(exp2\), …, \(expm\)} are extracted.
<a 
 id="dx213-763003"></a>
</p><!--l. 858--><p class="noindent" ><a 
 id="reserved:GREDUCE_RESULT"></a> The Gröbner basis computations can take some time; if interrupted, the intermediate
result of the reduction is set to the shared variable <span 
class="pcrr8t-x-x-109">greduce_result</span>, if one is done
already. However, this is not nesessarily the minimal form.
</p><!--l. 864--><p class="noindent" >If the variable <span 
class="pcrr8t-x-x-109">gorders </span>should be set to orders with a parameter, the term oder has to be
replaced by a list; the ﬁrst element is the term oder selected, followed by its parameter(s),
e.g.
</p>
<div class="center" 
>
<!--l. 868--><p class="noindent" >
</p><!--l. 869--><p class="noindent" ><span 
class="ptmri8t-x-x-109">orders </span>:= {{<span 
class="ptmri8t-x-x-109">gradlexgradlex</span>, 2}, {<span 
class="ptmri8t-x-x-109">lexgradlex</span>, 2}}</p></div>
<!--l. 872--><p class="noindent" >
</p>
<h5 class="likesubsubsectionHead"><a 
 id="x213-7640003"></a>Reduction Tree</h5>
<!--l. 873--><p class="noindent" >In some case not only are the results produced by <span 
class="pcrr8t-x-x-109">greduce </span>and <span 
class="pcrr8t-x-x-109">preduce </span>of interest,
but the reduction process is of some value too. If the switch <a 
 id="dx213-764001"></a><a 
 id="dx213-764002"></a><a 
 id="dx213-764003"></a> <a 
 id="switch:GROEBPROT"></a> </p>
<div class="center" 
>
<!--l. 878--><p class="noindent" >
</p><!--l. 879--><p class="noindent" ><span 
class="pcrr8t-x-x-109">groebprot</span></p></div>
                                                                     

                                                                     
<!--l. 881--><p class="noindent" >is set on, <span 
class="pcrr8t-x-x-109">groebner</span>, <span 
class="pcrr8t-x-x-109">greduce </span>and <span 
class="pcrr8t-x-x-109">preduce </span>produce as a side eﬀect a trace of their
work as a REDUCE list of equations in the shared variable <a 
 id="dx213-764004"></a> <a 
 id="reserved:GROEBPROTFILE"></a> </p>
<div class="center" 
>
<!--l. 885--><p class="noindent" >
</p><!--l. 886--><p class="noindent" ><span 
class="pcrr8t-x-x-109">groebprotfile</span>.</p></div>
<!--l. 888--><p class="noindent" >Its value is a list of equations with a variable “candidate” playing the role of the object to
be reduced. The polynomials are cited as “<span 
class="ptmri8t-x-x-109">poly1</span>”, “<span 
class="ptmri8t-x-x-109">poly2</span>”, … . If read as assignments,
these equations form a program which leads from the reduction input to its result. Note
that, due to the pseudo reduction with a ring as the coeﬃcient domain, the input
coeﬃcients may be changed by global factors.
<a 
 id="x213-764005r4"></a>
</p><!--l. 895--><p class="noindent" ><span 
class="ptmb8t-x-x-109">Example 4</span><a 
 id="dx213-764006"></a>
</p>
<div class="alltt">
<div class="obeylines-v">
<span 
class="pcrr8t-x-x-109"> </span><span 
class="pcrr8t-x-x-109"> on</span><span 
class="pcrr8t-x-x-109"> groebprot$</span><span 
class="pcrr8t-x-x-109"> </span><br 
class="newline" />
<br /><span 
class="pcrr8t-x-x-109"> </span><span 
class="pcrr8t-x-x-109"> preduce(5*y**2</span><span 
class="pcrr8t-x-x-109"> +</span><span 
class="pcrr8t-x-x-109"> 2*x**2*y</span><span 
class="pcrr8t-x-x-109"> +</span><span 
class="pcrr8t-x-x-109"> 5/2*x*y</span><span 
class="pcrr8t-x-x-109"> +</span><span 
class="pcrr8t-x-x-109"> 3/2*y</span><span 
class="pcrr8t-x-x-109"> +</span><span 
class="pcrr8t-x-x-109"> 8*x**2</span><span 
class="pcrr8t-x-x-109"> </span><br 
class="newline" />
<br /><span 
class="pcrr8t-x-x-109"> </span><span 
class="pcrr8t-x-x-109">     </span><span 
class="pcrr8t-x-x-109"> +</span><span 
class="pcrr8t-x-x-109"> 3/2*x</span><span 
class="pcrr8t-x-x-109"> -</span><span 
class="pcrr8t-x-x-109"> 9/2,</span><span 
class="pcrr8t-x-x-109"> gb);</span><br 
class="newline" />
<br />
<br /><span 
class="pcrr8t-x-x-109"> </span><span 
class="pcrr8t-x-x-109"> </span><span 
class="pcrr8t-x-x-109"> </span><span 
class="pcrr8t-x-x-109"> </span><span 
class="pcrr8t-x-x-109"> </span><span 
class="pcrr8t-x-x-109"> 2</span>
<br /><span 
class="pcrr8t-x-x-109"> </span><span 
class="pcrr8t-x-x-109"> </span><span 
class="pcrr8t-x-x-109"> </span><span 
class="pcrr8t-x-x-109"> </span><span 
class="pcrr8t-x-x-109"> y</span>
<br />
<br /><span 
class="pcrr8t-x-x-109">groebprotfile;</span>
<br />
<br /><span 
class="pcrr8t-x-x-109"> </span><span 
class="pcrr8t-x-x-109"> </span><span 
class="pcrr8t-x-x-109"> </span><span 
class="pcrr8t-x-x-109"> </span><span 
class="pcrr8t-x-x-109"> </span><span 
class="pcrr8t-x-x-109"> </span><span 
class="pcrr8t-x-x-109"> </span><span 
class="pcrr8t-x-x-109"> </span><span 
class="pcrr8t-x-x-109"> </span><span 
class="pcrr8t-x-x-109"> </span><span 
class="pcrr8t-x-x-109"> </span><span 
class="pcrr8t-x-x-109"> </span><span 
class="pcrr8t-x-x-109"> </span><span 
class="pcrr8t-x-x-109"> </span><span 
class="pcrr8t-x-x-109"> </span><span 
class="pcrr8t-x-x-109"> </span><span 
class="pcrr8t-x-x-109"> </span><span 
class="pcrr8t-x-x-109"> 2</span><span 
class="pcrr8t-x-x-109"> </span><span 
class="pcrr8t-x-x-109"> </span><span 
class="pcrr8t-x-x-109"> </span><span 
class="pcrr8t-x-x-109"> </span><span 
class="pcrr8t-x-x-109"> </span><span 
class="pcrr8t-x-x-109"> </span><span 
class="pcrr8t-x-x-109"> </span><span 
class="pcrr8t-x-x-109"> </span><span 
class="pcrr8t-x-x-109"> 2</span><span 
class="pcrr8t-x-x-109"> </span><span 
class="pcrr8t-x-x-109"> </span><span 
class="pcrr8t-x-x-109"> </span><span 
class="pcrr8t-x-x-109"> </span><span 
class="pcrr8t-x-x-109"> </span><span 
class="pcrr8t-x-x-109"> </span><span 
class="pcrr8t-x-x-109"> </span><span 
class="pcrr8t-x-x-109"> </span><span 
class="pcrr8t-x-x-109"> </span><span 
class="pcrr8t-x-x-109"> </span><span 
class="pcrr8t-x-x-109"> </span><span 
class="pcrr8t-x-x-109"> </span><span 
class="pcrr8t-x-x-109"> </span><span 
class="pcrr8t-x-x-109"> </span><span 
class="pcrr8t-x-x-109"> </span><span 
class="pcrr8t-x-x-109"> </span><span 
class="pcrr8t-x-x-109"> </span><span 
class="pcrr8t-x-x-109"> </span><span 
class="pcrr8t-x-x-109"> </span><span 
class="pcrr8t-x-x-109"> </span><span 
class="pcrr8t-x-x-109"> 2</span>
<br /><span 
class="pcrr8t-x-x-109"> </span><span 
class="pcrr8t-x-x-109"> </span><span 
class="pcrr8t-x-x-109"> </span><span 
class="pcrr8t-x-x-109"> candidate=4*x</span><span 
class="pcrr8t-x-x-109"> *y</span><span 
class="pcrr8t-x-x-109"> +</span><span 
class="pcrr8t-x-x-109"> 16*x</span><span 
class="pcrr8t-x-x-109"> </span><span 
class="pcrr8t-x-x-109"> +</span><span 
class="pcrr8t-x-x-109"> 5*x*y</span><span 
class="pcrr8t-x-x-109"> +</span><span 
class="pcrr8t-x-x-109"> 3*x</span><span 
class="pcrr8t-x-x-109"> +</span><span 
class="pcrr8t-x-x-109"> 10*y</span><span 
class="pcrr8t-x-x-109"> </span><span 
class="pcrr8t-x-x-109"> +</span><span 
class="pcrr8t-x-x-109"> 3*y</span><span 
class="pcrr8t-x-x-109"> -</span><span 
class="pcrr8t-x-x-109"> 9,</span>
<br />
<br /><span 
class="pcrr8t-x-x-109"> </span><span 
class="pcrr8t-x-x-109"> </span><span 
class="pcrr8t-x-x-109"> </span><span 
class="pcrr8t-x-x-109"> </span><span 
class="pcrr8t-x-x-109"> </span><span 
class="pcrr8t-x-x-109"> </span><span 
class="pcrr8t-x-x-109"> </span><span 
class="pcrr8t-x-x-109"> </span><span 
class="pcrr8t-x-x-109"> </span><span 
class="pcrr8t-x-x-109"> </span><span 
class="pcrr8t-x-x-109"> </span><span 
class="pcrr8t-x-x-109"> </span><span 
class="pcrr8t-x-x-109"> </span><span 
class="pcrr8t-x-x-109"> 2</span>
<br /><span 
class="pcrr8t-x-x-109"> </span><span 
class="pcrr8t-x-x-109"> </span><span 
class="pcrr8t-x-x-109"> </span><span 
class="pcrr8t-x-x-109"> </span><span 
class="pcrr8t-x-x-109"> poly1=8*x</span><span 
class="pcrr8t-x-x-109"> -</span><span 
class="pcrr8t-x-x-109"> 2*y</span><span 
class="pcrr8t-x-x-109"> </span><span 
class="pcrr8t-x-x-109"> +</span><span 
class="pcrr8t-x-x-109"> 5*y</span><span 
class="pcrr8t-x-x-109"> +</span><span 
class="pcrr8t-x-x-109"> 3,</span>
<br />
                                                                     

                                                                     
<br /><span 
class="pcrr8t-x-x-109"> </span><span 
class="pcrr8t-x-x-109"> </span><span 
class="pcrr8t-x-x-109"> </span><span 
class="pcrr8t-x-x-109"> </span><span 
class="pcrr8t-x-x-109"> </span><span 
class="pcrr8t-x-x-109"> </span><span 
class="pcrr8t-x-x-109"> </span><span 
class="pcrr8t-x-x-109"> </span><span 
class="pcrr8t-x-x-109"> </span><span 
class="pcrr8t-x-x-109"> </span><span 
class="pcrr8t-x-x-109"> </span><span 
class="pcrr8t-x-x-109"> </span><span 
class="pcrr8t-x-x-109"> </span><span 
class="pcrr8t-x-x-109"> 3</span><span 
class="pcrr8t-x-x-109"> </span><span 
class="pcrr8t-x-x-109"> </span><span 
class="pcrr8t-x-x-109"> </span><span 
class="pcrr8t-x-x-109"> </span><span 
class="pcrr8t-x-x-109"> </span><span 
class="pcrr8t-x-x-109"> 2</span>
<br /><span 
class="pcrr8t-x-x-109"> </span><span 
class="pcrr8t-x-x-109"> </span><span 
class="pcrr8t-x-x-109"> </span><span 
class="pcrr8t-x-x-109"> </span><span 
class="pcrr8t-x-x-109"> poly2=2*y</span><span 
class="pcrr8t-x-x-109"> </span><span 
class="pcrr8t-x-x-109"> -</span><span 
class="pcrr8t-x-x-109"> 3*y</span><span 
class="pcrr8t-x-x-109"> </span><span 
class="pcrr8t-x-x-109"> -</span><span 
class="pcrr8t-x-x-109"> 16*y</span><span 
class="pcrr8t-x-x-109"> +</span><span 
class="pcrr8t-x-x-109"> 21,</span>
<br /><span 
class="pcrr8t-x-x-109"> </span><span 
class="pcrr8t-x-x-109"> </span><span 
class="pcrr8t-x-x-109"> </span><span 
class="pcrr8t-x-x-109"> </span><span 
class="pcrr8t-x-x-109"> candidate=2*candidate,</span>
<br /><span 
class="pcrr8t-x-x-109"> </span><span 
class="pcrr8t-x-x-109"> </span><span 
class="pcrr8t-x-x-109"> </span><span 
class="pcrr8t-x-x-109"> </span><span 
class="pcrr8t-x-x-109"> candidate=</span><span 
class="pcrr8t-x-x-109"> -</span><span 
class="pcrr8t-x-x-109"> x*y*poly1</span><span 
class="pcrr8t-x-x-109"> +</span><span 
class="pcrr8t-x-x-109"> candidate,</span>
<br /><span 
class="pcrr8t-x-x-109"> </span><span 
class="pcrr8t-x-x-109"> </span><span 
class="pcrr8t-x-x-109"> </span><span 
class="pcrr8t-x-x-109"> </span><span 
class="pcrr8t-x-x-109"> candidate=</span><span 
class="pcrr8t-x-x-109"> -</span><span 
class="pcrr8t-x-x-109"> 4*x*poly1</span><span 
class="pcrr8t-x-x-109"> +</span><span 
class="pcrr8t-x-x-109"> candidate,</span>
<br /><span 
class="pcrr8t-x-x-109"> </span><span 
class="pcrr8t-x-x-109"> </span><span 
class="pcrr8t-x-x-109"> </span><span 
class="pcrr8t-x-x-109"> </span><span 
class="pcrr8t-x-x-109"> candidate=4*candidate,</span>
<br />
<br /><span 
class="pcrr8t-x-x-109"> </span><span 
class="pcrr8t-x-x-109"> </span><span 
class="pcrr8t-x-x-109"> </span><span 
class="pcrr8t-x-x-109"> </span><span 
class="pcrr8t-x-x-109"> </span><span 
class="pcrr8t-x-x-109"> </span><span 
class="pcrr8t-x-x-109"> </span><span 
class="pcrr8t-x-x-109"> </span><span 
class="pcrr8t-x-x-109"> </span><span 
class="pcrr8t-x-x-109"> </span><span 
class="pcrr8t-x-x-109"> </span><span 
class="pcrr8t-x-x-109"> </span><span 
class="pcrr8t-x-x-109"> </span><span 
class="pcrr8t-x-x-109"> </span><span 
class="pcrr8t-x-x-109"> </span><span 
class="pcrr8t-x-x-109"> </span><span 
class="pcrr8t-x-x-109"> </span><span 
class="pcrr8t-x-x-109"> </span><span 
class="pcrr8t-x-x-109"> 3</span>
<br /><span 
class="pcrr8t-x-x-109"> </span><span 
class="pcrr8t-x-x-109"> </span><span 
class="pcrr8t-x-x-109"> </span><span 
class="pcrr8t-x-x-109"> </span><span 
class="pcrr8t-x-x-109"> candidate=</span><span 
class="pcrr8t-x-x-109"> -</span><span 
class="pcrr8t-x-x-109"> y</span><span 
class="pcrr8t-x-x-109"> *poly1</span><span 
class="pcrr8t-x-x-109"> +</span><span 
class="pcrr8t-x-x-109"> candidate,</span>
<br /><span 
class="pcrr8t-x-x-109"> </span><span 
class="pcrr8t-x-x-109"> </span><span 
class="pcrr8t-x-x-109"> </span><span 
class="pcrr8t-x-x-109"> </span><span 
class="pcrr8t-x-x-109"> candidate=2*candidate,</span>
<br />
<br /><span 
class="pcrr8t-x-x-109"> </span><span 
class="pcrr8t-x-x-109"> </span><span 
class="pcrr8t-x-x-109"> </span><span 
class="pcrr8t-x-x-109"> </span><span 
class="pcrr8t-x-x-109"> </span><span 
class="pcrr8t-x-x-109"> </span><span 
class="pcrr8t-x-x-109"> </span><span 
class="pcrr8t-x-x-109"> </span><span 
class="pcrr8t-x-x-109"> </span><span 
class="pcrr8t-x-x-109"> </span><span 
class="pcrr8t-x-x-109"> </span><span 
class="pcrr8t-x-x-109"> </span><span 
class="pcrr8t-x-x-109"> </span><span 
class="pcrr8t-x-x-109"> </span><span 
class="pcrr8t-x-x-109"> </span><span 
class="pcrr8t-x-x-109"> </span><span 
class="pcrr8t-x-x-109"> </span><span 
class="pcrr8t-x-x-109"> </span><span 
class="pcrr8t-x-x-109"> </span><span 
class="pcrr8t-x-x-109"> </span><span 
class="pcrr8t-x-x-109"> 2</span>
<br /><span 
class="pcrr8t-x-x-109"> </span><span 
class="pcrr8t-x-x-109"> </span><span 
class="pcrr8t-x-x-109"> </span><span 
class="pcrr8t-x-x-109"> </span><span 
class="pcrr8t-x-x-109"> candidate=</span><span 
class="pcrr8t-x-x-109"> -</span><span 
class="pcrr8t-x-x-109"> 3*y</span><span 
class="pcrr8t-x-x-109"> *poly1</span><span 
class="pcrr8t-x-x-109"> +</span><span 
class="pcrr8t-x-x-109"> candidate,</span>
<br /><span 
class="pcrr8t-x-x-109"> </span><span 
class="pcrr8t-x-x-109"> </span><span 
class="pcrr8t-x-x-109"> </span><span 
class="pcrr8t-x-x-109"> </span><span 
class="pcrr8t-x-x-109"> candidate=13*y*poly1</span><span 
class="pcrr8t-x-x-109"> +</span><span 
class="pcrr8t-x-x-109"> candidate,</span>
<br /><span 
class="pcrr8t-x-x-109"> </span><span 
class="pcrr8t-x-x-109"> </span><span 
class="pcrr8t-x-x-109"> </span><span 
class="pcrr8t-x-x-109"> </span><span 
class="pcrr8t-x-x-109"> candidate=candidate</span><span 
class="pcrr8t-x-x-109"> +</span><span 
class="pcrr8t-x-x-109"> 6*poly1,</span>
<br />
<br /><span 
class="pcrr8t-x-x-109"> </span><span 
class="pcrr8t-x-x-109"> </span><span 
class="pcrr8t-x-x-109"> </span><span 
class="pcrr8t-x-x-109"> </span><span 
class="pcrr8t-x-x-109"> </span><span 
class="pcrr8t-x-x-109"> </span><span 
class="pcrr8t-x-x-109"> </span><span 
class="pcrr8t-x-x-109"> </span><span 
class="pcrr8t-x-x-109"> </span><span 
class="pcrr8t-x-x-109"> </span><span 
class="pcrr8t-x-x-109"> </span><span 
class="pcrr8t-x-x-109"> </span><span 
class="pcrr8t-x-x-109"> </span><span 
class="pcrr8t-x-x-109"> </span><span 
class="pcrr8t-x-x-109"> </span><span 
class="pcrr8t-x-x-109"> </span><span 
class="pcrr8t-x-x-109"> </span><span 
class="pcrr8t-x-x-109"> </span><span 
class="pcrr8t-x-x-109"> </span><span 
class="pcrr8t-x-x-109"> </span><span 
class="pcrr8t-x-x-109"> 2</span>
<br /><span 
class="pcrr8t-x-x-109"> </span><span 
class="pcrr8t-x-x-109"> </span><span 
class="pcrr8t-x-x-109"> </span><span 
class="pcrr8t-x-x-109"> </span><span 
class="pcrr8t-x-x-109"> candidate=</span><span 
class="pcrr8t-x-x-109"> -</span><span 
class="pcrr8t-x-x-109"> 2*y</span><span 
class="pcrr8t-x-x-109"> *poly2</span><span 
class="pcrr8t-x-x-109"> +</span><span 
class="pcrr8t-x-x-109"> candidate,</span>
<br /><span 
class="pcrr8t-x-x-109"> </span><span 
class="pcrr8t-x-x-109"> </span><span 
class="pcrr8t-x-x-109"> </span><span 
class="pcrr8t-x-x-109"> </span><span 
class="pcrr8t-x-x-109"> candidate=</span><span 
class="pcrr8t-x-x-109"> -</span><span 
class="pcrr8t-x-x-109"> y*poly2</span><span 
class="pcrr8t-x-x-109"> +</span><span 
class="pcrr8t-x-x-109"> candidate,</span>
<br /><span 
class="pcrr8t-x-x-109"> </span><span 
class="pcrr8t-x-x-109"> </span><span 
class="pcrr8t-x-x-109"> </span><span 
class="pcrr8t-x-x-109"> </span><span 
class="pcrr8t-x-x-109"> candidate=candidate</span><span 
class="pcrr8t-x-x-109"> +</span><span 
class="pcrr8t-x-x-109"> 6*poly2</span>
</div>
</div> This means \[ 16 (5 y^2 + 2 x^2 y + \frac {5}{2} x y + \frac {3}{2} y + 8 x^2+ \frac {3}{2} x - \frac {9}{2})= \] \[ (-8 x y -32 x -2 y^3 -3 y^2 + 13 y + 6)\,\mbox {poly1} \] \[ \mbox {} + (-2 y^2 -2 y + 6)\,\mbox {poly2} + y^2. \]
<!--l. 946--><p class="noindent" >
</p>
<h5 class="subsubsectionHead"><a 
 id="x213-7650004"></a>Tracing with <span 
class="pcrr8t-x-x-109">groebnert </span>and <span 
class="pcrr8t-x-x-109">preducet</span></h5>
<!--l. 947--><p class="noindent" >Given a set of polynomials \(\{f_1,\ldots ,f_k\}\) and their Gröbner basis \(\{g_1,\ldots ,g_l\}\), it is well known that there are
matrices of polynomials \(C_{ij}\) and \(D_{ji}\) such that \[ f_i = \displaystyle {\sum \limits _j} C_{ij} g_j \;\mbox { and } g_j = \displaystyle {\sum \limits _i} D_{ji} f_i \] and these relations are needed explicitly
sometimes. In <span 
class="ptmrc8t-x-x-109">B<span 
class="small-caps">U</span><span 
class="small-caps">C</span><span 
class="small-caps">H</span><span 
class="small-caps">B</span><span 
class="small-caps">E</span><span 
class="small-caps">R</span><span 
class="small-caps">G</span><span 
class="small-caps">E</span><span 
class="small-caps">R</span> </span><span class="cite">[<a 
href="manual/manualap2.html#XBuchberger:85">Buc85</a>]</span>, such cases are described in the context of linear
polynomial equations. The standard technique for computing the above formulae is to
perform Gröbner reductions, keeping track of the computation in terms of the input
data. In the current package such calculations are performed with (an internally hidden)
cofactor technique: the user has to assign unique names to the input expressions and the
arithmetic combinations are done with the expressions and with their names
simultaneously. So the result is accompanied by an expression which relates it
algebraically to the input values.
<a 
 id="dx213-765001"></a>
<a 
 id="dx213-765002"></a>
</p><!--l. 968--><p class="noindent" ><a 
 id="operator:GROEBNERT"></a> <a 
 id="operator:PREDUCET"></a> There are two complementary operators with this feature: <span 
class="pcrr8t-x-x-109">groebnert </span>and
<span 
class="pcrr8t-x-x-109">preducet</span>; functionally they correspond to <span 
class="pcrr8t-x-x-109">groebner </span>and <span 
class="pcrr8t-x-x-109">preduce</span>. However, the
                                                                     

                                                                     
sets of expressions here <span 
class="ptmbi8t-x-x-109">must be </span>equations with unique single identiﬁers on
their left side and the <span 
class="ptmri8t-x-x-109">lhs </span>are interpreted as names of the expressions. Their
results are sets of equations (<span 
class="pcrr8t-x-x-109">groebnert</span>) or equations (<span 
class="pcrr8t-x-x-109">preducet</span>), where a
<span 
class="ptmri8t-x-x-109">lhs </span>is the computed value, while the <span 
class="ptmri8t-x-x-109">rhs </span>is its equivalent in terms of the input
names.
<a 
 id="x213-765003r5"></a>
</p><!--l. 979--><p class="noindent" ><span 
class="ptmb8t-x-x-109">Example 5</span><a 
 id="dx213-765004"></a>
</p><!--l. 981--><p class="noindent" >We calculate the Gröbner basis for an ellipse (named “\(p1\)” ) and a line (named “\(p2\)” ); \(p2\) is
member of the basis immediately and so the corresponding ﬁrst result element is of a
very simple form; the second member is a combination of \(p1\) and \(p2\) as shown on the <span 
class="ptmri8t-x-x-109">rhs </span>of
this equation:
                                                                     

                                                                     
</p>
<pre class="verbatim" id="verbatim-1146">
gb1:=groebnert {p1=2*x**2+4*y**2-100,p2=2*x-y+1};

gb1 := {2*x - y + 1=p2,
           2
        9*y  - 2*y - 199= - 2*x*p2 - y*p2 + 2*p1 + p2}
</pre>
<!--l. 993--><p class="nopar" >
<a 
 id="x213-765005r6"></a>
</p><!--l. 995--><p class="noindent" ><span 
class="ptmb8t-x-x-109">Example 6</span><a 
 id="dx213-765006"></a>
</p><!--l. 997--><p class="noindent" >We want to reduce the polynomial <span 
class="pcrr8t-x-x-109">x**2 </span><span 
class="ptmri8t-x-x-109">wrt </span>the above Gröbner basis and need
knowledge about the reduction formula. We therefore extract the basis polynomials from
\(gb1\), assign unique names to them (here \(g1\), \(g2\)) and call <span 
class="pcrr8t-x-x-109">preducet</span>. The polynomial to be
reduced here is introduced with the name \(Q\), which then appears on the <span 
class="ptmri8t-x-x-109">rhs </span>of the result. If
the name for the polynomial is omitted, its formal value is used on the right side
too.
                                                                     

                                                                     
</p>
<pre class="verbatim" id="verbatim-1147">
  gb2 := for k := 1:length gb1 collect
        mkid(g,k) = lhs part(gb1,k)$
  preducet (q=x**2,gb2);

 - 16*y + 208= - 18*x*g1 - 9*y*g1 + 36*q + 9*g1 - g2
</pre>
<!--l. 1011--><p class="nopar" >
</p><!--l. 1013--><p class="noindent" >This output means \[ x^2 = (\frac {1}{2} x + \frac {1}{4} y - \frac {1}{4}) g1 + \frac {1}{36} g2 + (-\frac {4}{9} y + \frac {52}{9}). \]
<a 
 id="x213-765007r7"></a>
</p><!--l. 1020--><p class="noindent" ><span 
class="ptmb8t-x-x-109">Example 7</span><a 
 id="dx213-765008"></a>
</p><!--l. 1022--><p class="noindent" >If we reduce a polynomial which is member of the ideal, we consequently get a result
with <span 
class="ptmri8t-x-x-109">lhs </span>zero:
                                                                     

                                                                     
</p>
<pre class="verbatim" id="verbatim-1148">
   preducet(q=2*x**2+4*y**2-100,gb2);

   0= - 2*x*g1 - y*g1 + 2*q + g1 - g2
</pre>
<!--l. 1028--><p class="nopar" >
</p><!--l. 1030--><p class="noindent" >This means \[ q = ( x + \frac {1}{2} y - \frac {1}{2}) g1 + \frac {1}{2} g2. \]
</p><!--l. 1034--><p class="noindent" >With these operators the matrices \(C_{ij}\) and \(D_{ji}\) are available implicitly, \(D_{ji}\) as side eﬀect of
<span 
class="pcrr8t-x-x-109">groebnert</span>, \(c_{ij}\) by <span 
class="ptmri8t-x-x-109">calls </span>of <span 
class="pcrr8t-x-x-109">preducet </span>of \(f_i\) <span 
class="ptmri8t-x-x-109">wrt</span> \(\{g_j\}\). The latter by deﬁnition will have the <span 
class="ptmri8t-x-x-109">lhs</span>
zero and a <span 
class="ptmri8t-x-x-109">rhs </span>with linear \(f_i\).
</p><!--l. 1039--><p class="noindent" >If \(\{1\}\) is the Gröbner basis, the <span 
class="pcrr8t-x-x-109">groebnert </span>calculation gives a “proof”, showing, how \(1\)
can be computed as combination of the input polynomials.
</p>
<!--l. 1043--><p class="noindent" ><span class="paragraphHead"><a 
 id="x213-7660007"></a><span 
class="ptmb8t-x-x-109">Remark:</span></span>
Compared to the non-tracing algorithms, these operators are much more time consuming.
So they are applicable only on small sized problems.
</p><!--l. 1047--><p class="noindent" >
</p>
<h5 class="subsubsectionHead"><a 
 id="x213-7670007"></a>Gröbner Bases for Modules</h5>
<!--l. 1049--><p class="noindent" >Given a polynomial ring, e.g. \(r=z[x_1 \cdots x_k]\) and an integer \(n&gt;1\): the vectors with \(n\) elements of \(r\) form a
<span 
class="ptmri8t-x-x-109">module </span>under vector addition (= componentwise addition) and multiplication with
elements of \(r\). For a submodule given by a ﬁnite basis a Gröbner basis can be computed,
and the facilities of the <span 
class="ptmrc8t-x-x-109">G<span 
class="small-caps">R</span><span 
class="small-caps">O</span><span 
class="small-caps">E</span><span 
class="small-caps">B</span><span 
class="small-caps">N</span><span 
class="small-caps">E</span><span 
class="small-caps">R</span> </span>package can be used except the operators
<span 
class="pcrr8t-x-x-109">groebnerf </span>and <span 
class="pcrr8t-x-x-109">groesolve</span>.
</p><!--l. 1057--><p class="noindent" >The vectors are encoded using auxiliary variables which represent the unit vectors in the
module. E.g. using \(v_1,v_2,v_3\) the module element \([x_1^2,0,x_1-x_2]\) is represented as \(x_1^2 v_1 + x_1 v_3 - x_2 v_3\). The use of \(v_1,v_2,v_3\) as unit vectors is
set up by assigning the set of auxiliary variables to the shared variable <a 
 id="reserved:GMODULE"></a><span 
class="pcrr8t-x-x-109">gmodule</span><a 
 id="dx213-767001"></a>,
e.g.
                                                                     

                                                                     
</p>
<pre class="verbatim" id="verbatim-1149">
   gmodule := {v1,v2,v3};
</pre>
<!--l. 1065--><p class="nopar" > After this declaration all monomials built from these variables are considered as an
algebraically independent basis of a vector space. However, you had best use them only
linearly. Once <span 
class="ptmri8t-x-x-109">gmodule </span>has been set, the auxiliary variables automatically will
be added to the end of each variable list (if they are not yet member there).
Example:
                                                                     

                                                                     
</p>
<pre class="verbatim" id="verbatim-1150">
   torder({x,y,v1,v2,v3},lex)$
   gmodule := {v1,v2,v3}$
   g:=groebner{x^2*v1 + y*v2,x*y*v1 - v3,2y*v1 + y*v3};

       2
g := {x *v1 + y*v2,

              2
      x*v3 + y *v2,

       3
      y *v2 - 2*v3,

      2*y*v1 + y*v3}

   preduce((x+y)^3*v1,g);

             1   3         2
 - x*y*v2 - ---*y *v3 - 3*y *v2 + 3*y*v3
             2
</pre>
<!--l. 1094--><p class="nopar" >
</p><!--l. 1096--><p class="noindent" >In many cases a total degree oriented term order will be adequate for computations in
modules, e.g. for all cases where the submodule membership is investigated. However,
arranging the auxiliary variables in an elimination oriented term order can give
interesting results. E.g.
                                                                     

                                                                     
</p>
<pre class="verbatim" id="verbatim-1151">
   p1:=(x-1)*(x^2-x+3)$  p2:=(x-1)*(x^2+x-5)$
   gmodule := {v1,v2,v3};
   torder({v1,x,v2,v3},lex)$
   gb:=groebner {p1*v1+v2,p2*v1+v3};

gb := {30*v1*x - 30*v1 + x*v2 - x*v3 + 5*v2 - 3*v3,

        2       2
       x *v2 - x *v3 + x*v2 + x*v3 - 5*v2 - 3*v3}

   g:=coeffn(first gb,v1,1);

g := 30*(x - 1)

   c1:=coeffn(first gb,v2,1);

c1 := x + 5

   c2:=coeffn(first gb,v3,1);

c2 :=  - x - 3

   c1*p1 + c2*p2;

30*(x - 1)
</pre>
<!--l. 1127--><p class="nopar" > Here two polynomials are entered as vectors \([p_1,1,0]\) and \([p_2,0,1]\). Using a term ordering such that the
ﬁrst dimension ranges highest and the other components lowest, a classical cofactor
computation is executed just as in the extended Euclidean algorithm. Consequently the
leading polynomial in the resulting basis shows the greatest common divisor of \(p_1\) and \(p_2\),
found as a coeﬃcient of \(v_1\) while the coeﬃcients of \(v_2\) and \(v_3\) are the cofactors \(c_1\) and \(c_2\) of the
polynomials \(p_1\) and \(p_2\) with the relation \(gcd(p_1,p_2) = c_1p_1 + c_2p_2\).
</p><!--l. 1139--><p class="noindent" >
</p>
                                                                     

                                                                     
<h5 class="subsubsectionHead"><a 
 id="x213-7680007"></a>Additional Orderings</h5>
<!--l. 1140--><p class="noindent" >Besides the basic orderings, there are ordering options that are used for special
purposes.
</p><!--l. 1143--><p class="noindent" >
</p>
<h5 class="likesubsubsectionHead"><a 
 id="x213-7690007"></a>Separating the Variables into Groups </h5>
<a 
 id="dx213-769001"></a>
<a 
 id="dx213-769002"></a>
<!--l. 1145--><p class="noindent" >It is often desirable to separate variables and formal parameters in a system of
polynomials. This can be done with a <span 
class="ptmri8t-x-x-109">lex </span>Gröbner basis. That however may be hard to
compute as it does more separation than necessary. The following orderings group the
variables into two (or more) sets, where inside each set a classical ordering acts, while
the sets are handled via their total degrees, which are compared in elimination style. So
the Gröbner basis will eliminate the members of the ﬁrst set, if algebraically
possible. <span 
class="ptmri8t-x-x-109">torder </span>here gets an additional parameter which describe the grouping
<a 
 id="dx213-769003"></a> </p>
<div class="center" 
>
<!--l. 1156--><p class="noindent" >
</p>
<div class="tabular"> <table id="TBL-85" class="tabular" 
 
><colgroup id="TBL-85-1g"><col 
id="TBL-85-1" /></colgroup><tr  
 style="vertical-align:baseline;" id="TBL-85-1-"><td  style="white-space:nowrap; text-align:left;" id="TBL-85-1-1"  
class="td11"><span 
class="ptmri8t-x-x-109">torder </span>(<span 
class="ptmri8t-x-x-109">vl</span>, <span 
class="ptmri8t-x-x-109">gradlexgradlex</span>, \(n\))   </td>
</tr><tr  
 style="vertical-align:baseline;" id="TBL-85-2-"><td  style="white-space:nowrap; text-align:left;" id="TBL-85-2-1"  
class="td11"><span 
class="ptmri8t-x-x-109">torder </span>(<span 
class="ptmri8t-x-x-109">vl</span>, <span 
class="ptmri8t-x-x-109">gradlexrevgradlex</span>,\(n\))</td>
</tr><tr  
 style="vertical-align:baseline;" id="TBL-85-3-"><td  style="white-space:nowrap; text-align:left;" id="TBL-85-3-1"  
class="td11"><span 
class="ptmri8t-x-x-109">torder </span>(<span 
class="ptmri8t-x-x-109">vl</span>, <span 
class="ptmri8t-x-x-109">lexgradlex</span>, \(n\))           </td>
</tr><tr  
 style="vertical-align:baseline;" id="TBL-85-4-"><td  style="white-space:nowrap; text-align:left;" id="TBL-85-4-1"  
class="td11"><span 
class="ptmri8t-x-x-109">torder </span>(<span 
class="ptmri8t-x-x-109">vl</span>, <span 
class="ptmri8t-x-x-109">lexrevgradlex</span>, \(n\))      </td>
</tr></table></div></div>
<!--l. 1164--><p class="noindent" >Here the integer \(n\) is the number of variables in the ﬁrst group and the names combine the
local ordering for the ﬁrst and second group, e.g.
</p>
<div class="center" 
>
<!--l. 1168--><p class="noindent" >
</p>
<div class="tabular"> <table id="TBL-86" class="tabular" 
 
><colgroup id="TBL-86-1g"><col 
id="TBL-86-1" /><col 
id="TBL-86-2" /><col 
id="TBL-86-3" /><col 
id="TBL-86-4" /><col 
id="TBL-86-5" /></colgroup><tr  
 style="vertical-align:baseline;" id="TBL-86-1-"><td colspan="4" style="white-space:nowrap; text-align:left;" id="TBL-86-1-1"  
class="td01"> <div class="multicolumn"  style="white-space:nowrap; text-align:left;"><span 
class="ptmri8t-x-x-109">lexgradlex</span>, 3 for \(\{x_1,x_2,x_3,x_4,x_5\}\):</div>
</td></tr><tr  
 style="vertical-align:baseline;" id="TBL-86-2-"><td colspan="4" style="white-space:nowrap; text-align:left;" id="TBL-86-2-1"  
class="td01"> <div class="multicolumn"  style="white-space:nowrap; text-align:left;">\(x_1^{i_1}\ldots x_5^{i_5} \gg x_1^{j_1}\ldots x_5^{j_5}\)</div></td></tr><tr  
 style="vertical-align:baseline;" id="TBL-86-3-"><td  style="white-space:nowrap; text-align:left;" id="TBL-86-3-1"  
class="td01"> if</td><td  style="white-space:nowrap; text-align:left;" id="TBL-86-3-2"  
class="td11"> </td><td  style="white-space:nowrap; text-align:left;" id="TBL-86-3-3"  
class="td11">  </td><td  style="white-space:nowrap; text-align:left;" id="TBL-86-3-4"  
class="td11">\((i_1,i_2,i_3) \gg _{lex}(j_1,j_2,j_3)\) </td>
</tr><tr  
 style="vertical-align:baseline;" id="TBL-86-4-"><td  style="white-space:nowrap; text-align:left;" id="TBL-86-4-1"  
class="td01">   </td><td  style="white-space:nowrap; text-align:left;" id="TBL-86-4-2"  
class="td11">or</td><td  style="white-space:nowrap; text-align:left;" id="TBL-86-4-3"  
class="td11">  </td><td  style="white-space:nowrap; text-align:left;" id="TBL-86-4-4"  
class="td11">\((i_1,i_2,i_3) = (j_1,j_2,j_3)\) </td>
</tr><tr  
 style="vertical-align:baseline;" id="TBL-86-5-"><td  style="white-space:nowrap; text-align:left;" id="TBL-86-5-1"  
class="td01">   </td><td  style="white-space:nowrap; text-align:left;" id="TBL-86-5-2"  
class="td11"> </td><td  style="white-space:nowrap; text-align:left;" id="TBL-86-5-3"  
class="td11">and</td><td  style="white-space:nowrap; text-align:left;" id="TBL-86-5-4"  
class="td11">\((i_4,i_5) \gg _{gradlex}(j_4,j_5)\) </td>
</tr></table>
                                                                     

                                                                     
</div></div>
<!--l. 1178--><p class="noindent" >Note that in the second place there is no <span 
class="ptmri8t-x-x-109">lex </span>ordering available; that would not make
sense.
</p><!--l. 1181--><p class="noindent" >
</p>
<h5 class="likesubsubsectionHead"><a 
 id="x213-7700007"></a>Weighted Ordering</h5>
<a 
 id="dx213-770001"></a>
<a 
 id="dx213-770002"></a>
<a 
 id="dx213-770003"></a>
<!--l. 1183--><p class="noindent" >The statement </p>
<div class="center" 
>
<!--l. 1184--><p class="noindent" >
</p><!--l. 1185--><p class="noindent" ><span 
class="pcrr8t-x-x-109">torder</span>(<span 
class="ptmri8t-x-x-109">vl</span>, weighted, \(\{n_1,n_2,n_3 \ldots \}\));</p></div>
<!--l. 1187--><p class="noindent" >establishes a graduated ordering, where the exponents are ﬁrst multiplied by the given
weights. If there are less weight values than variables, the weight 1 is added
automatically. If the weighted degree calculation is not decidable, a <span 
class="ptmri8t-x-x-109">lex </span>comparison
follows.
</p><!--l. 1192--><p class="noindent" >
</p>
<h5 class="likesubsubsectionHead"><a 
 id="x213-7710007"></a>Graded Ordering</h5>
<a 
 id="dx213-771001"></a>
<a 
 id="dx213-771002"></a>
<a 
 id="dx213-771003"></a>
<!--l. 1194--><p class="noindent" >The statement </p>
<div class="center" 
>
<!--l. 1195--><p class="noindent" >
</p><!--l. 1196--><p class="noindent" ><span 
class="pcrr8t-x-x-109">torder</span>(<span 
class="ptmri8t-x-x-109">vl</span>, graded, \(\{n_1,n_2,n_3 \ldots \}\), \(order_2\));</p></div>
                                                                     

                                                                     
<!--l. 1198--><p class="noindent" >establishes a graduated ordering, where the exponents are ﬁrst multiplied by the given
weights. If there are less weight values than variables, the weight 1 is added
automatically. If the weighted degree calculation is not decidable, the term order \(order_2\)
speciﬁed in the following argument(s) is used. The ordering <span 
class="ptmri8t-x-x-109">graded </span>is designed primarily
for use with the operator <span 
class="pcrr8t-x-x-109">dd_groebner</span>.
</p><!--l. 1205--><p class="noindent" >
</p>
<h5 class="likesubsubsectionHead"><a 
 id="x213-7720007"></a>Matrix Ordering</h5>
<a 
 id="dx213-772001"></a>
<a 
 id="dx213-772002"></a>
<a 
 id="dx213-772003"></a>
<!--l. 1207--><p class="noindent" >The statement </p>
<div class="center" 
>
<!--l. 1208--><p class="noindent" >
</p><!--l. 1209--><p class="noindent" ><span 
class="pcrr8t-x-x-109">torder</span>(<span 
class="ptmri8t-x-x-109">vl</span>, matrix, \(m\));</p></div>
<!--l. 1211--><p class="noindent" >where \(m\) is a matrix with integer elements and row length which corresponds to the
variable number. The exponents of each monomial form a vector; two monomials are
compared by multiplying their exponent vectors ﬁrst with \(m\) and comparing the resulting
vector lexicographically. E.g. the unit matrix establishes the classical <span 
class="ptmri8t-x-x-109">lex </span>term order
mode, a matrix with a ﬁrst row of ones followed by the rows of a unit matrix corresponds
to the <span 
class="ptmri8t-x-x-109">gradlex </span>ordering.
</p><!--l. 1219--><p class="noindent" >The matrix \(m\) must have at least as many rows as columns; a non–square matrix contains
redundant rows. The matrix must have full rank, and the top non–zero element of each
column must be positive.
</p><!--l. 1223--><p class="noindent" >The generality of the matrix based term order has its price: the computing time spent in
the term sorting is signiﬁcantly higher than with the specialized term orders. To
overcome this problem, you can compile a matrix term order ; the compilation reduces
the computing time overhead signiﬁcantly. If you set the switch <span 
class="pcrr8t-x-x-109">comp</span><a 
 id="dx213-772004"></a> on, any
new order matrix is compiled when any operator of the <span 
class="ptmrc8t-x-x-109">G<span 
class="small-caps">R</span><span 
class="small-caps">O</span><span 
class="small-caps">E</span><span 
class="small-caps">B</span><span 
class="small-caps">N</span><span 
class="small-caps">E</span><span 
class="small-caps">R</span> </span>package
accesses it for the ﬁrst time. Alternatively you can compile a matrix explicitly
<a 
 id="dx213-772005"></a> <a 
 id="operator:TORDER_COMPILE"></a>
                                                                     

                                                                     
</p>
<pre class="verbatim" id="verbatim-1152">
    torder_compile(&#x003C;n&#x003E;,&#x003C;m&#x003E;);
</pre>
<!--l. 1236--><p class="nopar" > where \(&lt;n&gt;\) is a name (an identiﬁer) and \(&lt;m&gt;\) is a term order matrix. <span 
class="pcrr8t-x-x-109">torder_compile</span>
transforms the matrix into a LISP program, which is compiled by the LISP compiler
when <span 
class="pcrr8t-x-x-109">comp </span>is on or when you generate a fast loadable module. Later you can activate
the new term order by using the name \(&lt;n&gt;\) in a <span 
class="pcrr8t-x-x-109">torder </span>statement as term ordering
mode.
</p><!--l. 1244--><p class="noindent" >
</p>
<h5 class="subsubsectionHead"><a 
 id="x213-7730007"></a>Gröbner Bases for Graded Homogeneous Systems</h5>
<!--l. 1246--><p class="noindent" >For a homogeneous system of polynomials under a term order <span 
class="ptmri8t-x-x-109">graded</span>, <span 
class="ptmri8t-x-x-109">gradlex</span>,
<span 
class="ptmri8t-x-x-109">revgradlex </span>or <span 
class="ptmri8t-x-x-109">weighted </span>a Gröbner Base can be computed with limiting the grade of the
intermediate \(s\)–polynomials:
<a 
 id="dx213-773001"></a>
     </p><dl class="description"><dt class="description">
     <!--l. 1252--><p class="noindent" >
<span 
class="pcrr8t-x-x-109">dd_groebner</span><span 
class="ptmb8t-x-x-109">(</span>\(d1,d2,\{p_1,p_2,\ldots \}\)<span 
class="ptmb8t-x-x-109">);</span> </p></dt><dd 
class="description">
     <!--l. 1252--><p class="noindent" ><a 
 id="operator:DD_GROEBNER"></a></p></dd></dl>
<!--l. 1255--><p class="noindent" >where \(d1\) is a non–negative integer and \(d2\) is an integer \(&gt;\) \(d1\) or “inﬁnity&#x0022;. A pair of polynomials is
considered only if the grade of the lcm of their head terms is between \(d1\) and \(d2\). See
<span class="cite">[<a 
href="manual/manualap2.html#XBecker:93">BWK93</a>]</span> for the mathematical background. For the term orders <span 
class="ptmri8t-x-x-109">graded </span>or <span 
class="ptmri8t-x-x-109">weighted </span>the
(ﬁrst) weight vector is used for the grade computation. Otherwise the total degree of a
term is used.
</p><!--l. 1263--><p class="noindent" >
</p>
<h4 class="subsectionHead"><span class="titlemark">20.25.4    </span> <a 
 id="x213-77400020.25.4"></a>Ideal Decomposition &#x0026; Equation System Solving</h4>
<!--l. 1264--><p class="noindent" >Based on the elementary Gröbner operations, the <span 
class="ptmrc8t-x-x-109">G<span 
class="small-caps">R</span><span 
class="small-caps">O</span><span 
class="small-caps">E</span><span 
class="small-caps">B</span><span 
class="small-caps">N</span><span 
class="small-caps">E</span><span 
class="small-caps">R</span> </span>package oﬀers additional
                                                                     

                                                                     
operators, which allow the decomposition of an ideal or of a system of equations down to
the individual solutions.
</p><!--l. 1268--><p class="noindent" >
</p>
<h5 class="subsubsectionHead"><a 
 id="x213-77500020.25.4"></a>Solutions Based on Lex Type Gröbner Bases</h5>
<!--l. 1270--><p class="noindent" >
</p>
<h5 class="likesubsubsectionHead"><a 
 id="x213-77600020.25.4"></a>groesolve: Solution of a Set of Polynomial Equations</h5>
<a 
 id="dx213-776001"></a>
<a 
 id="dx213-776002"></a>
<!--l. 1272--><p class="noindent" ><a 
 id="operator:GROESOLVE"></a> The <span 
class="pcrr8t-x-x-109">groesolve </span>operator incorporates a macro algorithm; lexical Gröbner bases are
computed by <span 
class="pcrr8t-x-x-109">groebnerf </span>and decomposed into simpler ones by ideal decomposition
techniques; if algebraically possible, the problem is reduced to univariate polynomials
which are solved by <span 
class="pcrr8t-x-x-109">solve</span>; if <span 
class="pcrr8t-x-x-109">rounded </span>is on, numerical approximations are computed
for the roots of the univariate polynomials. \[ groesolve(\{exp1, exp2, \ldots , expm\}[,\{var1, var2, \ldots , varn\}]); \] where \(\{exp1, exp2,\ldots , expm\}\) is a list of any number of expressions
or equations, \(\{var1, var2, \ldots , varn\}\) is an optional list of variables.
</p><!--l. 1286--><p class="noindent" >The result is a set of subsets. The subsets contain the solutions of the polynomial
equations. If there are only ﬁnitely many solutions, then each subset is a set of
expressions of triangular type \(\{exp1, exp2,\ldots , expn\},\) where \(exp1\) depends only on \(var1,\) \(exp2\) depends only on \(var1\) and \(var2\) etc. until \(expn\)
which depends on \(var1,\ldots ,varn.\) This allows a successive determination of the solution components. If
there are inﬁnitely many solutions, some subsets consist in less than \(n\) expressions. By
considering some of the variables as “free parameters”, these subsets are usually again of
triangular type.
<a 
 id="x213-776003r8"></a>
</p><!--l. 1297--><p class="noindent" ><span 
class="ptmb8t-x-x-109">Example 8</span>(Intersubsections of a line with a circle): <a 
 id="dx213-776004"></a>
</p><!--l. 1300--><p class="noindent" >\[ groesolve(\{x**2 - y**2 - a, p*x+q*y+s\},\{x,y\}); \]
                                                                     

                                                                     
</p>
<pre class="verbatim" id="verbatim-1153">
                   2      2    2             2    2
   {{x=(sqrt( - a*p  + a*q  + s )*q - p*s)/(p  - q ),
                      2      2    2             2    2
     y= - (sqrt( - a*p  + a*q  + s )*p - q*s)/(p  - q )},
                      2      2    2             2    2
    {x= - (sqrt( - a*p  + a*q  + s )*q + p*s)/(p  - q ),
                   2      2    2             2    2
     y=(sqrt( - a*p  + a*q  + s )*p + q*s)/(p  - q )}}
</pre>
<!--l. 1311--><p class="nopar" >
</p><!--l. 1313--><p class="noindent" >If the system is zero–dimensional (has a number of isolated solutions), the algorithm
described in <span class="cite">[<a 
href="manual/manualap2.html#XHillebrand:99">Hil99</a>]</span> is used, if the decomposition leaves a polynomial with mixed
leading term. Hillebrand has written the article and Möller was the tutor of this
job.
</p><!--l. 1318--><p class="noindent" >The reordering of the <span 
class="pcrr8t-x-x-109">groesolve </span>variables is controlled by the REDUCE switch
<span 
class="pcrr8t-x-x-109">varopt</span>. If <span 
class="pcrr8t-x-x-109">varopt </span>is <span 
class="pcrr8t-x-x-109">on </span>(which is the default of <span 
class="pcrr8t-x-x-109">varopt</span>), the variable
sequence is optimized (the variables are reordered). If <span 
class="pcrr8t-x-x-109">varopt </span>is <span 
class="pcrr8t-x-x-109">off</span>, the given
variable sequence is taken (if no variables are given, the order of the REDUCE
system is taken instead). In general, the reordering of the variables makes the
Gröbner basis computation signiﬁcantly faster. A variable dependency, declare
by one (or several) <span 
class="pcrr8t-x-x-109">depend </span>statements, is regarded (if <span 
class="pcrr8t-x-x-109">varopt </span>is <span 
class="pcrr8t-x-x-109">on</span>). The
switch <span 
class="pcrr8t-x-x-109">groebopt </span>has no meaning for <span 
class="pcrr8t-x-x-109">groesolve</span>; it is stored during its
processing.
</p><!--l. 1329--><p class="noindent" >
</p>
<h5 class="likesubsubsectionHead"><a 
 id="x213-7770008"></a><span 
class="ptmri8t-x-x-109">groepostproc</span>: Postprocessing of a Gröbner Basis</h5>
<a 
 id="dx213-777001"></a>
<!--l. 1331--><p class="noindent" ><a 
 id="operator:GROEPOSTPROC"></a> In many cases, it is diﬃcult to do the general Gröbner processing. If a Gröbner basis
with a <span 
class="ptmri8t-x-x-109">lex </span>ordering is calculated already (e.g., by very individual parameter
settings), the solutions can be derived from it by a call to <span 
class="pcrr8t-x-x-109">groepostproc</span>.
<span 
class="pcrr8t-x-x-109">groesolve </span>is functionally equivalent to a call to <span 
class="pcrr8t-x-x-109">groebnerf </span>and subsequent calls to
<span 
class="pcrr8t-x-x-109">groepostproc </span>for each partial basis. \[ groepostproc(\{exp1, exp2, \ldots , expm\}[,\{var1, var2, \ldots , varn\}]); \] where \(\{exp1, exp2, \ldots , expm\}\) is a list of any number of expressions,
\(\{var1, var2, \ldots , varn\}\) is an optional list of variables. The expressions must be a <span 
class="ptmri8t-x-x-109">lex </span>Gröbner basis with the
                                                                     

                                                                     
given variables; the ordering must be still active.
</p><!--l. 1347--><p class="noindent" >The result is the same as with <span 
class="pcrr8t-x-x-109">groesolve</span>.
                                                                     

                                                                     
</p>
<pre class="verbatim" id="verbatim-1154">
groepostproc({x3**2 + x3 + x2 - 1,
              x2*x3 + x1*x3 + x3 + x1*x2 + x1 + 2,
              x2**2 + 2*x2 - 1,
              x1**2 - 2},{x3,x2,x1});

{{x3= - sqrt(2),

  x2=sqrt(2) - 1,

  x1=sqrt(2)},

 {x3=sqrt(2),

  x2= - (sqrt(2) + 1),

  x1= - sqrt(2)},

      sqrt(4*sqrt(2) + 9) - 1
 {x3=-------------------------,
                 2

  x2= - (sqrt(2) + 1),

  x1=sqrt(2)},

       - (sqrt(4*sqrt(2) + 9) + 1)
 {x3=------------------------------,
                   2

  x2= - (sqrt(2) + 1),

  x1=sqrt(2)},

      sqrt( - 4*sqrt(2) + 9) - 1
 {x3=----------------------------,
                  2

  x2=sqrt(2) - 1,
                                                                     

                                                                     

  x1= - sqrt(2)},

       - (sqrt( - 4*sqrt(2) + 9) + 1)
 {x3=---------------------------------,
                     2

  x2=sqrt(2) - 1,

  x1= - sqrt(2)}}
</pre>
<!--l. 1398--><p class="nopar" >
</p><!--l. 1400--><p class="noindent" >
</p>
<h5 class="likesubsubsectionHead"><a 
 id="x213-7780008"></a>Idealquotient: Quotient of an Ideal and an Expression</h5>
<a 
 id="dx213-778001"></a>
<a 
 id="dx213-778002"></a>
<!--l. 1402--><p class="noindent" ><a 
 id="operator:IDEALQUOTIENT"></a> Let \(i\) be an ideal and \(f\) be a polynomial in the same variables. Then the algebraic quotient
is deﬁned by \[ i:f = \{ p \;| \; p * f \;\mbox { member of }\; i\}\;. \] The ideal quotient \(i:f\) contains \(i\) and is obviously part of the whole polynomial
ring, i.e. contained in \(\{1\}\). The case \(i:f = \{1\}\) is equivalent to \(f\) being a member of \(i\). The other extremal
case, \(i:f=i\), occurs, when \(f\) does not vanish at any general zero of \(i\). The explanation of the
notion “general zero” introduced by van der Waerden, however, is beyond the aim of this
manual. The operation of <span 
class="pcrr8t-x-x-109">groesolve</span>/<span 
class="pcrr8t-x-x-109">groepostproc </span>is based on nested ideal
quotient calculations.
</p><!--l. 1417--><p class="noindent" >If \(i\) is given by a basis and \(f\) is given as an expression, the quotient can be calculated
by
  </p><div class="syntax">
   <span 
class="pcrr8t-x-x-109">idealquotient </span>({\(\langle \)<span 
class="ptmri8t-x-x-109">exp1</span>\(\rangle \), \(\langle \)<span 
class="ptmri8t-x-x-109">exp2</span>\(\rangle \),…, \(\langle \)<span 
class="ptmri8t-x-x-109">expm</span>\(\rangle \)}, \(\langle \)<span 
class="ptmri8t-x-x-109">exp</span>\(\rangle \));</div>
<!--l. 1422--><p class="noindent" >where {\(\langle \)<span 
class="ptmri8t-x-x-109">exp1</span>\(\rangle \), \(\langle \)<span 
class="ptmri8t-x-x-109">exp2</span>\(\rangle \), …, \(\langle \)<span 
class="ptmri8t-x-x-109">expm</span>\(\rangle \)} is a list of any number of expressions or equations, \(\langle \)<span 
class="ptmri8t-x-x-109">exp</span>\(\rangle \) is a
single expression or equation.
</p><!--l. 1425--><p class="noindent" ><span 
class="pcrr8t-x-x-109">idealquotient </span>calculates the algebraic quotient of the ideal \(i\) with the basis \(\{exp1, exp2, \ldots , expm\}\) and <span 
class="ptmri8t-x-x-109">exp</span>
with respect to the variables given or extracted. \(\{exp1, exp2, \ldots , expm\}\) is not necessarily a Gröbner basis. The
result is the Gröbner basis of the quotient.
</p><!--l. 1431--><p class="noindent" >
                                                                     

                                                                     
</p>
<h5 class="likesubsubsectionHead"><a 
 id="x213-7790008"></a>Saturation: Saturation of an Ideal and an Expression</h5>
<a 
 id="dx213-779001"></a>
<!--l. 1433--><p class="noindent" ><a 
 id="operator:SATURATION"></a> The <span 
class="pcrr8t-x-x-109">saturation </span>operator computes the quotient on an ideal and an arbitrary power of
an expression \(exp**n\) with arbitrary \(n\). The call is \[ saturation (\{exp1, \ldots , expm\}, exp); \] where \(\{exp1, exp2, \ldots , expm\}\) is a list of any number of expressions or
equations, <span 
class="ptmri8t-x-x-109">exp </span>is a single expression or equation.
</p><!--l. 1440--><p class="noindent" ><span 
class="ptmri8t-x-x-109">saturation </span>calls <span 
class="ptmri8t-x-x-109">idealquotient </span>several times, until the result is stable, and returns
it.
</p><!--l. 1443--><p class="noindent" >
</p>
<h5 class="subsubsectionHead"><a 
 id="x213-7800008"></a>Operators for Gröbner Bases in all Term Orderings</h5>
<a 
 id="dx213-780001"></a>
<!--l. 1445--><p class="noindent" >In some cases where no Gröbner basis with lexical ordering can be calculated, a
calculation with a total degree ordering is still possible. Then the Hilbert polynomial
gives information about the dimension of the solutions space and for ﬁnite sets of
solutions univariate polynomials can be calculated. The solutions of the equation
system then is contained in the cross product of all solutions of all univariate
polynomials.
</p><!--l. 1453--><p class="noindent" >
</p>
<h5 class="likesubsubsectionHead"><a 
 id="x213-7810008"></a>Hilbertpolynomial: Hilbert Polynomial of an Ideal</h5>
<a 
 id="dx213-781001"></a>
<!--l. 1455--><p class="noindent" >This algorithm was contributed by <span 
class="ptmrc8t-x-x-109">J<span 
class="small-caps">O</span><span 
class="small-caps">A</span><span 
class="small-caps">C</span><span 
class="small-caps">H</span><span 
class="small-caps">I</span><span 
class="small-caps">M</span> H<span 
class="small-caps">O</span><span 
class="small-caps">L</span><span 
class="small-caps">L</span><span 
class="small-caps">M</span><span 
class="small-caps">A</span><span 
class="small-caps">N</span></span>, Royal Institute of Technology,
Stockholm (private communication). <a 
 id="dx213-781002"></a> <a 
 id="operator:HILBERTPOLYNOMIAL"></a>
  </p><div class="syntax">
   <span 
class="pcrr8t-x-x-109">hilbertpolynomial (</span>\(\langle \)<span 
class="ptmri8t-x-x-109">exp1:expression</span>\(\rangle \)<span 
class="pcrr8t-x-x-109">,</span>…<span 
class="pcrr8t-x-x-109">,</span>\(\langle \)<span 
class="ptmri8t-x-x-109">expm:expression</span>\(\rangle \)<span 
class="pcrr8t-x-x-109">)</span></div>
<!--l. 1462--><p class="noindent" >where \(\{exp1, \ldots , expm\}\) is a list of any number of expressions or equations.
</p><!--l. 1465--><p class="noindent" ><span 
class="pcrr8t-x-x-109">hilertpolynomial </span>calculates the Hilbert polynomial of the ideal with basis \(\{exp1, \ldots , expm\}\) with
respect to the variables given or extracted provided the given term ordering is compatible
with the degree, such as the <span 
class="ptmri8t-x-x-109">gradlex</span>- or <span 
class="ptmri8t-x-x-109">revgradlex</span>-ordering. The term ordering of the
basis must be active and \(\{exp1, \ldots , expm\}\) should be a Gröbner basis with respect to this ordering. The
Hilbert polynomial gives information about the cardinality of solutions of the system \(\{exp1, \ldots , expm\}\): if
                                                                     

                                                                     
the Hilbert polynomial is an integer, the system has only a discrete set of solutions and
the polynomial is identical with the number of solutions counted with their multiplicities.
Otherwise the degree of the Hilbert polynomial is the dimension of the solution
space.
</p><!--l. 1479--><p class="noindent" >If the Hilbert polynomial is not a constant, it is constructed with the variable “x”
regardless of whether \(x\) is member of \(\{var1, \ldots , varn\}\) or not. The value of this polynomial at suﬃciently
large numbers “x” is the diﬀerence of the dimension of the linear vector space of all
polynomials of degree \( \leq x \) minus the dimension of the subspace of all polynomials of degree
\(\leq x \) which belong also to the ideal.
</p><!--l. 1487--><p class="noindent" >\(x\) must be an undeﬁned variable or the value of \(x\) must be an undeﬁned variable; otherwise a
warning is given and a new (generated) variable is taken instead.
</p>
<!--l. 1491--><p class="noindent" ><span class="paragraphHead"><a 
 id="x213-7820008"></a><span 
class="ptmb8t-x-x-109">Remark:</span></span>
The number of zeros in an ideal and the Hilbert polynomial depend only on the leading
terms of the Gröbner basis. So if a subsequent Hilbert calculation is planned,
the Gröbner calculation should be performed with <span 
class="pcrr8t-x-x-109">on gltbasis </span>and the
value of <span 
class="pcrr8t-x-x-109">gltb </span>(or its elements in a <span 
class="pcrr8t-x-x-109">groebnerf </span>context) should be given to
<span 
class="pcrr8t-x-x-109">hilbertpolynomial</span>. In this manner, a lot of computing time can be saved in the
case of long calculations.
</p><!--l. 1499--><p class="noindent" >
</p>
<h4 class="subsectionHead"><span class="titlemark">20.25.5    </span> <a 
 id="x213-78300020.25.5"></a>Calculations “by Hand”</h4>
<!--l. 1500--><p class="noindent" >The following operators support explicit calculations with polynomials in a
distributive representation at the REDUCE top level. So they allow one to do
Gröbner type evaluations stepwise by separate calls. Note that the normal
REDUCE arithmetic can be used for arithmetic combinations of monomials and
polynomials.
</p><!--l. 1506--><p class="noindent" >
</p>
<h5 class="subsubsectionHead"><a 
 id="x213-78400020.25.5"></a>Representing Polynomials in Distributive Form</h5>
<a 
 id="dx213-784001"></a>
                                                                     

                                                                     
<!--l. 1508--><p class="noindent" ><a 
 id="operator:GSORT"></a>
  </p><div class="syntax">
   <span 
class="pcrr8t-x-x-109">gsort</span> \(\langle \)<span 
class="ptmri8t-x-x-109">p</span>\(\rangle \)</div>
<!--l. 1512--><p class="noindent" >where \(\langle \)<span 
class="ptmri8t-x-x-109">p</span>\(\rangle \) is a polynomial or a list of polynomials.
</p><!--l. 1514--><p class="noindent" >If \(\langle \)<span 
class="ptmri8t-x-x-109">p</span>\(\rangle \) is a single polynomial, the result is a reordered version of \(\langle \)<span 
class="ptmri8t-x-x-109">p</span>\(\rangle \) in the distributive
representation according to the variables and the current term order mode; if \(\langle \)<span 
class="ptmri8t-x-x-109">p</span>\(\rangle \) is a list, its
members are converted into distributive representation and the result is the list sorted by
the term ordering of the leading terms; zero polynomials are eliminated from the
result.
                                                                     

                                                                     
</p>
<pre class="verbatim" id="verbatim-1155">
     torder({alpha,beta,gamma},lex);

     dip := gsort(gamma*(alpha-1)**2*(beta+1)**2);


                2     2                2
    dip := alpha *beta *gamma + 2*alpha *beta*gamma

           2                     2
    + alpha *gamma - 2*alpha*beta *gamma - 4*alpha*beta*gamma

                           2
     - 2*alpha*gamma + beta *gamma + 2*beta*gamma + gamma
</pre>
<!--l. 1535--><p class="nopar" >
</p><!--l. 1537--><p class="noindent" >
</p>
<h5 class="subsubsectionHead"><a 
 id="x213-78500020.25.5"></a>Splitting of a Polynomial into Leading Term and Reductum</h5>
<a 
 id="dx213-785001"></a>
<!--l. 1539--><p class="noindent" ><a 
 id="operator:GSPLIT"></a>
  </p><div class="syntax">
   <span 
class="pcrr8t-x-x-109">gsplit</span> \(\langle \)<span 
class="ptmri8t-x-x-109">p</span>\(\rangle \)</div>
<!--l. 1543--><p class="noindent" >where \(\langle \)<span 
class="ptmri8t-x-x-109">p</span>\(\rangle \) is a polynomial.
</p><!--l. 1545--><p class="noindent" ><span 
class="pcrr8t-x-x-109">gsplit </span>converts the polynomial \(\langle \)<span 
class="ptmri8t-x-x-109">p</span>\(\rangle \) into distributive representation and splits it into
leading monomial and reductum. The result is a list with two elements, the leading
monomial and the reductum.
                                                                     

                                                                     
</p>
<pre class="verbatim" id="verbatim-1156">
   gslit dip;

          2     2
    {alpha *beta *gamma,

            2                   2                     2
     2*alpha *beta*gamma + alpha *gamma - 2*alpha*beta *gamma

                         2
     - 4*alpha*beta*gamma - 2*alpha*gamma + beta *gamma


     + 2*beta*gamma + gamma}
</pre>
<!--l. 1563--><p class="nopar" >
</p><!--l. 1565--><p class="noindent" >
</p>
<h5 class="subsubsectionHead"><a 
 id="x213-78600020.25.5"></a>Calculation of Buchberger’s S-polynomial</h5>
<a 
 id="dx213-786001"></a>
<!--l. 1567--><p class="noindent" ><a 
 id="operator:GSPOLY"></a>
  </p><div class="syntax">
   <span 
class="pcrr8t-x-x-109">gspoly (</span>\(\langle \)<span 
class="ptmri8t-x-x-109">p1</span>\(\rangle \)<span 
class="pcrr8t-x-x-109">,</span>\(\langle \)<span 
class="ptmri8t-x-x-109">p2</span>\(\rangle \)<span 
class="pcrr8t-x-x-109">)</span></div>
<!--l. 1571--><p class="noindent" >where \(\langle \)<span 
class="ptmri8t-x-x-109">p1</span>\(\rangle \) and \(\langle \)<span 
class="ptmri8t-x-x-109">p2</span>\(\rangle \) are polynomials.
</p><!--l. 1573--><p class="noindent" ><span 
class="pcrr8t-x-x-109">gspoly </span>calculates the \(s\)-polynomial from \(\langle \)<span 
class="ptmri8t-x-x-109">p1</span>\(\rangle \) and \(\langle \)<span 
class="ptmri8t-x-x-109">p2</span>\(\rangle \).
</p><!--l. 1575--><p class="noindent" >Example for a complete calculation (taken from <span 
class="ptmrc8t-x-x-109">D<span 
class="small-caps">A</span><span 
class="small-caps">V</span><span 
class="small-caps">E</span><span 
class="small-caps">N</span><span 
class="small-caps">P</span><span 
class="small-caps">O</span><span 
class="small-caps">R</span><span 
class="small-caps">T</span> <span 
class="small-caps">E</span><span 
class="small-caps">T</span> <span 
class="small-caps">A</span><span 
class="small-caps">L</span>. </span><span class="cite">[<a 
href="manual/manualap2.html#XDavenport:88a">DST93</a>]</span>):
                                                                     

                                                                     
</p>
<pre class="verbatim" id="verbatim-1157">
   torder({x,y,z},lex)$
   g1  :=  x**3*y*z - x*z**2;
   g2  :=  x*y**2*z - x*y*z;
   g3  :=  x**2*y**2 - z;$

   % first S-polynomial

   g4  :=  gspoly(g2,g3);$

           2        2
    g4 := x *y*z - z

    % next S-polynomial

    p :=  gspoly(g2,g4); $

          2          2
    p := x *y*z - y*z

    % and reducing, here only by g4

    g5  :=  preduce(p,{g4});

                2    2
    g5 :=  - y*z  + z

    % last S-polynomial}

    g6  :=  gspoly(g4,g5);

           2  2    3
    g6 := x *z  - z

    % and the final basis sorted descending

    gsort{g2,g3,g4,g5,g6};

      2  2
                                                                     

                                                                     
    {x *y  - z,

      2        2
     x *y*z - z ,

      2  2    3
     x *z  - z ,

        2
     x*y *z - x*y*z,

           2    2
      - y*z  + z }
</pre>
<!--l. 1629--><p class="nopar" >
</p><!--l. 534--><p class="noindent" >
                                                                     

                                                                     
                                                                     

                                                                     
</p><!--l. 536--><p class="noindent" ><table cellspacing="5"><tr><td class="clinks"><a 
href="manual-lookup.php%3FUser&#32;Contributed&#32;Packages.html#manualse148.html" >Up</a></td><td class="clinks"><a 
href="manual/manualse149.html" >Next</a></td><td class="clinks"><a 
href="manual/manualse147.html" >Prev</a></td><td class="clinks"><a 
href="manual/manualse147.html#tailmanualse147.html" >PrevTail</a></td><td class="clinks"><a 
href="manual-lookup.php%3FGROEBNER:.html" >Front</a></td></tr></table><a 
 id="tailmanualse148.html"></a>   <hr> <p style="font-family:sans-serif">Hosted by <a href="https://sourceforge.net/p/reduce-algebra/"> <img title="Download REDUCE" alt="Download REDUCE" style="vertical-align:middle" src="https://sourceforge.net/sflogo.php?type=16&amp;group_id=248416"/></a> <a href="https://www.mathjax.org"> <img title="Powered by MathJax" alt="Powered by MathJax" style="float:right" src="https://www.mathjax.org/badge/badge.gif"/></a></p></p> 
</body> 
</html>