<!DOCTYPE html> 
<html lang="en-US" xml:lang="en-US" > 
<head><title>NCPOLY: Non-commutative Polynomial Ideals</title> 
<meta  charset="utf-8" /> 
<meta name="generator" content="TeX4ht (https://tug.org/tex4ht/)" /> 
<meta name="viewport" content="width=device-width,initial-scale=1" /> 
<link rel="stylesheet" type="text/css" href="manual.css" /> 
<meta name="src" content="manual.tex" /> 
<script>window.MathJax = { tex: { tags: "ams", }, }; </script> 
 <script type="text/javascript" async="async" id="MathJax-script" src="../../cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js"></script>  
<meta name="description" content="The REDUCE Computer Algebra System User's Manual" /> 
</head><body 
>
<header>REDUCE</header><table cellspacing="5"><tr><td class="clinks"><a 
href="../manual-lookup.php%3FUser&#32;Contributed&#32;Packages.html#manualse159.html" >Up</a></td><td class="clinks"><a 
href="manualse160.html" >Next</a></td><td class="clinks"><a 
href="manualse158.html" >Prev</a></td><td class="clinks"><a 
href="manualse158.html#tailmanualse158.html" >PrevTail</a></td><td class="clinks"><a 
href="manualse159.html#tailmanualse159.html">Tail</a></td></tr></table><h3 class="sectionHead"><span class="titlemark">20.36    </span> <a 
 id="x234-93200020.36"></a>NCPOLY: Non-commutative Polynomial Ideals</h3>
<a 
 id="dx234-932001"></a>
<a 
 id="dx234-932002"></a>
<!--l. 701--><p class="noindent" >This package allows the user to set up automatically a consistent environment for
computing in an algebra where the non–commutativity is deﬁned by Lie-bracket
commutators. The package uses the REDUCE <span 
class="ptmb8t-x-x-109">noncom </span>mechanism for elementary
polynomial arithmetic; the commutator rules are automatically computed from the Lie
brackets.
</p><!--l. 707--><p class="noindent" >Authors: Herbert Melenk and Joachim Apel.
<a 
 id="dx234-932003"></a>
</p><!--l. 3--><p class="noindent" >
</p>
<h4 class="subsectionHead"><span class="titlemark">20.36.1    </span> <a 
 id="x234-93300020.36.1"></a>Introduction</h4>
<!--l. 5--><p class="noindent" >REDUCE supports a very general mechanism for computing with objects under a
non–commutative multiplication, where commutator relations must be introduced
explicitly by rule sets when needed. The package <span 
class="ptmrc8t-x-x-109">N<span 
class="small-caps">C</span><span 
class="small-caps">P</span><span 
class="small-caps">O</span><span 
class="small-caps">L</span><span 
class="small-caps">Y</span> </span>allows you to set up
automatically a consistent environment for computing in an algebra where the
non–commutativity is deﬁned by Lie-bracket commutators. The package uses the
REDUCE <span 
class="pcrr8t-x-x-109">noncom</span><a 
 id="dx234-933001"></a> mechanism for elementary polynomial arithmetic; the commutator
rules are automatically computed from the Lie brackets. You can perform polynomial
arithmetic directly, including <span 
class="ptmri8t-x-x-109">division </span>and <span 
class="ptmri8t-x-x-109">factorization</span>. Additionally <span 
class="ptmrc8t-x-x-109">N<span 
class="small-caps">C</span><span 
class="small-caps">P</span><span 
class="small-caps">O</span><span 
class="small-caps">L</span><span 
class="small-caps">Y</span> </span>supports
computations in a one sided ideal (left or right), especially one sided Gröbner bases and
<span 
class="ptmri8t-x-x-109">polynomial reduction</span>.
</p><!--l. 19--><p class="noindent" >
</p>
<h4 class="subsectionHead"><span class="titlemark">20.36.2    </span> <a 
 id="x234-93400020.36.2"></a>Setup, Cleanup</h4>
<a 
 id="dx234-934001"></a>
                                                                     

                                                                     
<!--l. 22--><p class="noindent" ><a 
 id="operator:NC_SETUP"></a> Before the computations can start the environment for a non–commutative computation
must be deﬁned by a call to <span 
class="pcrr8t-x-x-109">nc_setup</span>:
  </p><div class="syntax">
   <span 
class="pcrr8t-x-x-109">nc_setup</span>(\(\langle \)<span 
class="ptmri8t-x-x-109">vars</span>\(\rangle \)[,\(\langle \)<span 
class="ptmri8t-x-x-109">comms</span>\(\rangle \)][,\(\langle \)<span 
class="ptmri8t-x-x-109">dir</span>\(\rangle \)]);</div>
<!--l. 29--><p class="noindent" >where
</p><!--l. 31--><p class="noindent" >\(\langle \)<span 
class="ptmri8t-x-x-109">vars</span>\(\rangle \) is a list of variables; these must include the non–commutative quantities.
</p><!--l. 34--><p class="noindent" >\(\langle \)<span 
class="ptmri8t-x-x-109">comms</span>\(\rangle \) is a list of equations <span 
class="pcrr8t-x-x-109">&#x003C;u&#x003E;*&#x003C;v&#x003E; - &#x003C;v&#x003E;*&#x003C;u&#x003E;=&#x003C;rh&#x003E; </span>where \(&lt;u&gt;\) and \(&lt;v&gt;\) are members
of \(&lt;vars&gt;\), and \(&lt;rh&gt;\) is a polynomial.
</p><!--l. 38--><p class="noindent" >\(\langle \)<span 
class="ptmri8t-x-x-109">dir</span>\(\rangle \) is either \(left\) or \(right\) selecting a left or a right one sided ideal. The initial direction is
\(left\).
</p><!--l. 41--><p class="noindent" ><span 
class="pcrr8t-x-x-109">nc_setup </span>generates from \(\langle \)<span 
class="ptmri8t-x-x-109">comms</span>\(\rangle \) the necessary rules to support an algebra where all
monomials are ordered corresponding to the given variable sequence. All pairs of
variables which are not explicitly covered in the commutator set are considered as
commutative and the corresponding rules are also activated.
</p><!--l. 48--><p class="noindent" >The second parameter in <span 
class="pcrr8t-x-x-109">nc_setup </span>may be omitted if the operator is called for the
second time, e.g. with a reordered variable sequence. In such a case the last commutator
set is used again.
</p><!--l. 53--><p class="noindent" >Remarks: </p>
     <ul class="itemize1">
     <li class="itemize">
     <!--l. 54--><p class="noindent" >The  variables  need  not  be  declared  <span 
class="pcrr8t-x-x-109">noncom </span>-  <span 
class="pcrr8t-x-x-109">nc_setup </span>performs  all
     necessary declarations.
     </p></li>
     <li class="itemize">
     <!--l. 56--><p class="noindent" >The   variables   need   not   be   formal   operator   expressions;   <span 
class="pcrr8t-x-x-109">nc_setup</span>
     encapsulates  a  variable  <span 
class="pcrr8t-x-x-109">x </span>internally  as  <span 
class="pcrr8t-x-x-109">nc!*(!_x) </span>expressions  anyway
     where the operator fnc!* keeps the noncom property.
     </p></li>
     <li class="itemize">
     <!--l. 60--><p class="noindent" >The commands <span 
class="pcrr8t-x-x-109">order </span>and <span 
class="pcrr8t-x-x-109">korder </span>should be avoided because <span 
class="pcrr8t-x-x-109">nc_setup</span>
     sets these such that the computation results are printed in the correct term
     order.</p></li></ul>
<!--l. 65--><p class="noindent" >Example:
                                                                     

                                                                     
</p>
<pre class="verbatim" id="verbatim-1210">
   nc_setup({KK,NN,k,n},
              {NN*n-n*NN= NN, KK*k-k*KK= KK});

   NN*n;            -&#x003E;   nn*n
   n*NN;            -&#x003E;   nn*n - nn
   nc_setup({k,n,KK,NN});
   NN*n - NN        -&#x003E;   n*nn;

</pre>
<!--l. 75--><p class="nopar" > Here \(KK,NN,k,n\) are non–commutative variables where the commutators are described as \([NN,n]=NN\),
\([KK,k]=KK\).
</p><!--l. 79--><p class="noindent" >The current term order must be compatible with the commutators: the product \(&lt;u&gt;*&lt;v&gt;\) must
precede all terms on the right hand side \(&lt;rh&gt;\) under the current term order. Consequently
</p>
     <ul class="itemize1">
     <li class="itemize">
     <!--l. 83--><p class="noindent" >the maximal degree of \(&lt;u&gt;\) or \(&lt;v&gt;\) in \(&lt;rh&gt;\) is 1,
     </p></li>
     <li class="itemize">
     <!--l. 84--><p class="noindent" >in a total degree ordering the total degree of \(&lt;rh&gt;\) may be not higher than 1,
     </p></li>
     <li class="itemize">
     <!--l. 86--><p class="noindent" >in  an  elimination  degree  order  (e.g.  \(lex\))  all  variables  in  \(&lt;rh&gt;\)  must  be  below  the
     minimum of \(&lt;u&gt;\) and \(&lt;v&gt;\).
     </p></li>
     <li class="itemize">
     <!--l. 88--><p class="noindent" >If \(&lt;rh&gt;\) does not contain any variables or has at most \(&lt;u&gt;\) or \(&lt;v&gt;\), any term order can be
     selected.</p></li></ul>
<a 
 id="dx234-934002"></a>
                                                                     

                                                                     
<!--l. 93--><p class="noindent" ><a 
 id="operator:NC_CLEANUP"></a> If you want to use the non–commutative variables or results from non–commutative
computations later in commutative operations it might be necessary to switch oﬀ the
non–commutative evaluation mode because not all operators in REDUCE are prepared
for that environment. In such a case use the command
  </p><div class="syntax">
   <span 
class="pcrr8t-x-x-109">nc_cleanup</span>;</div>
<!--l. 103--><p class="noindent" >without parameters. It removes all internal rules and deﬁnitions which <span 
class="pcrr8t-x-x-109">nc_setup </span>had
introduced. To reactive non–commutative call <span 
class="pcrr8t-x-x-109">nc_setup </span>again.
</p><!--l. 107--><p class="noindent" >
</p>
<h4 class="subsectionHead"><span class="titlemark">20.36.3    </span> <a 
 id="x234-93500020.36.3"></a>Left and right ideals</h4>
<!--l. 109--><p class="noindent" >A (polynomial) left ideal \(L\) is deﬁned by the axioms
</p><!--l. 111--><p class="noindent" >\(u \in L, v \in L \Longrightarrow u+v \in L\)
</p><!--l. 113--><p class="noindent" >\(u \in L \Longrightarrow k*u \in L\) for an arbitrary polynomial \(k\)
</p><!--l. 115--><p class="noindent" >where “*” is the non–commutative multiplication. Correspondingly, a right ideal \(R\) is
deﬁned by
</p><!--l. 118--><p class="noindent" >\(u \in R, v \in R \Longrightarrow u+v \in R\)
</p><!--l. 120--><p class="noindent" >\(u \in R \Longrightarrow u*k \in R\) for an arbitrary polynomial \(k\)
</p><!--l. 122--><p class="noindent" >
</p>
<h4 class="subsectionHead"><span class="titlemark">20.36.4    </span> <a 
 id="x234-93600020.36.4"></a>Gröbner bases</h4>
<a 
 id="dx234-936001"></a>
<!--l. 125--><p class="noindent" ><a 
 id="operator:NC_GROEBNER"></a> When a non–commutative environment has been set up by <span 
class="pcrr8t-x-x-109">nc_setup</span>, a basis for a left
or right polynomial ideal can be transformed into a Gröbner basis by the operator
<span 
class="pcrr8t-x-x-109">nc_groebner</span>:
  </p><div class="syntax">
   <span 
class="pcrr8t-x-x-109">nc_groebner</span>(\(\langle \)<span 
class="ptmri8t-x-x-109">plist</span>\(\rangle \));</div>
<!--l. 133--><p class="noindent" >Note that the variable set and variable sequence must be deﬁned before
in the <span 
class="pcrr8t-x-x-109">nc_setup </span>call. The term order for the Gröbner calculation can be
                                                                     

                                                                     
set by using the <span 
class="pcrr8t-x-x-109">torder </span>declaration. The internal steps of the Gröbner
calculation can be watched by setting the switches <span 
class="pcrr8t-x-x-109">trgroeb </span>(=list all internal
basis polynomials) or <span 
class="pcrr8t-x-x-109">trgroebs </span>(=list additionally the \(S\)-polynomials)
<span class="footnote-mark"><a 
href="manual235.html#fn36x20"><sup class="textsuperscript">36</sup></a></span><a 
 id="x234-936002f36"></a>.
</p><!--l. 144--><p class="noindent" >For details about <span 
class="pcrr8t-x-x-109">torder</span>, <span 
class="pcrr8t-x-x-109">trgroeb </span>and <span 
class="pcrr8t-x-x-109">trgroebs </span>see section <a 
href="../manual-lookup.php%3FGROEBNER:.html#x213-73800020.25">20.25<!--tex4ht:ref: GROEBNER --></a>.
                                                                     

                                                                     
</p>
<pre class="verbatim" id="verbatim-1211">
2: nc_setup({k,n,NN,KK},{NN*n-n*NN=NN,KK*k-k*KK=KK},left);

3: p1 := (n-k+1)*NN - (n+1);

p1 :=  - k*nn + n*nn - n + nn - 1

4: p2 := (k+1)*KK -(n-k);

p2 := k*kk + k - n + kk

5: nc_groebner ({p1,p2});

{k*nn - n*nn + n - nn + 1,

 k*kk + k - n + kk,

 n*nn*kk - n*kk - n + nn*kk - kk - 1}

</pre>
<!--l. 165--><p class="nopar" > Important: Do not use the operators of the <span 
class="ptmrc8t-x-x-109">G<span 
class="small-caps">R</span><span 
class="small-caps">O</span><span 
class="small-caps">E</span><span 
class="small-caps">B</span><span 
class="small-caps">N</span><span 
class="small-caps">E</span><span 
class="small-caps">R</span> </span>package directly as they would
not consider the non–commutative multiplication.
</p>
<h4 class="subsectionHead"><span class="titlemark">20.36.5    </span> <a 
 id="x234-93700020.36.5"></a>Left or right polynomial division</h4>
<a 
 id="dx234-937001"></a>
<!--l. 173--><p class="noindent" ><a 
 id="operator:NC_DIVIDE"></a> The operator <span 
class="pcrr8t-x-x-109">nc_divide </span>computes the one sided quotient and remainder of two
polynomials:
  </p><div class="syntax">
   <span 
class="pcrr8t-x-x-109">nc_divide</span>(\(\langle \)<span 
class="ptmri8t-x-x-109">p1</span>\(\rangle \),\(\langle \)<span 
class="ptmri8t-x-x-109">p2</span>\(\rangle \));</div>
<!--l. 179--><p class="noindent" >The result is a list with quotient and remainder. The division is performed as a
pseudo–division, multiplying \(&lt;p1&gt;\) by coeﬃcients if necessary. The result \(\{&lt;q&gt;,&lt;r&gt;\}\) is deﬁned by the
relation
</p><!--l. 184--><p class="noindent" >\(&lt;c&gt;*&lt;p1&gt;=&lt;q&gt;*&lt;p2&gt; + &lt;r&gt;\) for direction \(left\) and
                                                                     

                                                                     
</p><!--l. 186--><p class="noindent" >\(&lt;c&gt;*&lt;p1&gt;=&lt;p2&gt;*&lt;q&gt; + &lt;r&gt;\) for direction \(right\),
</p><!--l. 188--><p class="noindent" >where \(&lt;c&gt;\) is an expression that does not contain any of the ideal variables, and the
leading term of \(&lt;r&gt;\) is lower than the leading term of \(\langle \)<span 
class="ptmri8t-x-x-109">p2</span>\(\rangle \) according to the actual term
order.
</p><!--l. 192--><p class="noindent" >
</p>
<h4 class="subsectionHead"><span class="titlemark">20.36.6    </span> <a 
 id="x234-93800020.36.6"></a>Left or right polynomial reduction</h4>
<a 
 id="dx234-938001"></a>
<!--l. 195--><p class="noindent" ><a 
 id="operator:NC_PREDUCE"></a> For the computation of the one sided remainder of a polynomial modulo a given set of
other polynomials the operator <span 
class="pcrr8t-x-x-109">nc_preduce </span>may be used:
  </p><div class="syntax">
   <span 
class="pcrr8t-x-x-109">nc_preduce</span>(\(\langle \)<span 
class="ptmri8t-x-x-109">polynomial</span>\(\rangle \),\(\langle \)<span 
class="ptmri8t-x-x-109">plist</span>\(\rangle \));</div>
<!--l. 202--><p class="noindent" >The result of the reduction is unique (canonical) if and only if \(\langle \)<span 
class="ptmri8t-x-x-109">plist</span>\(\rangle \) is a one sided
Gröbner basis. Then the computation is at the same time an ideal membership test: if
the result is zero, the polynomial is member of the ideal, otherwise not.
</p><!--l. 208--><p class="noindent" >
</p>
<h4 class="subsectionHead"><span class="titlemark">20.36.7    </span> <a 
 id="x234-93900020.36.7"></a>Factorization</h4>
<!--l. 210--><p class="noindent" >
</p>
<h5 class="subsubsectionHead"><span class="titlemark">20.36.7.1    </span> <a 
 id="x234-94000020.36.7.1"></a>Technique</h5>
<a 
 id="dx234-940001"></a>
<!--l. 213--><p class="noindent" ><a 
 id="operator:NC_FACTORIZE"></a> Polynomials in a non–commutative ring cannot be factored using the ordinary
<span 
class="pcrr8t-x-x-109">factorize </span>command of REDUCE. Instead one of the operators of this section must be
used:
  </p><div class="syntax">
   <span 
class="pcrr8t-x-x-109">nc_factorize</span>(\(\langle \)<span 
class="ptmri8t-x-x-109">polynomial</span>\(\rangle \));</div>
<!--l. 220--><p class="noindent" >The result is a list of factors of \(\langle \)<span 
class="ptmri8t-x-x-109">polynomial</span>\(\rangle \). A list with the input expression is returned if
it is irreducible.
                                                                     

                                                                     
<a 
 id="dx234-940002"></a>
</p><!--l. 224--><p class="noindent" ><a 
 id="operator:NC_FACTORIZE_ALL"></a> As non–commutative factorization is not unique, there is an additional operator which
computes all possible factorizations
  </p><div class="syntax">
   <span 
class="pcrr8t-x-x-109">nc_factorize_all</span>(\(\langle \)<span 
class="ptmri8t-x-x-109">polynomial</span>\(\rangle \));</div>
<!--l. 230--><p class="noindent" >The result is a list of factor decompositions of \(\langle \)<span 
class="ptmri8t-x-x-109">polynomial</span>\(\rangle \). If there are no factors
at all the result list has only one member which is a list containing the input
polynomial.
</p><!--l. 234--><p class="noindent" >
</p>
<h5 class="subsubsectionHead"><span class="titlemark">20.36.7.2    </span> <a 
 id="x234-94100020.36.7.2"></a>Control of the factorization</h5>
<a 
 id="dx234-941001"></a>
<a 
 id="dx234-941002"></a>
<a 
 id="dx234-941003"></a>
<a 
 id="dx234-941004"></a>
<!--l. 240--><p class="noindent" ><a 
 id="operator:LEFT_FACTOR"></a> <a 
 id="operator:RIGHT_FACTOR"></a> <a 
 id="operator:LEFT_FACTORS"></a> <a 
 id="operator:RIGHT_FACTORS"></a> In contrast to factoring in commutative polynomial rings, the non–commutative
factorization is rather time consuming. Therefore two additional operators allow you to
reduce the amount of computing time when you look only for isolated factors in special
context, e.g. factors with a limited degree or factors which contain only explicitly
speciﬁed variables:
  </p><div class="syntax">
  <!--tex4ht:inline--><div class="tabular"> <table id="TBL-142" class="tabular" 
 
><colgroup id="TBL-142-1g"><col 
id="TBL-142-1" /><col 
id="TBL-142-2" /><col 
id="TBL-142-3" /></colgroup><tr  
 style="vertical-align:baseline;" id="TBL-142-1-"><td  style="white-space:nowrap; text-align:left;" id="TBL-142-1-1"  
class="td01"><span 
class="pcrr8t-x-x-109">left_factor</span>(\(\langle \)<span 
class="ptmri8t-x-x-109">polynomial</span>\(\rangle \)[,\(\langle \)<span 
class="ptmri8t-x-x-109">deg</span>\(\rangle \)[,\(\langle \)<span 
class="ptmri8t-x-x-109">vars</span>\(\rangle \)]])    </td>
</tr><tr  
 style="vertical-align:baseline;" id="TBL-142-2-"><td  style="white-space:nowrap; text-align:left;" id="TBL-142-2-1"  
class="td01"><span 
class="pcrr8t-x-x-109">right_factor</span>(\(\langle \)<span 
class="ptmri8t-x-x-109">polynomial</span>\(\rangle \)[,\(\langle \)<span 
class="ptmri8t-x-x-109">deg</span>\(\rangle \)[,\(\langle \)<span 
class="ptmri8t-x-x-109">vars</span>\(\rangle \)]])  </td>
</tr><tr  
 style="vertical-align:baseline;" id="TBL-142-3-"><td  style="white-space:nowrap; text-align:left;" id="TBL-142-3-1"  
class="td01"><span 
class="pcrr8t-x-x-109">left_factors</span>(\(\langle \)<span 
class="ptmri8t-x-x-109">polynomial</span>\(\rangle \)[,\(\langle \)<span 
class="ptmri8t-x-x-109">deg</span>\(\rangle \)[,\(\langle \)<span 
class="ptmri8t-x-x-109">vars</span>\(\rangle \)]])  </td>
</tr><tr  
 style="vertical-align:baseline;" id="TBL-142-4-"><td  style="white-space:nowrap; text-align:left;" id="TBL-142-4-1"  
class="td01"><span 
class="pcrr8t-x-x-109">right_factors</span>(\(\langle \)<span 
class="ptmri8t-x-x-109">polynomial</span>\(\rangle \)[,\(\langle \)<span 
class="ptmri8t-x-x-109">deg</span>\(\rangle \)[,\(\langle \)<span 
class="ptmri8t-x-x-109">vars</span>\(\rangle \)]])</td></tr></table>
  </div></div>
<!--l. 256--><p class="noindent" >where \(\langle \)<span 
class="ptmri8t-x-x-109">polynomial</span>\(\rangle \) is the form under investigation, \(\langle \)<span 
class="ptmri8t-x-x-109">vars</span>\(\rangle \) is an optional list of
variables which must appear in the factor, and \(\langle \)<span 
class="ptmri8t-x-x-109">deg</span>\(\rangle \) is an optional integer degree
bound for the total degree of the factor, a zero for an unbounded search, or
a monomial (product of powers of the variables) where each exponent is an
individual degree bound for its base variable; unmentioned variables are allowed in
arbitrary degree. The operators <span 
class="pcrr8t-x-x-109">right_factor </span>and <span 
class="pcrr8t-x-x-109">left_factor </span>stop
when they have found one factor, while the operators <span 
class="pcrr8t-x-x-109">right_factors </span>and
<span 
class="pcrr8t-x-x-109">left_factors </span>select all one–sided factors within the given range. If there is no
factor of the desired type, an empty list is returned by <span 
class="pcrr8t-x-x-109">right_factors </span>and
<span 
class="pcrr8t-x-x-109">left_factors </span>while the routines <span 
class="pcrr8t-x-x-109">right_factor </span>and <span 
class="pcrr8t-x-x-109">left_factor </span>return the
input polynomial.
                                                                     

                                                                     
</p><!--l. 270--><p class="noindent" >
</p>
<h5 class="subsubsectionHead"><span class="titlemark">20.36.7.3    </span> <a 
 id="x234-94200020.36.7.3"></a>Time of the factorization</h5>
<a 
 id="dx234-942001"></a>
<!--l. 273--><p class="noindent" ><a 
 id="variable:NC_FACTOR_TIME"></a> The share variable <span 
class="pcrr8t-x-x-109">nc_factor_time </span>sets an upper limit for the time to be spent for a
call to the non–commutative factorizer. If the value is a positive integer, a factorization is
terminated with an error message as soon as the time limit is reached. The time units are
milliseconds.
</p><!--l. 280--><p class="noindent" >
</p>
<h5 class="subsubsectionHead"><span class="titlemark">20.36.7.4    </span> <a 
 id="x234-94300020.36.7.4"></a>Usage of SOLVE</h5>
<!--l. 282--><p class="noindent" >The factorizer internally uses <span 
class="pcrr8t-x-x-109">solve</span><a 
 id="dx234-943001"></a>, which is controlled by the REDUCE switch
<span 
class="pcrr8t-x-x-109">varopt</span><a 
 id="dx234-943002"></a><a 
 id="dx234-943003"></a><a 
 id="dx234-943004"></a>. This switch (which per default is set on) allows to reorder the variable
sequence, which is favourable for the normal system. It should be avoided to set <span 
class="pcrr8t-x-x-109">varopt</span>
oﬀ when using the non–commutative factorizer, unless very small polynomials are
used.
</p><!--l. 289--><p class="noindent" >
</p>
<h4 class="subsectionHead"><span class="titlemark">20.36.8    </span> <a 
 id="x234-94400020.36.8"></a>Output of expressions</h4>
<a 
 id="dx234-944001"></a>
<!--l. 292--><p class="noindent" ><a 
 id="operator:NC_COMPACT"></a> It is often desirable to have the commutative parts (coeﬃcients) in a non–commutative
operation condensed by factorization. The operator
  </p><div class="syntax">
   <span 
class="pcrr8t-x-x-109">nc_compact</span>(\(\langle \)<span 
class="ptmri8t-x-x-109">polynomial</span>\(\rangle \))</div>
<!--l. 298--><p class="noindent" >collects the coeﬃcients to the powers of the lowest possible non-commutative
variable.
                                                                     

                                                                     
</p>
<pre class="verbatim" id="verbatim-1212">
load ncpoly;

nc_setup({n,NN},{NN*n-n*NN=NN})$
p1 := n**4 + n**2*nn + 4*n**2 + 4*n*nn + 4*nn + 4;

       4    2         2
p1 := n  + n *nn + 4*n  + 4*n*nn + 4*nn + 4

nc_compact p1;

  2     2          2
(n  + 2)  + (n + 2) *nn
</pre>
<!--l. 313--><p class="nopar" >
</p><!--l. 711--><p class="noindent" >
                                                                     

                                                                     
                                                                     

                                                                     
</p><!--l. 713--><p class="noindent" ><table cellspacing="5"><tr><td class="clinks"><a 
href="../manual-lookup.php%3FUser&#32;Contributed&#32;Packages.html#manualse159.html" >Up</a></td><td class="clinks"><a 
href="manualse160.html" >Next</a></td><td class="clinks"><a 
href="manualse158.html" >Prev</a></td><td class="clinks"><a 
href="manualse158.html#tailmanualse158.html" >PrevTail</a></td><td class="clinks"><a 
href="manualse159.html" >Front</a></td></tr></table><a 
 id="tailmanualse159.html"></a>  <hr> <p style="font-family:sans-serif">Hosted by <a href="https://sourceforge.net/p/reduce-algebra/"> <img title="Download REDUCE" alt="Download REDUCE" style="vertical-align:middle" src="https://sourceforge.net/sflogo.php?type=16&amp;group_id=248416"/></a> <a href="https://www.mathjax.org"> <img title="Powered by MathJax" alt="Powered by MathJax" style="float:right" src="https://www.mathjax.org/badge/badge.gif"/></a></p></p> 
</body> 
</html>