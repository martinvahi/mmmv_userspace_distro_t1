<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"  
  "http://www.w3.org/TR/html4/loose.dtd">  
<html > 
<head><title>Evaluator Functions Eval and Apply</title> 
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1"> 
<meta name="generator" content="TeX4ht (http://www.cse.ohio-state.edu/~gurari/TeX4ht/)"> 
<meta name="originator" content="TeX4ht (http://www.cse.ohio-state.edu/~gurari/TeX4ht/)"> 
<!-- 3,html --> 
<meta name="src" content="allman1.tex"> 
<meta name="date" content="2014-05-02 18:10:00"> 
<link rel="stylesheet" type="text/css" href="allman1.css"> 
</head><body 
>
<p align="centre"><img src="https://reduce-algebra.sourceforge.io/lisp-docs/redlogo.png" width=621 height=60 border=0 alt="REDUCE"></p><table cellspacing="5"><tr><td class="clinks"><a 
href="allman1li8.html#allman1se29.html" >Up</a></td><td class="clinks"><a 
href="allman1se30.html" >Next</a></td><td class="clinks"><a 
href="allman1se29.html#tailallman1se29.html">Tail</a></td></tr></table><h3 class="sectionHead"><span class="titlemark">9.1    </span> <a 
 id="x40-1050009.1"></a>Evaluator Functions Eval and Apply</h3>
<!--l. 6--><p class="noindent" >The evaluator is responsible for the execution of PSL programs. The evaluator is available to the
user through the function eval. This function gives the operational semantics, or meaning, to the
programming constructs found in PSL. With eval we have the ability to evaluate constructed
expressions. The ability to evaluate lists which have the appearance of expressions highlights the
program data duality of LISP.
<!--l. 14--><p class="noindent" >Apply represents the piece of the evaluator which is responsible for invoking functions. Any list
which is not quoted is taken to be a function application by the evaluator. Apply provides the
user with a tool to explicity invoke functions.
<!--l. 20--><p class="noindent" >In eval, apply and the support functions which follow, errors are continuable. When an error
occurs the user is permitted to correct the offending expression or perhaps define a
missing function (see Chapter 16 for more information). If the number of arguments to a
function is not equal to the number of parameters specified by the definition then the
error

<div class="verbatim" id="verbatim-266">
&#x22C6;&#x22C6;&#x22C6;&#x22C6;&#x22C6;&#x00A0;Argument&#x00A0;number&#x00A0;mismatch
</div>
<!--l. 29--><p class="nopar" >occurs. If there is an id in the function position of a form, and there is no function definition
associated with it, an error occurs and the message

<div class="verbatim" id="verbatim-267">
&#x22C6;&#x22C6;&#x22C6;&#x22C6;&#x22C6;&#x00A0;&#8216;NAME'&#x00A0;is&#x00A0;an&#x00A0;undefined&#x00A0;function
</div>
<!--l. 36--><p class="nopar" >is printed. If the function position is not occupied by an id, lambda expression or code-pointer
then it is an error and one of the following is printed.

<div class="verbatim" id="verbatim-268">
&#x22C6;&#x22C6;&#x22C6;&#x22C6;&#x22C6;&#x00A0;Ill-formed&#x00A0;expression&#x00A0;in&#x00A0;EVAL&#x00A0;&#8216;FORM'
</div>
<!--l. 43--><p class="nopar" >

<div class="verbatim" id="verbatim-269">
&#x22C6;&#x22C6;&#x22C6;&#x22C6;&#x22C6;&#x00A0;Ill-formed&#x00A0;expression&#x00A0;&#8216;FORM'
</div>
<!--l. 46--><p class="nopar" >The first message is displayed when the error is detected within eval.
<!--l. 56--><p class="noindent" ><div class="minipage"><a 
 id="dx40-105001"></a>
<span 
class="ptmb7t-x-x-120">(eval U:form): any                                                                                                        </span><span 
class="ptmri7t-x-x-120">expr</span>
<br 
class="newline" /><div class="minipage">The value of the form U is computed. Since eval is a function of type expr
it will receive its argument already evaluated. Since it will then evaluate the
argument itself, it may seem as though the evaluation is done twice. The
argument U cannot access local variables.</div>
</div>
<!--l. 58--><p class="noindent" >As a basis for discussion, an approximation to the actual definition of eval is given.

<div class="verbatim" id="verbatim-270">
&#x00A0;&#x00A0;&#x00A0;&#x00A0;(de&#x00A0;eval&#x00A0;(e)
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;(cond&#x00A0;((is-constant&#x00A0;e)&#x00A0;(denote&#x00A0;e))
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;((idp&#x00A0;e)&#x00A0;(valuecell&#x00A0;e))
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;(t&#x00A0;(let&#x00A0;((fun&#x00A0;(first&#x00A0;e))
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;(args&#x00A0;(rest&#x00A0;e)))
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;(cond&#x00A0;((and&#x00A0;(idp&#x00A0;fun)
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;(not&#x00A0;(funboundp&#x00A0;fun)))
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;(selectq&#x00A0;(first&#x00A0;(getd&#x00A0;fun))
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;(expr&#x00A0;(apply&#x00A0;fun&#x00A0;(evlis&#x00A0;args)))
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;(fexpr&#x00A0;(apply&#x00A0;fun&#x00A0;(list&#x00A0;args)))
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;(nexpr
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;(apply&#x00A0;fun
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;(list&#x00A0;(evlis&#x00A0;&#x00A0;args))))
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;(macro
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;(eval&#x00A0;(apply&#x00A0;fun&#x00A0;(list&#x00A0;e))))))
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;((or&#x00A0;(codep&#x00A0;fun)
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;(is-lambda&#x00A0;fun))
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;(apply&#x00A0;fun&#x00A0;(evlis&#x00A0;args)))
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;(t&#x00A0;(error)))))))
</div>
<!--l. 81--><p class="nopar" >Eval first determines if its argument is a constant. Examples of constants are numbers, strings,
vectors and quoted expressions. For the most part, the function denote will simply return its
argument. However, if the constant is a quoted expression then the expression is returned as
value.

<div class="verbatim" id="verbatim-271">
&#x00A0;&#x00A0;&#x00A0;&#x00A0;1&#x00A0;lisp&#x003E;&#x00A0;(eval&#x00A0;"STRING")
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;"STRING"
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;2&#x00A0;lisp&#x003E;&#x00A0;(eval&#x00A0;(mkquote&#x00A0;'(one)))
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;(ONE)
</div>
<!--l. 94--><p class="nopar" >An identifier is considered a variable. In such a case, eval returns the contents of
the value cell of the identifier. Of course things are not quite all that simple. This
raises a conceptual issue about when to find the values. The issue is one of scoping
rules. Scoping rules come into play when functions are defined. In particular, this
involves free variables (those variables which are not parameters of the definition). One
approach is static scoping. This strategy locates the values of free variables at the time
the function is defined. PSL uses a second approach called dynamic scoping. Using
this approach, the values of free variables are not determined until the function is
applied.

<div class="verbatim" id="verbatim-272">
&#x00A0;&#x00A0;&#x00A0;&#x00A0;1&#x00A0;lisp&#x003E;&#x00A0;(setq&#x00A0;number&#x00A0;0)
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;0
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;2&#x00A0;lisp&#x003E;&#x00A0;(de&#x00A0;bar&#x00A0;()&#x00A0;(foo)&#x00A0;(add1&#x00A0;number))
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;BAR
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;3&#x00A0;lisp&#x003E;&#x00A0;(de&#x00A0;foo&#x00A0;()&#x00A0;(setq&#x00A0;number&#x00A0;1))
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;FOO
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;%&#x00A0;When&#x00A0;bar&#x00A0;was&#x00A0;defined&#x00A0;the&#x00A0;value&#x00A0;of&#x00A0;number&#x00A0;was&#x00A0;0,
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;% during&#x00A0;the&#x00A0;evaluation
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;%&#x00A0;of&#x00A0;bar&#x00A0;the&#x00A0;application&#x00A0;of&#x00A0;foo&#x00A0;changed&#x00A0;the&#x00A0;value
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;% of&#x00A0;number&#x00A0;to&#x00A0;1.&#x00A0;If
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;%&#x00A0;static&#x00A0;scoping&#x00A0;were&#x00A0;being&#x00A0;used&#x00A0;then&#x00A0;the&#x00A0;result
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;% would&#x00A0;be&#x00A0;1&#x00A0;instead&#x00A0;of&#x00A0;2.
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;4&#x00A0;lisp&#x003E;&#x00A0;(bar)
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;2
</div>
<!--l. 124--><p class="nopar" >The PSL environment (the values associated with variables) will typically change during
evaluation. When a function is applied, the variables specified by its definition are
associated with the arguments of the application. As a result, the value of each variable has
changed. As noted above, the value of a variable is found in its value cell. However, the
definition and access of values depends upon the binding strategy being used by the
implementation. Two common techniques are shallow binding (used in the current
implementation of PSL), and deep binding. In a deep bound system the environment is
defined by a table of names and values. Each time a variable is set to a value, an entry is
added to the table. To locate the value of a variable this table must be searched. When
there are multiple definitions for a given variable within this table, the convention is
adopted that it is always the latest value which is retrieved. With this strategy we can
easily restore an old value, by simply removing the current value from the table. With
shallow binding, the value of a variable is positioned with the id which represents the
variable. In this case there is no need to search for a value. It is known to always
be in a fixed location, the value cell of the id. This second technique makes finding
values much more efficient, but it is much more difficult now to keep track of previous
values.<br 
class="newline" />
<!--l. 151--><p class="noindent" >If the expression being evaluated is neither a constant or a variable it is assumed to be a function
application form. When we apply the function definition to the arguments we associate the
parameters of the definition with the arguments. This process of association is called binding
and simulates substitution. Within the new environment the body of the function is
evaluated. Notice we do not explicitly substitute the values for the variables in an
expression.

<div class="verbatim" id="verbatim-273">
&#x00A0;&#x00A0;&#x00A0;&#x00A0;1&#x00A0;lisp&#x003E;&#x00A0;(eval&#x00A0;'((lambda&#x00A0;(this)&#x00A0;(add1&#x00A0;this))&#x00A0;0))
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;1
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;%&#x00A0;If&#x00A0;an&#x00A0;expression&#x00A0;is&#x00A0;neither&#x00A0;a&#x00A0;constant&#x00A0;or
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;% a&#x00A0;variable&#x00A0;then&#x00A0;it&#x00A0;is&#x00A0;assumed
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;%&#x00A0;to&#x00A0;be&#x00A0;a&#x00A0;function&#x00A0;application&#x00A0;form.
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;2&#x00A0;lisp&#x003E;&#x00A0;(eval&#x00A0;'(one))
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x22C6;&#x22C6;&#x22C6;&#x22C6;&#x22C6;&#x00A0;&#8216;ONE'&#x00A0;is&#x00A0;an&#x00A0;undefined&#x00A0;function
</div>
<!--l. 171--><p class="nopar" >Eval first looks at the function position, making sure a function definition is available. The
manner in which the function is applied depends upon the type of the function. For both exprs
and nexprs the arguments are evaluated in a left to right order by the function evlis. Since nexprs
expect a single argument, the arguments are gathered into a list. The arguments to an fexpr are
not evaluated but they are gathered into a list. The remaining function type to consider is macro.
The entire function application form is passed to macros. The result of applying the macro is
then evaluated.
<!--l. 188--><p class="noindent" ><div class="minipage"><a 
 id="dx40-105002"></a>
<span 
class="ptmb7t-x-x-120">(apply FUN:id, function ARGS:any-list): any                                                          </span><span 
class="ptmri7t-x-x-120">expr</span>
<br 
class="newline" /><div class="minipage">Applies the function FUN to the list of arguments ARGS. The following is
an approximation of the real code.</div>
</div>

<div class="verbatim" id="verbatim-274">
&#x00A0;&#x00A0;&#x00A0;&#x00A0;(de&#x00A0;apply&#x00A0;(fun&#x00A0;args)
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;(cond&#x00A0;((and&#x00A0;(idp&#x00A0;fun)&#x00A0;(not&#x00A0;(funboundp&#x00A0;fun)))
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;(if&#x00A0;(fcodep&#x00A0;fun)
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;(codeapply&#x00A0;(getfcodepointer&#x00A0;fun)&#x00A0;args)
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;(lambdaapply&#x00A0;(get&#x00A0;fun&#x00A0;'&#x22C6;lambdalink)&#x00A0;args)))
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;((codep&#x00A0;fun)&#x00A0;(codeapply&#x00A0;fun&#x00A0;args))
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;((is-lambda&#x00A0;fun)&#x00A0;(lambdaapply&#x00A0;fun&#x00A0;args))
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;(t&#x00A0;(error))))
</div>
<!--l. 198--><p class="nopar" >Apply uses the additional functions codeapply and lambdaapply to actually evaluate the body of
the function. The arguments in ARGS are not evaluated (for example, by a call on evlis). This
may seem odd since the type of the function may be expr or nexpr. Apply assumes that the
arguments are in the form required for binding to the formal parameters of FUN.
Getcodepointer returns the code-pointer associated with an id. The body of a function
which is not compiled is found on the property list of its name, under the *lambdalink
indicator.

<div class="verbatim" id="verbatim-275">
&#x00A0;&#x00A0;&#x00A0;&#x00A0;1&#x00A0;lisp&#x003E;&#x00A0;(setq&#x00A0;fn&#x00A0;'add1)
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;ADD1
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;2&#x00A0;lisp&#x003E;&#x00A0;(de&#x00A0;fn&#x00A0;(a)&#x00A0;(sub1&#x00A0;a))
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;FN
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;3&#x00A0;lisp&#x003E;&#x00A0;(apply&#x00A0;fn&#x00A0;'(1))
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;2
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;4&#x00A0;lisp&#x003E;&#x00A0;(apply&#x00A0;'fn&#x00A0;'(1))
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;0
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;5&#x00A0;lisp&#x003E;&#x00A0;(apply&#x00A0;'cons&#x00A0;'((add1&#x00A0;2)&#x00A0;3))
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;((add1&#x00A0;2)&#x00A0;.&#x00A0;3)&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;%&#x00A0;NOT&#x00A0;(3&#x00A0;.&#x00A0;3)
</div>
<!--l. 221--><p class="nopar" >
<!--l. 226--><p class="noindent" ><div class="minipage"><a 
 id="dx40-105003"></a>
<span 
class="ptmb7t-x-x-120">(funcall FUN:id, function [ARGUMENT:any]): any                                            </span><span 
class="ptmri7t-x-x-120">macro</span>
<br 
class="newline" /><div class="minipage">Equivalent to (apply FUN (list ARGUMENT1 ... ARGUMENTN)). This
function is defined in the USEFUL module.</div></div>

<table cellspacing="5"><tr><td class="clinks"><a 
href="allman1li8.html#allman1se29.html" >Up</a></td><td class="clinks"><a 
href="allman1se30.html" >Next</a></td><td class="clinks"><a 
href="allman1se29.html" >Front</a></td></tr></table><a 
 id="tailallman1se29.html"></a>  
</body></html> 
