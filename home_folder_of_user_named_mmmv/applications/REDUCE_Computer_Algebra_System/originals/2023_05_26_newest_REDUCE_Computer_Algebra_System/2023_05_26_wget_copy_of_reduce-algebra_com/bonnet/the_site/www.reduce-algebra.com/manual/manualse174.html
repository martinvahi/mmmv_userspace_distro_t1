<!DOCTYPE html> 
<html lang="en-US" xml:lang="en-US" > 
<head><title>SETS: A Basic Set Theory Package</title> 
<meta  charset="utf-8" /> 
<meta name="generator" content="TeX4ht (https://tug.org/tex4ht/)" /> 
<meta name="viewport" content="width=device-width,initial-scale=1" /> 
<link rel="stylesheet" type="text/css" href="manual.css" /> 
<meta name="src" content="manual.tex" /> 
<script>window.MathJax = { tex: { tags: "ams", }, }; </script> 
 <script type="text/javascript" async="async" id="MathJax-script" src="../../cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js"></script>  
<meta name="description" content="The REDUCE Computer Algebra System User's Manual" /> 
</head><body 
>
<header>REDUCE</header><table cellspacing="5"><tr><td class="clinks"><a 
href="../manual-lookup.php%3FUser&#32;Contributed&#32;Packages.html#manualse174.html" >Up</a></td><td class="clinks"><a 
href="manualse175.html" >Next</a></td><td class="clinks"><a 
href="../manual-lookup.php%3FSCOPE.html" >Prev</a></td><td class="clinks"><a 
href="../manual-lookup.php%3FSCOPE.html#tailmanualse173.html" >PrevTail</a></td><td class="clinks"><a 
href="manualse174.html#tailmanualse174.html">Tail</a></td></tr></table><h3 class="sectionHead"><span class="titlemark">20.51    </span> <a 
 id="x258-105200020.51"></a>SETS: A Basic Set Theory Package</h3>
<a 
 id="dx258-1052001"></a>
<a 
 id="dx258-1052002"></a>
<!--l. 1104--><p class="noindent" >Author: Francis J. Wright.
<a 
 id="dx258-1052003"></a>
</p><!--l. 1--><p class="noindent" > <a 
 id="dx258-1052004"></a>
</p><!--l. 6--><p class="noindent" >The SETS package for REDUCE provides algebraic-mode support for set operations on
lists regarded as sets (or representing explicit sets) and on implicit sets represented by
identiﬁers. It provides the set-valued inﬁx operators (with synonyms) <span 
class="pcrr8t-x-x-109">union</span>,
<span 
class="pcrr8t-x-x-109">intersection </span>(<span 
class="pcrr8t-x-x-109">intersect</span>) and <span 
class="pcrr8t-x-x-109">setdiff </span>(<span 
class="pcrr8t-x-x-109">\</span>, <span 
class="pcrr8t-x-x-109">minus</span>) and the Boolean-valued
inﬁx operators (predicates) <span 
class="pcrr8t-x-x-109">member</span>, <span 
class="pcrr8t-x-x-109">subset_eq</span>, <span 
class="pcrr8t-x-x-109">subset</span>, <span 
class="pcrr8t-x-x-109">set_eq</span>. The union and
intersection operators are n-ary and the rest are binary. A list can be explicitly converted
to the canonical set representation by applying the operator <span 
class="pcrr8t-x-x-109">mkset</span>. (The package also
provides an operator not speciﬁcally related to set theory called <span 
class="pcrr8t-x-x-109">evalb </span>that
allows the value of any Boolean-valued expression to be displayed in algebraic
mode.)
</p><!--l. 22--><p class="noindent" >
</p>
<h4 class="subsectionHead"><span class="titlemark">20.51.1    </span> <a 
 id="x258-105300020.51.1"></a>Introduction</h4>
<!--l. 24--><p class="noindent" >REDUCE has no speciﬁc representation for a set, neither in algebraic mode nor
internally, and any object that is mathematically a set is represented in REDUCE as a list.
The diﬀerence between a set and a list is that in a set the ordering of elements is not
signiﬁcant and duplicate elements are not allowed (or are ignored). Hence a list provides
a perfectly natural and satisfactory representation for a set (but not vice versa). Some
languages, such as Maple, provide diﬀerent internal representations for sets
and lists, which may allow sets to be processed more eﬃciently, but this is not
<span 
class="ptmri8t-x-x-109">necessary</span>.
</p><!--l. 34--><p class="noindent" >This package supports set theoretic operations on lists and represents the results as
normal algebraic-mode lists, so that all other REDUCE facilities that apply to lists can
still be applied to lists that have been constructed by explicit set operations. The
algebraic-mode set operations provided by this package have all been available in
symbolic mode for a long time, and indeed are used internally by the rest of REDUCE,
                                                                     

                                                                     
so in that sense set theory facilities in REDUCE are far from new. What this package
does is make them available in algebraic mode, generalize their operation by extending
the arity of union and intersection, and allow their arguments to be implicit sets
represented by unbound identiﬁers. It performs some simpliﬁcations on such
symbolic set-valued expressions, but this is currently rather <span 
class="ptmri8t-x-x-109">ad hoc </span>and is probably
incomplete.
</p><!--l. 48--><p class="noindent" >For examples of the operation of the SETS package see (or run) the test ﬁle <span 
class="pcrr8t-x-x-109">sets.tst</span>.
This package is experimental and developments are under consideration; if you have
suggestions for improvements (or corrections) then please send them to me (FJW),
preferably by email. The package is intended to be run under REDUCE 3.5 and later
versions; it may well run correctly under earlier versions although I cannot provide
support for such use.
</p><!--l. 57--><p class="noindent" >
</p>
<h4 class="subsectionHead"><span class="titlemark">20.51.2    </span> <a 
 id="x258-105400020.51.2"></a>Inﬁx operator precedence</h4>
<!--l. 59--><p class="noindent" >The set operators are currently inserted into the standard REDUCE precedence list (see
page <a 
href="manualse7.html#x12-140002.7">66<!--tex4ht:ref: sect:infix --></a>, §<a 
href="manualse7.html#x12-140002.7">2.7<!--tex4ht:ref: sect:infix --></a>, of the REDUCE manual) as follows:
                                                                     

                                                                     
</p>
<pre class="verbatim" id="verbatim-1297">
or and not member memq = set_eq neq eq &#x003E;= &#x003E; &#x003C;= &#x003C; subset_eq
subset freeof + - setdiff union intersection * / ^ .
</pre>
<!--l. 65--><p class="nopar" >
</p><!--l. 68--><p class="noindent" >
</p>
<h4 class="subsectionHead"><span class="titlemark">20.51.3    </span> <a 
 id="x258-105500020.51.3"></a>Explicit set representation and <span 
class="pcrr8t-x-x-109">mkset</span></h4>
<a 
 id="dx258-1055001"></a>
<!--l. 70--><p class="noindent" ><a 
 id="operator:SETS_MKSET"></a>
</p><!--l. 72--><p class="noindent" >Explicit sets are represented by lists, and this package does not require any restrictions at
all on the forms of lists that are regarded as sets. Nevertheless, duplicate elements in a set
correspond by deﬁnition to the same element and it is conventional and convenient to
represent them by a single element, i.e. to remove any duplicate elements. I
will call this a normal representation. Since the order of elements in a set is
irrelevant it is also conventional and may be convenient to sort them into some
standard order, and an appropriate ordering of a normal representation gives
a canonical representation. This means that two identical sets have identical
representations, and therefore the standard REDUCE equality predicate (<span 
class="pcrr8t-x-x-109">=</span>)
<a 
 id="dx258-1055002"></a> correctly determines set equality; without a canonical representation this is not the
case.
</p><!--l. 87--><p class="noindent" >Pre-processing of explicit set-valued arguments of the set-valued operators to remove
duplicates is always done because of the obvious eﬃciency advantage if there were any
duplicates, and hence explicit sets appearing in the values of such operators will
never contain any duplicate elements. Such sets are also currently sorted, mainly
because the result looks better. The ordering used satisﬁes the <span 
class="pcrr8t-x-x-109">ordp</span><a 
 id="dx258-1055003"></a> predicate
used for most sorting within REDUCE, except that explicit integers are sorted
into increasing numerical order rather than the decreasing order that satisﬁes
<span 
class="pcrr8t-x-x-109">ordp</span>.
</p><!--l. 98--><p class="noindent" >Hence explicit sets appearing in the result of any set operator are currently returned in a
canonical form. Any explicit set can also be put into this form by applying the operator
<span 
class="pcrr8t-x-x-109">mkset </span>to the list representing it. For example
                                                                     

                                                                     
</p>
<pre class="verbatim" id="verbatim-1298">
mkset {1,2,y,x*y,x+y};

{x + y,x*y,y,1,2}
</pre>
<!--l. 106--><p class="nopar" >
</p><!--l. 108--><p class="noindent" >The empty set is represented by the empty list <span 
class="pcrr8t-x-x-109">{}</span>.
</p><!--l. 111--><p class="noindent" >
</p>
<h4 class="subsectionHead"><span class="titlemark">20.51.4    </span> <a 
 id="x258-105600020.51.4"></a>Union and intersection</h4>
<a 
 id="dx258-1056001"></a>
<a 
 id="dx258-1056002"></a>
<a 
 id="dx258-1056003"></a>
<!--l. 113--><p class="noindent" ><a 
 id="operator:SETS_UNION"></a> <a 
 id="operator:INTERSECTION"></a> <a 
 id="operator:SETS_INTERSECT"></a> The operator <span 
class="pcrr8t-x-x-109">intersection </span>(the name used internally) has the shorter synonym
<span 
class="pcrr8t-x-x-109">intersect</span>. These operators will probably most commonly be used as binary inﬁx
operators applied to explicit sets, e.g.
                                                                     

                                                                     
</p>
<pre class="verbatim" id="verbatim-1299">
{1,2,3} union {2,3,4};

{1,2,3,4}

{1,2,3} intersect {2,3,4};

{2,3}
</pre>
<!--l. 128--><p class="nopar" > They can also be used as n-ary operators with any number of arguments, in which case it
saves typing to use them as preﬁx operators (which is possible with all REDUCE inﬁx
operators), e.g.
                                                                     

                                                                     
</p>
<pre class="verbatim" id="verbatim-1300">
{1,2,3} union {2,3,4} union {3,4,5};

{1,2,3,4,5}

intersect({1,2,3}, {2,3,4}, {3,4,5});

{3}
</pre>
<!--l. 140--><p class="nopar" > For completeness, they can currently also be used as unary operators, in which case they
just return their arguments (in canonical form), and so act as slightly less eﬃcient
versions of <span 
class="pcrr8t-x-x-109">mkset </span>(but this may change), e.g.
                                                                     

                                                                     
</p>
<pre class="verbatim" id="verbatim-1301">
union {1,5,3,5,1};

{1,3,5}
</pre>
<!--l. 149--><p class="nopar" >
</p><!--l. 152--><p class="noindent" >
</p>
<h4 class="subsectionHead"><span class="titlemark">20.51.5    </span> <a 
 id="x258-105700020.51.5"></a>Symbolic set expressions</h4>
<!--l. 154--><p class="noindent" >If one or more of the arguments evaluates to an unbound identiﬁer then it is regarded as
representing a symbolic implicit set, and the union or intersection will evaluate to
an expression that still contains the union or intersection operator. These two
operators are symmetric, and so if they remain symbolic their arguments will
be sorted as for any symmetric operator. Such symbolic set expressions are
simpliﬁed, but the simpliﬁcation may not be complete in non-trivial cases. For
example:
                                                                     

                                                                     
</p>
<pre class="verbatim" id="verbatim-1302">
a union b union {} union b union {7,3};

{3,7} union a union b

a intersect {};

{}
</pre>
<!--l. 170--><p class="nopar" >
</p><!--l. 172--><p class="noindent" >In implementations of REDUCE that provide fancy display using mathematical notation,
the empty set, union, intersection and set diﬀerence are all displayed using their
conventional mathematical symbols, namely \(\emptyset \), \(\cup \), \(\cap \), \(\setminus \).
</p><!--l. 177--><p class="noindent" >A symbolic set expression is a valid argument for any other set operator, e.g.
                                                                     

                                                                     
</p>
<pre class="verbatim" id="verbatim-1303">
a union (b intersect c);

b intersection c union a
</pre>
<!--l. 183--><p class="nopar" >
</p><!--l. 185--><p class="noindent" >Intersection distributes over union, which is not applied by default but is implemented as
a rule list assigned to the variable <span 
class="pcrr8t-x-x-109">set_distribution_rule</span>, e.g. <a 
 id="dx258-1057001"></a> <a 
 id="reserved:SET_DISTRIBUTION_RULE"></a>
                                                                     

                                                                     
</p>
<pre class="verbatim" id="verbatim-1304">
a intersect (b union c);

(b union c) intersection a

a intersect (b union c) where set_distribution_rule;

a intersection b union a intersection c
</pre>
<!--l. 198--><p class="nopar" >
</p><!--l. 201--><p class="noindent" >
</p>
<h4 class="subsectionHead"><span class="titlemark">20.51.6    </span> <a 
 id="x258-105800020.51.6"></a>Set diﬀerence</h4>
<a 
 id="dx258-1058001"></a>
<a 
 id="dx258-1058002"></a>
<!--l. 204--><p class="noindent" ><a 
 id="operator:SETDIFF"></a> <a 
 id="operator:setdiffop"></a>
</p><!--l. 207--><p class="noindent" >The set diﬀerence operator is represented by the symbol <span 
class="pcrr8t-x-x-109">\ </span>and is always output using
this symbol, although it can also be input using either of the two names <span 
class="pcrr8t-x-x-109">setdiff </span>(the
name used internally) or <span 
class="pcrr8t-x-x-109">minus </span>(as used in Maple). It is a binary operator, its operands
may be any combination of explicit or implicit sets, and it may be used in an argument of
any other set operator. Here are some examples:
                                                                     

                                                                     
</p>
<pre class="verbatim" id="verbatim-1305">
{1,2,3} \ {2,4};

{1,3}

{1,2,3} \ {};

{1,2,3}

a \ {1,2};

a\{1,2}

a \ a;

{}

a \ {};

a

{} \ a;

{}
</pre>
<!--l. 238--><p class="nopar" >
</p><!--l. 241--><p class="noindent" >
</p>
<h4 class="subsectionHead"><span class="titlemark">20.51.7    </span> <a 
 id="x258-105900020.51.7"></a>Predicates on sets</h4>
<a 
 id="dx258-1059001"></a>
<a 
 id="dx258-1059002"></a>
<a 
 id="dx258-1059003"></a>
<!--l. 245--><p class="noindent" ><a 
 id="operator:EVALB"></a>
</p><!--l. 247--><p class="noindent" >These are all binary inﬁx operators. Currently, like all REDUCE predicates, they can
                                                                     

                                                                     
only be used within conditional statements <span 
class="pcrr8t-x-x-109">if</span>, <span 
class="pcrr8t-x-x-109">while</span>, <span 
class="pcrr8t-x-x-109">repeat</span>) or within the
argument of the <span 
class="pcrr8t-x-x-109">evalb </span>operator provided by this package, and they cannot remain
symbolic – a predicate that cannot be evaluated to a Boolean value causes a normal
REDUCE error.
</p><!--l. 254--><p class="noindent" >The <span 
class="pcrr8t-x-x-109">evalb </span>operator provides a convenient shorthand for an <span 
class="pcrr8t-x-x-109">if </span>statement designed
purely to display the value of any Boolean expression (not only predicates deﬁned in this
package). It has some similarity with the <span 
class="pcrr8t-x-x-109">evalb </span>function in Maple, except that the
values returned by <span 
class="pcrr8t-x-x-109">evalb </span>in REDUCE (the identiﬁers <span 
class="pcrr8t-x-x-109">true </span>and <span 
class="pcrr8t-x-x-109">false</span>) have no
signiﬁcance to REDUCE itself. Hence, in REDUCE, use of <span 
class="pcrr8t-x-x-109">evalb </span>is <span 
class="ptmri8t-x-x-109">never</span>
necessary.
                                                                     

                                                                     
</p>
<pre class="verbatim" id="verbatim-1306">
if a = a then true else false;

true

evalb(a = a);

true

if a = b then true else false;

false

evalb(a = b);

false

evalb 1;

true

evalb 0;

false
</pre>
<!--l. 285--><p class="nopar" > I will use the <span 
class="pcrr8t-x-x-109">evalb </span>operator in preference to an explicit <span 
class="pcrr8t-x-x-109">if </span>statement for purposes of
illustration.
</p><!--l. 290--><p class="noindent" >
</p>
<h5 class="subsubsectionHead"><span class="titlemark">20.51.7.1    </span> <a 
 id="x258-106000020.51.7.1"></a>Set membership</h5>
<a 
 id="dx258-1060001"></a>
<!--l. 292--><p class="noindent" ><a 
 id="operator:SETS_MEMBER"></a>
</p><!--l. 294--><p class="noindent" >Set membership is tested by the predicate <span 
class="pcrr8t-x-x-109">member</span>. Its left operand is regarded as a
potential set element and its right operand <span 
class="ptmri8t-x-x-109">must </span>evaluate to an explicit set. There is
                                                                     

                                                                     
currently no sense in which the right operand could be an implicit set; this would require
a mechanism for declaring implicit set membership (akin to implicit variable
dependence) which is currently not implemented. Set membership testing works like
this:
                                                                     

                                                                     
</p>
<pre class="verbatim" id="verbatim-1307">
evalb(1 member {1,2,3});

true

evalb(2 member {1,2} intersect {2,3});

true

evalb(a member b);

***** b invalid as list
</pre>
<!--l. 313--><p class="nopar" >
</p><!--l. 316--><p class="noindent" >
</p>
<h5 class="subsubsectionHead"><span class="titlemark">20.51.7.2    </span> <a 
 id="x258-106100020.51.7.2"></a>Set inclusion</h5>
<a 
 id="dx258-1061001"></a>
<a 
 id="dx258-1061002"></a>
<!--l. 318--><p class="noindent" ><a 
 id="operator:SUBSET_EQ"></a> <a 
 id="operator:SUBSET"></a>
</p><!--l. 321--><p class="noindent" >Set inclusion is tested by the predicate <span 
class="pcrr8t-x-x-109">subset_eq </span>where <span 
class="pcrr8t-x-x-109">a subset_eq b </span>is true if
the set \(a\) is either a subset of or equal to the set \(b\); strict inclusion is tested by the predicate
<span 
class="pcrr8t-x-x-109">subset </span>where <span 
class="pcrr8t-x-x-109">a subset b </span>is true if the set \(a\) is <span 
class="ptmri8t-x-x-109">strictly </span>a subset of the set \(b\) and
is false is \(a\) is equal to \(b\). These predicates provide some support for symbolic
set expressions, but this is not yet correct as indicated below. Here are some
examples:
                                                                     

                                                                     
</p>
<pre class="verbatim" id="verbatim-1308">
evalb({1,2} subset_eq {1,2,3});

true

evalb({1,2} subset_eq {1,2});

true

evalb({1,2} subset {1,2});

false


evalb(a subset a union b);

true

evalb(a\b subset a);

true

evalb(a intersect b subset a union b);  %%% BUG

false
</pre>
<!--l. 353--><p class="nopar" >
</p><!--l. 355--><p class="noindent" >An undecidable predicate causes a normal REDUCE error, e.g.
                                                                     

                                                                     
</p>
<pre class="verbatim" id="verbatim-1309">
evalb(a subset_eq {b});

***** Cannot evaluate a subset_eq {b} as Boolean-valued set
 expression

evalb(a subset_eq b);  %%% BUG

false
</pre>
<!--l. 365--><p class="nopar" >
</p><!--l. 368--><p class="noindent" >
</p>
<h5 class="subsubsectionHead"><span class="titlemark">20.51.7.3    </span> <a 
 id="x258-106200020.51.7.3"></a>Set equality</h5>
<a 
 id="dx258-1062001"></a>
<!--l. 370--><p class="noindent" ><a 
 id="operator:SET_EQ"></a>
</p><!--l. 372--><p class="noindent" >As explained above, equality of two sets in canonical form can be reliably tested by the
standard REDUCE equality predicate (<span 
class="pcrr8t-x-x-109">=</span>). This package also provides the predicate
<span 
class="pcrr8t-x-x-109">set_eq </span>to test equality of two sets not represented canonically. The two predicates
behave identically for operands that are symbolic set expressions because these are
always evaluated to canonical form (although currently this is probably strictly true only
in simple cases). Here are some examples:
                                                                     

                                                                     
</p>
<pre class="verbatim" id="verbatim-1310">
evalb({1,2,3} = {1,2,3});

true

evalb({2,1,3} = {1,3,2});

false

evalb(mkset{2,1,3} = mkset{1,3,2});

true

evalb({2,1,3} set_eq {1,3,2});

true

evalb(a union a = a\{});

true
</pre>
<!--l. 400--><p class="nopar" >
</p><!--l. 403--><p class="noindent" >
</p>
<h4 class="subsectionHead"><span class="titlemark">20.51.8    </span> <a 
 id="x258-106300020.51.8"></a>Possible future developments</h4>
     <ul class="itemize1">
     <li class="itemize">
     <!--l. 406--><p class="noindent" >Unary union/intersection to implement repeated union/intersection on a set
     of sets.
     </p></li>
     <li class="itemize">
     <!--l. 408--><p class="noindent" >More  symbolic  set  algebra,  canonical  forms  for  set  expressions,  more
                                                                     

                                                                     
     complete simpliﬁcation.
     </p></li>
     <li class="itemize">
     <!--l. 410--><p class="noindent" >Better support for Boolean variables via a version (evalb10?) of <span 
class="pcrr8t-x-x-109">evalb </span>that
     returns 1/0 instead of <span 
class="pcrr8t-x-x-109">true</span>/<span 
class="pcrr8t-x-x-109">false</span>, or predicates that return 1/0 directly.</p></li></ul>
<!--l. 1108--><p class="noindent" >
                                                                     

                                                                     
                                                                     

                                                                     
</p><!--l. 1110--><p class="noindent" ><table cellspacing="5"><tr><td class="clinks"><a 
href="../manual-lookup.php%3FUser&#32;Contributed&#32;Packages.html#manualse174.html" >Up</a></td><td class="clinks"><a 
href="manualse175.html" >Next</a></td><td class="clinks"><a 
href="../manual-lookup.php%3FSCOPE.html" >Prev</a></td><td class="clinks"><a 
href="../manual-lookup.php%3FSCOPE.html#tailmanualse173.html" >PrevTail</a></td><td class="clinks"><a 
href="manualse174.html" >Front</a></td></tr></table><a 
 id="tailmanualse174.html"></a>  <hr> <p style="font-family:sans-serif">Hosted by <a href="https://sourceforge.net/p/reduce-algebra/"> <img title="Download REDUCE" alt="Download REDUCE" style="vertical-align:middle" src="https://sourceforge.net/sflogo.php?type=16&amp;group_id=248416"/></a> <a href="https://www.mathjax.org"> <img title="Powered by MathJax" alt="Powered by MathJax" style="float:right" src="https://www.mathjax.org/badge/badge.gif"/></a></p></p> 
</body> 
</html>